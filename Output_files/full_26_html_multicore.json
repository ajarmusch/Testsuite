var jsonResults = {
    "configs": [
        {
            "CC": "nvc",
            "CCFlags": [
                "-fast",
                "-acc",
                "-ta=multicore"
            ],
            "CC_ACC_Version": "2.6",
            "CPP": "nvc++",
            "CPPFlags": [
                "-fast",
                "-acc",
                "-ta=multicore"
            ],
            "CPP_ACC_Version": "2.6",
            "FC": "nvfortran",
            "FCFlags": [
                "-fast",
                "-acc",
                "-ta=multicore"
            ],
            "FC_ACC_Version": "2.6",
            "PostCompileCommands": [],
            "PostRunCommands": [],
            "PreCompileCommands": [],
            "PreRunCommands": [],
            "build_dir": "/home/exouser/Testsuite/build",
            "config_id": -1,
            "config_name": "init_config.txt",
            "env": null,
            "exclude_tags": [],
            "exclude_tests": [
                "acc_testsuite.Fh",
                "acc_testsuite.h",
                "acc_testsuite_declare.h"
            ],
            "export_format": "html",
            "fast": false,
            "id": 1,
            "include_by_default": true,
            "include_tags": [],
            "include_tests": [],
            "keep_build_dir": false,
            "keep_mutated_tests": false,
            "keep_partial_results": false,
            "keep_policy": "on-error",
            "mutated_test_dir": "/home/exouser/Testsuite/build/mutated_tests",
            "mutators": [],
            "partial": false,
            "partial_results_dir": "/home/exouser/Testsuite/build/partial_results",
            "runtime_prefix": "",
            "seed": null,
            "system_name": null,
            "tag_evaluation": null,
            "test_dir": "/home/exouser/Testsuite/Tests",
            "timeout": 10
        }
    ],
    "runs": {
        "acc_async_test.F90": [
            {
                "compilation": {
                    "command": "nvfortran -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/acc_async_test.F90/acc_async_test.F900 /home/exouser/Testsuite/Tests/acc_async_test.F90",
                    "config": 1,
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.36635236721485853
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.03404066385701299,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "acc_async_test.c": [
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/acc_async_test.c/acc_async_test.c0 /home/exouser/Testsuite/Tests/acc_async_test.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/acc_async_test.c\", line 142: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 1.0205201008357108
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.00971498666331172,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "acc_async_test_all.F90": [
            {
                "compilation": {
                    "command": "nvfortran -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/acc_async_test_all.F90/acc_async_test_all.F900 /home/exouser/Testsuite/Tests/acc_async_test_all.F90",
                    "config": 1,
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.31605510832741857
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.009647477883845568,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "acc_async_test_all.c": [
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/acc_async_test_all.c/acc_async_test_all.c0 /home/exouser/Testsuite/Tests/acc_async_test_all.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/acc_async_test_all.c\", line 214: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.4167251791805029
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "0 out of 1000\n",
                    "result": 0,
                    "runtime": 0.009478939697146416,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "acc_copyin.F90": [
            {
                "compilation": {
                    "command": "nvfortran -fast -acc -ta=multicore -DT1 -DT2 -DT3 -DT4 -DT5 -DT6 -DT7 -o /home/exouser/Testsuite/build/acc_copyin.F90/acc_copyin.F900 /home/exouser/Testsuite/Tests/acc_copyin.F90",
                    "config": 1,
                    "errors": "",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 0.11547403503209352
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 0.009078780189156532,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvfortran -fast -acc -ta=multicore -DT2 -DT3 -DT4 -DT5 -DT6 -DT7 -o /home/exouser/Testsuite/build/acc_copyin.F90/acc_copyin.F901 /home/exouser/Testsuite/Tests/acc_copyin.F90",
                    "config": 1,
                    "errors": "",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 0.16518856910988688
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 0.009742599911987782,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvfortran -fast -acc -ta=multicore -DT1 -DT3 -DT4 -DT5 -DT6 -DT7 -o /home/exouser/Testsuite/build/acc_copyin.F90/acc_copyin.F902 /home/exouser/Testsuite/Tests/acc_copyin.F90",
                    "config": 1,
                    "errors": "",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 0.21680188877508044
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 0.009314803872257471,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvfortran -fast -acc -ta=multicore -DT1 -DT2 -DT4 -DT5 -DT6 -DT7 -o /home/exouser/Testsuite/build/acc_copyin.F90/acc_copyin.F903 /home/exouser/Testsuite/Tests/acc_copyin.F90",
                    "config": 1,
                    "errors": "",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 0.16648699389770627
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 0.009362377692013979,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvfortran -fast -acc -ta=multicore -DT1 -DT2 -DT3 -DT5 -DT6 -DT7 -o /home/exouser/Testsuite/build/acc_copyin.F90/acc_copyin.F904 /home/exouser/Testsuite/Tests/acc_copyin.F90",
                    "config": 1,
                    "errors": "",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 0.16659062821418047
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 0.009977117646485567,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvfortran -fast -acc -ta=multicore -DT1 -DT2 -DT3 -DT4 -DT6 -DT7 -o /home/exouser/Testsuite/build/acc_copyin.F90/acc_copyin.F905 /home/exouser/Testsuite/Tests/acc_copyin.F90",
                    "config": 1,
                    "errors": "",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 0.165567628107965
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 0.009991929866373539,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvfortran -fast -acc -ta=multicore -DT1 -DT2 -DT3 -DT4 -DT5 -DT7 -o /home/exouser/Testsuite/build/acc_copyin.F90/acc_copyin.F906 /home/exouser/Testsuite/Tests/acc_copyin.F90",
                    "config": 1,
                    "errors": "",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 0.2161659151315689
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 0.009370540734380484,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvfortran -fast -acc -ta=multicore -DT1 -DT2 -DT3 -DT4 -DT5 -DT6 -o /home/exouser/Testsuite/build/acc_copyin.F90/acc_copyin.F907 /home/exouser/Testsuite/Tests/acc_copyin.F90",
                    "config": 1,
                    "errors": "",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 0.16632561897858977
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 0.009512100368738174,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvfortran -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/acc_copyin.F90/acc_copyin.F908 /home/exouser/Testsuite/Tests/acc_copyin.F90",
                    "config": 1,
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.41655293200165033
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.010371406096965075,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "acc_copyin.c": [
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -DT1 -DT2 -DT3 -DT4 -DT5 -DT6 -DT7 -o /home/exouser/Testsuite/build/acc_copyin.c/acc_copyin.c0 /home/exouser/Testsuite/Tests/acc_copyin.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/acc_copyin.c\", line 338: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n\"/home/exouser/Testsuite/Tests/acc_copyin.c\", line 339: warning: variable \"failed\" was declared but never referenced\n      int failed;\n          ^\n\n",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 0.16546507319435477
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 0.005398205015808344,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -DT2 -DT3 -DT4 -DT5 -DT6 -DT7 -o /home/exouser/Testsuite/build/acc_copyin.c/acc_copyin.c1 /home/exouser/Testsuite/Tests/acc_copyin.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/acc_copyin.c\", line 338: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 0.2158298511058092
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 0.009627427905797958,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -DT1 -DT3 -DT4 -DT5 -DT6 -DT7 -o /home/exouser/Testsuite/build/acc_copyin.c/acc_copyin.c2 /home/exouser/Testsuite/Tests/acc_copyin.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/acc_copyin.c\", line 338: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 0.21574784815311432
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 0.009585391264408827,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -DT1 -DT2 -DT4 -DT5 -DT6 -DT7 -o /home/exouser/Testsuite/build/acc_copyin.c/acc_copyin.c3 /home/exouser/Testsuite/Tests/acc_copyin.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/acc_copyin.c\", line 338: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 0.16552706388756633
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 0.005532217212021351,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -DT1 -DT2 -DT3 -DT5 -DT6 -DT7 -o /home/exouser/Testsuite/build/acc_copyin.c/acc_copyin.c4 /home/exouser/Testsuite/Tests/acc_copyin.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/acc_copyin.c\", line 338: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 0.216055020224303
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 0.009836432058364153,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -DT1 -DT2 -DT3 -DT4 -DT6 -DT7 -o /home/exouser/Testsuite/build/acc_copyin.c/acc_copyin.c5 /home/exouser/Testsuite/Tests/acc_copyin.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/acc_copyin.c\", line 338: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 0.21579405292868614
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 0.009662081953138113,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -DT1 -DT2 -DT3 -DT4 -DT5 -DT7 -o /home/exouser/Testsuite/build/acc_copyin.c/acc_copyin.c6 /home/exouser/Testsuite/Tests/acc_copyin.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/acc_copyin.c\", line 338: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 0.21581547427922487
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 0.009691924322396517,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -DT1 -DT2 -DT3 -DT4 -DT5 -DT6 -o /home/exouser/Testsuite/build/acc_copyin.c/acc_copyin.c7 /home/exouser/Testsuite/Tests/acc_copyin.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/acc_copyin.c\", line 338: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 0.16561588598415256
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 0.005385119933634996,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/acc_copyin.c/acc_copyin.c8 /home/exouser/Testsuite/Tests/acc_copyin.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/acc_copyin.c\", line 338: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.41613063495606184
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.009708138182759285,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "acc_copyin_async.F90": [
            {
                "compilation": {
                    "command": "nvfortran -fast -acc -ta=multicore -DT1 -DT2 -DT3 -DT4 -DT5 -o /home/exouser/Testsuite/build/acc_copyin_async.F90/acc_copyin_async.F900 /home/exouser/Testsuite/Tests/acc_copyin_async.F90",
                    "config": 1,
                    "errors": "",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 0.11706058913841844
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 0.010050108190625906,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvfortran -fast -acc -ta=multicore -DT2 -DT3 -DT4 -DT5 -o /home/exouser/Testsuite/build/acc_copyin_async.F90/acc_copyin_async.F901 /home/exouser/Testsuite/Tests/acc_copyin_async.F90",
                    "config": 1,
                    "errors": "",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 0.21611350774765015
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 0.009412943851202726,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvfortran -fast -acc -ta=multicore -DT1 -DT3 -DT4 -DT5 -o /home/exouser/Testsuite/build/acc_copyin_async.F90/acc_copyin_async.F902 /home/exouser/Testsuite/Tests/acc_copyin_async.F90",
                    "config": 1,
                    "errors": "",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 0.165597353130579
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 0.017886951100081205,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvfortran -fast -acc -ta=multicore -DT1 -DT2 -DT4 -DT5 -o /home/exouser/Testsuite/build/acc_copyin_async.F90/acc_copyin_async.F903 /home/exouser/Testsuite/Tests/acc_copyin_async.F90",
                    "config": 1,
                    "errors": "",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 0.16650776099413633
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 0.00924386689439416,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvfortran -fast -acc -ta=multicore -DT1 -DT2 -DT3 -DT5 -o /home/exouser/Testsuite/build/acc_copyin_async.F90/acc_copyin_async.F904 /home/exouser/Testsuite/Tests/acc_copyin_async.F90",
                    "config": 1,
                    "errors": "",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 0.1664634388871491
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 0.010004902258515358,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvfortran -fast -acc -ta=multicore -DT1 -DT2 -DT3 -DT4 -o /home/exouser/Testsuite/build/acc_copyin_async.F90/acc_copyin_async.F905 /home/exouser/Testsuite/Tests/acc_copyin_async.F90",
                    "config": 1,
                    "errors": "",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 0.16638059308752418
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": false,
                    "output": "",
                    "result": 16,
                    "runtime": 0.009480008855462074,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvfortran -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/acc_copyin_async.F90/acc_copyin_async.F906 /home/exouser/Testsuite/Tests/acc_copyin_async.F90",
                    "config": 1,
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.3665213459171355
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 16,
                    "runtime": 0.009720847010612488,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "acc_copyin_async.c": [
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -DT1 -DT2 -DT3 -DT4 -DT5 -o /home/exouser/Testsuite/build/acc_copyin_async.c/acc_copyin_async.c0 /home/exouser/Testsuite/Tests/acc_copyin_async.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/acc_copyin_async.c\", line 261: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n\"/home/exouser/Testsuite/Tests/acc_copyin_async.c\", line 262: warning: variable \"failed\" was declared but never referenced\n      int failed;\n          ^\n\n",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 0.16567140072584152
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 0.005390338599681854,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -DT2 -DT3 -DT4 -DT5 -o /home/exouser/Testsuite/build/acc_copyin_async.c/acc_copyin_async.c1 /home/exouser/Testsuite/Tests/acc_copyin_async.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/acc_copyin_async.c\", line 261: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 0.21549040311947465
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 0.009707552380859852,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -DT1 -DT3 -DT4 -DT5 -o /home/exouser/Testsuite/build/acc_copyin_async.c/acc_copyin_async.c2 /home/exouser/Testsuite/Tests/acc_copyin_async.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/acc_copyin_async.c\", line 261: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 0.21579909697175026
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 0.009431669022887945,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -DT1 -DT2 -DT4 -DT5 -o /home/exouser/Testsuite/build/acc_copyin_async.c/acc_copyin_async.c3 /home/exouser/Testsuite/Tests/acc_copyin_async.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/acc_copyin_async.c\", line 261: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 0.21595150511711836
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 0.009500675834715366,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -DT1 -DT2 -DT3 -DT5 -o /home/exouser/Testsuite/build/acc_copyin_async.c/acc_copyin_async.c4 /home/exouser/Testsuite/Tests/acc_copyin_async.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/acc_copyin_async.c\", line 261: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 0.21581967873498797
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 0.009672719985246658,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -DT1 -DT2 -DT3 -DT4 -o /home/exouser/Testsuite/build/acc_copyin_async.c/acc_copyin_async.c5 /home/exouser/Testsuite/Tests/acc_copyin_async.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/acc_copyin_async.c\", line 261: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 0.1658737249672413
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 0.009599557612091303,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/acc_copyin_async.c/acc_copyin_async.c6 /home/exouser/Testsuite/Tests/acc_copyin_async.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/acc_copyin_async.c\", line 261: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.36623601242899895
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.009616638999432325,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "acc_copyin_async_with_len.F90": [
            {
                "compilation": {
                    "command": "nvfortran -fast -acc -ta=multicore -DT1 -DT2 -DT3 -DT4 -DT5 -o /home/exouser/Testsuite/build/acc_copyin_async_with_len.F90/acc_copyin_async_with_len.F900 /home/exouser/Testsuite/Tests/acc_copyin_async_with_len.F90",
                    "config": 1,
                    "errors": "",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 0.11624101176857948
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 0.009484775364398956,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvfortran -fast -acc -ta=multicore -DT2 -DT3 -DT4 -DT5 -o /home/exouser/Testsuite/build/acc_copyin_async_with_len.F90/acc_copyin_async_with_len.F901 /home/exouser/Testsuite/Tests/acc_copyin_async_with_len.F90",
                    "config": 1,
                    "errors": "",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 0.21623264905065298
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 0.010270779021084309,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvfortran -fast -acc -ta=multicore -DT1 -DT3 -DT4 -DT5 -o /home/exouser/Testsuite/build/acc_copyin_async_with_len.F90/acc_copyin_async_with_len.F902 /home/exouser/Testsuite/Tests/acc_copyin_async_with_len.F90",
                    "config": 1,
                    "errors": "",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 0.16678747721016407
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 0.009168750140815973,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvfortran -fast -acc -ta=multicore -DT1 -DT2 -DT4 -DT5 -o /home/exouser/Testsuite/build/acc_copyin_async_with_len.F90/acc_copyin_async_with_len.F903 /home/exouser/Testsuite/Tests/acc_copyin_async_with_len.F90",
                    "config": 1,
                    "errors": "",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 0.16565167624503374
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 0.009495769161731005,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvfortran -fast -acc -ta=multicore -DT1 -DT2 -DT3 -DT5 -o /home/exouser/Testsuite/build/acc_copyin_async_with_len.F90/acc_copyin_async_with_len.F904 /home/exouser/Testsuite/Tests/acc_copyin_async_with_len.F90",
                    "config": 1,
                    "errors": "",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 0.16593549214303493
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 0.00936558423563838,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvfortran -fast -acc -ta=multicore -DT1 -DT2 -DT3 -DT4 -o /home/exouser/Testsuite/build/acc_copyin_async_with_len.F90/acc_copyin_async_with_len.F905 /home/exouser/Testsuite/Tests/acc_copyin_async_with_len.F90",
                    "config": 1,
                    "errors": "",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 0.1656655427068472
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 0.018065423239022493,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvfortran -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/acc_copyin_async_with_len.F90/acc_copyin_async_with_len.F906 /home/exouser/Testsuite/Tests/acc_copyin_async_with_len.F90",
                    "config": 1,
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.3669449118897319
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.00957782007753849,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "acc_copyin_with_len.F90": [
            {
                "compilation": {
                    "command": "nvfortran -fast -acc -ta=multicore -DT1 -DT2 -DT3 -DT4 -DT5 -DT6 -DT7 -o /home/exouser/Testsuite/build/acc_copyin_with_len.F90/acc_copyin_with_len.F900 /home/exouser/Testsuite/Tests/acc_copyin_with_len.F90",
                    "config": 1,
                    "errors": "",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 0.11540708225220442
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 0.009504825342446566,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvfortran -fast -acc -ta=multicore -DT2 -DT3 -DT4 -DT5 -DT6 -DT7 -o /home/exouser/Testsuite/build/acc_copyin_with_len.F90/acc_copyin_with_len.F901 /home/exouser/Testsuite/Tests/acc_copyin_with_len.F90",
                    "config": 1,
                    "errors": "",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 0.16577269602566957
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 0.009705009870231152,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvfortran -fast -acc -ta=multicore -DT1 -DT3 -DT4 -DT5 -DT6 -DT7 -o /home/exouser/Testsuite/build/acc_copyin_with_len.F90/acc_copyin_with_len.F902 /home/exouser/Testsuite/Tests/acc_copyin_with_len.F90",
                    "config": 1,
                    "errors": "",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 0.16676080599427223
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 0.009202671237289906,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvfortran -fast -acc -ta=multicore -DT1 -DT2 -DT4 -DT5 -DT6 -DT7 -o /home/exouser/Testsuite/build/acc_copyin_with_len.F90/acc_copyin_with_len.F903 /home/exouser/Testsuite/Tests/acc_copyin_with_len.F90",
                    "config": 1,
                    "errors": "",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 0.166251540184021
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 0.009411148726940155,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvfortran -fast -acc -ta=multicore -DT1 -DT2 -DT3 -DT5 -DT6 -DT7 -o /home/exouser/Testsuite/build/acc_copyin_with_len.F90/acc_copyin_with_len.F904 /home/exouser/Testsuite/Tests/acc_copyin_with_len.F90",
                    "config": 1,
                    "errors": "",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 0.16559732472524047
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 0.009758573956787586,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvfortran -fast -acc -ta=multicore -DT1 -DT2 -DT3 -DT4 -DT6 -DT7 -o /home/exouser/Testsuite/build/acc_copyin_with_len.F90/acc_copyin_with_len.F905 /home/exouser/Testsuite/Tests/acc_copyin_with_len.F90",
                    "config": 1,
                    "errors": "",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 0.16628231992945075
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 0.01023881696164608,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvfortran -fast -acc -ta=multicore -DT1 -DT2 -DT3 -DT4 -DT5 -DT7 -o /home/exouser/Testsuite/build/acc_copyin_with_len.F90/acc_copyin_with_len.F906 /home/exouser/Testsuite/Tests/acc_copyin_with_len.F90",
                    "config": 1,
                    "errors": "",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 0.16687046410515904
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": false,
                    "output": "",
                    "result": 32,
                    "runtime": 0.009536497294902802,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvfortran -fast -acc -ta=multicore -DT1 -DT2 -DT3 -DT4 -DT5 -DT6 -o /home/exouser/Testsuite/build/acc_copyin_with_len.F90/acc_copyin_with_len.F907 /home/exouser/Testsuite/Tests/acc_copyin_with_len.F90",
                    "config": 1,
                    "errors": "",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 0.16618021903559566
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 0.010082096327096224,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvfortran -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/acc_copyin_with_len.F90/acc_copyin_with_len.F908 /home/exouser/Testsuite/Tests/acc_copyin_with_len.F90",
                    "config": 1,
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.3669921434484422
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 32,
                    "runtime": 0.010243081953376532,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "acc_copyout.F90": [
            {
                "compilation": {
                    "command": "nvfortran -fast -acc -ta=multicore -DT1 -DT2 -DT3 -DT4 -DT5 -o /home/exouser/Testsuite/build/acc_copyout.F90/acc_copyout.F900 /home/exouser/Testsuite/Tests/acc_copyout.F90",
                    "config": 1,
                    "errors": "",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 0.11518101114779711
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 0.009019727353006601,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvfortran -fast -acc -ta=multicore -DT2 -DT3 -DT4 -DT5 -o /home/exouser/Testsuite/build/acc_copyout.F90/acc_copyout.F901 /home/exouser/Testsuite/Tests/acc_copyout.F90",
                    "config": 1,
                    "errors": "",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 0.1653533806093037
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 0.009547961875796318,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvfortran -fast -acc -ta=multicore -DT1 -DT3 -DT4 -DT5 -o /home/exouser/Testsuite/build/acc_copyout.F90/acc_copyout.F902 /home/exouser/Testsuite/Tests/acc_copyout.F90",
                    "config": 1,
                    "errors": "",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 0.1665033078752458
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 0.009605190251022577,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvfortran -fast -acc -ta=multicore -DT1 -DT2 -DT4 -DT5 -o /home/exouser/Testsuite/build/acc_copyout.F90/acc_copyout.F903 /home/exouser/Testsuite/Tests/acc_copyout.F90",
                    "config": 1,
                    "errors": "",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 0.1654923241585493
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 0.00957322958856821,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvfortran -fast -acc -ta=multicore -DT1 -DT2 -DT3 -DT5 -o /home/exouser/Testsuite/build/acc_copyout.F90/acc_copyout.F904 /home/exouser/Testsuite/Tests/acc_copyout.F90",
                    "config": 1,
                    "errors": "",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 0.1657218560576439
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 0.017485470045357943,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvfortran -fast -acc -ta=multicore -DT1 -DT2 -DT3 -DT4 -o /home/exouser/Testsuite/build/acc_copyout.F90/acc_copyout.F905 /home/exouser/Testsuite/Tests/acc_copyout.F90",
                    "config": 1,
                    "errors": "",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 0.16630130680277944
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 0.009579224046319723,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvfortran -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/acc_copyout.F90/acc_copyout.F906 /home/exouser/Testsuite/Tests/acc_copyout.F90",
                    "config": 1,
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.3169090594165027
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.009518847800791264,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "acc_copyout.c": [
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/acc_copyout.c/acc_copyout.c0 /home/exouser/Testsuite/Tests/acc_copyout.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/acc_copyout.c\", line 84: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.21569718606770039
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.017814904917031527,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "acc_copyout_async.F90": [
            {
                "compilation": {
                    "command": "nvfortran -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/acc_copyout_async.F90/acc_copyout_async.F900 /home/exouser/Testsuite/Tests/acc_copyout_async.F90",
                    "config": 1,
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.1663793819025159
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.00978148216381669,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "acc_copyout_async.c": [
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -DT1 -DT2 -DT3 -DT4 -o /home/exouser/Testsuite/build/acc_copyout_async.c/acc_copyout_async.c0 /home/exouser/Testsuite/Tests/acc_copyout_async.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/acc_copyout_async.c\", line 191: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n\"/home/exouser/Testsuite/Tests/acc_copyout_async.c\", line 192: warning: variable \"failed\" was declared but never referenced\n      int failed;\n          ^\n\n",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 0.16571723483502865
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 0.005318049807101488,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -DT2 -DT3 -DT4 -o /home/exouser/Testsuite/build/acc_copyout_async.c/acc_copyout_async.c1 /home/exouser/Testsuite/Tests/acc_copyout_async.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/acc_copyout_async.c\", line 191: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 0.21559443697333336
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 0.009691813960671425,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -DT1 -DT3 -DT4 -o /home/exouser/Testsuite/build/acc_copyout_async.c/acc_copyout_async.c2 /home/exouser/Testsuite/Tests/acc_copyout_async.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/acc_copyout_async.c\", line 191: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 0.21594416070729494
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 0.009485087357461452,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -DT1 -DT2 -DT4 -o /home/exouser/Testsuite/build/acc_copyout_async.c/acc_copyout_async.c3 /home/exouser/Testsuite/Tests/acc_copyout_async.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/acc_copyout_async.c\", line 191: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 0.21572372037917376
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 0.009699719026684761,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -DT1 -DT2 -DT3 -o /home/exouser/Testsuite/build/acc_copyout_async.c/acc_copyout_async.c4 /home/exouser/Testsuite/Tests/acc_copyout_async.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/acc_copyout_async.c\", line 191: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 0.21582228038460016
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 0.01762408809736371,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/acc_copyout_async.c/acc_copyout_async.c5 /home/exouser/Testsuite/Tests/acc_copyout_async.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/acc_copyout_async.c\", line 191: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.3682983429171145
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.009693799074739218,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "acc_copyout_async_with_len.F90": [
            {
                "compilation": {
                    "command": "nvfortran -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/acc_copyout_async_with_len.F90/acc_copyout_async_with_len.F900 /home/exouser/Testsuite/Tests/acc_copyout_async_with_len.F90",
                    "config": 1,
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.16566787799820304
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.009114872198551893,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "acc_copyout_finalize.F90": [
            {
                "compilation": {
                    "command": "nvfortran -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/acc_copyout_finalize.F90/acc_copyout_finalize.F900 /home/exouser/Testsuite/Tests/acc_copyout_finalize.F90",
                    "config": 1,
                    "errors": "/tmp/nvfortranx-9hfOFVZjbn.o: In function `test1_':\n/home/exouser/Testsuite/Tests/acc_copyout_finalize.F90:33: undefined reference to `acc_copyout_finalize_'\npgacclnk: child process exit status 1: /usr/bin/ld\n",
                    "export": false,
                    "output": "",
                    "result": 2,
                    "runtime": 0.1660058507695794
                },
                "post-compile commands": [],
                "pre-compile commands": [],
                "runtime": {
                    "export": false,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvfortran -fast -acc -ta=multicore -DT1 -o /home/exouser/Testsuite/build/acc_copyout_finalize.F90/acc_copyout_finalize.F901 /home/exouser/Testsuite/Tests/acc_copyout_finalize.F90",
                    "config": 1,
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.11617942526936531
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.009522739797830582,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "acc_copyout_finalize.c": [
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/acc_copyout_finalize.c/acc_copyout_finalize.c0 /home/exouser/Testsuite/Tests/acc_copyout_finalize.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/acc_copyout_finalize.c\", line 30: warning: function \"acc_copyout_finalize\" declared implicitly\n      acc_copyout_finalize(c, n * sizeof(real_t));\n      ^\n\n\"/home/exouser/Testsuite/Tests/acc_copyout_finalize.c\", line 68: warning: function \"acc_copyout_finalize\" declared implicitly\n      acc_copyout_finalize(c, n * sizeof(real_t));\n      ^\n\n\"/home/exouser/Testsuite/Tests/acc_copyout_finalize.c\", line 106: warning: function \"acc_copyout_finalize\" declared implicitly\n          acc_copyout_finalize(c, n * sizeof(real_t));\n          ^\n\n\"/home/exouser/Testsuite/Tests/acc_copyout_finalize.c\", line 131: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n/tmp/nvcOjQf4oduapNP.o: In function `test1':\n/home/exouser/Testsuite/Tests/acc_copyout_finalize.c:30: undefined reference to `acc_copyout_finalize'\n/tmp/nvcOjQf4oduapNP.o: In function `test2':\n/home/exouser/Testsuite/Tests/acc_copyout_finalize.c:68: undefined reference to `acc_copyout_finalize'\n/tmp/nvcOjQf4oduapNP.o: In function `test3':\n/home/exouser/Testsuite/Tests/acc_copyout_finalize.c:106: undefined reference to `acc_copyout_finalize'\npgacclnk: child process exit status 1: /usr/bin/ld\n",
                    "export": false,
                    "output": "",
                    "result": 2,
                    "runtime": 0.3163158120587468
                },
                "post-compile commands": [],
                "pre-compile commands": [],
                "runtime": {
                    "export": false,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -DT1 -o /home/exouser/Testsuite/build/acc_copyout_finalize.c/acc_copyout_finalize.c1 /home/exouser/Testsuite/Tests/acc_copyout_finalize.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/acc_copyout_finalize.c\", line 68: warning: function \"acc_copyout_finalize\" declared implicitly\n      acc_copyout_finalize(c, n * sizeof(real_t));\n      ^\n\n\"/home/exouser/Testsuite/Tests/acc_copyout_finalize.c\", line 106: warning: function \"acc_copyout_finalize\" declared implicitly\n          acc_copyout_finalize(c, n * sizeof(real_t));\n          ^\n\n\"/home/exouser/Testsuite/Tests/acc_copyout_finalize.c\", line 131: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n/tmp/nvcOrQf4I00DnOp.o: In function `test2':\n/home/exouser/Testsuite/Tests/acc_copyout_finalize.c:68: undefined reference to `acc_copyout_finalize'\n/tmp/nvcOrQf4I00DnOp.o: In function `test3':\n/home/exouser/Testsuite/Tests/acc_copyout_finalize.c:106: undefined reference to `acc_copyout_finalize'\npgacclnk: child process exit status 1: /usr/bin/ld\n",
                    "export": false,
                    "output": "",
                    "result": 2,
                    "runtime": 0.26686709513887763
                },
                "post-compile commands": [],
                "pre-compile commands": [],
                "runtime": {
                    "export": false,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -DT2 -o /home/exouser/Testsuite/build/acc_copyout_finalize.c/acc_copyout_finalize.c2 /home/exouser/Testsuite/Tests/acc_copyout_finalize.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/acc_copyout_finalize.c\", line 30: warning: function \"acc_copyout_finalize\" declared implicitly\n      acc_copyout_finalize(c, n * sizeof(real_t));\n      ^\n\n\"/home/exouser/Testsuite/Tests/acc_copyout_finalize.c\", line 106: warning: function \"acc_copyout_finalize\" declared implicitly\n          acc_copyout_finalize(c, n * sizeof(real_t));\n          ^\n\n\"/home/exouser/Testsuite/Tests/acc_copyout_finalize.c\", line 131: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n/tmp/nvcOzQf4UQND-RK.o: In function `test1':\n/home/exouser/Testsuite/Tests/acc_copyout_finalize.c:30: undefined reference to `acc_copyout_finalize'\n/tmp/nvcOzQf4UQND-RK.o: In function `test3':\n/home/exouser/Testsuite/Tests/acc_copyout_finalize.c:106: undefined reference to `acc_copyout_finalize'\npgacclnk: child process exit status 1: /usr/bin/ld\n",
                    "export": false,
                    "output": "",
                    "result": 2,
                    "runtime": 0.2668241700157523
                },
                "post-compile commands": [],
                "pre-compile commands": [],
                "runtime": {
                    "export": false,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -DT1 -o /home/exouser/Testsuite/build/acc_copyout_finalize.c/acc_copyout_finalize.c3 /home/exouser/Testsuite/Tests/acc_copyout_finalize.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/acc_copyout_finalize.c\", line 68: warning: function \"acc_copyout_finalize\" declared implicitly\n      acc_copyout_finalize(c, n * sizeof(real_t));\n      ^\n\n\"/home/exouser/Testsuite/Tests/acc_copyout_finalize.c\", line 106: warning: function \"acc_copyout_finalize\" declared implicitly\n          acc_copyout_finalize(c, n * sizeof(real_t));\n          ^\n\n\"/home/exouser/Testsuite/Tests/acc_copyout_finalize.c\", line 131: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n/tmp/nvcOHQf4coGDDcn.o: In function `test2':\n/home/exouser/Testsuite/Tests/acc_copyout_finalize.c:68: undefined reference to `acc_copyout_finalize'\n/tmp/nvcOHQf4coGDDcn.o: In function `test3':\n/home/exouser/Testsuite/Tests/acc_copyout_finalize.c:106: undefined reference to `acc_copyout_finalize'\npgacclnk: child process exit status 1: /usr/bin/ld\n",
                    "export": false,
                    "output": "",
                    "result": 2,
                    "runtime": 0.2668643812648952
                },
                "post-compile commands": [],
                "pre-compile commands": [],
                "runtime": {
                    "export": false,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -DT3 -o /home/exouser/Testsuite/build/acc_copyout_finalize.c/acc_copyout_finalize.c4 /home/exouser/Testsuite/Tests/acc_copyout_finalize.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/acc_copyout_finalize.c\", line 30: warning: function \"acc_copyout_finalize\" declared implicitly\n      acc_copyout_finalize(c, n * sizeof(real_t));\n      ^\n\n\"/home/exouser/Testsuite/Tests/acc_copyout_finalize.c\", line 68: warning: function \"acc_copyout_finalize\" declared implicitly\n      acc_copyout_finalize(c, n * sizeof(real_t));\n      ^\n\n\"/home/exouser/Testsuite/Tests/acc_copyout_finalize.c\", line 131: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n/tmp/nvcpPQfTqOLYVQ4.o: In function `test1':\n/home/exouser/Testsuite/Tests/acc_copyout_finalize.c:30: undefined reference to `acc_copyout_finalize'\n/tmp/nvcpPQfTqOLYVQ4.o: In function `test2':\n/home/exouser/Testsuite/Tests/acc_copyout_finalize.c:68: undefined reference to `acc_copyout_finalize'\npgacclnk: child process exit status 1: /usr/bin/ld\n",
                    "export": false,
                    "output": "",
                    "result": 2,
                    "runtime": 0.21676122909411788
                },
                "post-compile commands": [],
                "pre-compile commands": [],
                "runtime": {
                    "export": false,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -DT1 -o /home/exouser/Testsuite/build/acc_copyout_finalize.c/acc_copyout_finalize.c5 /home/exouser/Testsuite/Tests/acc_copyout_finalize.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/acc_copyout_finalize.c\", line 68: warning: function \"acc_copyout_finalize\" declared implicitly\n      acc_copyout_finalize(c, n * sizeof(real_t));\n      ^\n\n\"/home/exouser/Testsuite/Tests/acc_copyout_finalize.c\", line 106: warning: function \"acc_copyout_finalize\" declared implicitly\n          acc_copyout_finalize(c, n * sizeof(real_t));\n          ^\n\n\"/home/exouser/Testsuite/Tests/acc_copyout_finalize.c\", line 131: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n/tmp/nvcpXQfTav2YhDQ.o: In function `test2':\n/home/exouser/Testsuite/Tests/acc_copyout_finalize.c:68: undefined reference to `acc_copyout_finalize'\n/tmp/nvcpXQfTav2YhDQ.o: In function `test3':\n/home/exouser/Testsuite/Tests/acc_copyout_finalize.c:106: undefined reference to `acc_copyout_finalize'\npgacclnk: child process exit status 1: /usr/bin/ld\n",
                    "export": false,
                    "output": "",
                    "result": 2,
                    "runtime": 0.2669179840013385
                },
                "post-compile commands": [],
                "pre-compile commands": [],
                "runtime": {
                    "export": false,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -DT2 -o /home/exouser/Testsuite/build/acc_copyout_finalize.c/acc_copyout_finalize.c6 /home/exouser/Testsuite/Tests/acc_copyout_finalize.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/acc_copyout_finalize.c\", line 30: warning: function \"acc_copyout_finalize\" declared implicitly\n      acc_copyout_finalize(c, n * sizeof(real_t));\n      ^\n\n\"/home/exouser/Testsuite/Tests/acc_copyout_finalize.c\", line 106: warning: function \"acc_copyout_finalize\" declared implicitly\n          acc_copyout_finalize(c, n * sizeof(real_t));\n          ^\n\n\"/home/exouser/Testsuite/Tests/acc_copyout_finalize.c\", line 131: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n/tmp/nvcp5QfTmhkY1GR.o: In function `test1':\n/home/exouser/Testsuite/Tests/acc_copyout_finalize.c:30: undefined reference to `acc_copyout_finalize'\n/tmp/nvcp5QfTmhkY1GR.o: In function `test3':\n/home/exouser/Testsuite/Tests/acc_copyout_finalize.c:106: undefined reference to `acc_copyout_finalize'\npgacclnk: child process exit status 1: /usr/bin/ld\n",
                    "export": false,
                    "output": "",
                    "result": 2,
                    "runtime": 0.266663895919919
                },
                "post-compile commands": [],
                "pre-compile commands": [],
                "runtime": {
                    "export": false,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -DT1 -o /home/exouser/Testsuite/build/acc_copyout_finalize.c/acc_copyout_finalize.c7 /home/exouser/Testsuite/Tests/acc_copyout_finalize.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/acc_copyout_finalize.c\", line 68: warning: function \"acc_copyout_finalize\" declared implicitly\n      acc_copyout_finalize(c, n * sizeof(real_t));\n      ^\n\n\"/home/exouser/Testsuite/Tests/acc_copyout_finalize.c\", line 106: warning: function \"acc_copyout_finalize\" declared implicitly\n          acc_copyout_finalize(c, n * sizeof(real_t));\n          ^\n\n\"/home/exouser/Testsuite/Tests/acc_copyout_finalize.c\", line 131: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n/tmp/nvcpbRfTuGBY5YF.o: In function `test2':\n/home/exouser/Testsuite/Tests/acc_copyout_finalize.c:68: undefined reference to `acc_copyout_finalize'\n/tmp/nvcpbRfTuGBY5YF.o: In function `test3':\n/home/exouser/Testsuite/Tests/acc_copyout_finalize.c:106: undefined reference to `acc_copyout_finalize'\npgacclnk: child process exit status 1: /usr/bin/ld\n",
                    "export": true,
                    "output": "",
                    "result": 2,
                    "runtime": 0.2671500323340297
                },
                "post-compile commands": [],
                "pre-compile commands": [],
                "runtime": {
                    "export": true,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "acc_copyout_finalize_async.F90": [
            {
                "compilation": {
                    "command": "nvfortran -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/acc_copyout_finalize_async.F90/acc_copyout_finalize_async.F900 /home/exouser/Testsuite/Tests/acc_copyout_finalize_async.F90",
                    "config": 1,
                    "errors": "/tmp/nvfortranVx_hn3_6LorK.o: In function `test1_':\n/home/exouser/Testsuite/Tests/acc_copyout_finalize_async.F90:41: undefined reference to `acc_copyout_finalize_async_'\n/home/exouser/Testsuite/Tests/acc_copyout_finalize_async.F90:42: undefined reference to `acc_copyout_finalize_async_'\npgacclnk: child process exit status 1: /usr/bin/ld\n",
                    "export": false,
                    "output": "",
                    "result": 2,
                    "runtime": 0.16709073586389422
                },
                "post-compile commands": [],
                "pre-compile commands": [],
                "runtime": {
                    "export": false,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvfortran -fast -acc -ta=multicore -DT1 -o /home/exouser/Testsuite/build/acc_copyout_finalize_async.F90/acc_copyout_finalize_async.F901 /home/exouser/Testsuite/Tests/acc_copyout_finalize_async.F90",
                    "config": 1,
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.11662550223991275
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.005740949884057045,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "acc_copyout_finalize_async.c": [
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -DT1 -DT2 -DT3 -DT4 -o /home/exouser/Testsuite/build/acc_copyout_finalize_async.c/acc_copyout_finalize_async.c0 /home/exouser/Testsuite/Tests/acc_copyout_finalize_async.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/acc_copyout_finalize_async.c\", line 195: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n\"/home/exouser/Testsuite/Tests/acc_copyout_finalize_async.c\", line 196: warning: variable \"failed\" was declared but never referenced\n      int failed;\n          ^\n\n",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 0.165559196844697
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 0.005340305622667074,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -DT2 -DT3 -DT4 -o /home/exouser/Testsuite/build/acc_copyout_finalize_async.c/acc_copyout_finalize_async.c1 /home/exouser/Testsuite/Tests/acc_copyout_finalize_async.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/acc_copyout_finalize_async.c\", line 42: warning: function \"acc_copyout_finalize_async\" declared implicitly\n          acc_copyout_finalize_async(c, n * sizeof(real_t), 1);\n          ^\n\n\"/home/exouser/Testsuite/Tests/acc_copyout_finalize_async.c\", line 195: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n/tmp/nvcdxRfjWfErFwD.o: In function `test1':\n/home/exouser/Testsuite/Tests/acc_copyout_finalize_async.c:42: undefined reference to `acc_copyout_finalize_async'\n/home/exouser/Testsuite/Tests/acc_copyout_finalize_async.c:43: undefined reference to `acc_copyout_finalize_async'\npgacclnk: child process exit status 1: /usr/bin/ld\n",
                    "export": false,
                    "output": "",
                    "result": 2,
                    "runtime": 0.21551740588620305
                },
                "post-compile commands": [],
                "pre-compile commands": [],
                "runtime": {
                    "export": false,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -DT1 -DT3 -DT4 -o /home/exouser/Testsuite/build/acc_copyout_finalize_async.c/acc_copyout_finalize_async.c2 /home/exouser/Testsuite/Tests/acc_copyout_finalize_async.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/acc_copyout_finalize_async.c\", line 88: warning: function \"acc_copyout_finalize_async\" declared implicitly\n          acc_copyout_finalize_async(c, n * sizeof(real_t), def_async_var);\n          ^\n\n\"/home/exouser/Testsuite/Tests/acc_copyout_finalize_async.c\", line 195: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n/tmp/nvcdFRfj4dCrBGx.o: In function `test2':\n/home/exouser/Testsuite/Tests/acc_copyout_finalize_async.c:88: undefined reference to `acc_copyout_finalize_async'\npgacclnk: child process exit status 1: /usr/bin/ld\n",
                    "export": false,
                    "output": "",
                    "result": 2,
                    "runtime": 0.21670555183663964
                },
                "post-compile commands": [],
                "pre-compile commands": [],
                "runtime": {
                    "export": false,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -DT1 -DT2 -DT4 -o /home/exouser/Testsuite/build/acc_copyout_finalize_async.c/acc_copyout_finalize_async.c3 /home/exouser/Testsuite/Tests/acc_copyout_finalize_async.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/acc_copyout_finalize_async.c\", line 195: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 0.21661549899727106
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 0.009524229913949966,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -DT1 -DT2 -DT3 -o /home/exouser/Testsuite/build/acc_copyout_finalize_async.c/acc_copyout_finalize_async.c4 /home/exouser/Testsuite/Tests/acc_copyout_finalize_async.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/acc_copyout_finalize_async.c\", line 171: warning: function \"acc_copyout_finalize_async\" declared implicitly\n          acc_copyout_finalize_async(c, n * sizeof(real_t), 1);\n          ^\n\n\"/home/exouser/Testsuite/Tests/acc_copyout_finalize_async.c\", line 195: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n/tmp/nvc46RfOTHhYXjX.o: In function `test4':\n/home/exouser/Testsuite/Tests/acc_copyout_finalize_async.c:171: undefined reference to `acc_copyout_finalize_async'\npgacclnk: child process exit status 1: /usr/bin/ld\n",
                    "export": false,
                    "output": "",
                    "result": 2,
                    "runtime": 0.21547584980726242
                },
                "post-compile commands": [],
                "pre-compile commands": [],
                "runtime": {
                    "export": false,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -DT1 -DT2 -DT4 -o /home/exouser/Testsuite/build/acc_copyout_finalize_async.c/acc_copyout_finalize_async.c5 /home/exouser/Testsuite/Tests/acc_copyout_finalize_async.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/acc_copyout_finalize_async.c\", line 195: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.21683868998661637
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.009582779835909605,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "acc_copyout_finalize_async_with_len.F90": [
            {
                "compilation": {
                    "command": "nvfortran -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/acc_copyout_finalize_async_with_len.F90/acc_copyout_finalize_async_with_len.F900 /home/exouser/Testsuite/Tests/acc_copyout_finalize_async_with_len.F90",
                    "config": 1,
                    "errors": "/tmp/nvfortrantV_h5b866KVm.o: In function `test1_':\n/home/exouser/Testsuite/Tests/acc_copyout_finalize_async_with_len.F90:41: undefined reference to `acc_copyout_finalize_async_'\n/home/exouser/Testsuite/Tests/acc_copyout_finalize_async_with_len.F90:42: undefined reference to `acc_copyout_finalize_async_'\npgacclnk: child process exit status 1: /usr/bin/ld\n",
                    "export": false,
                    "output": "",
                    "result": 2,
                    "runtime": 0.16606950527057052
                },
                "post-compile commands": [],
                "pre-compile commands": [],
                "runtime": {
                    "export": false,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvfortran -fast -acc -ta=multicore -DT1 -o /home/exouser/Testsuite/build/acc_copyout_finalize_async_with_len.F90/acc_copyout_finalize_async_with_len.F901 /home/exouser/Testsuite/Tests/acc_copyout_finalize_async_with_len.F90",
                    "config": 1,
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.11626803921535611
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.005348898004740477,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "acc_copyout_finalize_with_len.F90": [
            {
                "compilation": {
                    "command": "nvfortran -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/acc_copyout_finalize_with_len.F90/acc_copyout_finalize_with_len.F900 /home/exouser/Testsuite/Tests/acc_copyout_finalize_with_len.F90",
                    "config": 1,
                    "errors": "/tmp/nvfortran9h-h3NdSZMRd.o: In function `test1_':\n/home/exouser/Testsuite/Tests/acc_copyout_finalize_with_len.F90:34: undefined reference to `acc_copyout_finalize_'\npgacclnk: child process exit status 1: /usr/bin/ld\n",
                    "export": false,
                    "output": "",
                    "result": 2,
                    "runtime": 0.16572256293147802
                },
                "post-compile commands": [],
                "pre-compile commands": [],
                "runtime": {
                    "export": false,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvfortran -fast -acc -ta=multicore -DT1 -o /home/exouser/Testsuite/build/acc_copyout_finalize_with_len.F90/acc_copyout_finalize_with_len.F901 /home/exouser/Testsuite/Tests/acc_copyout_finalize_with_len.F90",
                    "config": 1,
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.1162200360558927
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.009645352140069008,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "acc_copyout_with_len.F90": [
            {
                "compilation": {
                    "command": "nvfortran -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/acc_copyout_with_len.F90/acc_copyout_with_len.F900 /home/exouser/Testsuite/Tests/acc_copyout_with_len.F90",
                    "config": 1,
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.21599996788427234
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.01761586032807827,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "acc_create.F90": [
            {
                "compilation": {
                    "command": "nvfortran -fast -acc -ta=multicore -DT1 -DT2 -DT3 -DT4 -o /home/exouser/Testsuite/build/acc_create.F90/acc_create.F900 /home/exouser/Testsuite/Tests/acc_create.F90",
                    "config": 1,
                    "errors": "",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 0.11541126435622573
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 0.009561701212078333,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvfortran -fast -acc -ta=multicore -DT2 -DT3 -DT4 -o /home/exouser/Testsuite/build/acc_create.F90/acc_create.F901 /home/exouser/Testsuite/Tests/acc_create.F90",
                    "config": 1,
                    "errors": "",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 0.16664519999176264
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 0.009647693019360304,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvfortran -fast -acc -ta=multicore -DT1 -DT3 -DT4 -o /home/exouser/Testsuite/build/acc_create.F90/acc_create.F902 /home/exouser/Testsuite/Tests/acc_create.F90",
                    "config": 1,
                    "errors": "",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 0.1658107629045844
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 0.010177649091929197,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvfortran -fast -acc -ta=multicore -DT1 -DT2 -DT4 -o /home/exouser/Testsuite/build/acc_create.F90/acc_create.F903 /home/exouser/Testsuite/Tests/acc_create.F90",
                    "config": 1,
                    "errors": "",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 0.1660866942256689
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 0.010308251716196537,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvfortran -fast -acc -ta=multicore -DT1 -DT2 -DT3 -o /home/exouser/Testsuite/build/acc_create.F90/acc_create.F904 /home/exouser/Testsuite/Tests/acc_create.F90",
                    "config": 1,
                    "errors": "",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 0.16694056196138263
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 0.010051531717181206,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvfortran -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/acc_create.F90/acc_create.F905 /home/exouser/Testsuite/Tests/acc_create.F90",
                    "config": 1,
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.26596236880868673
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.009621814824640751,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "acc_create.c": [
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -DT1 -DT2 -DT3 -DT4 -DT5 -o /home/exouser/Testsuite/build/acc_create.c/acc_create.c0 /home/exouser/Testsuite/Tests/acc_create.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/acc_create.c\", line 217: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n\"/home/exouser/Testsuite/Tests/acc_create.c\", line 218: warning: variable \"failed\" was declared but never referenced\n      int failed;\n          ^\n\n",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 0.16551163513213396
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 0.0053565362468361855,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -DT2 -DT3 -DT4 -DT5 -o /home/exouser/Testsuite/build/acc_create.c/acc_create.c1 /home/exouser/Testsuite/Tests/acc_create.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/acc_create.c\", line 217: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 0.21582991629838943
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 0.017647393979132175,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -DT1 -DT3 -DT4 -DT5 -o /home/exouser/Testsuite/build/acc_create.c/acc_create.c2 /home/exouser/Testsuite/Tests/acc_create.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/acc_create.c\", line 217: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 0.21586025971919298
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 0.009654142893850803,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -DT1 -DT2 -DT4 -DT5 -o /home/exouser/Testsuite/build/acc_create.c/acc_create.c3 /home/exouser/Testsuite/Tests/acc_create.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/acc_create.c\", line 217: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 0.21573854377493262
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 0.009477526880800724,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -DT1 -DT2 -DT3 -DT5 -o /home/exouser/Testsuite/build/acc_create.c/acc_create.c4 /home/exouser/Testsuite/Tests/acc_create.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/acc_create.c\", line 217: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 0.2157402909360826
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 0.009506626054644585,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -DT1 -DT2 -DT3 -DT4 -o /home/exouser/Testsuite/build/acc_create.c/acc_create.c5 /home/exouser/Testsuite/Tests/acc_create.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/acc_create.c\", line 217: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 0.1656233398243785
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 0.005430327728390694,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/acc_create.c/acc_create.c6 /home/exouser/Testsuite/Tests/acc_create.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/acc_create.c\", line 217: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.31583584286272526
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.009543103165924549,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "acc_create_async.F90": [
            {
                "compilation": {
                    "command": "nvfortran -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/acc_create_async.F90/acc_create_async.F900 /home/exouser/Testsuite/Tests/acc_create_async.F90",
                    "config": 1,
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.1657979511655867
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.009810122195631266,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "acc_create_async.c": [
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -DT1 -DT2 -DT3 -DT4 -DT5 -o /home/exouser/Testsuite/build/acc_create_async.c/acc_create_async.c0 /home/exouser/Testsuite/Tests/acc_create_async.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/acc_create_async.c\", line 255: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n\"/home/exouser/Testsuite/Tests/acc_create_async.c\", line 256: warning: variable \"failed\" was declared but never referenced\n      int failed;\n          ^\n\n",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 0.1655308660119772
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 0.005431191995739937,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -DT2 -DT3 -DT4 -DT5 -o /home/exouser/Testsuite/build/acc_create_async.c/acc_create_async.c1 /home/exouser/Testsuite/Tests/acc_create_async.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/acc_create_async.c\", line 255: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 0.21589832985773683
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 0.009627808816730976,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -DT1 -DT3 -DT4 -DT5 -o /home/exouser/Testsuite/build/acc_create_async.c/acc_create_async.c2 /home/exouser/Testsuite/Tests/acc_create_async.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/acc_create_async.c\", line 255: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 0.21585803292691708
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 0.009675109293311834,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -DT1 -DT2 -DT4 -DT5 -o /home/exouser/Testsuite/build/acc_create_async.c/acc_create_async.c3 /home/exouser/Testsuite/Tests/acc_create_async.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/acc_create_async.c\", line 255: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 0.21558428183197975
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 0.00961028691381216,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -DT1 -DT2 -DT3 -DT5 -o /home/exouser/Testsuite/build/acc_create_async.c/acc_create_async.c4 /home/exouser/Testsuite/Tests/acc_create_async.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/acc_create_async.c\", line 255: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 0.21578406309708953
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 0.009386023972183466,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -DT1 -DT2 -DT3 -DT4 -o /home/exouser/Testsuite/build/acc_create_async.c/acc_create_async.c5 /home/exouser/Testsuite/Tests/acc_create_async.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/acc_create_async.c\", line 255: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 0.16551624378189445
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 0.005385444965213537,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/acc_create_async.c/acc_create_async.c6 /home/exouser/Testsuite/Tests/acc_create_async.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/acc_create_async.c\", line 255: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.36629027407616377
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.009693828877061605,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "acc_create_async_with_len.F90": [
            {
                "compilation": {
                    "command": "nvfortran -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/acc_create_async_with_len.F90/acc_create_async_with_len.F900 /home/exouser/Testsuite/Tests/acc_create_async_with_len.F90",
                    "config": 1,
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.16631326591596007
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.010290473233908415,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "acc_create_with_len.F90": [
            {
                "compilation": {
                    "command": "nvfortran -fast -acc -ta=multicore -DT1 -DT2 -DT3 -DT4 -o /home/exouser/Testsuite/build/acc_create_with_len.F90/acc_create_with_len.F900 /home/exouser/Testsuite/Tests/acc_create_with_len.F90",
                    "config": 1,
                    "errors": "",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 0.11651429580524564
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 0.0098414639942348,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvfortran -fast -acc -ta=multicore -DT2 -DT3 -DT4 -o /home/exouser/Testsuite/build/acc_create_with_len.F90/acc_create_with_len.F901 /home/exouser/Testsuite/Tests/acc_create_with_len.F90",
                    "config": 1,
                    "errors": "",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 0.16572418296709657
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 0.018120794091373682,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvfortran -fast -acc -ta=multicore -DT1 -DT3 -DT4 -o /home/exouser/Testsuite/build/acc_create_with_len.F90/acc_create_with_len.F902 /home/exouser/Testsuite/Tests/acc_create_with_len.F90",
                    "config": 1,
                    "errors": "",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 0.16620288789272308
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 0.010540178045630455,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvfortran -fast -acc -ta=multicore -DT1 -DT2 -DT4 -o /home/exouser/Testsuite/build/acc_create_with_len.F90/acc_create_with_len.F903 /home/exouser/Testsuite/Tests/acc_create_with_len.F90",
                    "config": 1,
                    "errors": "NVFORTRAN-S-0038-Symbol, test4, has not been explicitly declared (/home/exouser/Testsuite/Tests/acc_create_with_len.F90)\n  0 inform,   0 warnings,   1 severes, 0 fatal for test3\n",
                    "export": false,
                    "output": "",
                    "result": 2,
                    "runtime": 0.03399819182232022
                },
                "post-compile commands": [],
                "pre-compile commands": [],
                "runtime": {
                    "export": false,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvfortran -fast -acc -ta=multicore -DT1 -DT2 -DT3 -o /home/exouser/Testsuite/build/acc_create_with_len.F90/acc_create_with_len.F904 /home/exouser/Testsuite/Tests/acc_create_with_len.F90",
                    "config": 1,
                    "errors": "",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 0.16576095717027783
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 0.010011458769440651,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvfortran -fast -acc -ta=multicore -DT3 -o /home/exouser/Testsuite/build/acc_create_with_len.F90/acc_create_with_len.F905 /home/exouser/Testsuite/Tests/acc_create_with_len.F90",
                    "config": 1,
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.21620884304866195
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.010260727722197771,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "acc_delete.F90": [
            {
                "compilation": {
                    "command": "nvfortran -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/acc_delete.F90/acc_delete.F900 /home/exouser/Testsuite/Tests/acc_delete.F90",
                    "config": 1,
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.21716155018657446
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.010118540842086077,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "acc_delete.c": [
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/acc_delete.c/acc_delete.c0 /home/exouser/Testsuite/Tests/acc_delete.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/acc_delete.c\", line 87: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.21582713816314936
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.009497102349996567,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "acc_delete_async.F90": [
            {
                "compilation": {
                    "command": "nvfortran -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/acc_delete_async.F90/acc_delete_async.F900 /home/exouser/Testsuite/Tests/acc_delete_async.F90",
                    "config": 1,
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.21662678895518184
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.010553412139415741,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "acc_delete_async.c": [
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/acc_delete_async.c/acc_delete_async.c0 /home/exouser/Testsuite/Tests/acc_delete_async.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/acc_delete_async.c\", line 126: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.21582805830985308
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.009462731890380383,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "acc_delete_async_with_len.F90": [
            {
                "compilation": {
                    "command": "nvfortran -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/acc_delete_async_with_len.F90/acc_delete_async_with_len.F900 /home/exouser/Testsuite/Tests/acc_delete_async_with_len.F90",
                    "config": 1,
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.21707371482625604
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.010254737921059132,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "acc_delete_finalize.F90": [
            {
                "compilation": {
                    "command": "nvfortran -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/acc_delete_finalize.F90/acc_delete_finalize.F900 /home/exouser/Testsuite/Tests/acc_delete_finalize.F90",
                    "config": 1,
                    "errors": "/tmp/nvfortranbZjdoob1REL.o: In function `test1_':\n/home/exouser/Testsuite/Tests/acc_delete_finalize.F90:33: undefined reference to `acc_delete_finalize_'\n/home/exouser/Testsuite/Tests/acc_delete_finalize.F90:34: undefined reference to `acc_delete_finalize_'\n/tmp/nvfortranbZjdoob1REL.o: In function `test2_':\n/home/exouser/Testsuite/Tests/acc_delete_finalize.F90:77: undefined reference to `acc_delete_finalize_'\n/home/exouser/Testsuite/Tests/acc_delete_finalize.F90:78: undefined reference to `acc_delete_finalize_'\npgacclnk: child process exit status 1: /usr/bin/ld\n",
                    "export": false,
                    "output": "",
                    "result": 2,
                    "runtime": 0.21718116430565715
                },
                "post-compile commands": [],
                "pre-compile commands": [],
                "runtime": {
                    "export": false,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvfortran -fast -acc -ta=multicore -DT1 -o /home/exouser/Testsuite/build/acc_delete_finalize.F90/acc_delete_finalize.F901 /home/exouser/Testsuite/Tests/acc_delete_finalize.F90",
                    "config": 1,
                    "errors": "/tmp/nvfortranb8jdMnuW3hF.o: In function `test2_':\n/home/exouser/Testsuite/Tests/acc_delete_finalize.F90:77: undefined reference to `acc_delete_finalize_'\n/home/exouser/Testsuite/Tests/acc_delete_finalize.F90:78: undefined reference to `acc_delete_finalize_'\npgacclnk: child process exit status 1: /usr/bin/ld\n",
                    "export": false,
                    "output": "",
                    "result": 2,
                    "runtime": 0.1672797491773963
                },
                "post-compile commands": [],
                "pre-compile commands": [],
                "runtime": {
                    "export": false,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvfortran -fast -acc -ta=multicore -DT2 -o /home/exouser/Testsuite/build/acc_delete_finalize.F90/acc_delete_finalize.F902 /home/exouser/Testsuite/Tests/acc_delete_finalize.F90",
                    "config": 1,
                    "errors": "/tmp/nvfortranbfkdc-3WjOj.o: In function `test1_':\n/home/exouser/Testsuite/Tests/acc_delete_finalize.F90:33: undefined reference to `acc_delete_finalize_'\n/home/exouser/Testsuite/Tests/acc_delete_finalize.F90:34: undefined reference to `acc_delete_finalize_'\npgacclnk: child process exit status 1: /usr/bin/ld\n",
                    "export": false,
                    "output": "",
                    "result": 2,
                    "runtime": 0.167280456982553
                },
                "post-compile commands": [],
                "pre-compile commands": [],
                "runtime": {
                    "export": false,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvfortran -fast -acc -ta=multicore -DT1 -o /home/exouser/Testsuite/build/acc_delete_finalize.F90/acc_delete_finalize.F903 /home/exouser/Testsuite/Tests/acc_delete_finalize.F90",
                    "config": 1,
                    "errors": "/tmp/nvfortranbokd2NLW-Bt.o: In function `test2_':\n/home/exouser/Testsuite/Tests/acc_delete_finalize.F90:77: undefined reference to `acc_delete_finalize_'\n/home/exouser/Testsuite/Tests/acc_delete_finalize.F90:78: undefined reference to `acc_delete_finalize_'\npgacclnk: child process exit status 1: /usr/bin/ld\n",
                    "export": true,
                    "output": "",
                    "result": 2,
                    "runtime": 0.1669190051034093
                },
                "post-compile commands": [],
                "pre-compile commands": [],
                "runtime": {
                    "export": true,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "acc_delete_finalize.c": [
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/acc_delete_finalize.c/acc_delete_finalize.c0 /home/exouser/Testsuite/Tests/acc_delete_finalize.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/acc_delete_finalize.c\", line 31: warning: function \"acc_delete_finalize\" declared implicitly\n      acc_delete_finalize(a, n * sizeof(real_t));\n      ^\n\n\"/home/exouser/Testsuite/Tests/acc_delete_finalize.c\", line 75: warning: function \"acc_delete_finalize\" declared implicitly\n      acc_delete_finalize(a, n * sizeof(real_t));\n      ^\n\n\"/home/exouser/Testsuite/Tests/acc_delete_finalize.c\", line 90: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n/tmp/nvcs0Wf25tFlYW5.o: In function `test1':\n/home/exouser/Testsuite/Tests/acc_delete_finalize.c:31: undefined reference to `acc_delete_finalize'\n/home/exouser/Testsuite/Tests/acc_delete_finalize.c:32: undefined reference to `acc_delete_finalize'\n/tmp/nvcs0Wf25tFlYW5.o: In function `test2':\n/home/exouser/Testsuite/Tests/acc_delete_finalize.c:75: undefined reference to `acc_delete_finalize'\n/home/exouser/Testsuite/Tests/acc_delete_finalize.c:76: undefined reference to `acc_delete_finalize'\npgacclnk: child process exit status 1: /usr/bin/ld\n",
                    "export": false,
                    "output": "",
                    "result": 2,
                    "runtime": 0.21572659071534872
                },
                "post-compile commands": [],
                "pre-compile commands": [],
                "runtime": {
                    "export": false,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -DT1 -o /home/exouser/Testsuite/build/acc_delete_finalize.c/acc_delete_finalize.c1 /home/exouser/Testsuite/Tests/acc_delete_finalize.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/acc_delete_finalize.c\", line 75: warning: function \"acc_delete_finalize\" declared implicitly\n      acc_delete_finalize(a, n * sizeof(real_t));\n      ^\n\n\"/home/exouser/Testsuite/Tests/acc_delete_finalize.c\", line 90: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n/tmp/nvcs8Wf2vyoxKyk.o: In function `test2':\n/home/exouser/Testsuite/Tests/acc_delete_finalize.c:75: undefined reference to `acc_delete_finalize'\n/home/exouser/Testsuite/Tests/acc_delete_finalize.c:76: undefined reference to `acc_delete_finalize'\npgacclnk: child process exit status 1: /usr/bin/ld\n",
                    "export": false,
                    "output": "",
                    "result": 2,
                    "runtime": 0.21670963009819388
                },
                "post-compile commands": [],
                "pre-compile commands": [],
                "runtime": {
                    "export": false,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -DT2 -o /home/exouser/Testsuite/build/acc_delete_finalize.c/acc_delete_finalize.c2 /home/exouser/Testsuite/Tests/acc_delete_finalize.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/acc_delete_finalize.c\", line 31: warning: function \"acc_delete_finalize\" declared implicitly\n      acc_delete_finalize(a, n * sizeof(real_t));\n      ^\n\n\"/home/exouser/Testsuite/Tests/acc_delete_finalize.c\", line 90: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n/tmp/nvcseXf2bPhxMd1.o: In function `test1':\n/home/exouser/Testsuite/Tests/acc_delete_finalize.c:31: undefined reference to `acc_delete_finalize'\n/home/exouser/Testsuite/Tests/acc_delete_finalize.c:32: undefined reference to `acc_delete_finalize'\npgacclnk: child process exit status 1: /usr/bin/ld\n",
                    "export": false,
                    "output": "",
                    "result": 2,
                    "runtime": 0.2165262410417199
                },
                "post-compile commands": [],
                "pre-compile commands": [],
                "runtime": {
                    "export": false,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -DT1 -o /home/exouser/Testsuite/build/acc_delete_finalize.c/acc_delete_finalize.c3 /home/exouser/Testsuite/Tests/acc_delete_finalize.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/acc_delete_finalize.c\", line 75: warning: function \"acc_delete_finalize\" declared implicitly\n      acc_delete_finalize(a, n * sizeof(real_t));\n      ^\n\n\"/home/exouser/Testsuite/Tests/acc_delete_finalize.c\", line 90: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n/tmp/nvcsmXf2PDex6jU.o: In function `test2':\n/home/exouser/Testsuite/Tests/acc_delete_finalize.c:75: undefined reference to `acc_delete_finalize'\n/home/exouser/Testsuite/Tests/acc_delete_finalize.c:76: undefined reference to `acc_delete_finalize'\npgacclnk: child process exit status 1: /usr/bin/ld\n",
                    "export": true,
                    "output": "",
                    "result": 2,
                    "runtime": 0.2166892229579389
                },
                "post-compile commands": [],
                "pre-compile commands": [],
                "runtime": {
                    "export": true,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "acc_delete_finalize_async.F90": [
            {
                "compilation": {
                    "command": "nvfortran -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/acc_delete_finalize_async.F90/acc_delete_finalize_async.F900 /home/exouser/Testsuite/Tests/acc_delete_finalize_async.F90",
                    "config": 1,
                    "errors": "/tmp/nvfortran1zkFVyGF-Tz.o: In function `test1_':\n/home/exouser/Testsuite/Tests/acc_delete_finalize_async.F90:41: undefined reference to `acc_delete_finalize_async_'\n/home/exouser/Testsuite/Tests/acc_delete_finalize_async.F90:42: undefined reference to `acc_delete_finalize_async_'\n/home/exouser/Testsuite/Tests/acc_delete_finalize_async.F90:43: undefined reference to `acc_delete_finalize_async_'\n/home/exouser/Testsuite/Tests/acc_delete_finalize_async.F90:44: undefined reference to `acc_delete_finalize_async_'\n/tmp/nvfortran1zkFVyGF-Tz.o: In function `test2_':\n/home/exouser/Testsuite/Tests/acc_delete_finalize_async.F90:90: undefined reference to `acc_delete_finalize_async_'\npgacclnk: child process exit status 1: /usr/bin/ld\n",
                    "export": false,
                    "output": "",
                    "result": 2,
                    "runtime": 0.21598142199218273
                },
                "post-compile commands": [],
                "pre-compile commands": [],
                "runtime": {
                    "export": false,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvfortran -fast -acc -ta=multicore -DT1 -o /home/exouser/Testsuite/build/acc_delete_finalize_async.F90/acc_delete_finalize_async.F901 /home/exouser/Testsuite/Tests/acc_delete_finalize_async.F90",
                    "config": 1,
                    "errors": "/tmp/nvfortranUIkkjQmls06.o: In function `test2_':\n/home/exouser/Testsuite/Tests/acc_delete_finalize_async.F90:90: undefined reference to `acc_delete_finalize_async_'\npgacclnk: child process exit status 1: /usr/bin/ld\n",
                    "export": false,
                    "output": "",
                    "result": 2,
                    "runtime": 0.16688611125573516
                },
                "post-compile commands": [],
                "pre-compile commands": [],
                "runtime": {
                    "export": false,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvfortran -fast -acc -ta=multicore -DT2 -o /home/exouser/Testsuite/build/acc_delete_finalize_async.F90/acc_delete_finalize_async.F902 /home/exouser/Testsuite/Tests/acc_delete_finalize_async.F90",
                    "config": 1,
                    "errors": "/tmp/nvfortranURkkTH_l4Sn.o: In function `test1_':\n/home/exouser/Testsuite/Tests/acc_delete_finalize_async.F90:41: undefined reference to `acc_delete_finalize_async_'\n/home/exouser/Testsuite/Tests/acc_delete_finalize_async.F90:42: undefined reference to `acc_delete_finalize_async_'\n/home/exouser/Testsuite/Tests/acc_delete_finalize_async.F90:43: undefined reference to `acc_delete_finalize_async_'\n/home/exouser/Testsuite/Tests/acc_delete_finalize_async.F90:44: undefined reference to `acc_delete_finalize_async_'\npgacclnk: child process exit status 1: /usr/bin/ld\n",
                    "export": false,
                    "output": "",
                    "result": 2,
                    "runtime": 0.2172557469457388
                },
                "post-compile commands": [],
                "pre-compile commands": [],
                "runtime": {
                    "export": false,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvfortran -fast -acc -ta=multicore -DT1 -o /home/exouser/Testsuite/build/acc_delete_finalize_async.F90/acc_delete_finalize_async.F903 /home/exouser/Testsuite/Tests/acc_delete_finalize_async.F90",
                    "config": 1,
                    "errors": "/tmp/nvfortranU0kkD9Plq_u.o: In function `test2_':\n/home/exouser/Testsuite/Tests/acc_delete_finalize_async.F90:90: undefined reference to `acc_delete_finalize_async_'\npgacclnk: child process exit status 1: /usr/bin/ld\n",
                    "export": true,
                    "output": "",
                    "result": 2,
                    "runtime": 0.1668115509673953
                },
                "post-compile commands": [],
                "pre-compile commands": [],
                "runtime": {
                    "export": true,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "acc_delete_finalize_async.c": [
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/acc_delete_finalize_async.c/acc_delete_finalize_async.c0 /home/exouser/Testsuite/Tests/acc_delete_finalize_async.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/acc_delete_finalize_async.c\", line 42: warning: function \"acc_delete_finalize_async\" declared implicitly\n          acc_delete_finalize_async(a, n * sizeof(real_t), 1);\n          ^\n\n\"/home/exouser/Testsuite/Tests/acc_delete_finalize_async.c\", line 101: warning: function \"acc_delete_finalize_async\" declared implicitly\n          acc_delete_finalize_async(c, n * sizeof(real_t), 1);\n          ^\n\n\"/home/exouser/Testsuite/Tests/acc_delete_finalize_async.c\", line 128: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n/tmp/nvcZwXfz5Vv7H9t.o: In function `test1':\n/home/exouser/Testsuite/Tests/acc_delete_finalize_async.c:42: undefined reference to `acc_delete_finalize_async'\n/home/exouser/Testsuite/Tests/acc_delete_finalize_async.c:43: undefined reference to `acc_delete_finalize_async'\n/home/exouser/Testsuite/Tests/acc_delete_finalize_async.c:44: undefined reference to `acc_delete_finalize_async'\n/home/exouser/Testsuite/Tests/acc_delete_finalize_async.c:45: undefined reference to `acc_delete_finalize_async'\npgacclnk: child process exit status 1: /usr/bin/ld\n",
                    "export": false,
                    "output": "",
                    "result": 2,
                    "runtime": 0.21598751982674003
                },
                "post-compile commands": [],
                "pre-compile commands": [],
                "runtime": {
                    "export": false,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -DT1 -o /home/exouser/Testsuite/build/acc_delete_finalize_async.c/acc_delete_finalize_async.c1 /home/exouser/Testsuite/Tests/acc_delete_finalize_async.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/acc_delete_finalize_async.c\", line 101: warning: function \"acc_delete_finalize_async\" declared implicitly\n          acc_delete_finalize_async(c, n * sizeof(real_t), 1);\n          ^\n\n\"/home/exouser/Testsuite/Tests/acc_delete_finalize_async.c\", line 128: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.16649636486545205
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.005424449685961008,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "acc_delete_finalize_async_with_len.F90": [
            {
                "compilation": {
                    "command": "nvfortran -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/acc_delete_finalize_async_with_len.F90/acc_delete_finalize_async_with_len.F900 /home/exouser/Testsuite/Tests/acc_delete_finalize_async_with_len.F90",
                    "config": 1,
                    "errors": "/tmp/nvfortranf-kpHP58WGd.o: In function `test1_':\n/home/exouser/Testsuite/Tests/acc_delete_finalize_async_with_len.F90:40: undefined reference to `acc_delete_finalize_async_'\n/home/exouser/Testsuite/Tests/acc_delete_finalize_async_with_len.F90:41: undefined reference to `acc_delete_finalize_async_'\n/home/exouser/Testsuite/Tests/acc_delete_finalize_async_with_len.F90:42: undefined reference to `acc_delete_finalize_async_'\n/home/exouser/Testsuite/Tests/acc_delete_finalize_async_with_len.F90:43: undefined reference to `acc_delete_finalize_async_'\n/tmp/nvfortranf-kpHP58WGd.o: In function `test2_':\n/home/exouser/Testsuite/Tests/acc_delete_finalize_async_with_len.F90:93: undefined reference to `acc_delete_finalize_async_'\npgacclnk: child process exit status 1: /usr/bin/ld\n",
                    "export": false,
                    "output": "",
                    "result": 2,
                    "runtime": 0.2177189034409821
                },
                "post-compile commands": [],
                "pre-compile commands": [],
                "runtime": {
                    "export": false,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvfortran -fast -acc -ta=multicore -DT1 -o /home/exouser/Testsuite/build/acc_delete_finalize_async_with_len.F90/acc_delete_finalize_async_with_len.F901 /home/exouser/Testsuite/Tests/acc_delete_finalize_async_with_len.F90",
                    "config": 1,
                    "errors": "/tmp/nvfortranfilpHGlZqu0.o: In function `test2_':\n/home/exouser/Testsuite/Tests/acc_delete_finalize_async_with_len.F90:93: undefined reference to `acc_delete_finalize_async_'\npgacclnk: child process exit status 1: /usr/bin/ld\n",
                    "export": false,
                    "output": "",
                    "result": 2,
                    "runtime": 0.16698735486716032
                },
                "post-compile commands": [],
                "pre-compile commands": [],
                "runtime": {
                    "export": false,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvfortran -fast -acc -ta=multicore -DT2 -o /home/exouser/Testsuite/build/acc_delete_finalize_async_with_len.F90/acc_delete_finalize_async_with_len.F902 /home/exouser/Testsuite/Tests/acc_delete_finalize_async_with_len.F90",
                    "config": 1,
                    "errors": "/tmp/nvfortranmrlKlX_Yde0.o: In function `test1_':\n/home/exouser/Testsuite/Tests/acc_delete_finalize_async_with_len.F90:40: undefined reference to `acc_delete_finalize_async_'\n/home/exouser/Testsuite/Tests/acc_delete_finalize_async_with_len.F90:41: undefined reference to `acc_delete_finalize_async_'\n/home/exouser/Testsuite/Tests/acc_delete_finalize_async_with_len.F90:42: undefined reference to `acc_delete_finalize_async_'\n/home/exouser/Testsuite/Tests/acc_delete_finalize_async_with_len.F90:43: undefined reference to `acc_delete_finalize_async_'\npgacclnk: child process exit status 1: /usr/bin/ld\n",
                    "export": false,
                    "output": "",
                    "result": 2,
                    "runtime": 0.16697339620441198
                },
                "post-compile commands": [],
                "pre-compile commands": [],
                "runtime": {
                    "export": false,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvfortran -fast -acc -ta=multicore -DT1 -o /home/exouser/Testsuite/build/acc_delete_finalize_async_with_len.F90/acc_delete_finalize_async_with_len.F903 /home/exouser/Testsuite/Tests/acc_delete_finalize_async_with_len.F90",
                    "config": 1,
                    "errors": "/tmp/nvfortranmAlKx8VY16l.o: In function `test2_':\n/home/exouser/Testsuite/Tests/acc_delete_finalize_async_with_len.F90:93: undefined reference to `acc_delete_finalize_async_'\npgacclnk: child process exit status 1: /usr/bin/ld\n",
                    "export": true,
                    "output": "",
                    "result": 2,
                    "runtime": 0.16710105305537581
                },
                "post-compile commands": [],
                "pre-compile commands": [],
                "runtime": {
                    "export": true,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "acc_delete_finalize_with_len.F90": [
            {
                "compilation": {
                    "command": "nvfortran -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/acc_delete_finalize_with_len.F90/acc_delete_finalize_with_len.F900 /home/exouser/Testsuite/Tests/acc_delete_finalize_with_len.F90",
                    "config": 1,
                    "errors": "/tmp/nvfortransLl22QW0xV7.o: In function `test1_':\n/home/exouser/Testsuite/Tests/acc_delete_finalize_with_len.F90:34: undefined reference to `acc_delete_finalize_'\n/home/exouser/Testsuite/Tests/acc_delete_finalize_with_len.F90:35: undefined reference to `acc_delete_finalize_'\n/tmp/nvfortransLl22QW0xV7.o: In function `test2_':\n/home/exouser/Testsuite/Tests/acc_delete_finalize_with_len.F90:84: undefined reference to `acc_delete_finalize_'\n/home/exouser/Testsuite/Tests/acc_delete_finalize_with_len.F90:85: undefined reference to `acc_delete_finalize_'\npgacclnk: child process exit status 1: /usr/bin/ld\n",
                    "export": false,
                    "output": "",
                    "result": 2,
                    "runtime": 0.21740688430145383
                },
                "post-compile commands": [],
                "pre-compile commands": [],
                "runtime": {
                    "export": false,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvfortran -fast -acc -ta=multicore -DT1 -o /home/exouser/Testsuite/build/acc_delete_finalize_with_len.F90/acc_delete_finalize_with_len.F901 /home/exouser/Testsuite/Tests/acc_delete_finalize_with_len.F90",
                    "config": 1,
                    "errors": "/tmp/nvfortransUl2MlxXVIW.o: In function `test2_':\n/home/exouser/Testsuite/Tests/acc_delete_finalize_with_len.F90:84: undefined reference to `acc_delete_finalize_'\n/home/exouser/Testsuite/Tests/acc_delete_finalize_with_len.F90:85: undefined reference to `acc_delete_finalize_'\npgacclnk: child process exit status 1: /usr/bin/ld\n",
                    "export": false,
                    "output": "",
                    "result": 2,
                    "runtime": 0.1678008157759905
                },
                "post-compile commands": [],
                "pre-compile commands": [],
                "runtime": {
                    "export": false,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvfortran -fast -acc -ta=multicore -DT2 -o /home/exouser/Testsuite/build/acc_delete_finalize_with_len.F90/acc_delete_finalize_with_len.F902 /home/exouser/Testsuite/Tests/acc_delete_finalize_with_len.F90",
                    "config": 1,
                    "errors": "/tmp/nvfortrans3l2A9vX5pU.o: In function `test1_':\n/home/exouser/Testsuite/Tests/acc_delete_finalize_with_len.F90:34: undefined reference to `acc_delete_finalize_'\n/home/exouser/Testsuite/Tests/acc_delete_finalize_with_len.F90:35: undefined reference to `acc_delete_finalize_'\npgacclnk: child process exit status 1: /usr/bin/ld\n",
                    "export": false,
                    "output": "",
                    "result": 2,
                    "runtime": 0.16700926329940557
                },
                "post-compile commands": [],
                "pre-compile commands": [],
                "runtime": {
                    "export": false,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvfortran -fast -acc -ta=multicore -DT1 -o /home/exouser/Testsuite/build/acc_delete_finalize_with_len.F90/acc_delete_finalize_with_len.F903 /home/exouser/Testsuite/Tests/acc_delete_finalize_with_len.F90",
                    "config": 1,
                    "errors": "/tmp/nvfortransam2oQKXBVA.o: In function `test2_':\n/home/exouser/Testsuite/Tests/acc_delete_finalize_with_len.F90:84: undefined reference to `acc_delete_finalize_'\n/home/exouser/Testsuite/Tests/acc_delete_finalize_with_len.F90:85: undefined reference to `acc_delete_finalize_'\npgacclnk: child process exit status 1: /usr/bin/ld\n",
                    "export": true,
                    "output": "",
                    "result": 2,
                    "runtime": 0.1699970057234168
                },
                "post-compile commands": [],
                "pre-compile commands": [],
                "runtime": {
                    "export": true,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "acc_delete_with_len.F90": [
            {
                "compilation": {
                    "command": "nvfortran -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/acc_delete_with_len.F90/acc_delete_with_len.F900 /home/exouser/Testsuite/Tests/acc_delete_with_len.F90",
                    "config": 1,
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.21675906097516418
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.010836084838956594,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "acc_deviceptr.c": [
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/acc_deviceptr.c/acc_deviceptr.c0 /home/exouser/Testsuite/Tests/acc_deviceptr.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/acc_deviceptr.c\", line 50: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.21576755214482546
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.009667992126196623,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "acc_free.c": [
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/acc_free.c/acc_free.c0 /home/exouser/Testsuite/Tests/acc_free.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/acc_free.c\", line 20: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.16568591399118304
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 1,
                    "runtime": 0.009529863018542528,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "acc_get_default_async.F90": [
            {
                "compilation": {
                    "command": "nvfortran -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/acc_get_default_async.F90/acc_get_default_async.F900 /home/exouser/Testsuite/Tests/acc_get_default_async.F90",
                    "config": 1,
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.16720661520957947
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.01050564693287015,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "acc_get_default_async.c": [
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/acc_get_default_async.c/acc_get_default_async.c0 /home/exouser/Testsuite/Tests/acc_get_default_async.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/acc_get_default_async.c\", line 44: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.2155664237216115
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.009620972909033298,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "acc_get_device_num.F90": [
            {
                "compilation": {
                    "command": "nvfortran -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/acc_get_device_num.F90/acc_get_device_num.F900 /home/exouser/Testsuite/Tests/acc_get_device_num.F90",
                    "config": 1,
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.16637545684352517
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 1,
                    "runtime": 0.005488643888384104,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "acc_get_device_num.c": [
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/acc_get_device_num.c/acc_get_device_num.c0 /home/exouser/Testsuite/Tests/acc_get_device_num.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/acc_get_device_num.c\", line 22: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.1655946196988225
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.005344002041965723,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "acc_get_num_devices.F90": [
            {
                "compilation": {
                    "command": "nvfortran -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/acc_get_num_devices.F90/acc_get_num_devices.F900 /home/exouser/Testsuite/Tests/acc_get_num_devices.F90",
                    "config": 1,
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.11660814797505736
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.006448677740991116,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "acc_get_num_devices.c": [
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/acc_get_num_devices.c/acc_get_num_devices.c0 /home/exouser/Testsuite/Tests/acc_get_num_devices.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/acc_get_num_devices.c\", line 17: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.16565720783546567
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.005365978926420212,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "acc_get_property.F90": [
            {
                "compilation": {
                    "command": "nvfortran -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/acc_get_property.F90/acc_get_property.F900 /home/exouser/Testsuite/Tests/acc_get_property.F90",
                    "config": 1,
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.11627207789570093
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.006127893924713135,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "acc_get_property.c": [
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/acc_get_property.c/acc_get_property.c0 /home/exouser/Testsuite/Tests/acc_get_property.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/acc_get_property.c\", line 8: warning: variable \"returned_string1\" was set but never used\n          const char* returned_string1;\n                      ^\n\n\"/home/exouser/Testsuite/Tests/acc_get_property.c\", line 9: warning: variable \"returned_string2\" was set but never used\n          const char* returned_string2;\n                      ^\n\n\"/home/exouser/Testsuite/Tests/acc_get_property.c\", line 10: warning: variable \"returned_string3\" was set but never used\n          const char* returned_string3;\n                      ^\n\n\"/home/exouser/Testsuite/Tests/acc_get_property.c\", line 11: warning: variable \"returned_int\" was set but never used\n          int returned_int;\n              ^\n\n\"/home/exouser/Testsuite/Tests/acc_get_property.c\", line 25: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.16544651286676526
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.005340821109712124,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "acc_get_property_string.F90": [
            {
                "compilation": {
                    "command": "nvfortran -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/acc_get_property_string.F90/acc_get_property_string.F900 /home/exouser/Testsuite/Tests/acc_get_property_string.F90",
                    "config": 1,
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.11676498409360647
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.006041221786290407,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "acc_hostptr.c": [
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/acc_hostptr.c/acc_hostptr.c0 /home/exouser/Testsuite/Tests/acc_hostptr.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/acc_hostptr.c\", line 7: warning: variable \"a_ptr\" was set but never used\n      real_t *a_ptr;\n              ^\n\n\"/home/exouser/Testsuite/Tests/acc_hostptr.c\", line 23: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.16562438383698463
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.005393735133111477,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "acc_init.F90": [
            {
                "compilation": {
                    "command": "nvfortran -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/acc_init.F90/acc_init.F900 /home/exouser/Testsuite/Tests/acc_init.F90",
                    "config": 1,
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.11589128570631146
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.0053531997837126255,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "acc_init.c": [
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/acc_init.c/acc_init.c0 /home/exouser/Testsuite/Tests/acc_init.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/acc_init.c\", line 17: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.16573868179693818
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.005350133404135704,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "acc_is_present.F90": [
            {
                "compilation": {
                    "command": "nvfortran -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/acc_is_present.F90/acc_is_present.F900 /home/exouser/Testsuite/Tests/acc_is_present.F90",
                    "config": 1,
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.1661636969074607
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.01004302129149437,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "acc_is_present.c": [
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/acc_is_present.c/acc_is_present.c0 /home/exouser/Testsuite/Tests/acc_is_present.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/acc_is_present.c\", line 34: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.16579584404826164
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.005358756985515356,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "acc_is_present_with_len.F90": [
            {
                "compilation": {
                    "command": "nvfortran -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/acc_is_present_with_len.F90/acc_is_present_with_len.F900 /home/exouser/Testsuite/Tests/acc_is_present_with_len.F90",
                    "config": 1,
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.11604853300377727
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.009959274902939796,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "acc_malloc.c": [
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/acc_malloc.c/acc_malloc.c0 /home/exouser/Testsuite/Tests/acc_malloc.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/acc_malloc.c\", line 23: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.16584624210372567
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 1,
                    "runtime": 0.005331357009708881,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "acc_map_data.c": [
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/acc_map_data.c/acc_map_data.c0 /home/exouser/Testsuite/Tests/acc_map_data.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/acc_map_data.c\", line 157: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.3164680921472609
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 4,
                    "runtime": 0.009496807120740414,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "acc_memcpy_device.c": [
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/acc_memcpy_device.c/acc_memcpy_device.c0 /home/exouser/Testsuite/Tests/acc_memcpy_device.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/acc_memcpy_device.c\", line 57: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.16566274408251047
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.009571586735546589,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "acc_memcpy_from_device.c": [
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/acc_memcpy_from_device.c/acc_memcpy_from_device.c0 /home/exouser/Testsuite/Tests/acc_memcpy_from_device.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/acc_memcpy_from_device.c\", line 56: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.16566391522064805
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.009430092759430408,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "acc_memcpy_from_device_async.c": [
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/acc_memcpy_from_device_async.c/acc_memcpy_from_device_async.c0 /home/exouser/Testsuite/Tests/acc_memcpy_from_device_async.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/acc_memcpy_from_device_async.c\", line 129: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.31602080911397934
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.009545586071908474,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "acc_memcpy_to_device.c": [
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/acc_memcpy_to_device.c/acc_memcpy_to_device.c0 /home/exouser/Testsuite/Tests/acc_memcpy_to_device.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/acc_memcpy_to_device.c\", line 47: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.1656597671099007
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.00939841428771615,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "acc_memcpy_to_device_async.c": [
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/acc_memcpy_to_device_async.c/acc_memcpy_to_device_async.c0 /home/exouser/Testsuite/Tests/acc_memcpy_to_device_async.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/acc_memcpy_to_device_async.c\", line 115: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.2662805123254657
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.009720680769532919,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "acc_on_device.F90": [
            {
                "compilation": {
                    "command": "nvfortran -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/acc_on_device.F90/acc_on_device.F900 /home/exouser/Testsuite/Tests/acc_on_device.F90",
                    "config": 1,
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.16666378127411008
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.010314387734979391,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "acc_on_device.c": [
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/acc_on_device.c/acc_on_device.c0 /home/exouser/Testsuite/Tests/acc_on_device.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/acc_on_device.c\", line 13: warning: enumerated type mixed with another type\n                  if (acc_on_device(device_type) == 0){\n                                    ^\n\n\"/home/exouser/Testsuite/Tests/acc_on_device.c\", line 34: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.16589059494435787
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.005344155244529247,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "acc_set_default_async.F90": [
            {
                "compilation": {
                    "command": "nvfortran -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/acc_set_default_async.F90/acc_set_default_async.F900 /home/exouser/Testsuite/Tests/acc_set_default_async.F90",
                    "config": 1,
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.1660930230282247
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.019133280962705612,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "acc_set_default_async.c": [
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/acc_set_default_async.c/acc_set_default_async.c0 /home/exouser/Testsuite/Tests/acc_set_default_async.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/acc_set_default_async.c\", line 60: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.21575142908841372
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.009588277898728848,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "acc_set_device_num.F90": [
            {
                "compilation": {
                    "command": "nvfortran -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/acc_set_device_num.F90/acc_set_device_num.F900 /home/exouser/Testsuite/Tests/acc_set_device_num.F90",
                    "config": 1,
                    "errors": "NVFORTRAN-S-0034-Syntax error at or near end of line (/home/exouser/Testsuite/Tests/acc_set_device_num.F90: 22)\nNVFORTRAN-S-0034-Syntax error at or near end of line (/home/exouser/Testsuite/Tests/acc_set_device_num.F90: 27)\nNVFORTRAN-S-0034-Syntax error at or near end of line (/home/exouser/Testsuite/Tests/acc_set_device_num.F90: 39)\n  0 inform,   0 warnings,   3 severes, 0 fatal for test1\n",
                    "export": false,
                    "output": "",
                    "result": 2,
                    "runtime": 0.03394424729049206
                },
                "post-compile commands": [],
                "pre-compile commands": [],
                "runtime": {
                    "export": false,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvfortran -fast -acc -ta=multicore -DT1 -o /home/exouser/Testsuite/build/acc_set_device_num.F90/acc_set_device_num.F901 /home/exouser/Testsuite/Tests/acc_set_device_num.F90",
                    "config": 1,
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.11581537872552872
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.005679860711097717,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "acc_set_device_num.c": [
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/acc_set_device_num.c/acc_set_device_num.c0 /home/exouser/Testsuite/Tests/acc_set_device_num.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/acc_set_device_num.c\", line 51: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.16556305019184947
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.017532565165311098,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "acc_set_device_type.F90": [
            {
                "compilation": {
                    "command": "nvfortran -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/acc_set_device_type.F90/acc_set_device_type.F900 /home/exouser/Testsuite/Tests/acc_set_device_type.F90",
                    "config": 1,
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.11593530420213938
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.010249963030219078,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "acc_set_device_type.c": [
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/acc_set_device_type.c/acc_set_device_type.c0 /home/exouser/Testsuite/Tests/acc_set_device_type.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/acc_set_device_type.c\", line 9: warning: enumerated type mixed with another type\n      acc_set_device_type(device_type);\n                          ^\n\n\"/home/exouser/Testsuite/Tests/acc_set_device_type.c\", line 20: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.16568879829719663
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.005395734217017889,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "acc_shutdown.F90": [
            {
                "compilation": {
                    "command": "nvfortran -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/acc_shutdown.F90/acc_shutdown.F900 /home/exouser/Testsuite/Tests/acc_shutdown.F90",
                    "config": 1,
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.11610947316512465
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.005669509992003441,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "acc_shutdown.c": [
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/acc_shutdown.c/acc_shutdown.c0 /home/exouser/Testsuite/Tests/acc_shutdown.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/acc_shutdown.c\", line 17: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.16557023860514164
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.009449340868741274,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "acc_unmap_data.c": [
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/acc_unmap_data.c/acc_unmap_data.c0 /home/exouser/Testsuite/Tests/acc_unmap_data.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/acc_unmap_data.c\", line 157: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.31603572703897953
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 4,
                    "runtime": 0.009689059108495712,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "acc_update_device.F90": [
            {
                "compilation": {
                    "command": "nvfortran -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/acc_update_device.F90/acc_update_device.F900 /home/exouser/Testsuite/Tests/acc_update_device.F90",
                    "config": 1,
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.21623898623511195
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.010042797774076462,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "acc_update_device.c": [
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/acc_update_device.c/acc_update_device.c0 /home/exouser/Testsuite/Tests/acc_update_device.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/acc_update_device.c\", line 111: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.21581861469894648
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.009557144716382027,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "acc_update_device_async.F90": [
            {
                "compilation": {
                    "command": "nvfortran -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/acc_update_device_async.F90/acc_update_device_async.F900 /home/exouser/Testsuite/Tests/acc_update_device_async.F90",
                    "config": 1,
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.2675123047083616
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.01001207111403346,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "acc_update_device_async.c": [
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/acc_update_device_async.c/acc_update_device_async.c0 /home/exouser/Testsuite/Tests/acc_update_device_async.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/acc_update_device_async.c\", line 137: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.21591155091300607
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.017520009074360132,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "acc_update_device_async_with_len.F90": [
            {
                "compilation": {
                    "command": "nvfortran -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/acc_update_device_async_with_len.F90/acc_update_device_async_with_len.F900 /home/exouser/Testsuite/Tests/acc_update_device_async_with_len.F90",
                    "config": 1,
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.2679726700298488
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.009910644963383675,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "acc_update_device_with_len.F90": [
            {
                "compilation": {
                    "command": "nvfortran -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/acc_update_device_with_len.F90/acc_update_device_with_len.F900 /home/exouser/Testsuite/Tests/acc_update_device_with_len.F90",
                    "config": 1,
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.2162842289544642
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.010165790095925331,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "acc_update_self.F90": [
            {
                "compilation": {
                    "command": "nvfortran -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/acc_update_self.F90/acc_update_self.F900 /home/exouser/Testsuite/Tests/acc_update_self.F90",
                    "config": 1,
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.21651995740830898
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.018061724957078695,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "acc_update_self.c": [
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/acc_update_self.c/acc_update_self.c0 /home/exouser/Testsuite/Tests/acc_update_self.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/acc_update_self.c\", line 92: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.2663205647841096
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.009665544144809246,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "acc_update_self_async.F90": [
            {
                "compilation": {
                    "command": "nvfortran -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/acc_update_self_async.F90/acc_update_self_async.F900 /home/exouser/Testsuite/Tests/acc_update_self_async.F90",
                    "config": 1,
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.2667893972247839
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.009845074266195297,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "acc_update_self_async.c": [
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/acc_update_self_async.c/acc_update_self_async.c0 /home/exouser/Testsuite/Tests/acc_update_self_async.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/acc_update_self_async.c\", line 144: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.266163423191756
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.009668793994933367,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "acc_update_self_async_with_len.F90": [
            {
                "compilation": {
                    "command": "nvfortran -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/acc_update_self_async_with_len.F90/acc_update_self_async_with_len.F900 /home/exouser/Testsuite/Tests/acc_update_self_async_with_len.F90",
                    "config": 1,
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.26693054381757975
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.009941070806235075,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "acc_update_self_with_len.F90": [
            {
                "compilation": {
                    "command": "nvfortran -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/acc_update_self_with_len.F90/acc_update_self_with_len.F900 /home/exouser/Testsuite/Tests/acc_update_self_with_len.F90",
                    "config": 1,
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.2162804789841175
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.009481377899646759,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "acc_wait.F90": [
            {
                "compilation": {
                    "command": "nvfortran -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/acc_wait.F90/acc_wait.F900 /home/exouser/Testsuite/Tests/acc_wait.F90",
                    "config": 1,
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.16592960711568594
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.010059641674160957,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "acc_wait.c": [
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/acc_wait.c/acc_wait.c0 /home/exouser/Testsuite/Tests/acc_wait.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/acc_wait.c\", line 53: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.21548695536330342
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.009582918137311935,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "acc_wait_all.F90": [
            {
                "compilation": {
                    "command": "nvfortran -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/acc_wait_all.F90/acc_wait_all.F900 /home/exouser/Testsuite/Tests/acc_wait_all.F90",
                    "config": 1,
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.21731218416243792
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.018141950014978647,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "acc_wait_all.c": [
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/acc_wait_all.c/acc_wait_all.c0 /home/exouser/Testsuite/Tests/acc_wait_all.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/acc_wait_all.c\", line 69: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.21587913110852242
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.009644854813814163,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "acc_wait_all_async.F90": [
            {
                "compilation": {
                    "command": "nvfortran -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/acc_wait_all_async.F90/acc_wait_all_async.F900 /home/exouser/Testsuite/Tests/acc_wait_all_async.F90",
                    "config": 1,
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.26675302581861615
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.009862000122666359,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "acc_wait_all_async.c": [
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/acc_wait_all_async.c/acc_wait_all_async.c0 /home/exouser/Testsuite/Tests/acc_wait_all_async.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/acc_wait_all_async.c\", line 113: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.36693041725084186
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.00954012293368578,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "acc_wait_async.F90": [
            {
                "compilation": {
                    "command": "nvfortran -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/acc_wait_async.F90/acc_wait_async.F900 /home/exouser/Testsuite/Tests/acc_wait_async.F90",
                    "config": 1,
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.2165549648925662
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.017778178676962852,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "acc_wait_async.c": [
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/acc_wait_async.c/acc_wait_async.c0 /home/exouser/Testsuite/Tests/acc_wait_async.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/acc_wait_async.c\", line 75: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.2655911589972675
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.017739213071763515,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "atomic_bitand_equals.c": [
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/atomic_bitand_equals.c/atomic_bitand_equals.c0 /home/exouser/Testsuite/Tests/atomic_bitand_equals.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/atomic_bitand_equals.c\", line 53: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.21598531398922205
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 1,
                    "runtime": 0.009525483008474112,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "atomic_bitor_equals.c": [
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/atomic_bitor_equals.c/atomic_bitor_equals.c0 /home/exouser/Testsuite/Tests/atomic_bitor_equals.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/atomic_bitor_equals.c\", line 51: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.16606597416102886
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.010273711755871773,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "atomic_bitxor_equals.c": [
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/atomic_bitxor_equals.c/atomic_bitxor_equals.c0 /home/exouser/Testsuite/Tests/atomic_bitxor_equals.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/atomic_bitxor_equals.c\", line 51: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.2160637159831822
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.010036660358309746,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "atomic_capture_assign_expr_and_x.F90": [
            {
                "compilation": {
                    "command": "nvfortran -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/atomic_capture_assign_expr_and_x.F90/atomic_capture_assign_expr_and_x.F900 /home/exouser/Testsuite/Tests/atomic_capture_assign_expr_and_x.F90",
                    "config": 1,
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.3168087722733617
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.010131244082003832,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "atomic_capture_assign_expr_divided_x.F90": [
            {
                "compilation": {
                    "command": "nvfortran -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/atomic_capture_assign_expr_divided_x.F90/atomic_capture_assign_expr_divided_x.F900 /home/exouser/Testsuite/Tests/atomic_capture_assign_expr_divided_x.F90",
                    "config": 1,
                    "errors": "",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 0.21636789524927735
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "Failed to complete within timeout",
                    "export": false,
                    "output": "",
                    "result": -1,
                    "runtime": -1,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvfortran -fast -acc -ta=multicore -DT1 -o /home/exouser/Testsuite/build/atomic_capture_assign_expr_divided_x.F90/atomic_capture_assign_expr_divided_x.F901 /home/exouser/Testsuite/Tests/atomic_capture_assign_expr_divided_x.F90",
                    "config": 1,
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.16662575490772724
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.009540131315588951,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "atomic_capture_assign_expr_eqv_x.F90": [
            {
                "compilation": {
                    "command": "nvfortran -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/atomic_capture_assign_expr_eqv_x.F90/atomic_capture_assign_expr_eqv_x.F900 /home/exouser/Testsuite/Tests/atomic_capture_assign_expr_eqv_x.F90",
                    "config": 1,
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.31606146367266774
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.0097464588470757,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "atomic_capture_assign_expr_minus_x.F90": [
            {
                "compilation": {
                    "command": "nvfortran -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/atomic_capture_assign_expr_minus_x.F90/atomic_capture_assign_expr_minus_x.F900 /home/exouser/Testsuite/Tests/atomic_capture_assign_expr_minus_x.F90",
                    "config": 1,
                    "errors": "",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 0.21599647030234337
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "Failed to complete within timeout",
                    "export": false,
                    "output": "",
                    "result": -1,
                    "runtime": -1,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvfortran -fast -acc -ta=multicore -DT1 -o /home/exouser/Testsuite/build/atomic_capture_assign_expr_minus_x.F90/atomic_capture_assign_expr_minus_x.F901 /home/exouser/Testsuite/Tests/atomic_capture_assign_expr_minus_x.F90",
                    "config": 1,
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.16693850280717015
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.009487422183156013,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "atomic_capture_assign_expr_neqv_x.F90": [
            {
                "compilation": {
                    "command": "nvfortran -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/atomic_capture_assign_expr_neqv_x.F90/atomic_capture_assign_expr_neqv_x.F900 /home/exouser/Testsuite/Tests/atomic_capture_assign_expr_neqv_x.F90",
                    "config": 1,
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.3160987230949104
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.017685858067125082,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "atomic_capture_assign_expr_or_x.F90": [
            {
                "compilation": {
                    "command": "nvfortran -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/atomic_capture_assign_expr_or_x.F90/atomic_capture_assign_expr_or_x.F900 /home/exouser/Testsuite/Tests/atomic_capture_assign_expr_or_x.F90",
                    "config": 1,
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.31587569369003177
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.03355369810014963,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "atomic_capture_assign_expr_plus_x.F90": [
            {
                "compilation": {
                    "command": "nvfortran -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/atomic_capture_assign_expr_plus_x.F90/atomic_capture_assign_expr_plus_x.F900 /home/exouser/Testsuite/Tests/atomic_capture_assign_expr_plus_x.F90",
                    "config": 1,
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.21583617525175214
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 1,
                    "runtime": 0.01775113819167018,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "atomic_capture_assign_expr_times_x.F90": [
            {
                "compilation": {
                    "command": "nvfortran -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/atomic_capture_assign_expr_times_x.F90/atomic_capture_assign_expr_times_x.F900 /home/exouser/Testsuite/Tests/atomic_capture_assign_expr_times_x.F90",
                    "config": 1,
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.21601969189941883
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.01773872133344412,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "atomic_capture_assign_iand_expr_x.F90": [
            {
                "compilation": {
                    "command": "nvfortran -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/atomic_capture_assign_iand_expr_x.F90/atomic_capture_assign_iand_expr_x.F900 /home/exouser/Testsuite/Tests/atomic_capture_assign_iand_expr_x.F90",
                    "config": 1,
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.26596793392673135
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.017737810034304857,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "atomic_capture_assign_iand_x_expr.F90": [
            {
                "compilation": {
                    "command": "nvfortran -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/atomic_capture_assign_iand_x_expr.F90/atomic_capture_assign_iand_x_expr.F900 /home/exouser/Testsuite/Tests/atomic_capture_assign_iand_x_expr.F90",
                    "config": 1,
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.2662363671697676
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.018066409043967724,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "atomic_capture_assign_ior_expr_x.F90": [
            {
                "compilation": {
                    "command": "nvfortran -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/atomic_capture_assign_ior_expr_x.F90/atomic_capture_assign_ior_expr_x.F900 /home/exouser/Testsuite/Tests/atomic_capture_assign_ior_expr_x.F90",
                    "config": 1,
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.26591186318546534
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.01775909774005413,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "atomic_capture_assign_ior_x_expr.F90": [
            {
                "compilation": {
                    "command": "nvfortran -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/atomic_capture_assign_ior_x_expr.F90/atomic_capture_assign_ior_x_expr.F900 /home/exouser/Testsuite/Tests/atomic_capture_assign_ior_x_expr.F90",
                    "config": 1,
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.26574589125812054
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.01746721798554063,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "atomic_capture_assign_ixor_expr_x.F90": [
            {
                "compilation": {
                    "command": "nvfortran -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/atomic_capture_assign_ixor_expr_x.F90/atomic_capture_assign_ixor_expr_x.F900 /home/exouser/Testsuite/Tests/atomic_capture_assign_ixor_expr_x.F90",
                    "config": 1,
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.2661294839344919
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.017559094820171595,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "atomic_capture_assign_ixor_x_expr.F90": [
            {
                "compilation": {
                    "command": "nvfortran -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/atomic_capture_assign_ixor_x_expr.F90/atomic_capture_assign_ixor_x_expr.F900 /home/exouser/Testsuite/Tests/atomic_capture_assign_ixor_x_expr.F90",
                    "config": 1,
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.26593142841011286
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.033558391965925694,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "atomic_capture_assign_max_expr_list_x.F90": [
            {
                "compilation": {
                    "command": "nvfortran -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/atomic_capture_assign_max_expr_list_x.F90/atomic_capture_assign_max_expr_list_x.F900 /home/exouser/Testsuite/Tests/atomic_capture_assign_max_expr_list_x.F90",
                    "config": 1,
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.266187293920666
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 1,
                    "runtime": 0.03383082430809736,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "atomic_capture_assign_max_expr_x.F90": [
            {
                "compilation": {
                    "command": "nvfortran -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/atomic_capture_assign_max_expr_x.F90/atomic_capture_assign_max_expr_x.F900 /home/exouser/Testsuite/Tests/atomic_capture_assign_max_expr_x.F90",
                    "config": 1,
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.21602327981963754
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 1,
                    "runtime": 0.03441777266561985,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "atomic_capture_assign_max_x_expr.F90": [
            {
                "compilation": {
                    "command": "nvfortran -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/atomic_capture_assign_max_x_expr.F90/atomic_capture_assign_max_x_expr.F900 /home/exouser/Testsuite/Tests/atomic_capture_assign_max_x_expr.F90",
                    "config": 1,
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.21591420518234372
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 1,
                    "runtime": 0.017727231606841087,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "atomic_capture_assign_max_x_expr_list.F90": [
            {
                "compilation": {
                    "command": "nvfortran -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/atomic_capture_assign_max_x_expr_list.F90/atomic_capture_assign_max_x_expr_list.F900 /home/exouser/Testsuite/Tests/atomic_capture_assign_max_x_expr_list.F90",
                    "config": 1,
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.2657631170004606
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 1,
                    "runtime": 0.03370808809995651,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "atomic_capture_assign_min_expr_list_x.F90": [
            {
                "compilation": {
                    "command": "nvfortran -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/atomic_capture_assign_min_expr_list_x.F90/atomic_capture_assign_min_expr_list_x.F900 /home/exouser/Testsuite/Tests/atomic_capture_assign_min_expr_list_x.F90",
                    "config": 1,
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.2660328238271177
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 1,
                    "runtime": 0.03375856811180711,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "atomic_capture_assign_min_expr_x.F90": [
            {
                "compilation": {
                    "command": "nvfortran -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/atomic_capture_assign_min_expr_x.F90/atomic_capture_assign_min_expr_x.F900 /home/exouser/Testsuite/Tests/atomic_capture_assign_min_expr_x.F90",
                    "config": 1,
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.2155015580356121
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 1,
                    "runtime": 0.017703368328511715,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "atomic_capture_assign_min_x_expr.F90": [
            {
                "compilation": {
                    "command": "nvfortran -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/atomic_capture_assign_min_x_expr.F90/atomic_capture_assign_min_x_expr.F900 /home/exouser/Testsuite/Tests/atomic_capture_assign_min_x_expr.F90",
                    "config": 1,
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.2155504203401506
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 1,
                    "runtime": 0.033828011248260736,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "atomic_capture_assign_min_x_expr_list.F90": [
            {
                "compilation": {
                    "command": "nvfortran -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/atomic_capture_assign_min_x_expr_list.F90/atomic_capture_assign_min_x_expr_list.F900 /home/exouser/Testsuite/Tests/atomic_capture_assign_min_x_expr_list.F90",
                    "config": 1,
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.2661166898906231
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 1,
                    "runtime": 0.01774880802258849,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "atomic_capture_assign_x_and_expr.F90": [
            {
                "compilation": {
                    "command": "nvfortran -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/atomic_capture_assign_x_and_expr.F90/atomic_capture_assign_x_and_expr.F900 /home/exouser/Testsuite/Tests/atomic_capture_assign_x_and_expr.F90",
                    "config": 1,
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.3161824210546911
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.017731516156345606,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "atomic_capture_assign_x_divided_expr.F90": [
            {
                "compilation": {
                    "command": "nvfortran -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/atomic_capture_assign_x_divided_expr.F90/atomic_capture_assign_x_divided_expr.F900 /home/exouser/Testsuite/Tests/atomic_capture_assign_x_divided_expr.F90",
                    "config": 1,
                    "errors": "",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 0.21620660368353128
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "Failed to complete within timeout",
                    "export": false,
                    "output": "",
                    "result": -1,
                    "runtime": -1,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvfortran -fast -acc -ta=multicore -DT1 -o /home/exouser/Testsuite/build/atomic_capture_assign_x_divided_expr.F90/atomic_capture_assign_x_divided_expr.F901 /home/exouser/Testsuite/Tests/atomic_capture_assign_x_divided_expr.F90",
                    "config": 1,
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.1667913100682199
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.009675586130470037,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "atomic_capture_assign_x_eqv_expr.F90": [
            {
                "compilation": {
                    "command": "nvfortran -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/atomic_capture_assign_x_eqv_expr.F90/atomic_capture_assign_x_eqv_expr.F900 /home/exouser/Testsuite/Tests/atomic_capture_assign_x_eqv_expr.F90",
                    "config": 1,
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.3171576699241996
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.0177517281845212,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "atomic_capture_assign_x_minus_expr.F90": [
            {
                "compilation": {
                    "command": "nvfortran -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/atomic_capture_assign_x_minus_expr.F90/atomic_capture_assign_x_minus_expr.F900 /home/exouser/Testsuite/Tests/atomic_capture_assign_x_minus_expr.F90",
                    "config": 1,
                    "errors": "",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 0.21597102982923388
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "Failed to complete within timeout",
                    "export": false,
                    "output": "",
                    "result": -1,
                    "runtime": -1,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvfortran -fast -acc -ta=multicore -DT1 -o /home/exouser/Testsuite/build/atomic_capture_assign_x_minus_expr.F90/atomic_capture_assign_x_minus_expr.F901 /home/exouser/Testsuite/Tests/atomic_capture_assign_x_minus_expr.F90",
                    "config": 1,
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.2169104004278779
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.009700476191937923,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "atomic_capture_assign_x_neqv_expr.F90": [
            {
                "compilation": {
                    "command": "nvfortran -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/atomic_capture_assign_x_neqv_expr.F90/atomic_capture_assign_x_neqv_expr.F900 /home/exouser/Testsuite/Tests/atomic_capture_assign_x_neqv_expr.F90",
                    "config": 1,
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.36684801802039146
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.03342899680137634,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "atomic_capture_assign_x_or_expr.F90": [
            {
                "compilation": {
                    "command": "nvfortran -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/atomic_capture_assign_x_or_expr.F90/atomic_capture_assign_x_or_expr.F900 /home/exouser/Testsuite/Tests/atomic_capture_assign_x_or_expr.F90",
                    "config": 1,
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.3666755398735404
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.03401096165180206,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "atomic_capture_assign_x_plus_expr.F90": [
            {
                "compilation": {
                    "command": "nvfortran -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/atomic_capture_assign_x_plus_expr.F90/atomic_capture_assign_x_plus_expr.F900 /home/exouser/Testsuite/Tests/atomic_capture_assign_x_plus_expr.F90",
                    "config": 1,
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.2670183479785919
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 1,
                    "runtime": 0.06613151216879487,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "atomic_capture_assign_x_times_expr.F90": [
            {
                "compilation": {
                    "command": "nvfortran -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/atomic_capture_assign_x_times_expr.F90/atomic_capture_assign_x_times_expr.F900 /home/exouser/Testsuite/Tests/atomic_capture_assign_x_times_expr.F90",
                    "config": 1,
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.2672324678860605
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.034181558061391115,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "atomic_capture_bitand_equals.c": [
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/atomic_capture_bitand_equals.c/atomic_capture_bitand_equals.c0 /home/exouser/Testsuite/Tests/atomic_capture_bitand_equals.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/atomic_capture_bitand_equals.c\", line 103: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\nNVC++-S-0155-Invalid atomic capture block, multiple updates.  (/home/exouser/Testsuite/Tests/atomic_capture_bitand_equals.c: 70)\nNVC++-S-0155-Invalid atomic update expression  (/home/exouser/Testsuite/Tests/atomic_capture_bitand_equals.c: 70)\nNVC++-S-0155-Invalid atomic update expression  (/home/exouser/Testsuite/Tests/atomic_capture_bitand_equals.c: 70)\nNVC++-S-0155-Invalid atomic capture.  (/home/exouser/Testsuite/Tests/atomic_capture_bitand_equals.c: 70)\nNVC++-F-0000-Internal compiler error. mr_precedes: too many st/br      33  (/home/exouser/Testsuite/Tests/atomic_capture_bitand_equals.c: 68)\nNVC++/x86-64 Linux 21.5-0: compilation aborted\n",
                    "export": false,
                    "output": "",
                    "result": 2,
                    "runtime": 0.11601825058460236
                },
                "post-compile commands": [],
                "pre-compile commands": [],
                "runtime": {
                    "export": false,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -DT1 -o /home/exouser/Testsuite/build/atomic_capture_bitand_equals.c/atomic_capture_bitand_equals.c1 /home/exouser/Testsuite/Tests/atomic_capture_bitand_equals.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/atomic_capture_bitand_equals.c\", line 103: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n\"/home/exouser/Testsuite/Tests/atomic_capture_bitand_equals.c\", line 104: warning: variable \"failed\" was declared but never referenced\n      int failed;\n          ^\n\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.21611067932099104
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.005486070644110441,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "atomic_capture_bitor_equals.c": [
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/atomic_capture_bitor_equals.c/atomic_capture_bitor_equals.c0 /home/exouser/Testsuite/Tests/atomic_capture_bitor_equals.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/atomic_capture_bitor_equals.c\", line 96: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\nNVC++-S-0155-Invalid atomic capture block, multiple updates.  (/home/exouser/Testsuite/Tests/atomic_capture_bitor_equals.c: 66)\nNVC++-S-0155-Invalid atomic update expression  (/home/exouser/Testsuite/Tests/atomic_capture_bitor_equals.c: 66)\nNVC++-S-0155-Invalid atomic update expression  (/home/exouser/Testsuite/Tests/atomic_capture_bitor_equals.c: 66)\nNVC++-S-0155-Invalid atomic capture.  (/home/exouser/Testsuite/Tests/atomic_capture_bitor_equals.c: 66)\nNVC++-F-0000-Internal compiler error. mr_precedes: too many st/br      33  (/home/exouser/Testsuite/Tests/atomic_capture_bitor_equals.c: 64)\nNVC++/x86-64 Linux 21.5-0: compilation aborted\n",
                    "export": false,
                    "output": "",
                    "result": 2,
                    "runtime": 0.1156112221069634
                },
                "post-compile commands": [],
                "pre-compile commands": [],
                "runtime": {
                    "export": false,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -DT1 -o /home/exouser/Testsuite/build/atomic_capture_bitor_equals.c/atomic_capture_bitor_equals.c1 /home/exouser/Testsuite/Tests/atomic_capture_bitor_equals.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/atomic_capture_bitor_equals.c\", line 96: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n\"/home/exouser/Testsuite/Tests/atomic_capture_bitor_equals.c\", line 97: warning: variable \"failed\" was declared but never referenced\n      int failed;\n          ^\n\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.2162019768729806
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.005352768115699291,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "atomic_capture_bitxor_equals.c": [
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/atomic_capture_bitxor_equals.c/atomic_capture_bitxor_equals.c0 /home/exouser/Testsuite/Tests/atomic_capture_bitxor_equals.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/atomic_capture_bitxor_equals.c\", line 94: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\nNVC++-S-0155-Invalid atomic capture block, multiple updates.  (/home/exouser/Testsuite/Tests/atomic_capture_bitxor_equals.c: 63)\nNVC++-S-0155-Invalid atomic update expression  (/home/exouser/Testsuite/Tests/atomic_capture_bitxor_equals.c: 63)\nNVC++-S-0155-Invalid atomic update expression  (/home/exouser/Testsuite/Tests/atomic_capture_bitxor_equals.c: 63)\nNVC++-S-0155-Invalid atomic capture.  (/home/exouser/Testsuite/Tests/atomic_capture_bitxor_equals.c: 63)\nNVC++-F-0000-Internal compiler error. mr_precedes: too many st/br      33  (/home/exouser/Testsuite/Tests/atomic_capture_bitxor_equals.c: 61)\nNVC++/x86-64 Linux 21.5-0: compilation aborted\n",
                    "export": false,
                    "output": "",
                    "result": 2,
                    "runtime": 0.11547905905172229
                },
                "post-compile commands": [],
                "pre-compile commands": [],
                "runtime": {
                    "export": false,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -DT1 -o /home/exouser/Testsuite/build/atomic_capture_bitxor_equals.c/atomic_capture_bitxor_equals.c1 /home/exouser/Testsuite/Tests/atomic_capture_bitxor_equals.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/atomic_capture_bitxor_equals.c\", line 94: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n\"/home/exouser/Testsuite/Tests/atomic_capture_bitxor_equals.c\", line 95: warning: variable \"failed\" was declared but never referenced\n      int failed;\n          ^\n\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.215969517827034
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.005436035804450512,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "atomic_capture_divided_equals.c": [
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/atomic_capture_divided_equals.c/atomic_capture_divided_equals.c0 /home/exouser/Testsuite/Tests/atomic_capture_divided_equals.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/atomic_capture_divided_equals.c\", line 102: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\nNVC++-S-0155-Invalid atomic capture block, multiple updates.  (/home/exouser/Testsuite/Tests/atomic_capture_divided_equals.c: 68)\nNVC++-S-0155-Invalid atomic update expression  (/home/exouser/Testsuite/Tests/atomic_capture_divided_equals.c: 68)\nNVC++-S-0155-Invalid atomic update expression  (/home/exouser/Testsuite/Tests/atomic_capture_divided_equals.c: 68)\nNVC++-S-0155-Invalid atomic capture.  (/home/exouser/Testsuite/Tests/atomic_capture_divided_equals.c: 68)\nNVC++-F-0000-Internal compiler error. mr_precedes: too many st/br      39  (/home/exouser/Testsuite/Tests/atomic_capture_divided_equals.c: 66)\nNVC++/x86-64 Linux 21.5-0: compilation aborted\n",
                    "export": false,
                    "output": "",
                    "result": 2,
                    "runtime": 0.11549175484105945
                },
                "post-compile commands": [],
                "pre-compile commands": [],
                "runtime": {
                    "export": false,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -DT1 -o /home/exouser/Testsuite/build/atomic_capture_divided_equals.c/atomic_capture_divided_equals.c1 /home/exouser/Testsuite/Tests/atomic_capture_divided_equals.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/atomic_capture_divided_equals.c\", line 102: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n\"/home/exouser/Testsuite/Tests/atomic_capture_divided_equals.c\", line 103: warning: variable \"failed\" was declared but never referenced\n      int failed;\n          ^\n\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.16606500186026096
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.005303143989294767,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "atomic_capture_expr_and_x_assign.F90": [
            {
                "compilation": {
                    "command": "nvfortran -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/atomic_capture_expr_and_x_assign.F90/atomic_capture_expr_and_x_assign.F900 /home/exouser/Testsuite/Tests/atomic_capture_expr_and_x_assign.F90",
                    "config": 1,
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.3165604309178889
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.03382859006524086,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "atomic_capture_expr_bitand_x.c": [
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/atomic_capture_expr_bitand_x.c/atomic_capture_expr_bitand_x.c0 /home/exouser/Testsuite/Tests/atomic_capture_expr_bitand_x.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/atomic_capture_expr_bitand_x.c\", line 101: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\nNVC++-S-0155-Invalid atomic capture block, multiple updates.  (/home/exouser/Testsuite/Tests/atomic_capture_expr_bitand_x.c: 66)\nNVC++-S-0155-Invalid atomic update expression  (/home/exouser/Testsuite/Tests/atomic_capture_expr_bitand_x.c: 66)\nNVC++-S-0155-Invalid atomic update expression  (/home/exouser/Testsuite/Tests/atomic_capture_expr_bitand_x.c: 66)\nNVC++-S-0155-Invalid atomic capture.  (/home/exouser/Testsuite/Tests/atomic_capture_expr_bitand_x.c: 66)\nNVC++-F-0000-Internal compiler error. mr_precedes: too many st/br      33  (/home/exouser/Testsuite/Tests/atomic_capture_expr_bitand_x.c: 64)\nNVC++/x86-64 Linux 21.5-0: compilation aborted\n",
                    "export": false,
                    "output": "",
                    "result": 2,
                    "runtime": 0.1154819568619132
                },
                "post-compile commands": [],
                "pre-compile commands": [],
                "runtime": {
                    "export": false,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -DT1 -o /home/exouser/Testsuite/build/atomic_capture_expr_bitand_x.c/atomic_capture_expr_bitand_x.c1 /home/exouser/Testsuite/Tests/atomic_capture_expr_bitand_x.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/atomic_capture_expr_bitand_x.c\", line 101: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n\"/home/exouser/Testsuite/Tests/atomic_capture_expr_bitand_x.c\", line 102: warning: variable \"failed\" was declared but never referenced\n      int failed;\n          ^\n\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.21595524484291673
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.005450753960758448,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "atomic_capture_expr_bitor_x.c": [
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/atomic_capture_expr_bitor_x.c/atomic_capture_expr_bitor_x.c0 /home/exouser/Testsuite/Tests/atomic_capture_expr_bitor_x.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/atomic_capture_expr_bitor_x.c\", line 93: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\nNVC++-S-0155-Invalid atomic capture block, multiple updates.  (/home/exouser/Testsuite/Tests/atomic_capture_expr_bitor_x.c: 63)\nNVC++-S-0155-Invalid atomic update expression  (/home/exouser/Testsuite/Tests/atomic_capture_expr_bitor_x.c: 63)\nNVC++-S-0155-Invalid atomic update expression  (/home/exouser/Testsuite/Tests/atomic_capture_expr_bitor_x.c: 63)\nNVC++-S-0155-Invalid atomic capture.  (/home/exouser/Testsuite/Tests/atomic_capture_expr_bitor_x.c: 63)\nNVC++-F-0000-Internal compiler error. mr_precedes: too many st/br      33  (/home/exouser/Testsuite/Tests/atomic_capture_expr_bitor_x.c: 61)\nNVC++/x86-64 Linux 21.5-0: compilation aborted\n",
                    "export": false,
                    "output": "",
                    "result": 2,
                    "runtime": 0.11540749436244369
                },
                "post-compile commands": [],
                "pre-compile commands": [],
                "runtime": {
                    "export": false,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -DT1 -o /home/exouser/Testsuite/build/atomic_capture_expr_bitor_x.c/atomic_capture_expr_bitor_x.c1 /home/exouser/Testsuite/Tests/atomic_capture_expr_bitor_x.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/atomic_capture_expr_bitor_x.c\", line 93: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n\"/home/exouser/Testsuite/Tests/atomic_capture_expr_bitor_x.c\", line 94: warning: variable \"failed\" was declared but never referenced\n      int failed;\n          ^\n\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.21615658095106483
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.005426653660833836,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "atomic_capture_expr_bitxor_x.c": [
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/atomic_capture_expr_bitxor_x.c/atomic_capture_expr_bitxor_x.c0 /home/exouser/Testsuite/Tests/atomic_capture_expr_bitxor_x.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/atomic_capture_expr_bitxor_x.c\", line 94: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\nNVC++-S-0155-Invalid atomic capture block, multiple updates.  (/home/exouser/Testsuite/Tests/atomic_capture_expr_bitxor_x.c: 63)\nNVC++-S-0155-Invalid atomic update expression  (/home/exouser/Testsuite/Tests/atomic_capture_expr_bitxor_x.c: 63)\nNVC++-S-0155-Invalid atomic update expression  (/home/exouser/Testsuite/Tests/atomic_capture_expr_bitxor_x.c: 63)\nNVC++-S-0155-Invalid atomic capture.  (/home/exouser/Testsuite/Tests/atomic_capture_expr_bitxor_x.c: 63)\nNVC++-F-0000-Internal compiler error. mr_precedes: too many st/br      33  (/home/exouser/Testsuite/Tests/atomic_capture_expr_bitxor_x.c: 61)\nNVC++/x86-64 Linux 21.5-0: compilation aborted\n",
                    "export": false,
                    "output": "",
                    "result": 2,
                    "runtime": 0.11570729687809944
                },
                "post-compile commands": [],
                "pre-compile commands": [],
                "runtime": {
                    "export": false,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -DT1 -o /home/exouser/Testsuite/build/atomic_capture_expr_bitxor_x.c/atomic_capture_expr_bitxor_x.c1 /home/exouser/Testsuite/Tests/atomic_capture_expr_bitxor_x.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/atomic_capture_expr_bitxor_x.c\", line 94: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n\"/home/exouser/Testsuite/Tests/atomic_capture_expr_bitxor_x.c\", line 95: warning: variable \"failed\" was declared but never referenced\n      int failed;\n          ^\n\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.3163674590177834
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.005556431133300066,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "atomic_capture_expr_divided_x.c": [
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/atomic_capture_expr_divided_x.c/atomic_capture_expr_divided_x.c0 /home/exouser/Testsuite/Tests/atomic_capture_expr_divided_x.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/atomic_capture_expr_divided_x.c\", line 120: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\nNVC++-S-0155-Invalid atomic capture block, multiple updates.  (/home/exouser/Testsuite/Tests/atomic_capture_expr_divided_x.c: 87)\nNVC++-S-0155-Invalid atomic update expression  (/home/exouser/Testsuite/Tests/atomic_capture_expr_divided_x.c: 87)\nNVC++-S-0155-Invalid atomic update expression  (/home/exouser/Testsuite/Tests/atomic_capture_expr_divided_x.c: 87)\nNVC++-S-0155-Invalid atomic capture.  (/home/exouser/Testsuite/Tests/atomic_capture_expr_divided_x.c: 87)\nNVC++-F-0000-Internal compiler error. mr_precedes: too many st/br      39  (/home/exouser/Testsuite/Tests/atomic_capture_expr_divided_x.c: 85)\nNVC++/x86-64 Linux 21.5-0: compilation aborted\n",
                    "export": false,
                    "output": "",
                    "result": 2,
                    "runtime": 0.11549372086301446
                },
                "post-compile commands": [],
                "pre-compile commands": [],
                "runtime": {
                    "export": false,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -DT1 -o /home/exouser/Testsuite/build/atomic_capture_expr_divided_x.c/atomic_capture_expr_divided_x.c1 /home/exouser/Testsuite/Tests/atomic_capture_expr_divided_x.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/atomic_capture_expr_divided_x.c\", line 120: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n\"/home/exouser/Testsuite/Tests/atomic_capture_expr_divided_x.c\", line 121: warning: variable \"failed\" was declared but never referenced\n      int failed;\n          ^\n\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.21631785109639168
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.005402041133493185,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "atomic_capture_expr_divided_x_assign.F90": [
            {
                "compilation": {
                    "command": "nvfortran -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/atomic_capture_expr_divided_x_assign.F90/atomic_capture_expr_divided_x_assign.F900 /home/exouser/Testsuite/Tests/atomic_capture_expr_divided_x_assign.F90",
                    "config": 1,
                    "errors": "",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 0.21650481689721346
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "Failed to complete within timeout",
                    "export": false,
                    "output": "",
                    "result": -1,
                    "runtime": -1,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvfortran -fast -acc -ta=multicore -DT1 -o /home/exouser/Testsuite/build/atomic_capture_expr_divided_x_assign.F90/atomic_capture_expr_divided_x_assign.F901 /home/exouser/Testsuite/Tests/atomic_capture_expr_divided_x_assign.F90",
                    "config": 1,
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.3254301850683987
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.02206779597327113,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "atomic_capture_expr_eqv_x_assign.F90": [
            {
                "compilation": {
                    "command": "nvfortran -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/atomic_capture_expr_eqv_x_assign.F90/atomic_capture_expr_eqv_x_assign.F900 /home/exouser/Testsuite/Tests/atomic_capture_expr_eqv_x_assign.F90",
                    "config": 1,
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.36631520092487335
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.03355804504826665,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "atomic_capture_expr_lshift_x.c": [
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/atomic_capture_expr_lshift_x.c/atomic_capture_expr_lshift_x.c0 /home/exouser/Testsuite/Tests/atomic_capture_expr_lshift_x.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/atomic_capture_expr_lshift_x.c\", line 90: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\nNVC++-S-0155-Invalid atomic capture block, multiple updates.  (/home/exouser/Testsuite/Tests/atomic_capture_expr_lshift_x.c: 57)\nNVC++-S-0155-Invalid atomic capture block, multiple updates.  (/home/exouser/Testsuite/Tests/atomic_capture_expr_lshift_x.c: 57)\nNVC++-S-0155-Invalid atomic update expression  (/home/exouser/Testsuite/Tests/atomic_capture_expr_lshift_x.c: 57)\nNVC++-S-0155-Invalid atomic capture.  (/home/exouser/Testsuite/Tests/atomic_capture_expr_lshift_x.c: 57)\nNVC++-F-0000-Internal compiler error. mr_precedes: too many st/br      20  (/home/exouser/Testsuite/Tests/atomic_capture_expr_lshift_x.c: 78)\nNVC++/x86-64 Linux 21.5-0: compilation aborted\n",
                    "export": false,
                    "output": "",
                    "result": 2,
                    "runtime": 0.11547258915379643
                },
                "post-compile commands": [],
                "pre-compile commands": [],
                "runtime": {
                    "export": false,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -DT1 -o /home/exouser/Testsuite/build/atomic_capture_expr_lshift_x.c/atomic_capture_expr_lshift_x.c1 /home/exouser/Testsuite/Tests/atomic_capture_expr_lshift_x.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/atomic_capture_expr_lshift_x.c\", line 90: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n\"/home/exouser/Testsuite/Tests/atomic_capture_expr_lshift_x.c\", line 91: warning: variable \"failed\" was declared but never referenced\n      int failed;\n          ^\n\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.2164173130877316
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.0050164880231022835,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "atomic_capture_expr_minus_x.c": [
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/atomic_capture_expr_minus_x.c/atomic_capture_expr_minus_x.c0 /home/exouser/Testsuite/Tests/atomic_capture_expr_minus_x.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/atomic_capture_expr_minus_x.c\", line 118: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\nNVC++-S-0155-Invalid atomic capture block, multiple updates.  (/home/exouser/Testsuite/Tests/atomic_capture_expr_minus_x.c: 86)\nNVC++-S-0155-Invalid atomic update expression  (/home/exouser/Testsuite/Tests/atomic_capture_expr_minus_x.c: 86)\nNVC++-S-0155-Invalid atomic update expression  (/home/exouser/Testsuite/Tests/atomic_capture_expr_minus_x.c: 86)\nNVC++-S-0155-Invalid atomic capture.  (/home/exouser/Testsuite/Tests/atomic_capture_expr_minus_x.c: 86)\nNVC++-F-0000-Internal compiler error. mr_precedes: too many st/br      25  (/home/exouser/Testsuite/Tests/atomic_capture_expr_minus_x.c: 84)\nNVC++/x86-64 Linux 21.5-0: compilation aborted\n",
                    "export": false,
                    "output": "",
                    "result": 2,
                    "runtime": 0.11540977098047733
                },
                "post-compile commands": [],
                "pre-compile commands": [],
                "runtime": {
                    "export": false,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -DT1 -o /home/exouser/Testsuite/build/atomic_capture_expr_minus_x.c/atomic_capture_expr_minus_x.c1 /home/exouser/Testsuite/Tests/atomic_capture_expr_minus_x.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/atomic_capture_expr_minus_x.c\", line 118: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n\"/home/exouser/Testsuite/Tests/atomic_capture_expr_minus_x.c\", line 119: warning: variable \"failed\" was declared but never referenced\n      int failed;\n          ^\n\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.2159854043275118
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.005133736878633499,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "atomic_capture_expr_minus_x_assign.F90": [
            {
                "compilation": {
                    "command": "nvfortran -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/atomic_capture_expr_minus_x_assign.F90/atomic_capture_expr_minus_x_assign.F900 /home/exouser/Testsuite/Tests/atomic_capture_expr_minus_x_assign.F90",
                    "config": 1,
                    "errors": "",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 0.21542913280427456
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "Failed to complete within timeout",
                    "export": false,
                    "output": "",
                    "result": -1,
                    "runtime": -1,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvfortran -fast -acc -ta=multicore -DT1 -o /home/exouser/Testsuite/build/atomic_capture_expr_minus_x_assign.F90/atomic_capture_expr_minus_x_assign.F901 /home/exouser/Testsuite/Tests/atomic_capture_expr_minus_x_assign.F90",
                    "config": 1,
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.16659269109368324
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.009709369856864214,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "atomic_capture_expr_multiply_x.c": [
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/atomic_capture_expr_multiply_x.c/atomic_capture_expr_multiply_x.c0 /home/exouser/Testsuite/Tests/atomic_capture_expr_multiply_x.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/atomic_capture_expr_multiply_x.c\", line 92: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\nNVC++-S-0155-Invalid atomic capture block, multiple updates.  (/home/exouser/Testsuite/Tests/atomic_capture_expr_multiply_x.c: 61)\nNVC++-S-0155-Invalid atomic update expression  (/home/exouser/Testsuite/Tests/atomic_capture_expr_multiply_x.c: 61)\nNVC++-S-0155-Invalid atomic update expression  (/home/exouser/Testsuite/Tests/atomic_capture_expr_multiply_x.c: 61)\nNVC++-S-0155-Invalid atomic capture.  (/home/exouser/Testsuite/Tests/atomic_capture_expr_multiply_x.c: 61)\nNVC++-F-0000-Internal compiler error. mr_precedes: too many st/br      39  (/home/exouser/Testsuite/Tests/atomic_capture_expr_multiply_x.c: 59)\nNVC++/x86-64 Linux 21.5-0: compilation aborted\n",
                    "export": false,
                    "output": "",
                    "result": 2,
                    "runtime": 0.11587027925997972
                },
                "post-compile commands": [],
                "pre-compile commands": [],
                "runtime": {
                    "export": false,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -DT1 -o /home/exouser/Testsuite/build/atomic_capture_expr_multiply_x.c/atomic_capture_expr_multiply_x.c1 /home/exouser/Testsuite/Tests/atomic_capture_expr_multiply_x.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/atomic_capture_expr_multiply_x.c\", line 92: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n\"/home/exouser/Testsuite/Tests/atomic_capture_expr_multiply_x.c\", line 93: warning: variable \"failed\" was declared but never referenced\n      int failed;\n          ^\n\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.21586010372266173
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.005451928824186325,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "atomic_capture_expr_neqv_x_assign.F90": [
            {
                "compilation": {
                    "command": "nvfortran -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/atomic_capture_expr_neqv_x_assign.F90/atomic_capture_expr_neqv_x_assign.F900 /home/exouser/Testsuite/Tests/atomic_capture_expr_neqv_x_assign.F90",
                    "config": 1,
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.3162808050401509
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.06582319177687168,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "atomic_capture_expr_or_x_assign.F90": [
            {
                "compilation": {
                    "command": "nvfortran -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/atomic_capture_expr_or_x_assign.F90/atomic_capture_expr_or_x_assign.F900 /home/exouser/Testsuite/Tests/atomic_capture_expr_or_x_assign.F90",
                    "config": 1,
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.315566373988986
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.06617619702592492,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "atomic_capture_expr_plus_x.c": [
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/atomic_capture_expr_plus_x.c/atomic_capture_expr_plus_x.c0 /home/exouser/Testsuite/Tests/atomic_capture_expr_plus_x.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/atomic_capture_expr_plus_x.c\", line 92: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\nNVC++-S-0155-Invalid atomic update expression  (/home/exouser/Testsuite/Tests/atomic_capture_expr_plus_x.c: 61)\nNVC++-S-0155-Invalid atomic update expression  (/home/exouser/Testsuite/Tests/atomic_capture_expr_plus_x.c: 61)\nNVC++-S-0155-Invalid atomic capture.  (/home/exouser/Testsuite/Tests/atomic_capture_expr_plus_x.c: 61)\nNVC++/x86-64 Linux 21.5-0: compilation completed with severe errors\n",
                    "export": false,
                    "output": "",
                    "result": 2,
                    "runtime": 0.1164357797242701
                },
                "post-compile commands": [],
                "pre-compile commands": [],
                "runtime": {
                    "export": false,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -DT1 -o /home/exouser/Testsuite/build/atomic_capture_expr_plus_x.c/atomic_capture_expr_plus_x.c1 /home/exouser/Testsuite/Tests/atomic_capture_expr_plus_x.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/atomic_capture_expr_plus_x.c\", line 92: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n\"/home/exouser/Testsuite/Tests/atomic_capture_expr_plus_x.c\", line 93: warning: variable \"failed\" was declared but never referenced\n      int failed;\n          ^\n\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.21617838507518172
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.0052948808297514915,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "atomic_capture_expr_plus_x_assign.F90": [
            {
                "compilation": {
                    "command": "nvfortran -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/atomic_capture_expr_plus_x_assign.F90/atomic_capture_expr_plus_x_assign.F900 /home/exouser/Testsuite/Tests/atomic_capture_expr_plus_x_assign.F90",
                    "config": 1,
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.21663508424535394
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 1,
                    "runtime": 0.06618461897596717,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "atomic_capture_expr_rshift_x.c": [
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/atomic_capture_expr_rshift_x.c/atomic_capture_expr_rshift_x.c0 /home/exouser/Testsuite/Tests/atomic_capture_expr_rshift_x.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/atomic_capture_expr_rshift_x.c\", line 90: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\nNVC++-S-0155-Invalid atomic capture block, multiple updates.  (/home/exouser/Testsuite/Tests/atomic_capture_expr_rshift_x.c: 57)\nNVC++-S-0155-Invalid atomic capture block, multiple updates.  (/home/exouser/Testsuite/Tests/atomic_capture_expr_rshift_x.c: 57)\nNVC++-S-0155-Invalid atomic update expression  (/home/exouser/Testsuite/Tests/atomic_capture_expr_rshift_x.c: 57)\nNVC++-S-0155-Invalid atomic capture.  (/home/exouser/Testsuite/Tests/atomic_capture_expr_rshift_x.c: 57)\nNVC++-F-0000-Internal compiler error. mr_precedes: too many st/br      20  (/home/exouser/Testsuite/Tests/atomic_capture_expr_rshift_x.c: 78)\nNVC++/x86-64 Linux 21.5-0: compilation aborted\n",
                    "export": false,
                    "output": "",
                    "result": 2,
                    "runtime": 0.11629269970580935
                },
                "post-compile commands": [],
                "pre-compile commands": [],
                "runtime": {
                    "export": false,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -DT1 -o /home/exouser/Testsuite/build/atomic_capture_expr_rshift_x.c/atomic_capture_expr_rshift_x.c1 /home/exouser/Testsuite/Tests/atomic_capture_expr_rshift_x.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/atomic_capture_expr_rshift_x.c\", line 90: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n\"/home/exouser/Testsuite/Tests/atomic_capture_expr_rshift_x.c\", line 91: warning: variable \"failed\" was declared but never referenced\n      int failed;\n          ^\n\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.2156676948070526
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.005155500024557114,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "atomic_capture_expr_times_x_assign.F90": [
            {
                "compilation": {
                    "command": "nvfortran -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/atomic_capture_expr_times_x_assign.F90/atomic_capture_expr_times_x_assign.F900 /home/exouser/Testsuite/Tests/atomic_capture_expr_times_x_assign.F90",
                    "config": 1,
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.21672150399535894
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.06562356185168028,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "atomic_capture_iand_expr_x_assign.F90": [
            {
                "compilation": {
                    "command": "nvfortran -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/atomic_capture_iand_expr_x_assign.F90/atomic_capture_iand_expr_x_assign.F900 /home/exouser/Testsuite/Tests/atomic_capture_iand_expr_x_assign.F90",
                    "config": 1,
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.2657620566897094
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.0659674652852118,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "atomic_capture_iand_x_expr_assign.F90": [
            {
                "compilation": {
                    "command": "nvfortran -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/atomic_capture_iand_x_expr_assign.F90/atomic_capture_iand_x_expr_assign.F900 /home/exouser/Testsuite/Tests/atomic_capture_iand_x_expr_assign.F90",
                    "config": 1,
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.26648510387167335
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.0658767782151699,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "atomic_capture_ior_expr_x_assign.F90": [
            {
                "compilation": {
                    "command": "nvfortran -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/atomic_capture_ior_expr_x_assign.F90/atomic_capture_ior_expr_x_assign.F900 /home/exouser/Testsuite/Tests/atomic_capture_ior_expr_x_assign.F90",
                    "config": 1,
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.2670111279003322
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.06577357184141874,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "atomic_capture_ior_x_expr_assign.F90": [
            {
                "compilation": {
                    "command": "nvfortran -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/atomic_capture_ior_x_expr_assign.F90/atomic_capture_ior_x_expr_assign.F900 /home/exouser/Testsuite/Tests/atomic_capture_ior_x_expr_assign.F90",
                    "config": 1,
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.2658997899852693
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.06568990973755717,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "atomic_capture_ixor_expr_x_assign.F90": [
            {
                "compilation": {
                    "command": "nvfortran -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/atomic_capture_ixor_expr_x_assign.F90/atomic_capture_ixor_expr_x_assign.F900 /home/exouser/Testsuite/Tests/atomic_capture_ixor_expr_x_assign.F90",
                    "config": 1,
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.26544066006317735
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.06596611207351089,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "atomic_capture_ixor_x_expr_assign.F90": [
            {
                "compilation": {
                    "command": "nvfortran -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/atomic_capture_ixor_x_expr_assign.F90/atomic_capture_ixor_x_expr_assign.F900 /home/exouser/Testsuite/Tests/atomic_capture_ixor_x_expr_assign.F90",
                    "config": 1,
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.2659811503253877
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.06571073597297072,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "atomic_capture_lshift_equals.c": [
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/atomic_capture_lshift_equals.c/atomic_capture_lshift_equals.c0 /home/exouser/Testsuite/Tests/atomic_capture_lshift_equals.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/atomic_capture_lshift_equals.c\", line 92: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\nNVC++-S-0155-Invalid atomic capture block, multiple updates.  (/home/exouser/Testsuite/Tests/atomic_capture_lshift_equals.c: 62)\nNVC++-S-0155-Invalid atomic capture block, multiple updates.  (/home/exouser/Testsuite/Tests/atomic_capture_lshift_equals.c: 62)\nNVC++-S-0155-Invalid atomic update expression  (/home/exouser/Testsuite/Tests/atomic_capture_lshift_equals.c: 62)\nNVC++-S-0155-Invalid atomic capture.  (/home/exouser/Testsuite/Tests/atomic_capture_lshift_equals.c: 62)\nNVC++-F-0000-Internal compiler error. mr_precedes: too many st/br      11  (/home/exouser/Testsuite/Tests/atomic_capture_lshift_equals.c: 56)\nNVC++/x86-64 Linux 21.5-0: compilation aborted\n",
                    "export": false,
                    "output": "",
                    "result": 2,
                    "runtime": 0.11553635494783521
                },
                "post-compile commands": [],
                "pre-compile commands": [],
                "runtime": {
                    "export": false,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -DT1 -o /home/exouser/Testsuite/build/atomic_capture_lshift_equals.c/atomic_capture_lshift_equals.c1 /home/exouser/Testsuite/Tests/atomic_capture_lshift_equals.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/atomic_capture_lshift_equals.c\", line 92: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n\"/home/exouser/Testsuite/Tests/atomic_capture_lshift_equals.c\", line 93: warning: variable \"failed\" was declared but never referenced\n      int failed;\n          ^\n\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.26621926575899124
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.00519937090575695,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "atomic_capture_max_expr_list_x_assign.F90": [
            {
                "compilation": {
                    "command": "nvfortran -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/atomic_capture_max_expr_list_x_assign.F90/atomic_capture_max_expr_list_x_assign.F900 /home/exouser/Testsuite/Tests/atomic_capture_max_expr_list_x_assign.F90",
                    "config": 1,
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.2658423031680286
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 1,
                    "runtime": 0.06564122624695301,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "atomic_capture_max_expr_x_assign.F90": [
            {
                "compilation": {
                    "command": "nvfortran -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/atomic_capture_max_expr_x_assign.F90/atomic_capture_max_expr_x_assign.F900 /home/exouser/Testsuite/Tests/atomic_capture_max_expr_x_assign.F90",
                    "config": 1,
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.21516362857073545
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 1,
                    "runtime": 0.0657068588770926,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "atomic_capture_max_x_expr_assign.F90": [
            {
                "compilation": {
                    "command": "nvfortran -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/atomic_capture_max_x_expr_assign.F90/atomic_capture_max_x_expr_assign.F900 /home/exouser/Testsuite/Tests/atomic_capture_max_x_expr_assign.F90",
                    "config": 1,
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.2158157736994326
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 1,
                    "runtime": 0.06584976706653833,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "atomic_capture_max_x_expr_list_assign.F90": [
            {
                "compilation": {
                    "command": "nvfortran -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/atomic_capture_max_x_expr_list_assign.F90/atomic_capture_max_x_expr_list_assign.F900 /home/exouser/Testsuite/Tests/atomic_capture_max_x_expr_list_assign.F90",
                    "config": 1,
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.26576789887622
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 1,
                    "runtime": 0.11590630188584328,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "atomic_capture_min_expr_list_x_assign.F90": [
            {
                "compilation": {
                    "command": "nvfortran -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/atomic_capture_min_expr_list_x_assign.F90/atomic_capture_min_expr_list_x_assign.F900 /home/exouser/Testsuite/Tests/atomic_capture_min_expr_list_x_assign.F90",
                    "config": 1,
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.2655270672403276
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 1,
                    "runtime": 0.06643356522545218,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "atomic_capture_min_expr_x_assign.F90": [
            {
                "compilation": {
                    "command": "nvfortran -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/atomic_capture_min_expr_x_assign.F90/atomic_capture_min_expr_x_assign.F900 /home/exouser/Testsuite/Tests/atomic_capture_min_expr_x_assign.F90",
                    "config": 1,
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.21612454298883677
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 1,
                    "runtime": 0.06651444220915437,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "atomic_capture_min_x_expr_assign.F90": [
            {
                "compilation": {
                    "command": "nvfortran -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/atomic_capture_min_x_expr_assign.F90/atomic_capture_min_x_expr_assign.F900 /home/exouser/Testsuite/Tests/atomic_capture_min_x_expr_assign.F90",
                    "config": 1,
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.21569221606478095
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 1,
                    "runtime": 0.06606419384479523,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "atomic_capture_min_x_expr_list_assign.F90": [
            {
                "compilation": {
                    "command": "nvfortran -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/atomic_capture_min_x_expr_list_assign.F90/atomic_capture_min_x_expr_list_assign.F900 /home/exouser/Testsuite/Tests/atomic_capture_min_x_expr_list_assign.F90",
                    "config": 1,
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.2670620968565345
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 1,
                    "runtime": 0.0658443788997829,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "atomic_capture_minus_equals.c": [
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/atomic_capture_minus_equals.c/atomic_capture_minus_equals.c0 /home/exouser/Testsuite/Tests/atomic_capture_minus_equals.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/atomic_capture_minus_equals.c\", line 90: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\nNVC++-S-0155-Invalid atomic capture block, multiple updates.  (/home/exouser/Testsuite/Tests/atomic_capture_minus_equals.c: 60)\nNVC++-S-0155-Invalid atomic update expression  (/home/exouser/Testsuite/Tests/atomic_capture_minus_equals.c: 60)\nNVC++-S-0155-Invalid atomic update expression  (/home/exouser/Testsuite/Tests/atomic_capture_minus_equals.c: 60)\nNVC++-S-0155-Invalid atomic capture.  (/home/exouser/Testsuite/Tests/atomic_capture_minus_equals.c: 60)\nNVC++-F-0000-Internal compiler error. mr_precedes: too many st/br      27  (/home/exouser/Testsuite/Tests/atomic_capture_minus_equals.c: 58)\nNVC++/x86-64 Linux 21.5-0: compilation aborted\n",
                    "export": false,
                    "output": "",
                    "result": 2,
                    "runtime": 0.11628206772729754
                },
                "post-compile commands": [],
                "pre-compile commands": [],
                "runtime": {
                    "export": false,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -DT1 -o /home/exouser/Testsuite/build/atomic_capture_minus_equals.c/atomic_capture_minus_equals.c1 /home/exouser/Testsuite/Tests/atomic_capture_minus_equals.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/atomic_capture_minus_equals.c\", line 90: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n\"/home/exouser/Testsuite/Tests/atomic_capture_minus_equals.c\", line 91: warning: variable \"failed\" was declared but never referenced\n      int failed;\n          ^\n\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.21700895903632045
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.004802510142326355,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "atomic_capture_multiply_equals.c": [
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/atomic_capture_multiply_equals.c/atomic_capture_multiply_equals.c0 /home/exouser/Testsuite/Tests/atomic_capture_multiply_equals.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/atomic_capture_multiply_equals.c\", line 92: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\nNVC++-S-0155-Invalid atomic capture block, multiple updates.  (/home/exouser/Testsuite/Tests/atomic_capture_multiply_equals.c: 61)\nNVC++-S-0155-Invalid atomic update expression  (/home/exouser/Testsuite/Tests/atomic_capture_multiply_equals.c: 61)\nNVC++-S-0155-Invalid atomic update expression  (/home/exouser/Testsuite/Tests/atomic_capture_multiply_equals.c: 61)\nNVC++-S-0155-Invalid atomic capture.  (/home/exouser/Testsuite/Tests/atomic_capture_multiply_equals.c: 61)\nNVC++-F-0000-Internal compiler error. mr_precedes: too many st/br      39  (/home/exouser/Testsuite/Tests/atomic_capture_multiply_equals.c: 59)\nNVC++/x86-64 Linux 21.5-0: compilation aborted\n",
                    "export": false,
                    "output": "",
                    "result": 2,
                    "runtime": 0.11679009906947613
                },
                "post-compile commands": [],
                "pre-compile commands": [],
                "runtime": {
                    "export": false,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -DT1 -o /home/exouser/Testsuite/build/atomic_capture_multiply_equals.c/atomic_capture_multiply_equals.c1 /home/exouser/Testsuite/Tests/atomic_capture_multiply_equals.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/atomic_capture_multiply_equals.c\", line 92: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n\"/home/exouser/Testsuite/Tests/atomic_capture_multiply_equals.c\", line 93: warning: variable \"failed\" was declared but never referenced\n      int failed;\n          ^\n\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.2166898907162249
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.004780590068548918,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "atomic_capture_plus_equals.c": [
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/atomic_capture_plus_equals.c/atomic_capture_plus_equals.c0 /home/exouser/Testsuite/Tests/atomic_capture_plus_equals.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/atomic_capture_plus_equals.c\", line 92: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\nNVC++-S-0155-Invalid atomic capture block, multiple updates.  (/home/exouser/Testsuite/Tests/atomic_capture_plus_equals.c: 61)\nNVC++-S-0155-Invalid atomic update expression  (/home/exouser/Testsuite/Tests/atomic_capture_plus_equals.c: 61)\nNVC++-S-0155-Invalid atomic update expression  (/home/exouser/Testsuite/Tests/atomic_capture_plus_equals.c: 61)\nNVC++-S-0155-Invalid atomic capture.  (/home/exouser/Testsuite/Tests/atomic_capture_plus_equals.c: 61)\nNVC++-F-0000-Internal compiler error. mr_precedes: too many st/br      39  (/home/exouser/Testsuite/Tests/atomic_capture_plus_equals.c: 59)\nNVC++/x86-64 Linux 21.5-0: compilation aborted\n",
                    "export": false,
                    "output": "",
                    "result": 2,
                    "runtime": 0.11539035197347403
                },
                "post-compile commands": [],
                "pre-compile commands": [],
                "runtime": {
                    "export": false,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -DT1 -o /home/exouser/Testsuite/build/atomic_capture_plus_equals.c/atomic_capture_plus_equals.c1 /home/exouser/Testsuite/Tests/atomic_capture_plus_equals.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/atomic_capture_plus_equals.c\", line 92: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n\"/home/exouser/Testsuite/Tests/atomic_capture_plus_equals.c\", line 93: warning: variable \"failed\" was declared but never referenced\n      int failed;\n          ^\n\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.21617840882390738
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.009354520589113235,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "atomic_capture_postdecrement.c": [
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/atomic_capture_postdecrement.c/atomic_capture_postdecrement.c0 /home/exouser/Testsuite/Tests/atomic_capture_postdecrement.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/atomic_capture_postdecrement.c\", line 66: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.166642596013844
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.009305191691964865,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "atomic_capture_postincrement.c": [
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/atomic_capture_postincrement.c/atomic_capture_postincrement.c0 /home/exouser/Testsuite/Tests/atomic_capture_postincrement.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/atomic_capture_postincrement.c\", line 66: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.16615643072873354
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.009304686915129423,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "atomic_capture_predecrement.c": [
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/atomic_capture_predecrement.c/atomic_capture_predecrement.c0 /home/exouser/Testsuite/Tests/atomic_capture_predecrement.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/atomic_capture_predecrement.c\", line 66: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\nNVC++-S-0155-Invalid atomic capture block, multiple updates.  (/home/exouser/Testsuite/Tests/atomic_capture_predecrement.c: 29)\nNVC++-S-0155-Invalid atomic update expression  (/home/exouser/Testsuite/Tests/atomic_capture_predecrement.c: 29)\nNVC++-S-0155-Invalid atomic update expression  (/home/exouser/Testsuite/Tests/atomic_capture_predecrement.c: 29)\nNVC++-S-0155-Invalid atomic capture.  (/home/exouser/Testsuite/Tests/atomic_capture_predecrement.c: 29)\nNVC++-F-0000-Internal compiler error. mr_precedes: too many st/br      35  (/home/exouser/Testsuite/Tests/atomic_capture_predecrement.c: 27)\nNVC++/x86-64 Linux 21.5-0: compilation aborted\n",
                    "export": false,
                    "output": "",
                    "result": 2,
                    "runtime": 0.0665637138299644
                },
                "post-compile commands": [],
                "pre-compile commands": [],
                "runtime": {
                    "export": false,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -DT1 -o /home/exouser/Testsuite/build/atomic_capture_predecrement.c/atomic_capture_predecrement.c1 /home/exouser/Testsuite/Tests/atomic_capture_predecrement.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/atomic_capture_predecrement.c\", line 66: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n\"/home/exouser/Testsuite/Tests/atomic_capture_predecrement.c\", line 67: warning: variable \"failed\" was declared but never referenced\n      int failed;\n          ^\n\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.16560778208076954
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.008930562064051628,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "atomic_capture_preincrement.c": [
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/atomic_capture_preincrement.c/atomic_capture_preincrement.c0 /home/exouser/Testsuite/Tests/atomic_capture_preincrement.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/atomic_capture_preincrement.c\", line 66: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\nNVC++-S-0155-Invalid atomic capture block, multiple updates.  (/home/exouser/Testsuite/Tests/atomic_capture_preincrement.c: 29)\nNVC++-S-0155-Invalid atomic update expression  (/home/exouser/Testsuite/Tests/atomic_capture_preincrement.c: 29)\nNVC++-S-0155-Invalid atomic update expression  (/home/exouser/Testsuite/Tests/atomic_capture_preincrement.c: 29)\nNVC++-S-0155-Invalid atomic capture.  (/home/exouser/Testsuite/Tests/atomic_capture_preincrement.c: 29)\nNVC++-F-0000-Internal compiler error. mr_precedes: too many st/br      35  (/home/exouser/Testsuite/Tests/atomic_capture_preincrement.c: 27)\nNVC++/x86-64 Linux 21.5-0: compilation aborted\n",
                    "export": false,
                    "output": "",
                    "result": 2,
                    "runtime": 0.0660954019986093
                },
                "post-compile commands": [],
                "pre-compile commands": [],
                "runtime": {
                    "export": false,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -DT1 -o /home/exouser/Testsuite/build/atomic_capture_preincrement.c/atomic_capture_preincrement.c1 /home/exouser/Testsuite/Tests/atomic_capture_preincrement.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/atomic_capture_preincrement.c\", line 66: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n\"/home/exouser/Testsuite/Tests/atomic_capture_preincrement.c\", line 67: warning: variable \"failed\" was declared but never referenced\n      int failed;\n          ^\n\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.16731064626947045
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.009649443440139294,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "atomic_capture_rshift_equals.c": [
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/atomic_capture_rshift_equals.c/atomic_capture_rshift_equals.c0 /home/exouser/Testsuite/Tests/atomic_capture_rshift_equals.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/atomic_capture_rshift_equals.c\", line 92: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\nNVC++-S-0155-Invalid atomic capture block, multiple updates.  (/home/exouser/Testsuite/Tests/atomic_capture_rshift_equals.c: 62)\nNVC++-S-0155-Invalid atomic capture block, multiple updates.  (/home/exouser/Testsuite/Tests/atomic_capture_rshift_equals.c: 62)\nNVC++-S-0155-Invalid atomic update expression  (/home/exouser/Testsuite/Tests/atomic_capture_rshift_equals.c: 62)\nNVC++-S-0155-Invalid atomic capture.  (/home/exouser/Testsuite/Tests/atomic_capture_rshift_equals.c: 62)\nNVC++-F-0000-Internal compiler error. mr_precedes: too many st/br      11  (/home/exouser/Testsuite/Tests/atomic_capture_rshift_equals.c: 56)\nNVC++/x86-64 Linux 21.5-0: compilation aborted\n",
                    "export": false,
                    "output": "",
                    "result": 2,
                    "runtime": 0.11698693269863725
                },
                "post-compile commands": [],
                "pre-compile commands": [],
                "runtime": {
                    "export": false,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -DT1 -o /home/exouser/Testsuite/build/atomic_capture_rshift_equals.c/atomic_capture_rshift_equals.c1 /home/exouser/Testsuite/Tests/atomic_capture_rshift_equals.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/atomic_capture_rshift_equals.c\", line 92: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n\"/home/exouser/Testsuite/Tests/atomic_capture_rshift_equals.c\", line 93: warning: variable \"failed\" was declared but never referenced\n      int failed;\n          ^\n\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.2169688050635159
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.004694635048508644,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "atomic_capture_x_and_expr_assign.F90": [
            {
                "compilation": {
                    "command": "nvfortran -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/atomic_capture_x_and_expr_assign.F90/atomic_capture_x_and_expr_assign.F900 /home/exouser/Testsuite/Tests/atomic_capture_x_and_expr_assign.F90",
                    "config": 1,
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.3157404991798103
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.0658434759825468,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "atomic_capture_x_divided_expr_assign.F90": [
            {
                "compilation": {
                    "command": "nvfortran -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/atomic_capture_x_divided_expr_assign.F90/atomic_capture_x_divided_expr_assign.F900 /home/exouser/Testsuite/Tests/atomic_capture_x_divided_expr_assign.F90",
                    "config": 1,
                    "errors": "",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 0.2156533426605165
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "Failed to complete within timeout",
                    "export": false,
                    "output": "",
                    "result": -1,
                    "runtime": -1,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvfortran -fast -acc -ta=multicore -DT1 -o /home/exouser/Testsuite/build/atomic_capture_x_divided_expr_assign.F90/atomic_capture_x_divided_expr_assign.F901 /home/exouser/Testsuite/Tests/atomic_capture_x_divided_expr_assign.F90",
                    "config": 1,
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.16611147904768586
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.00955018401145935,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "atomic_capture_x_eqv_expr_assign.F90": [
            {
                "compilation": {
                    "command": "nvfortran -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/atomic_capture_x_eqv_expr_assign.F90/atomic_capture_x_eqv_expr_assign.F900 /home/exouser/Testsuite/Tests/atomic_capture_x_eqv_expr_assign.F90",
                    "config": 1,
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.3165139751508832
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.06576047837734222,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "atomic_capture_x_minus_expr_assign.F90": [
            {
                "compilation": {
                    "command": "nvfortran -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/atomic_capture_x_minus_expr_assign.F90/atomic_capture_x_minus_expr_assign.F900 /home/exouser/Testsuite/Tests/atomic_capture_x_minus_expr_assign.F90",
                    "config": 1,
                    "errors": "",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 0.2152293249964714
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "Failed to complete within timeout",
                    "export": false,
                    "output": "",
                    "result": -1,
                    "runtime": -1,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvfortran -fast -acc -ta=multicore -DT1 -o /home/exouser/Testsuite/build/atomic_capture_x_minus_expr_assign.F90/atomic_capture_x_minus_expr_assign.F901 /home/exouser/Testsuite/Tests/atomic_capture_x_minus_expr_assign.F90",
                    "config": 1,
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.4854373838752508
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.05051355715841055,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "atomic_capture_x_neqv_expr_assign.F90": [
            {
                "compilation": {
                    "command": "nvfortran -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/atomic_capture_x_neqv_expr_assign.F90/atomic_capture_x_neqv_expr_assign.F900 /home/exouser/Testsuite/Tests/atomic_capture_x_neqv_expr_assign.F90",
                    "config": 1,
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.6425532572902739
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.0855292328633368,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "atomic_capture_x_or_expr_assign.F90": [
            {
                "compilation": {
                    "command": "nvfortran -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/atomic_capture_x_or_expr_assign.F90/atomic_capture_x_or_expr_assign.F900 /home/exouser/Testsuite/Tests/atomic_capture_x_or_expr_assign.F90",
                    "config": 1,
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.4837509701028466
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.0795974601060152,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "atomic_capture_x_plus_expr_assign.F90": [
            {
                "compilation": {
                    "command": "nvfortran -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/atomic_capture_x_plus_expr_assign.F90/atomic_capture_x_plus_expr_assign.F900 /home/exouser/Testsuite/Tests/atomic_capture_x_plus_expr_assign.F90",
                    "config": 1,
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.4803106328472495
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 1,
                    "runtime": 0.08696671901270747,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "atomic_capture_x_times_expr_assign.F90": [
            {
                "compilation": {
                    "command": "nvfortran -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/atomic_capture_x_times_expr_assign.F90/atomic_capture_x_times_expr_assign.F900 /home/exouser/Testsuite/Tests/atomic_capture_x_times_expr_assign.F90",
                    "config": 1,
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.5303024956956506
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.13119341293349862,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "atomic_divided_equals.c": [
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/atomic_divided_equals.c/atomic_divided_equals.c0 /home/exouser/Testsuite/Tests/atomic_divided_equals.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/atomic_divided_equals.c\", line 49: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.2159796878695488
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.017355114221572876,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "atomic_expr_and_x.F90": [
            {
                "compilation": {
                    "command": "nvfortran -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/atomic_expr_and_x.F90/atomic_expr_and_x.F900 /home/exouser/Testsuite/Tests/atomic_expr_and_x.F90",
                    "config": 1,
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.3800526289269328
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.08735925424844027,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "atomic_expr_and_x_end.F90": [
            {
                "compilation": {
                    "command": "nvfortran -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/atomic_expr_and_x_end.F90/atomic_expr_and_x_end.F900 /home/exouser/Testsuite/Tests/atomic_expr_and_x_end.F90",
                    "config": 1,
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.5845020790584385
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.09110219683498144,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "atomic_expr_bitand_x.c": [
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/atomic_expr_bitand_x.c/atomic_expr_bitand_x.c0 /home/exouser/Testsuite/Tests/atomic_expr_bitand_x.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/atomic_expr_bitand_x.c\", line 54: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.21697110822424293
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.00953884981572628,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "atomic_expr_bitor_x.c": [
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/atomic_expr_bitor_x.c/atomic_expr_bitor_x.c0 /home/exouser/Testsuite/Tests/atomic_expr_bitor_x.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/atomic_expr_bitor_x.c\", line 51: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.16561173368245363
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.00941819278523326,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "atomic_expr_bitxor_x.c": [
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/atomic_expr_bitxor_x.c/atomic_expr_bitxor_x.c0 /home/exouser/Testsuite/Tests/atomic_expr_bitxor_x.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/atomic_expr_bitxor_x.c\", line 51: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.21691784402355552
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.01771623408421874,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "atomic_expr_divided_x.F90": [
            {
                "compilation": {
                    "command": "nvfortran -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/atomic_expr_divided_x.F90/atomic_expr_divided_x.F900 /home/exouser/Testsuite/Tests/atomic_expr_divided_x.F90",
                    "config": 1,
                    "errors": "",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 0.43772024707868695
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "Failed to complete within timeout",
                    "export": false,
                    "output": "",
                    "result": -1,
                    "runtime": -1,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvfortran -fast -acc -ta=multicore -DT1 -o /home/exouser/Testsuite/build/atomic_expr_divided_x.F90/atomic_expr_divided_x.F901 /home/exouser/Testsuite/Tests/atomic_expr_divided_x.F90",
                    "config": 1,
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.5094393761828542
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.04343697428703308,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "atomic_expr_divided_x.c": [
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/atomic_expr_divided_x.c/atomic_expr_divided_x.c0 /home/exouser/Testsuite/Tests/atomic_expr_divided_x.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/atomic_expr_divided_x.c\", line 77: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.16588063910603523
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.009936423972249031,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "atomic_expr_divided_x_end.F90": [
            {
                "compilation": {
                    "command": "nvfortran -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/atomic_expr_divided_x_end.F90/atomic_expr_divided_x_end.F900 /home/exouser/Testsuite/Tests/atomic_expr_divided_x_end.F90",
                    "config": 1,
                    "errors": "",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 0.48020071210339665
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "Failed to complete within timeout",
                    "export": false,
                    "output": "",
                    "result": -1,
                    "runtime": -1,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvfortran -fast -acc -ta=multicore -DT1 -o /home/exouser/Testsuite/build/atomic_expr_divided_x_end.F90/atomic_expr_divided_x_end.F901 /home/exouser/Testsuite/Tests/atomic_expr_divided_x_end.F90",
                    "config": 1,
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.4331426080316305
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.0403984859585762,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "atomic_expr_eqv_x.F90": [
            {
                "compilation": {
                    "command": "nvfortran -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/atomic_expr_eqv_x.F90/atomic_expr_eqv_x.F900 /home/exouser/Testsuite/Tests/atomic_expr_eqv_x.F90",
                    "config": 1,
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.6303817238658667
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.07740542106330395,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "atomic_expr_eqv_x_end.F90": [
            {
                "compilation": {
                    "command": "nvfortran -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/atomic_expr_eqv_x_end.F90/atomic_expr_eqv_x_end.F900 /home/exouser/Testsuite/Tests/atomic_expr_eqv_x_end.F90",
                    "config": 1,
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.6350446701981127
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.08114772289991379,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "atomic_expr_lshift_x.c": [
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/atomic_expr_lshift_x.c/atomic_expr_lshift_x.c0 /home/exouser/Testsuite/Tests/atomic_expr_lshift_x.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/atomic_expr_lshift_x.c\", line 55: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n/tmp/nvcqgdgW-jm4uIJ.o: In function `__nv_test1_F1L20_1':\n/home/exouser/Testsuite/Tests/atomic_expr_lshift_x.c:28: undefined reference to `atomiclshiftu'\n/home/exouser/Testsuite/Tests/atomic_expr_lshift_x.c:28: undefined reference to `atomiclshiftu'\n/home/exouser/Testsuite/Tests/atomic_expr_lshift_x.c:28: undefined reference to `atomiclshiftu'\npgacclnk: child process exit status 1: /usr/bin/ld\n",
                    "export": false,
                    "output": "",
                    "result": 2,
                    "runtime": 0.2166657317429781
                },
                "post-compile commands": [],
                "pre-compile commands": [],
                "runtime": {
                    "export": false,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -DT1 -o /home/exouser/Testsuite/build/atomic_expr_lshift_x.c/atomic_expr_lshift_x.c1 /home/exouser/Testsuite/Tests/atomic_expr_lshift_x.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/atomic_expr_lshift_x.c\", line 55: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n\"/home/exouser/Testsuite/Tests/atomic_expr_lshift_x.c\", line 56: warning: variable \"failed\" was declared but never referenced\n      int failed;\n          ^\n\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.1699689538218081
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.009583863895386457,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "atomic_expr_minus_x.F90": [
            {
                "compilation": {
                    "command": "nvfortran -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/atomic_expr_minus_x.F90/atomic_expr_minus_x.F900 /home/exouser/Testsuite/Tests/atomic_expr_minus_x.F90",
                    "config": 1,
                    "errors": "",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 0.48036829102784395
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "Failed to complete within timeout",
                    "export": false,
                    "output": "",
                    "result": -1,
                    "runtime": -1,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvfortran -fast -acc -ta=multicore -DT1 -o /home/exouser/Testsuite/build/atomic_expr_minus_x.F90/atomic_expr_minus_x.F901 /home/exouser/Testsuite/Tests/atomic_expr_minus_x.F90",
                    "config": 1,
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.44021784607321024
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.053158103954046965,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "atomic_expr_minus_x.c": [
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/atomic_expr_minus_x.c/atomic_expr_minus_x.c0 /home/exouser/Testsuite/Tests/atomic_expr_minus_x.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/atomic_expr_minus_x.c\", line 73: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.1655976022593677
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.009570853784680367,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "atomic_expr_minus_x_end.F90": [
            {
                "compilation": {
                    "command": "nvfortran -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/atomic_expr_minus_x_end.F90/atomic_expr_minus_x_end.F900 /home/exouser/Testsuite/Tests/atomic_expr_minus_x_end.F90",
                    "config": 1,
                    "errors": "",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 0.4882132401689887
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "Failed to complete within timeout",
                    "export": false,
                    "output": "",
                    "result": -1,
                    "runtime": -1,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvfortran -fast -acc -ta=multicore -DT1 -o /home/exouser/Testsuite/build/atomic_expr_minus_x_end.F90/atomic_expr_minus_x_end.F901 /home/exouser/Testsuite/Tests/atomic_expr_minus_x_end.F90",
                    "config": 1,
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.4813113142736256
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.04629093408584595,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "atomic_expr_multiply_x.c": [
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/atomic_expr_multiply_x.c/atomic_expr_multiply_x.c0 /home/exouser/Testsuite/Tests/atomic_expr_multiply_x.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/atomic_expr_multiply_x.c\", line 49: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.2159726689569652
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.009645354934036732,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "atomic_expr_neqv_x.F90": [
            {
                "compilation": {
                    "command": "nvfortran -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/atomic_expr_neqv_x.F90/atomic_expr_neqv_x.F900 /home/exouser/Testsuite/Tests/atomic_expr_neqv_x.F90",
                    "config": 1,
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.6769090071320534
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.09042970696464181,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "atomic_expr_neqv_x_end.F90": [
            {
                "compilation": {
                    "command": "nvfortran -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/atomic_expr_neqv_x_end.F90/atomic_expr_neqv_x_end.F900 /home/exouser/Testsuite/Tests/atomic_expr_neqv_x_end.F90",
                    "config": 1,
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.7305163908749819
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.08449364174157381,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "atomic_expr_or_x.F90": [
            {
                "compilation": {
                    "command": "nvfortran -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/atomic_expr_or_x.F90/atomic_expr_or_x.F900 /home/exouser/Testsuite/Tests/atomic_expr_or_x.F90",
                    "config": 1,
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.43001263961195946
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.13107811892405152,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "atomic_expr_or_x_end.F90": [
            {
                "compilation": {
                    "command": "nvfortran -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/atomic_expr_or_x_end.F90/atomic_expr_or_x_end.F900 /home/exouser/Testsuite/Tests/atomic_expr_or_x_end.F90",
                    "config": 1,
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.5804269649088383
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.07932015508413315,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "atomic_expr_plus_x.F90": [
            {
                "compilation": {
                    "command": "nvfortran -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/atomic_expr_plus_x.F90/atomic_expr_plus_x.F900 /home/exouser/Testsuite/Tests/atomic_expr_plus_x.F90",
                    "config": 1,
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.4803092507645488
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.1256353440694511,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "atomic_expr_plus_x.c": [
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/atomic_expr_plus_x.c/atomic_expr_plus_x.c0 /home/exouser/Testsuite/Tests/atomic_expr_plus_x.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/atomic_expr_plus_x.c\", line 54: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.1659355848096311
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 1,
                    "runtime": 0.008848831057548523,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "atomic_expr_plus_x_end.F90": [
            {
                "compilation": {
                    "command": "nvfortran -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/atomic_expr_plus_x_end.F90/atomic_expr_plus_x_end.F900 /home/exouser/Testsuite/Tests/atomic_expr_plus_x_end.F90",
                    "config": 1,
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.48629101598635316
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.07679978106170893,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "atomic_expr_rshift_x.c": [
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/atomic_expr_rshift_x.c/atomic_expr_rshift_x.c0 /home/exouser/Testsuite/Tests/atomic_expr_rshift_x.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/atomic_expr_rshift_x.c\", line 55: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n/tmp/nvc3zegLTruhles.o: In function `__nv_test1_F1L20_1':\n/home/exouser/Testsuite/Tests/atomic_expr_rshift_x.c:28: undefined reference to `atomicrshiftu'\n/home/exouser/Testsuite/Tests/atomic_expr_rshift_x.c:28: undefined reference to `atomicrshiftu'\n/home/exouser/Testsuite/Tests/atomic_expr_rshift_x.c:28: undefined reference to `atomicrshiftu'\npgacclnk: child process exit status 1: /usr/bin/ld\n",
                    "export": false,
                    "output": "",
                    "result": 2,
                    "runtime": 0.21649903990328312
                },
                "post-compile commands": [],
                "pre-compile commands": [],
                "runtime": {
                    "export": false,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -DT1 -o /home/exouser/Testsuite/build/atomic_expr_rshift_x.c/atomic_expr_rshift_x.c1 /home/exouser/Testsuite/Tests/atomic_expr_rshift_x.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/atomic_expr_rshift_x.c\", line 55: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n\"/home/exouser/Testsuite/Tests/atomic_expr_rshift_x.c\", line 56: warning: variable \"failed\" was declared but never referenced\n      int failed;\n          ^\n\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.16660792706534266
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.005141167901456356,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "atomic_expr_times_x.F90": [
            {
                "compilation": {
                    "command": "nvfortran -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/atomic_expr_times_x.F90/atomic_expr_times_x.F900 /home/exouser/Testsuite/Tests/atomic_expr_times_x.F90",
                    "config": 1,
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.4281108761206269
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.12555200513452291,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "atomic_expr_times_x_end.F90": [
            {
                "compilation": {
                    "command": "nvfortran -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/atomic_expr_times_x_end.F90/atomic_expr_times_x_end.F900 /home/exouser/Testsuite/Tests/atomic_expr_times_x_end.F90",
                    "config": 1,
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.3766918540932238
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.12892026407644153,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "atomic_iand_expr_x.F90": [
            {
                "compilation": {
                    "command": "nvfortran -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/atomic_iand_expr_x.F90/atomic_iand_expr_x.F900 /home/exouser/Testsuite/Tests/atomic_iand_expr_x.F90",
                    "config": 1,
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.43787124985828996
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.13932426180690527,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "atomic_iand_expr_x_end.F90": [
            {
                "compilation": {
                    "command": "nvfortran -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/atomic_iand_expr_x_end.F90/atomic_iand_expr_x_end.F900 /home/exouser/Testsuite/Tests/atomic_iand_expr_x_end.F90",
                    "config": 1,
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.4841701127588749
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.1256940714083612,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "atomic_iand_x_expr.F90": [
            {
                "compilation": {
                    "command": "nvfortran -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/atomic_iand_x_expr.F90/atomic_iand_x_expr.F900 /home/exouser/Testsuite/Tests/atomic_iand_x_expr.F90",
                    "config": 1,
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.38015359872952104
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.08750264020636678,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "atomic_iand_x_expr_end.F90": [
            {
                "compilation": {
                    "command": "nvfortran -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/atomic_iand_x_expr_end.F90/atomic_iand_x_expr_end.F900 /home/exouser/Testsuite/Tests/atomic_iand_x_expr_end.F90",
                    "config": 1,
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.3301814869046211
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.08146260399371386,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "atomic_ior_expr_x.F90": [
            {
                "compilation": {
                    "command": "nvfortran -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/atomic_ior_expr_x.F90/atomic_ior_expr_x.F900 /home/exouser/Testsuite/Tests/atomic_ior_expr_x.F90",
                    "config": 1,
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.4382681241258979
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.07760675810277462,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "atomic_ior_expr_x_end.F90": [
            {
                "compilation": {
                    "command": "nvfortran -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/atomic_ior_expr_x_end.F90/atomic_ior_expr_x_end.F900 /home/exouser/Testsuite/Tests/atomic_ior_expr_x_end.F90",
                    "config": 1,
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.42642036313191056
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.12709636287763715,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "atomic_ior_x_expr.F90": [
            {
                "compilation": {
                    "command": "nvfortran -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/atomic_ior_x_expr.F90/atomic_ior_x_expr.F900 /home/exouser/Testsuite/Tests/atomic_ior_x_expr.F90",
                    "config": 1,
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.4303079401142895
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.08504979498684406,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "atomic_ior_x_expr_end.F90": [
            {
                "compilation": {
                    "command": "nvfortran -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/atomic_ior_x_expr_end.F90/atomic_ior_x_expr_end.F900 /home/exouser/Testsuite/Tests/atomic_ior_x_expr_end.F90",
                    "config": 1,
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.47639696579426527
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.08238319726660848,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "atomic_ixor_expr_x.F90": [
            {
                "compilation": {
                    "command": "nvfortran -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/atomic_ixor_expr_x.F90/atomic_ixor_expr_x.F900 /home/exouser/Testsuite/Tests/atomic_ixor_expr_x.F90",
                    "config": 1,
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.4340292806737125
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.08826500829309225,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "atomic_ixor_expr_x_end.F90": [
            {
                "compilation": {
                    "command": "nvfortran -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/atomic_ixor_expr_x_end.F90/atomic_ixor_expr_x_end.F900 /home/exouser/Testsuite/Tests/atomic_ixor_expr_x_end.F90",
                    "config": 1,
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.4383761566132307
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.1273502609692514,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "atomic_ixor_x_expr.F90": [
            {
                "compilation": {
                    "command": "nvfortran -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/atomic_ixor_x_expr.F90/atomic_ixor_x_expr.F900 /home/exouser/Testsuite/Tests/atomic_ixor_x_expr.F90",
                    "config": 1,
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.4267116808332503
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.12325568916276097,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "atomic_ixor_x_expr_end.F90": [
            {
                "compilation": {
                    "command": "nvfortran -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/atomic_ixor_x_expr_end.F90/atomic_ixor_x_expr_end.F900 /home/exouser/Testsuite/Tests/atomic_ixor_x_expr_end.F90",
                    "config": 1,
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.4298242097720504
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.07751933112740517,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "atomic_lshift_equals.c": [
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/atomic_lshift_equals.c/atomic_lshift_equals.c0 /home/exouser/Testsuite/Tests/atomic_lshift_equals.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/atomic_lshift_equals.c\", line 53: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n/tmp/nvc3VegLrUbhT3C.o: In function `__nv_test1_F1L20_1':\n/home/exouser/Testsuite/Tests/atomic_lshift_equals.c:29: undefined reference to `atomiclshiftu'\n/home/exouser/Testsuite/Tests/atomic_lshift_equals.c:29: undefined reference to `atomiclshiftu'\n/home/exouser/Testsuite/Tests/atomic_lshift_equals.c:29: undefined reference to `atomiclshiftu'\n/home/exouser/Testsuite/Tests/atomic_lshift_equals.c:29: undefined reference to `atomiclshiftu'\n/home/exouser/Testsuite/Tests/atomic_lshift_equals.c:29: undefined reference to `atomiclshiftu'\n/tmp/nvc3VegLrUbhT3C.o:/home/exouser/Testsuite/Tests/atomic_lshift_equals.c:29: more undefined references to `atomiclshiftu' follow\npgacclnk: child process exit status 1: /usr/bin/ld\n",
                    "export": false,
                    "output": "",
                    "result": 2,
                    "runtime": 0.16587930684909225
                },
                "post-compile commands": [],
                "pre-compile commands": [],
                "runtime": {
                    "export": false,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -DT1 -o /home/exouser/Testsuite/build/atomic_lshift_equals.c/atomic_lshift_equals.c1 /home/exouser/Testsuite/Tests/atomic_lshift_equals.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/atomic_lshift_equals.c\", line 53: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n\"/home/exouser/Testsuite/Tests/atomic_lshift_equals.c\", line 54: warning: variable \"failed\" was declared but never referenced\n      int failed;\n          ^\n\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.16644619591534138
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.0052753328345716,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "atomic_max_expr_list_x.F90": [
            {
                "compilation": {
                    "command": "nvfortran -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/atomic_max_expr_list_x.F90/atomic_max_expr_list_x.F900 /home/exouser/Testsuite/Tests/atomic_max_expr_list_x.F90",
                    "config": 1,
                    "errors": "NVFORTRAN-S-0017-Unable to open include file: acc_testsuite.f90 (/home/exouser/Testsuite/Tests/atomic_max_expr_list_x.F90: 5)\nNVFORTRAN-S-0038-Symbol, loopcount, has not been explicitly declared (/home/exouser/Testsuite/Tests/atomic_max_expr_list_x.F90)\nNVFORTRAN-S-0310-Adjustable array can not have automatic bounds specifiers - a (/home/exouser/Testsuite/Tests/atomic_max_expr_list_x.F90: 7)\nNVFORTRAN-S-0310-Adjustable array can not have automatic bounds specifiers - b (/home/exouser/Testsuite/Tests/atomic_max_expr_list_x.F90: 7)\nNVFORTRAN-S-0310-Adjustable array can not have automatic bounds specifiers - totals (/home/exouser/Testsuite/Tests/atomic_max_expr_list_x.F90: 8)\nNVFORTRAN-S-0310-Adjustable array can not have automatic bounds specifiers - totals_comparison (/home/exouser/Testsuite/Tests/atomic_max_expr_list_x.F90: 8)\n  0 inform,   0 warnings,   6 severes, 0 fatal for test1\n",
                    "export": false,
                    "output": "",
                    "result": 2,
                    "runtime": 0.12984901992604136
                },
                "post-compile commands": [],
                "pre-compile commands": [],
                "runtime": {
                    "export": false,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvfortran -fast -acc -ta=multicore -DT1 -o /home/exouser/Testsuite/build/atomic_max_expr_list_x.F90/atomic_max_expr_list_x.F901 /home/exouser/Testsuite/Tests/atomic_max_expr_list_x.F90",
                    "config": 1,
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.3738535000011325
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.04761494183912873,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "atomic_max_expr_list_x_end.F90": [
            {
                "compilation": {
                    "command": "nvfortran -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/atomic_max_expr_list_x_end.F90/atomic_max_expr_list_x_end.F900 /home/exouser/Testsuite/Tests/atomic_max_expr_list_x_end.F90",
                    "config": 1,
                    "errors": "NVFORTRAN-S-0104-Illegal control structure - unterminated DO (/home/exouser/Testsuite/Tests/atomic_max_expr_list_x_end.F90: 37)\n  0 inform,   0 warnings,   1 severes, 0 fatal for test1\n",
                    "export": false,
                    "output": "",
                    "result": 2,
                    "runtime": 0.125756508205086
                },
                "post-compile commands": [],
                "pre-compile commands": [],
                "runtime": {
                    "export": false,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvfortran -fast -acc -ta=multicore -DT1 -o /home/exouser/Testsuite/build/atomic_max_expr_list_x_end.F90/atomic_max_expr_list_x_end.F901 /home/exouser/Testsuite/Tests/atomic_max_expr_list_x_end.F90",
                    "config": 1,
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.3778999028727412
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.043706993106752634,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "atomic_max_expr_x.F90": [
            {
                "compilation": {
                    "command": "nvfortran -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/atomic_max_expr_x.F90/atomic_max_expr_x.F900 /home/exouser/Testsuite/Tests/atomic_max_expr_x.F90",
                    "config": 1,
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.4303247737698257
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.07734301965683699,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "atomic_max_expr_x_end.F90": [
            {
                "compilation": {
                    "command": "nvfortran -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/atomic_max_expr_x_end.F90/atomic_max_expr_x_end.F900 /home/exouser/Testsuite/Tests/atomic_max_expr_x_end.F90",
                    "config": 1,
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.4302122271619737
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.1240011677145958,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "atomic_max_x_expr.F90": [
            {
                "compilation": {
                    "command": "nvfortran -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/atomic_max_x_expr.F90/atomic_max_x_expr.F900 /home/exouser/Testsuite/Tests/atomic_max_x_expr.F90",
                    "config": 1,
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.4301763349212706
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.12747069401666522,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "atomic_max_x_expr_end.F90": [
            {
                "compilation": {
                    "command": "nvfortran -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/atomic_max_x_expr_end.F90/atomic_max_x_expr_end.F900 /home/exouser/Testsuite/Tests/atomic_max_x_expr_end.F90",
                    "config": 1,
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.3880970682948828
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.07921546790748835,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "atomic_max_x_expr_list.F90": [
            {
                "compilation": {
                    "command": "nvfortran -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/atomic_max_x_expr_list.F90/atomic_max_x_expr_list.F900 /home/exouser/Testsuite/Tests/atomic_max_x_expr_list.F90",
                    "config": 1,
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.42621728405356407
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.13130093226209283,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "atomic_max_x_expr_list_end.F90": [
            {
                "compilation": {
                    "command": "nvfortran -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/atomic_max_x_expr_list_end.F90/atomic_max_x_expr_list_end.F900 /home/exouser/Testsuite/Tests/atomic_max_x_expr_list_end.F90",
                    "config": 1,
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.43026902014389634
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.08133934298530221,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "atomic_min_expr_list_x.F90": [
            {
                "compilation": {
                    "command": "nvfortran -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/atomic_min_expr_list_x.F90/atomic_min_expr_list_x.F900 /home/exouser/Testsuite/Tests/atomic_min_expr_list_x.F90",
                    "config": 1,
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.3801305629312992
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.09144730679690838,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "atomic_min_expr_list_x_end.F90": [
            {
                "compilation": {
                    "command": "nvfortran -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/atomic_min_expr_list_x_end.F90/atomic_min_expr_list_x_end.F900 /home/exouser/Testsuite/Tests/atomic_min_expr_list_x_end.F90",
                    "config": 1,
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.38019570196047425
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.07166213495656848,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "atomic_min_expr_x.F90": [
            {
                "compilation": {
                    "command": "nvfortran -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/atomic_min_expr_x.F90/atomic_min_expr_x.F900 /home/exouser/Testsuite/Tests/atomic_min_expr_x.F90",
                    "config": 1,
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.43022340908646584
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.12799248797819018,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "atomic_min_expr_x_end.F90": [
            {
                "compilation": {
                    "command": "nvfortran -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/atomic_min_expr_x_end.F90/atomic_min_expr_x_end.F900 /home/exouser/Testsuite/Tests/atomic_min_expr_x_end.F90",
                    "config": 1,
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.3837223961018026
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.07932155579328537,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "atomic_min_x_expr.F90": [
            {
                "compilation": {
                    "command": "nvfortran -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/atomic_min_x_expr.F90/atomic_min_x_expr.F900 /home/exouser/Testsuite/Tests/atomic_min_x_expr.F90",
                    "config": 1,
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.43020195234566927
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.08141429489478469,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "atomic_min_x_expr_end.F90": [
            {
                "compilation": {
                    "command": "nvfortran -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/atomic_min_x_expr_end.F90/atomic_min_x_expr_end.F900 /home/exouser/Testsuite/Tests/atomic_min_x_expr_end.F90",
                    "config": 1,
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.4335298100486398
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.08067198283970356,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "atomic_min_x_expr_list.F90": [
            {
                "compilation": {
                    "command": "nvfortran -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/atomic_min_x_expr_list.F90/atomic_min_x_expr_list.F900 /home/exouser/Testsuite/Tests/atomic_min_x_expr_list.F90",
                    "config": 1,
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.43507117591798306
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.08050824189558625,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "atomic_min_x_expr_list_end.F90": [
            {
                "compilation": {
                    "command": "nvfortran -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/atomic_min_x_expr_list_end.F90/atomic_min_x_expr_list_end.F900 /home/exouser/Testsuite/Tests/atomic_min_x_expr_list_end.F90",
                    "config": 1,
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.43044428434222937
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.1316932193003595,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "atomic_minus_equals.c": [
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/atomic_minus_equals.c/atomic_minus_equals.c0 /home/exouser/Testsuite/Tests/atomic_minus_equals.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/atomic_minus_equals.c\", line 47: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.16565082175657153
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.017667588777840137,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "atomic_multiply_equals.c": [
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/atomic_multiply_equals.c/atomic_multiply_equals.c0 /home/exouser/Testsuite/Tests/atomic_multiply_equals.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/atomic_multiply_equals.c\", line 49: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.2165428721345961
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.00984289264306426,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "atomic_plus_equals.c": [
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/atomic_plus_equals.c/atomic_plus_equals.c0 /home/exouser/Testsuite/Tests/atomic_plus_equals.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/atomic_plus_equals.c\", line 49: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.21685136714950204
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.009545859880745411,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "atomic_postdecrement.c": [
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/atomic_postdecrement.c/atomic_postdecrement.c0 /home/exouser/Testsuite/Tests/atomic_postdecrement.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/atomic_postdecrement.c\", line 49: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.165658846963197
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.009300472214818,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "atomic_postincrement.c": [
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/atomic_postincrement.c/atomic_postincrement.c0 /home/exouser/Testsuite/Tests/atomic_postincrement.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/atomic_postincrement.c\", line 54: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.16687043709680438
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.009944167919456959,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "atomic_predecrement.c": [
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/atomic_predecrement.c/atomic_predecrement.c0 /home/exouser/Testsuite/Tests/atomic_predecrement.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/atomic_predecrement.c\", line 54: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.16611812263727188
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.017388342414051294,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "atomic_preincrement.c": [
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/atomic_preincrement.c/atomic_preincrement.c0 /home/exouser/Testsuite/Tests/atomic_preincrement.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/atomic_preincrement.c\", line 54: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.16706208419054747
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.00955052487552166,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "atomic_rshift_equals.c": [
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/atomic_rshift_equals.c/atomic_rshift_equals.c0 /home/exouser/Testsuite/Tests/atomic_rshift_equals.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/atomic_rshift_equals.c\", line 53: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n/tmp/nvcfyhgpTizfo0B.o: In function `__nv_test1_F1L20_1':\n/home/exouser/Testsuite/Tests/atomic_rshift_equals.c:29: undefined reference to `atomicrshiftu'\n/home/exouser/Testsuite/Tests/atomic_rshift_equals.c:29: undefined reference to `atomicrshiftu'\n/home/exouser/Testsuite/Tests/atomic_rshift_equals.c:29: undefined reference to `atomicrshiftu'\n/home/exouser/Testsuite/Tests/atomic_rshift_equals.c:29: undefined reference to `atomicrshiftu'\n/home/exouser/Testsuite/Tests/atomic_rshift_equals.c:29: undefined reference to `atomicrshiftu'\n/tmp/nvcfyhgpTizfo0B.o:/home/exouser/Testsuite/Tests/atomic_rshift_equals.c:29: more undefined references to `atomicrshiftu' follow\npgacclnk: child process exit status 1: /usr/bin/ld\n",
                    "export": false,
                    "output": "",
                    "result": 2,
                    "runtime": 0.1654424392618239
                },
                "post-compile commands": [],
                "pre-compile commands": [],
                "runtime": {
                    "export": false,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -DT1 -o /home/exouser/Testsuite/build/atomic_rshift_equals.c/atomic_rshift_equals.c1 /home/exouser/Testsuite/Tests/atomic_rshift_equals.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/atomic_rshift_equals.c\", line 53: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n\"/home/exouser/Testsuite/Tests/atomic_rshift_equals.c\", line 54: warning: variable \"failed\" was declared but never referenced\n      int failed;\n          ^\n\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.16601141588762403
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.005290681030601263,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "atomic_structured_assign_assign.c": [
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/atomic_structured_assign_assign.c/atomic_structured_assign_assign.c0 /home/exouser/Testsuite/Tests/atomic_structured_assign_assign.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/atomic_structured_assign_assign.c\", line 24: error: extra text after expected end of preprocessing directive\n                  #pragma acc atomic update capture\n                                            ^\n\n\"/home/exouser/Testsuite/Tests/atomic_structured_assign_assign.c\", line 48: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n1 error detected in the compilation of \"/home/exouser/Testsuite/Tests/atomic_structured_assign_assign.c\".\n",
                    "export": false,
                    "output": "",
                    "result": 2,
                    "runtime": 0.06599123403429985
                },
                "post-compile commands": [],
                "pre-compile commands": [],
                "runtime": {
                    "export": false,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -DT1 -o /home/exouser/Testsuite/build/atomic_structured_assign_assign.c/atomic_structured_assign_assign.c1 /home/exouser/Testsuite/Tests/atomic_structured_assign_assign.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/atomic_structured_assign_assign.c\", line 48: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n\"/home/exouser/Testsuite/Tests/atomic_structured_assign_assign.c\", line 49: warning: variable \"failed\" was declared but never referenced\n      int failed;\n          ^\n\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.16672506369650364
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.005145876202732325,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "atomic_structured_assign_bitand_equals.c": [
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/atomic_structured_assign_bitand_equals.c/atomic_structured_assign_bitand_equals.c0 /home/exouser/Testsuite/Tests/atomic_structured_assign_bitand_equals.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/atomic_structured_assign_bitand_equals.c\", line 67: error: extra text after expected end of preprocessing directive\n                  #pragma acc atomic update capture\n                                            ^\n\n\"/home/exouser/Testsuite/Tests/atomic_structured_assign_bitand_equals.c\", line 41: warning: variable \"iterator\" was declared but never referenced\n      int iterator;\n          ^\n\n\"/home/exouser/Testsuite/Tests/atomic_structured_assign_bitand_equals.c\", line 42: warning: variable \"iterator2\" was declared but never referenced\n      int iterator2;\n          ^\n\n\"/home/exouser/Testsuite/Tests/atomic_structured_assign_bitand_equals.c\", line 106: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n1 error detected in the compilation of \"/home/exouser/Testsuite/Tests/atomic_structured_assign_bitand_equals.c\".\n",
                    "export": false,
                    "output": "",
                    "result": 2,
                    "runtime": 0.06521328212693334
                },
                "post-compile commands": [],
                "pre-compile commands": [],
                "runtime": {
                    "export": false,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -DT1 -o /home/exouser/Testsuite/build/atomic_structured_assign_bitand_equals.c/atomic_structured_assign_bitand_equals.c1 /home/exouser/Testsuite/Tests/atomic_structured_assign_bitand_equals.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/atomic_structured_assign_bitand_equals.c\", line 106: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n\"/home/exouser/Testsuite/Tests/atomic_structured_assign_bitand_equals.c\", line 107: warning: variable \"failed\" was declared but never referenced\n      int failed;\n          ^\n\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.21575334994122386
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.004801034927368164,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "atomic_structured_assign_bitor_equals.c": [
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/atomic_structured_assign_bitor_equals.c/atomic_structured_assign_bitor_equals.c0 /home/exouser/Testsuite/Tests/atomic_structured_assign_bitor_equals.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/atomic_structured_assign_bitor_equals.c\", line 67: error: extra text after expected end of preprocessing directive\n                  #pragma acc atomic update capture\n                                            ^\n\n\"/home/exouser/Testsuite/Tests/atomic_structured_assign_bitor_equals.c\", line 41: warning: variable \"iterator\" was declared but never referenced\n      int iterator;\n          ^\n\n\"/home/exouser/Testsuite/Tests/atomic_structured_assign_bitor_equals.c\", line 42: warning: variable \"iterator2\" was declared but never referenced\n      int iterator2;\n          ^\n\n\"/home/exouser/Testsuite/Tests/atomic_structured_assign_bitor_equals.c\", line 106: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n1 error detected in the compilation of \"/home/exouser/Testsuite/Tests/atomic_structured_assign_bitor_equals.c\".\n",
                    "export": false,
                    "output": "",
                    "result": 2,
                    "runtime": 0.06615454331040382
                },
                "post-compile commands": [],
                "pre-compile commands": [],
                "runtime": {
                    "export": false,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -DT1 -o /home/exouser/Testsuite/build/atomic_structured_assign_bitor_equals.c/atomic_structured_assign_bitor_equals.c1 /home/exouser/Testsuite/Tests/atomic_structured_assign_bitor_equals.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/atomic_structured_assign_bitor_equals.c\", line 106: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n\"/home/exouser/Testsuite/Tests/atomic_structured_assign_bitor_equals.c\", line 107: warning: variable \"failed\" was declared but never referenced\n      int failed;\n          ^\n\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.21639307122677565
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.005337846931070089,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "atomic_structured_assign_bitxor_equals.c": [
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/atomic_structured_assign_bitxor_equals.c/atomic_structured_assign_bitxor_equals.c0 /home/exouser/Testsuite/Tests/atomic_structured_assign_bitxor_equals.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/atomic_structured_assign_bitxor_equals.c\", line 67: error: extra text after expected end of preprocessing directive\n                  #pragma acc atomic update capture\n                                            ^\n\n\"/home/exouser/Testsuite/Tests/atomic_structured_assign_bitxor_equals.c\", line 41: warning: variable \"iterator\" was declared but never referenced\n      int iterator;\n          ^\n\n\"/home/exouser/Testsuite/Tests/atomic_structured_assign_bitxor_equals.c\", line 42: warning: variable \"iterator2\" was declared but never referenced\n      int iterator2;\n          ^\n\n\"/home/exouser/Testsuite/Tests/atomic_structured_assign_bitxor_equals.c\", line 106: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n1 error detected in the compilation of \"/home/exouser/Testsuite/Tests/atomic_structured_assign_bitxor_equals.c\".\n",
                    "export": false,
                    "output": "",
                    "result": 2,
                    "runtime": 0.06529936706647277
                },
                "post-compile commands": [],
                "pre-compile commands": [],
                "runtime": {
                    "export": false,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -DT1 -o /home/exouser/Testsuite/build/atomic_structured_assign_bitxor_equals.c/atomic_structured_assign_bitxor_equals.c1 /home/exouser/Testsuite/Tests/atomic_structured_assign_bitxor_equals.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/atomic_structured_assign_bitxor_equals.c\", line 106: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n\"/home/exouser/Testsuite/Tests/atomic_structured_assign_bitxor_equals.c\", line 107: warning: variable \"failed\" was declared but never referenced\n      int failed;\n          ^\n\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.21610661316663027
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.00530272489413619,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "atomic_structured_assign_divided_equals.c": [
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/atomic_structured_assign_divided_equals.c/atomic_structured_assign_divided_equals.c0 /home/exouser/Testsuite/Tests/atomic_structured_assign_divided_equals.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/atomic_structured_assign_divided_equals.c\", line 67: error: extra text after expected end of preprocessing directive\n                  #pragma acc atomic update capture\n                                            ^\n\n\"/home/exouser/Testsuite/Tests/atomic_structured_assign_divided_equals.c\", line 105: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n1 error detected in the compilation of \"/home/exouser/Testsuite/Tests/atomic_structured_assign_divided_equals.c\".\n",
                    "export": false,
                    "output": "",
                    "result": 2,
                    "runtime": 0.06601515877991915
                },
                "post-compile commands": [],
                "pre-compile commands": [],
                "runtime": {
                    "export": false,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -DT1 -o /home/exouser/Testsuite/build/atomic_structured_assign_divided_equals.c/atomic_structured_assign_divided_equals.c1 /home/exouser/Testsuite/Tests/atomic_structured_assign_divided_equals.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/atomic_structured_assign_divided_equals.c\", line 105: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n\"/home/exouser/Testsuite/Tests/atomic_structured_assign_divided_equals.c\", line 106: warning: variable \"failed\" was declared but never referenced\n      int failed;\n          ^\n\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.1658499320037663
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.005096619948744774,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "atomic_structured_assign_expr_bitand_x.c": [
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/atomic_structured_assign_expr_bitand_x.c/atomic_structured_assign_expr_bitand_x.c0 /home/exouser/Testsuite/Tests/atomic_structured_assign_expr_bitand_x.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/atomic_structured_assign_expr_bitand_x.c\", line 67: error: extra text after expected end of preprocessing directive\n                  #pragma acc atomic update capture\n                                            ^\n\n\"/home/exouser/Testsuite/Tests/atomic_structured_assign_expr_bitand_x.c\", line 41: warning: variable \"iterator\" was declared but never referenced\n      int iterator;\n          ^\n\n\"/home/exouser/Testsuite/Tests/atomic_structured_assign_expr_bitand_x.c\", line 42: warning: variable \"iterator2\" was declared but never referenced\n      int iterator2;\n          ^\n\n\"/home/exouser/Testsuite/Tests/atomic_structured_assign_expr_bitand_x.c\", line 106: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n1 error detected in the compilation of \"/home/exouser/Testsuite/Tests/atomic_structured_assign_expr_bitand_x.c\".\n",
                    "export": false,
                    "output": "",
                    "result": 2,
                    "runtime": 0.06567118177190423
                },
                "post-compile commands": [],
                "pre-compile commands": [],
                "runtime": {
                    "export": false,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -DT1 -o /home/exouser/Testsuite/build/atomic_structured_assign_expr_bitand_x.c/atomic_structured_assign_expr_bitand_x.c1 /home/exouser/Testsuite/Tests/atomic_structured_assign_expr_bitand_x.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/atomic_structured_assign_expr_bitand_x.c\", line 106: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n\"/home/exouser/Testsuite/Tests/atomic_structured_assign_expr_bitand_x.c\", line 107: warning: variable \"failed\" was declared but never referenced\n      int failed;\n          ^\n\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.2156328889541328
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.005245781037956476,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "atomic_structured_assign_expr_bitor_x.c": [
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/atomic_structured_assign_expr_bitor_x.c/atomic_structured_assign_expr_bitor_x.c0 /home/exouser/Testsuite/Tests/atomic_structured_assign_expr_bitor_x.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/atomic_structured_assign_expr_bitor_x.c\", line 67: error: extra text after expected end of preprocessing directive\n                  #pragma acc atomic update capture\n                                            ^\n\n\"/home/exouser/Testsuite/Tests/atomic_structured_assign_expr_bitor_x.c\", line 41: warning: variable \"iterator\" was declared but never referenced\n      int iterator;\n          ^\n\n\"/home/exouser/Testsuite/Tests/atomic_structured_assign_expr_bitor_x.c\", line 42: warning: variable \"iterator2\" was declared but never referenced\n      int iterator2;\n          ^\n\n\"/home/exouser/Testsuite/Tests/atomic_structured_assign_expr_bitor_x.c\", line 106: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n1 error detected in the compilation of \"/home/exouser/Testsuite/Tests/atomic_structured_assign_expr_bitor_x.c\".\n",
                    "export": false,
                    "output": "",
                    "result": 2,
                    "runtime": 0.06534190801903605
                },
                "post-compile commands": [],
                "pre-compile commands": [],
                "runtime": {
                    "export": false,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -DT1 -o /home/exouser/Testsuite/build/atomic_structured_assign_expr_bitor_x.c/atomic_structured_assign_expr_bitor_x.c1 /home/exouser/Testsuite/Tests/atomic_structured_assign_expr_bitor_x.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/atomic_structured_assign_expr_bitor_x.c\", line 106: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n\"/home/exouser/Testsuite/Tests/atomic_structured_assign_expr_bitor_x.c\", line 107: warning: variable \"failed\" was declared but never referenced\n      int failed;\n          ^\n\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.21605452802032232
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.005372708197683096,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "atomic_structured_assign_expr_bitxor_x.c": [
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/atomic_structured_assign_expr_bitxor_x.c/atomic_structured_assign_expr_bitxor_x.c0 /home/exouser/Testsuite/Tests/atomic_structured_assign_expr_bitxor_x.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/atomic_structured_assign_expr_bitxor_x.c\", line 67: error: extra text after expected end of preprocessing directive\n                  #pragma acc atomic update capture\n                                            ^\n\n\"/home/exouser/Testsuite/Tests/atomic_structured_assign_expr_bitxor_x.c\", line 41: warning: variable \"iterator\" was declared but never referenced\n      int iterator;\n          ^\n\n\"/home/exouser/Testsuite/Tests/atomic_structured_assign_expr_bitxor_x.c\", line 42: warning: variable \"iterator2\" was declared but never referenced\n      int iterator2;\n          ^\n\n\"/home/exouser/Testsuite/Tests/atomic_structured_assign_expr_bitxor_x.c\", line 106: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n1 error detected in the compilation of \"/home/exouser/Testsuite/Tests/atomic_structured_assign_expr_bitxor_x.c\".\n",
                    "export": false,
                    "output": "",
                    "result": 2,
                    "runtime": 0.06547758495435119
                },
                "post-compile commands": [],
                "pre-compile commands": [],
                "runtime": {
                    "export": false,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -DT1 -o /home/exouser/Testsuite/build/atomic_structured_assign_expr_bitxor_x.c/atomic_structured_assign_expr_bitxor_x.c1 /home/exouser/Testsuite/Tests/atomic_structured_assign_expr_bitxor_x.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/atomic_structured_assign_expr_bitxor_x.c\", line 106: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n\"/home/exouser/Testsuite/Tests/atomic_structured_assign_expr_bitxor_x.c\", line 107: warning: variable \"failed\" was declared but never referenced\n      int failed;\n          ^\n\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.21549855964258313
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.00508540915325284,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "atomic_structured_assign_expr_divided_x.c": [
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/atomic_structured_assign_expr_divided_x.c/atomic_structured_assign_expr_divided_x.c0 /home/exouser/Testsuite/Tests/atomic_structured_assign_expr_divided_x.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/atomic_structured_assign_expr_divided_x.c\", line 93: error: extra text after expected end of preprocessing directive\n                  #pragma acc atomic update capture\n                                            ^\n\n\"/home/exouser/Testsuite/Tests/atomic_structured_assign_expr_divided_x.c\", line 132: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n1 error detected in the compilation of \"/home/exouser/Testsuite/Tests/atomic_structured_assign_expr_divided_x.c\".\n",
                    "export": false,
                    "output": "",
                    "result": 2,
                    "runtime": 0.06544947857037187
                },
                "post-compile commands": [],
                "pre-compile commands": [],
                "runtime": {
                    "export": false,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -DT1 -o /home/exouser/Testsuite/build/atomic_structured_assign_expr_divided_x.c/atomic_structured_assign_expr_divided_x.c1 /home/exouser/Testsuite/Tests/atomic_structured_assign_expr_divided_x.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/atomic_structured_assign_expr_divided_x.c\", line 132: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n\"/home/exouser/Testsuite/Tests/atomic_structured_assign_expr_divided_x.c\", line 133: warning: variable \"failed\" was declared but never referenced\n      int failed;\n          ^\n\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.21587777324020863
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.005148847121745348,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "atomic_structured_assign_expr_multiply_x.c": [
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/atomic_structured_assign_expr_multiply_x.c/atomic_structured_assign_expr_multiply_x.c0 /home/exouser/Testsuite/Tests/atomic_structured_assign_expr_multiply_x.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/atomic_structured_assign_expr_multiply_x.c\", line 60: error: extra text after expected end of preprocessing directive\n                  #pragma acc atomic update capture\n                                            ^\n\n\"/home/exouser/Testsuite/Tests/atomic_structured_assign_expr_multiply_x.c\", line 95: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n1 error detected in the compilation of \"/home/exouser/Testsuite/Tests/atomic_structured_assign_expr_multiply_x.c\".\n",
                    "export": false,
                    "output": "",
                    "result": 2,
                    "runtime": 0.06631097430363297
                },
                "post-compile commands": [],
                "pre-compile commands": [],
                "runtime": {
                    "export": false,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -DT1 -o /home/exouser/Testsuite/build/atomic_structured_assign_expr_multiply_x.c/atomic_structured_assign_expr_multiply_x.c1 /home/exouser/Testsuite/Tests/atomic_structured_assign_expr_multiply_x.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/atomic_structured_assign_expr_multiply_x.c\", line 95: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n\"/home/exouser/Testsuite/Tests/atomic_structured_assign_expr_multiply_x.c\", line 96: warning: variable \"failed\" was declared but never referenced\n      int failed;\n          ^\n\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.21579394303262234
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.005153676960617304,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "atomic_structured_assign_expr_plus_x.c": [
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/atomic_structured_assign_expr_plus_x.c/atomic_structured_assign_expr_plus_x.c0 /home/exouser/Testsuite/Tests/atomic_structured_assign_expr_plus_x.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/atomic_structured_assign_expr_plus_x.c\", line 60: error: extra text after expected end of preprocessing directive\n                  #pragma acc atomic update capture\n                                            ^\n\n\"/home/exouser/Testsuite/Tests/atomic_structured_assign_expr_plus_x.c\", line 95: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n1 error detected in the compilation of \"/home/exouser/Testsuite/Tests/atomic_structured_assign_expr_plus_x.c\".\n",
                    "export": false,
                    "output": "",
                    "result": 2,
                    "runtime": 0.06546944100409746
                },
                "post-compile commands": [],
                "pre-compile commands": [],
                "runtime": {
                    "export": false,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -DT1 -o /home/exouser/Testsuite/build/atomic_structured_assign_expr_plus_x.c/atomic_structured_assign_expr_plus_x.c1 /home/exouser/Testsuite/Tests/atomic_structured_assign_expr_plus_x.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/atomic_structured_assign_expr_plus_x.c\", line 95: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n\"/home/exouser/Testsuite/Tests/atomic_structured_assign_expr_plus_x.c\", line 96: warning: variable \"failed\" was declared but never referenced\n      int failed;\n          ^\n\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.21607627533376217
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.005197952967137098,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "atomic_structured_assign_lshift_equals.c": [
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/atomic_structured_assign_lshift_equals.c/atomic_structured_assign_lshift_equals.c0 /home/exouser/Testsuite/Tests/atomic_structured_assign_lshift_equals.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/atomic_structured_assign_lshift_equals.c\", line 67: error: extra text after expected end of preprocessing directive\n                          #pragma acc atomic update capture\n                                                    ^\n\n\"/home/exouser/Testsuite/Tests/atomic_structured_assign_lshift_equals.c\", line 101: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n1 error detected in the compilation of \"/home/exouser/Testsuite/Tests/atomic_structured_assign_lshift_equals.c\".\n",
                    "export": false,
                    "output": "",
                    "result": 2,
                    "runtime": 0.06563990097492933
                },
                "post-compile commands": [],
                "pre-compile commands": [],
                "runtime": {
                    "export": false,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -DT1 -o /home/exouser/Testsuite/build/atomic_structured_assign_lshift_equals.c/atomic_structured_assign_lshift_equals.c1 /home/exouser/Testsuite/Tests/atomic_structured_assign_lshift_equals.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/atomic_structured_assign_lshift_equals.c\", line 101: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n\"/home/exouser/Testsuite/Tests/atomic_structured_assign_lshift_equals.c\", line 102: warning: variable \"failed\" was declared but never referenced\n      int failed;\n          ^\n\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.21692039910703897
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.005223351996392012,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "atomic_structured_assign_minus_equals.c": [
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/atomic_structured_assign_minus_equals.c/atomic_structured_assign_minus_equals.c0 /home/exouser/Testsuite/Tests/atomic_structured_assign_minus_equals.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/atomic_structured_assign_minus_equals.c\", line 59: error: extra text after expected end of preprocessing directive\n                  #pragma acc atomic update capture\n                                            ^\n\n\"/home/exouser/Testsuite/Tests/atomic_structured_assign_minus_equals.c\", line 93: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n1 error detected in the compilation of \"/home/exouser/Testsuite/Tests/atomic_structured_assign_minus_equals.c\".\n",
                    "export": false,
                    "output": "",
                    "result": 2,
                    "runtime": 0.06527688773348927
                },
                "post-compile commands": [],
                "pre-compile commands": [],
                "runtime": {
                    "export": false,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -DT1 -o /home/exouser/Testsuite/build/atomic_structured_assign_minus_equals.c/atomic_structured_assign_minus_equals.c1 /home/exouser/Testsuite/Tests/atomic_structured_assign_minus_equals.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/atomic_structured_assign_minus_equals.c\", line 93: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n\"/home/exouser/Testsuite/Tests/atomic_structured_assign_minus_equals.c\", line 94: warning: variable \"failed\" was declared but never referenced\n      int failed;\n          ^\n\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.21621150523424149
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.005223593674600124,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "atomic_structured_assign_multiply_equals.c": [
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/atomic_structured_assign_multiply_equals.c/atomic_structured_assign_multiply_equals.c0 /home/exouser/Testsuite/Tests/atomic_structured_assign_multiply_equals.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/atomic_structured_assign_multiply_equals.c\", line 60: error: extra text after expected end of preprocessing directive\n                  #pragma acc atomic update capture\n                                            ^\n\n\"/home/exouser/Testsuite/Tests/atomic_structured_assign_multiply_equals.c\", line 95: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n1 error detected in the compilation of \"/home/exouser/Testsuite/Tests/atomic_structured_assign_multiply_equals.c\".\n",
                    "export": false,
                    "output": "",
                    "result": 2,
                    "runtime": 0.0653826491907239
                },
                "post-compile commands": [],
                "pre-compile commands": [],
                "runtime": {
                    "export": false,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -DT1 -o /home/exouser/Testsuite/build/atomic_structured_assign_multiply_equals.c/atomic_structured_assign_multiply_equals.c1 /home/exouser/Testsuite/Tests/atomic_structured_assign_multiply_equals.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/atomic_structured_assign_multiply_equals.c\", line 95: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n\"/home/exouser/Testsuite/Tests/atomic_structured_assign_multiply_equals.c\", line 96: warning: variable \"failed\" was declared but never referenced\n      int failed;\n          ^\n\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.21591971814632416
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.0051481458358466625,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "atomic_structured_assign_plus_equals.c": [
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/atomic_structured_assign_plus_equals.c/atomic_structured_assign_plus_equals.c0 /home/exouser/Testsuite/Tests/atomic_structured_assign_plus_equals.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/atomic_structured_assign_plus_equals.c\", line 60: error: extra text after expected end of preprocessing directive\n                  #pragma acc atomic update capture\n                                            ^\n\n\"/home/exouser/Testsuite/Tests/atomic_structured_assign_plus_equals.c\", line 95: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n1 error detected in the compilation of \"/home/exouser/Testsuite/Tests/atomic_structured_assign_plus_equals.c\".\n",
                    "export": false,
                    "output": "",
                    "result": 2,
                    "runtime": 0.06591915106400847
                },
                "post-compile commands": [],
                "pre-compile commands": [],
                "runtime": {
                    "export": false,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -DT1 -o /home/exouser/Testsuite/build/atomic_structured_assign_plus_equals.c/atomic_structured_assign_plus_equals.c1 /home/exouser/Testsuite/Tests/atomic_structured_assign_plus_equals.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/atomic_structured_assign_plus_equals.c\", line 95: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n\"/home/exouser/Testsuite/Tests/atomic_structured_assign_plus_equals.c\", line 96: warning: variable \"failed\" was declared but never referenced\n      int failed;\n          ^\n\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.21697759674862027
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.004902568645775318,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "atomic_structured_assign_postdecrement.c": [
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/atomic_structured_assign_postdecrement.c/atomic_structured_assign_postdecrement.c0 /home/exouser/Testsuite/Tests/atomic_structured_assign_postdecrement.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/atomic_structured_assign_postdecrement.c\", line 29: error: extra text after expected end of preprocessing directive\n                  #pragma acc atomic update capture\n                                            ^\n\n\"/home/exouser/Testsuite/Tests/atomic_structured_assign_postdecrement.c\", line 69: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n1 error detected in the compilation of \"/home/exouser/Testsuite/Tests/atomic_structured_assign_postdecrement.c\".\n",
                    "export": false,
                    "output": "",
                    "result": 2,
                    "runtime": 0.06596192810684443
                },
                "post-compile commands": [],
                "pre-compile commands": [],
                "runtime": {
                    "export": false,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -DT1 -o /home/exouser/Testsuite/build/atomic_structured_assign_postdecrement.c/atomic_structured_assign_postdecrement.c1 /home/exouser/Testsuite/Tests/atomic_structured_assign_postdecrement.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/atomic_structured_assign_postdecrement.c\", line 69: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n\"/home/exouser/Testsuite/Tests/atomic_structured_assign_postdecrement.c\", line 70: warning: variable \"failed\" was declared but never referenced\n      int failed;\n          ^\n\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.1666194531135261
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.004893846809864044,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "atomic_structured_assign_postincrement.c": [
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/atomic_structured_assign_postincrement.c/atomic_structured_assign_postincrement.c0 /home/exouser/Testsuite/Tests/atomic_structured_assign_postincrement.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/atomic_structured_assign_postincrement.c\", line 29: error: extra text after expected end of preprocessing directive\n                  #pragma acc atomic update capture\n                                            ^\n\n\"/home/exouser/Testsuite/Tests/atomic_structured_assign_postincrement.c\", line 69: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n1 error detected in the compilation of \"/home/exouser/Testsuite/Tests/atomic_structured_assign_postincrement.c\".\n",
                    "export": false,
                    "output": "",
                    "result": 2,
                    "runtime": 0.06595076620578766
                },
                "post-compile commands": [],
                "pre-compile commands": [],
                "runtime": {
                    "export": false,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -DT1 -o /home/exouser/Testsuite/build/atomic_structured_assign_postincrement.c/atomic_structured_assign_postincrement.c1 /home/exouser/Testsuite/Tests/atomic_structured_assign_postincrement.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/atomic_structured_assign_postincrement.c\", line 69: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n\"/home/exouser/Testsuite/Tests/atomic_structured_assign_postincrement.c\", line 70: warning: variable \"failed\" was declared but never referenced\n      int failed;\n          ^\n\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.16625426476821303
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.004927303176373243,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "atomic_structured_assign_predecrement.c": [
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/atomic_structured_assign_predecrement.c/atomic_structured_assign_predecrement.c0 /home/exouser/Testsuite/Tests/atomic_structured_assign_predecrement.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/atomic_structured_assign_predecrement.c\", line 29: error: extra text after expected end of preprocessing directive\n                  #pragma acc atomic update capture\n                                            ^\n\n\"/home/exouser/Testsuite/Tests/atomic_structured_assign_predecrement.c\", line 69: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n1 error detected in the compilation of \"/home/exouser/Testsuite/Tests/atomic_structured_assign_predecrement.c\".\n",
                    "export": false,
                    "output": "",
                    "result": 2,
                    "runtime": 0.06549665611237288
                },
                "post-compile commands": [],
                "pre-compile commands": [],
                "runtime": {
                    "export": false,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -DT1 -o /home/exouser/Testsuite/build/atomic_structured_assign_predecrement.c/atomic_structured_assign_predecrement.c1 /home/exouser/Testsuite/Tests/atomic_structured_assign_predecrement.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/atomic_structured_assign_predecrement.c\", line 69: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n\"/home/exouser/Testsuite/Tests/atomic_structured_assign_predecrement.c\", line 70: warning: variable \"failed\" was declared but never referenced\n      int failed;\n          ^\n\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.16568106692284346
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.0049125198274850845,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "atomic_structured_assign_preincrement.c": [
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/atomic_structured_assign_preincrement.c/atomic_structured_assign_preincrement.c0 /home/exouser/Testsuite/Tests/atomic_structured_assign_preincrement.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/atomic_structured_assign_preincrement.c\", line 29: error: extra text after expected end of preprocessing directive\n                  #pragma acc atomic update capture\n                                            ^\n\n\"/home/exouser/Testsuite/Tests/atomic_structured_assign_preincrement.c\", line 69: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n1 error detected in the compilation of \"/home/exouser/Testsuite/Tests/atomic_structured_assign_preincrement.c\".\n",
                    "export": false,
                    "output": "",
                    "result": 2,
                    "runtime": 0.0654704156331718
                },
                "post-compile commands": [],
                "pre-compile commands": [],
                "runtime": {
                    "export": false,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -DT1 -o /home/exouser/Testsuite/build/atomic_structured_assign_preincrement.c/atomic_structured_assign_preincrement.c1 /home/exouser/Testsuite/Tests/atomic_structured_assign_preincrement.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/atomic_structured_assign_preincrement.c\", line 69: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n\"/home/exouser/Testsuite/Tests/atomic_structured_assign_preincrement.c\", line 70: warning: variable \"failed\" was declared but never referenced\n      int failed;\n          ^\n\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.16539877792820334
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.0052626668475568295,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "atomic_structured_assign_rshift_equals.c": [
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/atomic_structured_assign_rshift_equals.c/atomic_structured_assign_rshift_equals.c0 /home/exouser/Testsuite/Tests/atomic_structured_assign_rshift_equals.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/atomic_structured_assign_rshift_equals.c\", line 69: error: extra text after expected end of preprocessing directive\n                          #pragma acc atomic update capture\n                                                    ^\n\n\"/home/exouser/Testsuite/Tests/atomic_structured_assign_rshift_equals.c\", line 103: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n1 error detected in the compilation of \"/home/exouser/Testsuite/Tests/atomic_structured_assign_rshift_equals.c\".\n",
                    "export": false,
                    "output": "",
                    "result": 2,
                    "runtime": 0.06606582505628467
                },
                "post-compile commands": [],
                "pre-compile commands": [],
                "runtime": {
                    "export": false,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -DT1 -o /home/exouser/Testsuite/build/atomic_structured_assign_rshift_equals.c/atomic_structured_assign_rshift_equals.c1 /home/exouser/Testsuite/Tests/atomic_structured_assign_rshift_equals.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/atomic_structured_assign_rshift_equals.c\", line 103: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n\"/home/exouser/Testsuite/Tests/atomic_structured_assign_rshift_equals.c\", line 104: warning: variable \"failed\" was declared but never referenced\n      int failed;\n          ^\n\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.2167969341389835
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.00509334821254015,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "atomic_structured_assign_x_bitand_expr.c": [
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/atomic_structured_assign_x_bitand_expr.c/atomic_structured_assign_x_bitand_expr.c0 /home/exouser/Testsuite/Tests/atomic_structured_assign_x_bitand_expr.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/atomic_structured_assign_x_bitand_expr.c\", line 67: error: extra text after expected end of preprocessing directive\n                  #pragma acc atomic update capture\n                                            ^\n\n\"/home/exouser/Testsuite/Tests/atomic_structured_assign_x_bitand_expr.c\", line 41: warning: variable \"iterator\" was declared but never referenced\n      int iterator;\n          ^\n\n\"/home/exouser/Testsuite/Tests/atomic_structured_assign_x_bitand_expr.c\", line 42: warning: variable \"iterator2\" was declared but never referenced\n      int iterator2;\n          ^\n\n\"/home/exouser/Testsuite/Tests/atomic_structured_assign_x_bitand_expr.c\", line 106: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n1 error detected in the compilation of \"/home/exouser/Testsuite/Tests/atomic_structured_assign_x_bitand_expr.c\".\n",
                    "export": false,
                    "output": "",
                    "result": 2,
                    "runtime": 0.06522368406876922
                },
                "post-compile commands": [],
                "pre-compile commands": [],
                "runtime": {
                    "export": false,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -DT1 -o /home/exouser/Testsuite/build/atomic_structured_assign_x_bitand_expr.c/atomic_structured_assign_x_bitand_expr.c1 /home/exouser/Testsuite/Tests/atomic_structured_assign_x_bitand_expr.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/atomic_structured_assign_x_bitand_expr.c\", line 106: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n\"/home/exouser/Testsuite/Tests/atomic_structured_assign_x_bitand_expr.c\", line 107: warning: variable \"failed\" was declared but never referenced\n      int failed;\n          ^\n\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.2157408338971436
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.005039580632001162,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "atomic_structured_assign_x_bitor_expr.c": [
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/atomic_structured_assign_x_bitor_expr.c/atomic_structured_assign_x_bitor_expr.c0 /home/exouser/Testsuite/Tests/atomic_structured_assign_x_bitor_expr.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/atomic_structured_assign_x_bitor_expr.c\", line 68: error: extra text after expected end of preprocessing directive\n                  #pragma acc atomic update capture\n                                            ^\n\n\"/home/exouser/Testsuite/Tests/atomic_structured_assign_x_bitor_expr.c\", line 41: warning: variable \"iterator\" was declared but never referenced\n      int iterator;\n          ^\n\n\"/home/exouser/Testsuite/Tests/atomic_structured_assign_x_bitor_expr.c\", line 42: warning: variable \"iterator2\" was declared but never referenced\n      int iterator2;\n          ^\n\n\"/home/exouser/Testsuite/Tests/atomic_structured_assign_x_bitor_expr.c\", line 106: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n1 error detected in the compilation of \"/home/exouser/Testsuite/Tests/atomic_structured_assign_x_bitor_expr.c\".\n",
                    "export": false,
                    "output": "",
                    "result": 2,
                    "runtime": 0.06541063683107495
                },
                "post-compile commands": [],
                "pre-compile commands": [],
                "runtime": {
                    "export": false,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -DT1 -o /home/exouser/Testsuite/build/atomic_structured_assign_x_bitor_expr.c/atomic_structured_assign_x_bitor_expr.c1 /home/exouser/Testsuite/Tests/atomic_structured_assign_x_bitor_expr.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/atomic_structured_assign_x_bitor_expr.c\", line 106: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n\"/home/exouser/Testsuite/Tests/atomic_structured_assign_x_bitor_expr.c\", line 107: warning: variable \"failed\" was declared but never referenced\n      int failed;\n          ^\n\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.21614917926490307
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.005080349277704954,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "atomic_structured_assign_x_bitxor_expr.c": [
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/atomic_structured_assign_x_bitxor_expr.c/atomic_structured_assign_x_bitxor_expr.c0 /home/exouser/Testsuite/Tests/atomic_structured_assign_x_bitxor_expr.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/atomic_structured_assign_x_bitxor_expr.c\", line 68: error: extra text after expected end of preprocessing directive\n                  #pragma acc atomic update capture\n                                            ^\n\n\"/home/exouser/Testsuite/Tests/atomic_structured_assign_x_bitxor_expr.c\", line 41: warning: variable \"iterator\" was declared but never referenced\n      int iterator;\n          ^\n\n\"/home/exouser/Testsuite/Tests/atomic_structured_assign_x_bitxor_expr.c\", line 42: warning: variable \"iterator2\" was declared but never referenced\n      int iterator2;\n          ^\n\n\"/home/exouser/Testsuite/Tests/atomic_structured_assign_x_bitxor_expr.c\", line 106: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n1 error detected in the compilation of \"/home/exouser/Testsuite/Tests/atomic_structured_assign_x_bitxor_expr.c\".\n",
                    "export": false,
                    "output": "",
                    "result": 2,
                    "runtime": 0.06636089133098722
                },
                "post-compile commands": [],
                "pre-compile commands": [],
                "runtime": {
                    "export": false,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -DT1 -o /home/exouser/Testsuite/build/atomic_structured_assign_x_bitxor_expr.c/atomic_structured_assign_x_bitxor_expr.c1 /home/exouser/Testsuite/Tests/atomic_structured_assign_x_bitxor_expr.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/atomic_structured_assign_x_bitxor_expr.c\", line 106: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n\"/home/exouser/Testsuite/Tests/atomic_structured_assign_x_bitxor_expr.c\", line 107: warning: variable \"failed\" was declared but never referenced\n      int failed;\n          ^\n\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.2166941137984395
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.004947499372065067,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "atomic_structured_assign_x_divided_expr.c": [
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/atomic_structured_assign_x_divided_expr.c/atomic_structured_assign_x_divided_expr.c0 /home/exouser/Testsuite/Tests/atomic_structured_assign_x_divided_expr.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/atomic_structured_assign_x_divided_expr.c\", line 67: error: extra text after expected end of preprocessing directive\n                  #pragma acc atomic update capture\n                                            ^\n\n\"/home/exouser/Testsuite/Tests/atomic_structured_assign_x_divided_expr.c\", line 105: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n1 error detected in the compilation of \"/home/exouser/Testsuite/Tests/atomic_structured_assign_x_divided_expr.c\".\n",
                    "export": false,
                    "output": "",
                    "result": 2,
                    "runtime": 0.066297248005867
                },
                "post-compile commands": [],
                "pre-compile commands": [],
                "runtime": {
                    "export": false,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -DT1 -o /home/exouser/Testsuite/build/atomic_structured_assign_x_divided_expr.c/atomic_structured_assign_x_divided_expr.c1 /home/exouser/Testsuite/Tests/atomic_structured_assign_x_divided_expr.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/atomic_structured_assign_x_divided_expr.c\", line 105: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n\"/home/exouser/Testsuite/Tests/atomic_structured_assign_x_divided_expr.c\", line 106: warning: variable \"failed\" was declared but never referenced\n      int failed;\n          ^\n\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.21663511637598276
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.005038628354668617,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "atomic_structured_assign_x_lshift_expr.c": [
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/atomic_structured_assign_x_lshift_expr.c/atomic_structured_assign_x_lshift_expr.c0 /home/exouser/Testsuite/Tests/atomic_structured_assign_x_lshift_expr.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/atomic_structured_assign_x_lshift_expr.c\", line 67: error: extra text after expected end of preprocessing directive\n                          #pragma acc atomic update capture\n                                                    ^\n\n\"/home/exouser/Testsuite/Tests/atomic_structured_assign_x_lshift_expr.c\", line 101: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n1 error detected in the compilation of \"/home/exouser/Testsuite/Tests/atomic_structured_assign_x_lshift_expr.c\".\n",
                    "export": false,
                    "output": "",
                    "result": 2,
                    "runtime": 0.06623829202726483
                },
                "post-compile commands": [],
                "pre-compile commands": [],
                "runtime": {
                    "export": false,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -DT1 -o /home/exouser/Testsuite/build/atomic_structured_assign_x_lshift_expr.c/atomic_structured_assign_x_lshift_expr.c1 /home/exouser/Testsuite/Tests/atomic_structured_assign_x_lshift_expr.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/atomic_structured_assign_x_lshift_expr.c\", line 101: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n\"/home/exouser/Testsuite/Tests/atomic_structured_assign_x_lshift_expr.c\", line 102: warning: variable \"failed\" was declared but never referenced\n      int failed;\n          ^\n\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.21670836117118597
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.005083892960101366,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "atomic_structured_assign_x_minus_expr.c": [
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/atomic_structured_assign_x_minus_expr.c/atomic_structured_assign_x_minus_expr.c0 /home/exouser/Testsuite/Tests/atomic_structured_assign_x_minus_expr.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/atomic_structured_assign_x_minus_expr.c\", line 59: error: extra text after expected end of preprocessing directive\n                  #pragma acc atomic update capture\n                                            ^\n\n\"/home/exouser/Testsuite/Tests/atomic_structured_assign_x_minus_expr.c\", line 93: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n1 error detected in the compilation of \"/home/exouser/Testsuite/Tests/atomic_structured_assign_x_minus_expr.c\".\n",
                    "export": false,
                    "output": "",
                    "result": 2,
                    "runtime": 0.06588663114234805
                },
                "post-compile commands": [],
                "pre-compile commands": [],
                "runtime": {
                    "export": false,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -DT1 -o /home/exouser/Testsuite/build/atomic_structured_assign_x_minus_expr.c/atomic_structured_assign_x_minus_expr.c1 /home/exouser/Testsuite/Tests/atomic_structured_assign_x_minus_expr.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/atomic_structured_assign_x_minus_expr.c\", line 93: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n\"/home/exouser/Testsuite/Tests/atomic_structured_assign_x_minus_expr.c\", line 94: warning: variable \"failed\" was declared but never referenced\n      int failed;\n          ^\n\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.21688472805544734
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.004942377097904682,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "atomic_structured_assign_x_multiply_expr.c": [
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/atomic_structured_assign_x_multiply_expr.c/atomic_structured_assign_x_multiply_expr.c0 /home/exouser/Testsuite/Tests/atomic_structured_assign_x_multiply_expr.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/atomic_structured_assign_x_multiply_expr.c\", line 60: error: extra text after expected end of preprocessing directive\n                  #pragma acc atomic update capture\n                                            ^\n\n\"/home/exouser/Testsuite/Tests/atomic_structured_assign_x_multiply_expr.c\", line 95: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n1 error detected in the compilation of \"/home/exouser/Testsuite/Tests/atomic_structured_assign_x_multiply_expr.c\".\n",
                    "export": false,
                    "output": "",
                    "result": 2,
                    "runtime": 0.06557266507297754
                },
                "post-compile commands": [],
                "pre-compile commands": [],
                "runtime": {
                    "export": false,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -DT1 -o /home/exouser/Testsuite/build/atomic_structured_assign_x_multiply_expr.c/atomic_structured_assign_x_multiply_expr.c1 /home/exouser/Testsuite/Tests/atomic_structured_assign_x_multiply_expr.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/atomic_structured_assign_x_multiply_expr.c\", line 95: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n\"/home/exouser/Testsuite/Tests/atomic_structured_assign_x_multiply_expr.c\", line 96: warning: variable \"failed\" was declared but never referenced\n      int failed;\n          ^\n\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.21558374585583806
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.005256925243884325,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "atomic_structured_assign_x_plus_expr.c": [
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/atomic_structured_assign_x_plus_expr.c/atomic_structured_assign_x_plus_expr.c0 /home/exouser/Testsuite/Tests/atomic_structured_assign_x_plus_expr.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/atomic_structured_assign_x_plus_expr.c\", line 60: error: extra text after expected end of preprocessing directive\n                  #pragma acc atomic update capture\n                                            ^\n\n\"/home/exouser/Testsuite/Tests/atomic_structured_assign_x_plus_expr.c\", line 95: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n1 error detected in the compilation of \"/home/exouser/Testsuite/Tests/atomic_structured_assign_x_plus_expr.c\".\n",
                    "export": false,
                    "output": "",
                    "result": 2,
                    "runtime": 0.06532543804496527
                },
                "post-compile commands": [],
                "pre-compile commands": [],
                "runtime": {
                    "export": false,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -DT1 -o /home/exouser/Testsuite/build/atomic_structured_assign_x_plus_expr.c/atomic_structured_assign_x_plus_expr.c1 /home/exouser/Testsuite/Tests/atomic_structured_assign_x_plus_expr.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/atomic_structured_assign_x_plus_expr.c\", line 95: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n\"/home/exouser/Testsuite/Tests/atomic_structured_assign_x_plus_expr.c\", line 96: warning: variable \"failed\" was declared but never referenced\n      int failed;\n          ^\n\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.21592268999665976
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.00543410237878561,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "atomic_structured_assign_x_rshift_expr.c": [
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/atomic_structured_assign_x_rshift_expr.c/atomic_structured_assign_x_rshift_expr.c0 /home/exouser/Testsuite/Tests/atomic_structured_assign_x_rshift_expr.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/atomic_structured_assign_x_rshift_expr.c\", line 69: error: extra text after expected end of preprocessing directive\n                          #pragma acc atomic update capture\n                                                    ^\n\n\"/home/exouser/Testsuite/Tests/atomic_structured_assign_x_rshift_expr.c\", line 103: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n1 error detected in the compilation of \"/home/exouser/Testsuite/Tests/atomic_structured_assign_x_rshift_expr.c\".\n",
                    "export": false,
                    "output": "",
                    "result": 2,
                    "runtime": 0.06622428819537163
                },
                "post-compile commands": [],
                "pre-compile commands": [],
                "runtime": {
                    "export": false,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -DT1 -o /home/exouser/Testsuite/build/atomic_structured_assign_x_rshift_expr.c/atomic_structured_assign_x_rshift_expr.c1 /home/exouser/Testsuite/Tests/atomic_structured_assign_x_rshift_expr.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/atomic_structured_assign_x_rshift_expr.c\", line 103: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n\"/home/exouser/Testsuite/Tests/atomic_structured_assign_x_rshift_expr.c\", line 104: warning: variable \"failed\" was declared but never referenced\n      int failed;\n          ^\n\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.21694598998874426
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.004981554113328457,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "atomic_structured_bitand_equals_assign.c": [
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/atomic_structured_bitand_equals_assign.c/atomic_structured_bitand_equals_assign.c0 /home/exouser/Testsuite/Tests/atomic_structured_bitand_equals_assign.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/atomic_structured_bitand_equals_assign.c\", line 67: error: extra text after expected end of preprocessing directive\n                  #pragma acc atomic update capture\n                                            ^\n\n\"/home/exouser/Testsuite/Tests/atomic_structured_bitand_equals_assign.c\", line 41: warning: variable \"iterator\" was declared but never referenced\n      int iterator;\n          ^\n\n\"/home/exouser/Testsuite/Tests/atomic_structured_bitand_equals_assign.c\", line 42: warning: variable \"iterator2\" was declared but never referenced\n      int iterator2;\n          ^\n\n\"/home/exouser/Testsuite/Tests/atomic_structured_bitand_equals_assign.c\", line 106: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n1 error detected in the compilation of \"/home/exouser/Testsuite/Tests/atomic_structured_bitand_equals_assign.c\".\n",
                    "export": false,
                    "output": "",
                    "result": 2,
                    "runtime": 0.06557338312268257
                },
                "post-compile commands": [],
                "pre-compile commands": [],
                "runtime": {
                    "export": false,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -DT1 -o /home/exouser/Testsuite/build/atomic_structured_bitand_equals_assign.c/atomic_structured_bitand_equals_assign.c1 /home/exouser/Testsuite/Tests/atomic_structured_bitand_equals_assign.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/atomic_structured_bitand_equals_assign.c\", line 106: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n\"/home/exouser/Testsuite/Tests/atomic_structured_bitand_equals_assign.c\", line 107: warning: variable \"failed\" was declared but never referenced\n      int failed;\n          ^\n\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.21572883194312453
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.004932023119181395,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "atomic_structured_bitor_equals_assign.c": [
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/atomic_structured_bitor_equals_assign.c/atomic_structured_bitor_equals_assign.c0 /home/exouser/Testsuite/Tests/atomic_structured_bitor_equals_assign.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/atomic_structured_bitor_equals_assign.c\", line 67: error: extra text after expected end of preprocessing directive\n                  #pragma acc atomic update capture\n                                            ^\n\n\"/home/exouser/Testsuite/Tests/atomic_structured_bitor_equals_assign.c\", line 41: warning: variable \"iterator\" was declared but never referenced\n      int iterator;\n          ^\n\n\"/home/exouser/Testsuite/Tests/atomic_structured_bitor_equals_assign.c\", line 42: warning: variable \"iterator2\" was declared but never referenced\n      int iterator2;\n          ^\n\n\"/home/exouser/Testsuite/Tests/atomic_structured_bitor_equals_assign.c\", line 106: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n1 error detected in the compilation of \"/home/exouser/Testsuite/Tests/atomic_structured_bitor_equals_assign.c\".\n",
                    "export": false,
                    "output": "",
                    "result": 2,
                    "runtime": 0.06544166710227728
                },
                "post-compile commands": [],
                "pre-compile commands": [],
                "runtime": {
                    "export": false,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -DT1 -o /home/exouser/Testsuite/build/atomic_structured_bitor_equals_assign.c/atomic_structured_bitor_equals_assign.c1 /home/exouser/Testsuite/Tests/atomic_structured_bitor_equals_assign.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/atomic_structured_bitor_equals_assign.c\", line 106: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n\"/home/exouser/Testsuite/Tests/atomic_structured_bitor_equals_assign.c\", line 107: warning: variable \"failed\" was declared but never referenced\n      int failed;\n          ^\n\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.2157787368632853
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.0054215677082538605,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "atomic_structured_bitxor_equals_assign.c": [
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/atomic_structured_bitxor_equals_assign.c/atomic_structured_bitxor_equals_assign.c0 /home/exouser/Testsuite/Tests/atomic_structured_bitxor_equals_assign.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/atomic_structured_bitxor_equals_assign.c\", line 67: error: extra text after expected end of preprocessing directive\n                  #pragma acc atomic update capture\n                                            ^\n\n\"/home/exouser/Testsuite/Tests/atomic_structured_bitxor_equals_assign.c\", line 41: warning: variable \"iterator\" was declared but never referenced\n      int iterator;\n          ^\n\n\"/home/exouser/Testsuite/Tests/atomic_structured_bitxor_equals_assign.c\", line 42: warning: variable \"iterator2\" was declared but never referenced\n      int iterator2;\n          ^\n\n\"/home/exouser/Testsuite/Tests/atomic_structured_bitxor_equals_assign.c\", line 106: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n1 error detected in the compilation of \"/home/exouser/Testsuite/Tests/atomic_structured_bitxor_equals_assign.c\".\n",
                    "export": false,
                    "output": "",
                    "result": 2,
                    "runtime": 0.06588906096294522
                },
                "post-compile commands": [],
                "pre-compile commands": [],
                "runtime": {
                    "export": false,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -DT1 -o /home/exouser/Testsuite/build/atomic_structured_bitxor_equals_assign.c/atomic_structured_bitxor_equals_assign.c1 /home/exouser/Testsuite/Tests/atomic_structured_bitxor_equals_assign.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/atomic_structured_bitxor_equals_assign.c\", line 106: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n\"/home/exouser/Testsuite/Tests/atomic_structured_bitxor_equals_assign.c\", line 107: warning: variable \"failed\" was declared but never referenced\n      int failed;\n          ^\n\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.21569012012332678
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.004938511177897453,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "atomic_structured_divided_equals_assign.c": [
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/atomic_structured_divided_equals_assign.c/atomic_structured_divided_equals_assign.c0 /home/exouser/Testsuite/Tests/atomic_structured_divided_equals_assign.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/atomic_structured_divided_equals_assign.c\", line 67: error: extra text after expected end of preprocessing directive\n                #pragma acc atomic update capture\n                                          ^\n\n\"/home/exouser/Testsuite/Tests/atomic_structured_divided_equals_assign.c\", line 105: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n1 error detected in the compilation of \"/home/exouser/Testsuite/Tests/atomic_structured_divided_equals_assign.c\".\n",
                    "export": false,
                    "output": "",
                    "result": 2,
                    "runtime": 0.0659438082948327
                },
                "post-compile commands": [],
                "pre-compile commands": [],
                "runtime": {
                    "export": false,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -DT1 -o /home/exouser/Testsuite/build/atomic_structured_divided_equals_assign.c/atomic_structured_divided_equals_assign.c1 /home/exouser/Testsuite/Tests/atomic_structured_divided_equals_assign.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/atomic_structured_divided_equals_assign.c\", line 105: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n\"/home/exouser/Testsuite/Tests/atomic_structured_divided_equals_assign.c\", line 106: warning: variable \"failed\" was declared but never referenced\n      int failed;\n          ^\n\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.21681224089115858
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.005379278212785721,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "atomic_structured_expr_bitand_x_assign.c": [
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/atomic_structured_expr_bitand_x_assign.c/atomic_structured_expr_bitand_x_assign.c0 /home/exouser/Testsuite/Tests/atomic_structured_expr_bitand_x_assign.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/atomic_structured_expr_bitand_x_assign.c\", line 67: error: extra text after expected end of preprocessing directive\n                  #pragma acc atomic update capture\n                                            ^\n\n\"/home/exouser/Testsuite/Tests/atomic_structured_expr_bitand_x_assign.c\", line 41: warning: variable \"iterator\" was declared but never referenced\n      int iterator;\n          ^\n\n\"/home/exouser/Testsuite/Tests/atomic_structured_expr_bitand_x_assign.c\", line 42: warning: variable \"iterator2\" was declared but never referenced\n      int iterator2;\n          ^\n\n\"/home/exouser/Testsuite/Tests/atomic_structured_expr_bitand_x_assign.c\", line 106: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n1 error detected in the compilation of \"/home/exouser/Testsuite/Tests/atomic_structured_expr_bitand_x_assign.c\".\n",
                    "export": false,
                    "output": "",
                    "result": 2,
                    "runtime": 0.06651759892702103
                },
                "post-compile commands": [],
                "pre-compile commands": [],
                "runtime": {
                    "export": false,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -DT1 -o /home/exouser/Testsuite/build/atomic_structured_expr_bitand_x_assign.c/atomic_structured_expr_bitand_x_assign.c1 /home/exouser/Testsuite/Tests/atomic_structured_expr_bitand_x_assign.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/atomic_structured_expr_bitand_x_assign.c\", line 106: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n\"/home/exouser/Testsuite/Tests/atomic_structured_expr_bitand_x_assign.c\", line 107: warning: variable \"failed\" was declared but never referenced\n      int failed;\n          ^\n\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.21680030366405845
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.005351347383111715,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "atomic_structured_expr_bitor_x_assign.c": [
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/atomic_structured_expr_bitor_x_assign.c/atomic_structured_expr_bitor_x_assign.c0 /home/exouser/Testsuite/Tests/atomic_structured_expr_bitor_x_assign.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/atomic_structured_expr_bitor_x_assign.c\", line 67: error: extra text after expected end of preprocessing directive\n                  #pragma acc atomic update capture\n                                            ^\n\n\"/home/exouser/Testsuite/Tests/atomic_structured_expr_bitor_x_assign.c\", line 41: warning: variable \"iterator\" was declared but never referenced\n      int iterator;\n          ^\n\n\"/home/exouser/Testsuite/Tests/atomic_structured_expr_bitor_x_assign.c\", line 42: warning: variable \"iterator2\" was declared but never referenced\n      int iterator2;\n          ^\n\n\"/home/exouser/Testsuite/Tests/atomic_structured_expr_bitor_x_assign.c\", line 106: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n1 error detected in the compilation of \"/home/exouser/Testsuite/Tests/atomic_structured_expr_bitor_x_assign.c\".\n",
                    "export": false,
                    "output": "",
                    "result": 2,
                    "runtime": 0.06651209993287921
                },
                "post-compile commands": [],
                "pre-compile commands": [],
                "runtime": {
                    "export": false,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -DT1 -o /home/exouser/Testsuite/build/atomic_structured_expr_bitor_x_assign.c/atomic_structured_expr_bitor_x_assign.c1 /home/exouser/Testsuite/Tests/atomic_structured_expr_bitor_x_assign.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/atomic_structured_expr_bitor_x_assign.c\", line 106: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n\"/home/exouser/Testsuite/Tests/atomic_structured_expr_bitor_x_assign.c\", line 107: warning: variable \"failed\" was declared but never referenced\n      int failed;\n          ^\n\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.21666537690907717
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.005661732982844114,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "atomic_structured_expr_bitxor_x_assign.c": [
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/atomic_structured_expr_bitxor_x_assign.c/atomic_structured_expr_bitxor_x_assign.c0 /home/exouser/Testsuite/Tests/atomic_structured_expr_bitxor_x_assign.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/atomic_structured_expr_bitxor_x_assign.c\", line 68: error: extra text after expected end of preprocessing directive\n                  #pragma acc atomic update capture\n                                            ^\n\n\"/home/exouser/Testsuite/Tests/atomic_structured_expr_bitxor_x_assign.c\", line 41: warning: variable \"iterator\" was declared but never referenced\n      int iterator;\n          ^\n\n\"/home/exouser/Testsuite/Tests/atomic_structured_expr_bitxor_x_assign.c\", line 42: warning: variable \"iterator2\" was declared but never referenced\n      int iterator2;\n          ^\n\n\"/home/exouser/Testsuite/Tests/atomic_structured_expr_bitxor_x_assign.c\", line 106: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n1 error detected in the compilation of \"/home/exouser/Testsuite/Tests/atomic_structured_expr_bitxor_x_assign.c\".\n",
                    "export": false,
                    "output": "",
                    "result": 2,
                    "runtime": 0.06631483789533377
                },
                "post-compile commands": [],
                "pre-compile commands": [],
                "runtime": {
                    "export": false,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -DT1 -o /home/exouser/Testsuite/build/atomic_structured_expr_bitxor_x_assign.c/atomic_structured_expr_bitxor_x_assign.c1 /home/exouser/Testsuite/Tests/atomic_structured_expr_bitxor_x_assign.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/atomic_structured_expr_bitxor_x_assign.c\", line 106: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n\"/home/exouser/Testsuite/Tests/atomic_structured_expr_bitxor_x_assign.c\", line 107: warning: variable \"failed\" was declared but never referenced\n      int failed;\n          ^\n\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.21730539109557867
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.005456448066979647,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "atomic_structured_expr_multiply_x_assign.c": [
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/atomic_structured_expr_multiply_x_assign.c/atomic_structured_expr_multiply_x_assign.c0 /home/exouser/Testsuite/Tests/atomic_structured_expr_multiply_x_assign.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/atomic_structured_expr_multiply_x_assign.c\", line 60: error: extra text after expected end of preprocessing directive\n                  #pragma acc atomic update capture\n                                            ^\n\n\"/home/exouser/Testsuite/Tests/atomic_structured_expr_multiply_x_assign.c\", line 95: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n1 error detected in the compilation of \"/home/exouser/Testsuite/Tests/atomic_structured_expr_multiply_x_assign.c\".\n",
                    "export": false,
                    "output": "",
                    "result": 2,
                    "runtime": 0.06641232082620263
                },
                "post-compile commands": [],
                "pre-compile commands": [],
                "runtime": {
                    "export": false,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -DT1 -o /home/exouser/Testsuite/build/atomic_structured_expr_multiply_x_assign.c/atomic_structured_expr_multiply_x_assign.c1 /home/exouser/Testsuite/Tests/atomic_structured_expr_multiply_x_assign.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/atomic_structured_expr_multiply_x_assign.c\", line 95: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n\"/home/exouser/Testsuite/Tests/atomic_structured_expr_multiply_x_assign.c\", line 96: warning: variable \"failed\" was declared but never referenced\n      int failed;\n          ^\n\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.21697844099253416
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.009004217572510242,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "atomic_structured_expr_plus_x_assign.c": [
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/atomic_structured_expr_plus_x_assign.c/atomic_structured_expr_plus_x_assign.c0 /home/exouser/Testsuite/Tests/atomic_structured_expr_plus_x_assign.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/atomic_structured_expr_plus_x_assign.c\", line 60: error: extra text after expected end of preprocessing directive\n                  #pragma acc atomic update capture\n                                            ^\n\n\"/home/exouser/Testsuite/Tests/atomic_structured_expr_plus_x_assign.c\", line 95: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n1 error detected in the compilation of \"/home/exouser/Testsuite/Tests/atomic_structured_expr_plus_x_assign.c\".\n",
                    "export": false,
                    "output": "",
                    "result": 2,
                    "runtime": 0.06578098703175783
                },
                "post-compile commands": [],
                "pre-compile commands": [],
                "runtime": {
                    "export": false,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -DT1 -o /home/exouser/Testsuite/build/atomic_structured_expr_plus_x_assign.c/atomic_structured_expr_plus_x_assign.c1 /home/exouser/Testsuite/Tests/atomic_structured_expr_plus_x_assign.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/atomic_structured_expr_plus_x_assign.c\", line 95: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n\"/home/exouser/Testsuite/Tests/atomic_structured_expr_plus_x_assign.c\", line 96: warning: variable \"failed\" was declared but never referenced\n      int failed;\n          ^\n\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.2161110993474722
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.004922152031213045,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "atomic_structured_lshift_equals_assign.c": [
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/atomic_structured_lshift_equals_assign.c/atomic_structured_lshift_equals_assign.c0 /home/exouser/Testsuite/Tests/atomic_structured_lshift_equals_assign.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/atomic_structured_lshift_equals_assign.c\", line 61: error: extra text after expected end of preprocessing directive\n                          #pragma acc atomic update capture\n                                                    ^\n\n\"/home/exouser/Testsuite/Tests/atomic_structured_lshift_equals_assign.c\", line 95: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n1 error detected in the compilation of \"/home/exouser/Testsuite/Tests/atomic_structured_lshift_equals_assign.c\".\n",
                    "export": false,
                    "output": "",
                    "result": 2,
                    "runtime": 0.06661767605692148
                },
                "post-compile commands": [],
                "pre-compile commands": [],
                "runtime": {
                    "export": false,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -DT1 -o /home/exouser/Testsuite/build/atomic_structured_lshift_equals_assign.c/atomic_structured_lshift_equals_assign.c1 /home/exouser/Testsuite/Tests/atomic_structured_lshift_equals_assign.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/atomic_structured_lshift_equals_assign.c\", line 95: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n\"/home/exouser/Testsuite/Tests/atomic_structured_lshift_equals_assign.c\", line 96: warning: variable \"failed\" was declared but never referenced\n      int failed;\n          ^\n\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.166498189792037
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.004877896048128605,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "atomic_structured_minus_equals_assign.c": [
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/atomic_structured_minus_equals_assign.c/atomic_structured_minus_equals_assign.c0 /home/exouser/Testsuite/Tests/atomic_structured_minus_equals_assign.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/atomic_structured_minus_equals_assign.c\", line 59: error: extra text after expected end of preprocessing directive\n                  #pragma acc atomic update capture\n                                            ^\n\n\"/home/exouser/Testsuite/Tests/atomic_structured_minus_equals_assign.c\", line 93: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n1 error detected in the compilation of \"/home/exouser/Testsuite/Tests/atomic_structured_minus_equals_assign.c\".\n",
                    "export": false,
                    "output": "",
                    "result": 2,
                    "runtime": 0.06605387525632977
                },
                "post-compile commands": [],
                "pre-compile commands": [],
                "runtime": {
                    "export": false,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -DT1 -o /home/exouser/Testsuite/build/atomic_structured_minus_equals_assign.c/atomic_structured_minus_equals_assign.c1 /home/exouser/Testsuite/Tests/atomic_structured_minus_equals_assign.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/atomic_structured_minus_equals_assign.c\", line 93: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n\"/home/exouser/Testsuite/Tests/atomic_structured_minus_equals_assign.c\", line 94: warning: variable \"failed\" was declared but never referenced\n      int failed;\n          ^\n\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.21703301602974534
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.009423003997653723,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "atomic_structured_multiply_equals_assign.c": [
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/atomic_structured_multiply_equals_assign.c/atomic_structured_multiply_equals_assign.c0 /home/exouser/Testsuite/Tests/atomic_structured_multiply_equals_assign.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/atomic_structured_multiply_equals_assign.c\", line 60: error: extra text after expected end of preprocessing directive\n                  #pragma acc atomic update capture\n                                            ^\n\n\"/home/exouser/Testsuite/Tests/atomic_structured_multiply_equals_assign.c\", line 95: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n1 error detected in the compilation of \"/home/exouser/Testsuite/Tests/atomic_structured_multiply_equals_assign.c\".\n",
                    "export": false,
                    "output": "",
                    "result": 2,
                    "runtime": 0.06691770115867257
                },
                "post-compile commands": [],
                "pre-compile commands": [],
                "runtime": {
                    "export": false,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -DT1 -o /home/exouser/Testsuite/build/atomic_structured_multiply_equals_assign.c/atomic_structured_multiply_equals_assign.c1 /home/exouser/Testsuite/Tests/atomic_structured_multiply_equals_assign.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/atomic_structured_multiply_equals_assign.c\", line 95: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n\"/home/exouser/Testsuite/Tests/atomic_structured_multiply_equals_assign.c\", line 96: warning: variable \"failed\" was declared but never referenced\n      int failed;\n          ^\n\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.21735289273783565
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.0098138521425426,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "atomic_structured_plus_equals_assign.c": [
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/atomic_structured_plus_equals_assign.c/atomic_structured_plus_equals_assign.c0 /home/exouser/Testsuite/Tests/atomic_structured_plus_equals_assign.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/atomic_structured_plus_equals_assign.c\", line 61: error: extra text after expected end of preprocessing directive\n                  #pragma acc atomic update capture\n                                            ^\n\n\"/home/exouser/Testsuite/Tests/atomic_structured_plus_equals_assign.c\", line 96: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n1 error detected in the compilation of \"/home/exouser/Testsuite/Tests/atomic_structured_plus_equals_assign.c\".\n",
                    "export": false,
                    "output": "",
                    "result": 2,
                    "runtime": 0.0669734850525856
                },
                "post-compile commands": [],
                "pre-compile commands": [],
                "runtime": {
                    "export": false,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -DT1 -o /home/exouser/Testsuite/build/atomic_structured_plus_equals_assign.c/atomic_structured_plus_equals_assign.c1 /home/exouser/Testsuite/Tests/atomic_structured_plus_equals_assign.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/atomic_structured_plus_equals_assign.c\", line 96: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n\"/home/exouser/Testsuite/Tests/atomic_structured_plus_equals_assign.c\", line 97: warning: variable \"failed\" was declared but never referenced\n      int failed;\n          ^\n\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.21682381303980947
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.009824789129197598,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "atomic_structured_postdecrement_assign.c": [
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/atomic_structured_postdecrement_assign.c/atomic_structured_postdecrement_assign.c0 /home/exouser/Testsuite/Tests/atomic_structured_postdecrement_assign.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/atomic_structured_postdecrement_assign.c\", line 29: error: extra text after expected end of preprocessing directive\n                  #pragma acc atomic update capture\n                                            ^\n\n\"/home/exouser/Testsuite/Tests/atomic_structured_postdecrement_assign.c\", line 69: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n1 error detected in the compilation of \"/home/exouser/Testsuite/Tests/atomic_structured_postdecrement_assign.c\".\n",
                    "export": false,
                    "output": "",
                    "result": 2,
                    "runtime": 0.06590777402743697
                },
                "post-compile commands": [],
                "pre-compile commands": [],
                "runtime": {
                    "export": false,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -DT1 -o /home/exouser/Testsuite/build/atomic_structured_postdecrement_assign.c/atomic_structured_postdecrement_assign.c1 /home/exouser/Testsuite/Tests/atomic_structured_postdecrement_assign.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/atomic_structured_postdecrement_assign.c\", line 69: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n\"/home/exouser/Testsuite/Tests/atomic_structured_postdecrement_assign.c\", line 70: warning: variable \"failed\" was declared but never referenced\n      int failed;\n          ^\n\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.16610206803306937
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.004634813871234655,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "atomic_structured_postincrement_assign.c": [
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/atomic_structured_postincrement_assign.c/atomic_structured_postincrement_assign.c0 /home/exouser/Testsuite/Tests/atomic_structured_postincrement_assign.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/atomic_structured_postincrement_assign.c\", line 29: error: extra text after expected end of preprocessing directive\n                  #pragma acc atomic update capture\n                                            ^\n\n\"/home/exouser/Testsuite/Tests/atomic_structured_postincrement_assign.c\", line 69: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n1 error detected in the compilation of \"/home/exouser/Testsuite/Tests/atomic_structured_postincrement_assign.c\".\n",
                    "export": false,
                    "output": "",
                    "result": 2,
                    "runtime": 0.0662137889303267
                },
                "post-compile commands": [],
                "pre-compile commands": [],
                "runtime": {
                    "export": false,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -DT1 -o /home/exouser/Testsuite/build/atomic_structured_postincrement_assign.c/atomic_structured_postincrement_assign.c1 /home/exouser/Testsuite/Tests/atomic_structured_postincrement_assign.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/atomic_structured_postincrement_assign.c\", line 69: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n\"/home/exouser/Testsuite/Tests/atomic_structured_postincrement_assign.c\", line 70: warning: variable \"failed\" was declared but never referenced\n      int failed;\n          ^\n\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.1666884757578373
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.00570223294198513,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "atomic_structured_predecrement_assign.c": [
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/atomic_structured_predecrement_assign.c/atomic_structured_predecrement_assign.c0 /home/exouser/Testsuite/Tests/atomic_structured_predecrement_assign.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/atomic_structured_predecrement_assign.c\", line 29: error: extra text after expected end of preprocessing directive\n                  #pragma acc atomic update capture\n                                            ^\n\n\"/home/exouser/Testsuite/Tests/atomic_structured_predecrement_assign.c\", line 69: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n1 error detected in the compilation of \"/home/exouser/Testsuite/Tests/atomic_structured_predecrement_assign.c\".\n",
                    "export": false,
                    "output": "",
                    "result": 2,
                    "runtime": 0.0669164047576487
                },
                "post-compile commands": [],
                "pre-compile commands": [],
                "runtime": {
                    "export": false,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -DT1 -o /home/exouser/Testsuite/build/atomic_structured_predecrement_assign.c/atomic_structured_predecrement_assign.c1 /home/exouser/Testsuite/Tests/atomic_structured_predecrement_assign.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/atomic_structured_predecrement_assign.c\", line 69: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n\"/home/exouser/Testsuite/Tests/atomic_structured_predecrement_assign.c\", line 70: warning: variable \"failed\" was declared but never referenced\n      int failed;\n          ^\n\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.1174654639326036
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.006225429940968752,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "atomic_structured_preincrement_assign.c": [
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/atomic_structured_preincrement_assign.c/atomic_structured_preincrement_assign.c0 /home/exouser/Testsuite/Tests/atomic_structured_preincrement_assign.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/atomic_structured_preincrement_assign.c\", line 29: error: extra text after expected end of preprocessing directive\n                  #pragma acc atomic update capture\n                                            ^\n\n\"/home/exouser/Testsuite/Tests/atomic_structured_preincrement_assign.c\", line 69: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n1 error detected in the compilation of \"/home/exouser/Testsuite/Tests/atomic_structured_preincrement_assign.c\".\n",
                    "export": false,
                    "output": "",
                    "result": 2,
                    "runtime": 0.06693585077300668
                },
                "post-compile commands": [],
                "pre-compile commands": [],
                "runtime": {
                    "export": false,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -DT1 -o /home/exouser/Testsuite/build/atomic_structured_preincrement_assign.c/atomic_structured_preincrement_assign.c1 /home/exouser/Testsuite/Tests/atomic_structured_preincrement_assign.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/atomic_structured_preincrement_assign.c\", line 69: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n\"/home/exouser/Testsuite/Tests/atomic_structured_preincrement_assign.c\", line 70: warning: variable \"failed\" was declared but never referenced\n      int failed;\n          ^\n\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.11699663801118731
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.006105903070420027,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "atomic_structured_rshift_equals_assign.c": [
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/atomic_structured_rshift_equals_assign.c/atomic_structured_rshift_equals_assign.c0 /home/exouser/Testsuite/Tests/atomic_structured_rshift_equals_assign.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/atomic_structured_rshift_equals_assign.c\", line 61: error: extra text after expected end of preprocessing directive\n                          #pragma acc atomic update capture\n                                                    ^\n\n\"/home/exouser/Testsuite/Tests/atomic_structured_rshift_equals_assign.c\", line 95: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n1 error detected in the compilation of \"/home/exouser/Testsuite/Tests/atomic_structured_rshift_equals_assign.c\".\n",
                    "export": false,
                    "output": "",
                    "result": 2,
                    "runtime": 0.06712963711470366
                },
                "post-compile commands": [],
                "pre-compile commands": [],
                "runtime": {
                    "export": false,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -DT1 -o /home/exouser/Testsuite/build/atomic_structured_rshift_equals_assign.c/atomic_structured_rshift_equals_assign.c1 /home/exouser/Testsuite/Tests/atomic_structured_rshift_equals_assign.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/atomic_structured_rshift_equals_assign.c\", line 95: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n\"/home/exouser/Testsuite/Tests/atomic_structured_rshift_equals_assign.c\", line 96: warning: variable \"failed\" was declared but never referenced\n      int failed;\n          ^\n\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.1666064760647714
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.0047747171483933926,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "atomic_structured_x_bitand_expr_assign.c": [
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/atomic_structured_x_bitand_expr_assign.c/atomic_structured_x_bitand_expr_assign.c0 /home/exouser/Testsuite/Tests/atomic_structured_x_bitand_expr_assign.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/atomic_structured_x_bitand_expr_assign.c\", line 10: error: expression must have integral type\n          if (b[x] == (prev & a[x])){\n                       ^\n\n\"/home/exouser/Testsuite/Tests/atomic_structured_x_bitand_expr_assign.c\", line 10: error: expression must have integral type\n          if (b[x] == (prev & a[x])){\n                              ^\n\n\"/home/exouser/Testsuite/Tests/atomic_structured_x_bitand_expr_assign.c\", line 19: warning: argument of type \"int *\" is incompatible with parameter of type \"real_t *\"\n              if (is_possible(passed_a, passed_b, length - 1, b[x])){\n                              ^\n\n\"/home/exouser/Testsuite/Tests/atomic_structured_x_bitand_expr_assign.c\", line 19: warning: argument of type \"int *\" is incompatible with parameter of type \"real_t *\"\n              if (is_possible(passed_a, passed_b, length - 1, b[x])){\n                                        ^\n\n\"/home/exouser/Testsuite/Tests/atomic_structured_x_bitand_expr_assign.c\", line 68: error: extra text after expected end of preprocessing directive\n                  #pragma acc atomic update capture\n                                            ^\n\n\"/home/exouser/Testsuite/Tests/atomic_structured_x_bitand_expr_assign.c\", line 96: warning: argument of type \"int *\" is incompatible with parameter of type \"real_t *\"\n          if (!is_possible(temp_a, temp_b, y - x, init)){\n                           ^\n\n\"/home/exouser/Testsuite/Tests/atomic_structured_x_bitand_expr_assign.c\", line 96: warning: argument of type \"int *\" is incompatible with parameter of type \"real_t *\"\n          if (!is_possible(temp_a, temp_b, y - x, init)){\n                                   ^\n\n\"/home/exouser/Testsuite/Tests/atomic_structured_x_bitand_expr_assign.c\", line 42: warning: variable \"iterator\" was declared but never referenced\n      int iterator;\n          ^\n\n\"/home/exouser/Testsuite/Tests/atomic_structured_x_bitand_expr_assign.c\", line 43: warning: variable \"iterator2\" was declared but never referenced\n      int iterator2;\n          ^\n\n\"/home/exouser/Testsuite/Tests/atomic_structured_x_bitand_expr_assign.c\", line 107: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n3 errors detected in the compilation of \"/home/exouser/Testsuite/Tests/atomic_structured_x_bitand_expr_assign.c\".\n",
                    "export": false,
                    "output": "",
                    "result": 2,
                    "runtime": 0.06634183181449771
                },
                "post-compile commands": [],
                "pre-compile commands": [],
                "runtime": {
                    "export": false,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -DT1 -o /home/exouser/Testsuite/build/atomic_structured_x_bitand_expr_assign.c/atomic_structured_x_bitand_expr_assign.c1 /home/exouser/Testsuite/Tests/atomic_structured_x_bitand_expr_assign.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/atomic_structured_x_bitand_expr_assign.c\", line 10: error: expression must have integral type\n          if (b[x] == (prev & a[x])){\n                       ^\n\n\"/home/exouser/Testsuite/Tests/atomic_structured_x_bitand_expr_assign.c\", line 10: error: expression must have integral type\n          if (b[x] == (prev & a[x])){\n                              ^\n\n\"/home/exouser/Testsuite/Tests/atomic_structured_x_bitand_expr_assign.c\", line 19: warning: argument of type \"int *\" is incompatible with parameter of type \"real_t *\"\n              if (is_possible(passed_a, passed_b, length - 1, b[x])){\n                              ^\n\n\"/home/exouser/Testsuite/Tests/atomic_structured_x_bitand_expr_assign.c\", line 19: warning: argument of type \"int *\" is incompatible with parameter of type \"real_t *\"\n              if (is_possible(passed_a, passed_b, length - 1, b[x])){\n                                        ^\n\n\"/home/exouser/Testsuite/Tests/atomic_structured_x_bitand_expr_assign.c\", line 107: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n\"/home/exouser/Testsuite/Tests/atomic_structured_x_bitand_expr_assign.c\", line 108: warning: variable \"failed\" was declared but never referenced\n      int failed;\n          ^\n\n2 errors detected in the compilation of \"/home/exouser/Testsuite/Tests/atomic_structured_x_bitand_expr_assign.c\".\n",
                    "export": true,
                    "output": "",
                    "result": 2,
                    "runtime": 0.06622447678819299
                },
                "post-compile commands": [],
                "pre-compile commands": [],
                "runtime": {
                    "export": true,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "atomic_structured_x_bitor_expr_assign.c": [
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/atomic_structured_x_bitor_expr_assign.c/atomic_structured_x_bitor_expr_assign.c0 /home/exouser/Testsuite/Tests/atomic_structured_x_bitor_expr_assign.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/atomic_structured_x_bitor_expr_assign.c\", line 67: error: extra text after expected end of preprocessing directive\n                  #pragma acc atomic update capture\n                                            ^\n\n\"/home/exouser/Testsuite/Tests/atomic_structured_x_bitor_expr_assign.c\", line 41: warning: variable \"iterator\" was declared but never referenced\n      int iterator;\n          ^\n\n\"/home/exouser/Testsuite/Tests/atomic_structured_x_bitor_expr_assign.c\", line 42: warning: variable \"iterator2\" was declared but never referenced\n      int iterator2;\n          ^\n\n\"/home/exouser/Testsuite/Tests/atomic_structured_x_bitor_expr_assign.c\", line 106: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n1 error detected in the compilation of \"/home/exouser/Testsuite/Tests/atomic_structured_x_bitor_expr_assign.c\".\n",
                    "export": false,
                    "output": "",
                    "result": 2,
                    "runtime": 0.06651120306923985
                },
                "post-compile commands": [],
                "pre-compile commands": [],
                "runtime": {
                    "export": false,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -DT1 -o /home/exouser/Testsuite/build/atomic_structured_x_bitor_expr_assign.c/atomic_structured_x_bitor_expr_assign.c1 /home/exouser/Testsuite/Tests/atomic_structured_x_bitor_expr_assign.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/atomic_structured_x_bitor_expr_assign.c\", line 106: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n\"/home/exouser/Testsuite/Tests/atomic_structured_x_bitor_expr_assign.c\", line 107: warning: variable \"failed\" was declared but never referenced\n      int failed;\n          ^\n\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.21691267797723413
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.004825840704143047,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "atomic_structured_x_bitxor_expr_assign.c": [
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/atomic_structured_x_bitxor_expr_assign.c/atomic_structured_x_bitxor_expr_assign.c0 /home/exouser/Testsuite/Tests/atomic_structured_x_bitxor_expr_assign.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/atomic_structured_x_bitxor_expr_assign.c\", line 67: error: extra text after expected end of preprocessing directive\n                  #pragma acc atomic update capture\n                                            ^\n\n\"/home/exouser/Testsuite/Tests/atomic_structured_x_bitxor_expr_assign.c\", line 41: warning: variable \"iterator\" was declared but never referenced\n      int iterator;\n          ^\n\n\"/home/exouser/Testsuite/Tests/atomic_structured_x_bitxor_expr_assign.c\", line 42: warning: variable \"iterator2\" was declared but never referenced\n      int iterator2;\n          ^\n\n\"/home/exouser/Testsuite/Tests/atomic_structured_x_bitxor_expr_assign.c\", line 106: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n1 error detected in the compilation of \"/home/exouser/Testsuite/Tests/atomic_structured_x_bitxor_expr_assign.c\".\n",
                    "export": false,
                    "output": "",
                    "result": 2,
                    "runtime": 0.06625169515609741
                },
                "post-compile commands": [],
                "pre-compile commands": [],
                "runtime": {
                    "export": false,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -DT1 -o /home/exouser/Testsuite/build/atomic_structured_x_bitxor_expr_assign.c/atomic_structured_x_bitxor_expr_assign.c1 /home/exouser/Testsuite/Tests/atomic_structured_x_bitxor_expr_assign.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/atomic_structured_x_bitxor_expr_assign.c\", line 106: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n\"/home/exouser/Testsuite/Tests/atomic_structured_x_bitxor_expr_assign.c\", line 107: warning: variable \"failed\" was declared but never referenced\n      int failed;\n          ^\n\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.21699012909084558
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.004928289912641048,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "atomic_structured_x_divided_expr_assign.c": [
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/atomic_structured_x_divided_expr_assign.c/atomic_structured_x_divided_expr_assign.c0 /home/exouser/Testsuite/Tests/atomic_structured_x_divided_expr_assign.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/atomic_structured_x_divided_expr_assign.c\", line 67: error: extra text after expected end of preprocessing directive\n                  #pragma acc atomic update capture\n                                            ^\n\n\"/home/exouser/Testsuite/Tests/atomic_structured_x_divided_expr_assign.c\", line 105: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n1 error detected in the compilation of \"/home/exouser/Testsuite/Tests/atomic_structured_x_divided_expr_assign.c\".\n",
                    "export": false,
                    "output": "",
                    "result": 2,
                    "runtime": 0.06701211910694838
                },
                "post-compile commands": [],
                "pre-compile commands": [],
                "runtime": {
                    "export": false,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -DT1 -o /home/exouser/Testsuite/build/atomic_structured_x_divided_expr_assign.c/atomic_structured_x_divided_expr_assign.c1 /home/exouser/Testsuite/Tests/atomic_structured_x_divided_expr_assign.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/atomic_structured_x_divided_expr_assign.c\", line 105: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n\"/home/exouser/Testsuite/Tests/atomic_structured_x_divided_expr_assign.c\", line 106: warning: variable \"failed\" was declared but never referenced\n      int failed;\n          ^\n\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.16636149305850267
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.004828276112675667,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "atomic_structured_x_lshift_expr_assign.c": [
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/atomic_structured_x_lshift_expr_assign.c/atomic_structured_x_lshift_expr_assign.c0 /home/exouser/Testsuite/Tests/atomic_structured_x_lshift_expr_assign.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/atomic_structured_x_lshift_expr_assign.c\", line 61: error: extra text after expected end of preprocessing directive\n                          #pragma acc atomic update capture\n                                                    ^\n\n\"/home/exouser/Testsuite/Tests/atomic_structured_x_lshift_expr_assign.c\", line 95: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n1 error detected in the compilation of \"/home/exouser/Testsuite/Tests/atomic_structured_x_lshift_expr_assign.c\".\n",
                    "export": false,
                    "output": "",
                    "result": 2,
                    "runtime": 0.06582917599007487
                },
                "post-compile commands": [],
                "pre-compile commands": [],
                "runtime": {
                    "export": false,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -DT1 -o /home/exouser/Testsuite/build/atomic_structured_x_lshift_expr_assign.c/atomic_structured_x_lshift_expr_assign.c1 /home/exouser/Testsuite/Tests/atomic_structured_x_lshift_expr_assign.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/atomic_structured_x_lshift_expr_assign.c\", line 95: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n\"/home/exouser/Testsuite/Tests/atomic_structured_x_lshift_expr_assign.c\", line 96: warning: variable \"failed\" was declared but never referenced\n      int failed;\n          ^\n\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.16598006105050445
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.005135223735123873,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "atomic_structured_x_minus_expr_assign.c": [
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/atomic_structured_x_minus_expr_assign.c/atomic_structured_x_minus_expr_assign.c0 /home/exouser/Testsuite/Tests/atomic_structured_x_minus_expr_assign.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/atomic_structured_x_minus_expr_assign.c\", line 59: error: extra text after expected end of preprocessing directive\n                  #pragma acc atomic update capture\n                                            ^\n\n\"/home/exouser/Testsuite/Tests/atomic_structured_x_minus_expr_assign.c\", line 93: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n1 error detected in the compilation of \"/home/exouser/Testsuite/Tests/atomic_structured_x_minus_expr_assign.c\".\n",
                    "export": false,
                    "output": "",
                    "result": 2,
                    "runtime": 0.06650521513074636
                },
                "post-compile commands": [],
                "pre-compile commands": [],
                "runtime": {
                    "export": false,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -DT1 -o /home/exouser/Testsuite/build/atomic_structured_x_minus_expr_assign.c/atomic_structured_x_minus_expr_assign.c1 /home/exouser/Testsuite/Tests/atomic_structured_x_minus_expr_assign.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/atomic_structured_x_minus_expr_assign.c\", line 93: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n\"/home/exouser/Testsuite/Tests/atomic_structured_x_minus_expr_assign.c\", line 94: warning: variable \"failed\" was declared but never referenced\n      int failed;\n          ^\n\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.21728032920509577
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.005560248624533415,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "atomic_structured_x_multiply_expr_assign.c": [
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/atomic_structured_x_multiply_expr_assign.c/atomic_structured_x_multiply_expr_assign.c0 /home/exouser/Testsuite/Tests/atomic_structured_x_multiply_expr_assign.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/atomic_structured_x_multiply_expr_assign.c\", line 60: error: extra text after expected end of preprocessing directive\n                  #pragma acc atomic update capture\n                                            ^\n\n\"/home/exouser/Testsuite/Tests/atomic_structured_x_multiply_expr_assign.c\", line 95: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n1 error detected in the compilation of \"/home/exouser/Testsuite/Tests/atomic_structured_x_multiply_expr_assign.c\".\n",
                    "export": false,
                    "output": "",
                    "result": 2,
                    "runtime": 0.06651528924703598
                },
                "post-compile commands": [],
                "pre-compile commands": [],
                "runtime": {
                    "export": false,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -DT1 -o /home/exouser/Testsuite/build/atomic_structured_x_multiply_expr_assign.c/atomic_structured_x_multiply_expr_assign.c1 /home/exouser/Testsuite/Tests/atomic_structured_x_multiply_expr_assign.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/atomic_structured_x_multiply_expr_assign.c\", line 95: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n\"/home/exouser/Testsuite/Tests/atomic_structured_x_multiply_expr_assign.c\", line 96: warning: variable \"failed\" was declared but never referenced\n      int failed;\n          ^\n\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.21707257628440857
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.005502151325345039,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "atomic_structured_x_plus_expr_assign.c": [
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/atomic_structured_x_plus_expr_assign.c/atomic_structured_x_plus_expr_assign.c0 /home/exouser/Testsuite/Tests/atomic_structured_x_plus_expr_assign.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/atomic_structured_x_plus_expr_assign.c\", line 60: error: extra text after expected end of preprocessing directive\n                  #pragma acc atomic update capture\n                                            ^\n\n\"/home/exouser/Testsuite/Tests/atomic_structured_x_plus_expr_assign.c\", line 95: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n1 error detected in the compilation of \"/home/exouser/Testsuite/Tests/atomic_structured_x_plus_expr_assign.c\".\n",
                    "export": false,
                    "output": "",
                    "result": 2,
                    "runtime": 0.06647373409941792
                },
                "post-compile commands": [],
                "pre-compile commands": [],
                "runtime": {
                    "export": false,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -DT1 -o /home/exouser/Testsuite/build/atomic_structured_x_plus_expr_assign.c/atomic_structured_x_plus_expr_assign.c1 /home/exouser/Testsuite/Tests/atomic_structured_x_plus_expr_assign.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/atomic_structured_x_plus_expr_assign.c\", line 95: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n\"/home/exouser/Testsuite/Tests/atomic_structured_x_plus_expr_assign.c\", line 96: warning: variable \"failed\" was declared but never referenced\n      int failed;\n          ^\n\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.21790660684928298
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.005096953362226486,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "atomic_structured_x_rshift_expr_assign.c": [
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/atomic_structured_x_rshift_expr_assign.c/atomic_structured_x_rshift_expr_assign.c0 /home/exouser/Testsuite/Tests/atomic_structured_x_rshift_expr_assign.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/atomic_structured_x_rshift_expr_assign.c\", line 61: error: extra text after expected end of preprocessing directive\n                          #pragma acc atomic update capture\n                                                    ^\n\n\"/home/exouser/Testsuite/Tests/atomic_structured_x_rshift_expr_assign.c\", line 95: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n1 error detected in the compilation of \"/home/exouser/Testsuite/Tests/atomic_structured_x_rshift_expr_assign.c\".\n",
                    "export": false,
                    "output": "",
                    "result": 2,
                    "runtime": 0.06591187277808785
                },
                "post-compile commands": [],
                "pre-compile commands": [],
                "runtime": {
                    "export": false,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -DT1 -o /home/exouser/Testsuite/build/atomic_structured_x_rshift_expr_assign.c/atomic_structured_x_rshift_expr_assign.c1 /home/exouser/Testsuite/Tests/atomic_structured_x_rshift_expr_assign.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/atomic_structured_x_rshift_expr_assign.c\", line 95: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n\"/home/exouser/Testsuite/Tests/atomic_structured_x_rshift_expr_assign.c\", line 96: warning: variable \"failed\" was declared but never referenced\n      int failed;\n          ^\n\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.21712248399853706
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.005095204338431358,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "atomic_update_bitand_equals.c": [
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/atomic_update_bitand_equals.c/atomic_update_bitand_equals.c0 /home/exouser/Testsuite/Tests/atomic_update_bitand_equals.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/atomic_update_bitand_equals.c\", line 54: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.16638052882626653
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.009688182268291712,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "atomic_update_bitor_equals.c": [
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/atomic_update_bitor_equals.c/atomic_update_bitor_equals.c0 /home/exouser/Testsuite/Tests/atomic_update_bitor_equals.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/atomic_update_bitor_equals.c\", line 51: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.16668230714276433
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.010005302727222443,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "atomic_update_bitxor_equals.c": [
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/atomic_update_bitxor_equals.c/atomic_update_bitxor_equals.c0 /home/exouser/Testsuite/Tests/atomic_update_bitxor_equals.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/atomic_update_bitxor_equals.c\", line 51: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.21734199533239007
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.009508522227406502,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "atomic_update_divided_equals.c": [
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/atomic_update_divided_equals.c/atomic_update_divided_equals.c0 /home/exouser/Testsuite/Tests/atomic_update_divided_equals.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/atomic_update_divided_equals.c\", line 49: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.21574093215167522
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.009479290805757046,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "atomic_update_expr_and_x.F90": [
            {
                "compilation": {
                    "command": "nvfortran -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/atomic_update_expr_and_x.F90/atomic_update_expr_and_x.F900 /home/exouser/Testsuite/Tests/atomic_update_expr_and_x.F90",
                    "config": 1,
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.6292627779766917
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.12801423901692033,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "atomic_update_expr_and_x_end.F90": [
            {
                "compilation": {
                    "command": "nvfortran -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/atomic_update_expr_and_x_end.F90/atomic_update_expr_and_x_end.F900 /home/exouser/Testsuite/Tests/atomic_update_expr_and_x_end.F90",
                    "config": 1,
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.6306224232539535
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.0739883091300726,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "atomic_update_expr_bitand_x.c": [
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/atomic_update_expr_bitand_x.c/atomic_update_expr_bitand_x.c0 /home/exouser/Testsuite/Tests/atomic_update_expr_bitand_x.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/atomic_update_expr_bitand_x.c\", line 54: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.21710800705477595
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.008675165940076113,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "atomic_update_expr_bitor_x.c": [
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/atomic_update_expr_bitor_x.c/atomic_update_expr_bitor_x.c0 /home/exouser/Testsuite/Tests/atomic_update_expr_bitor_x.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/atomic_update_expr_bitor_x.c\", line 51: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.1661559953354299
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.009851506911218166,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "atomic_update_expr_bitxor_x.c": [
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/atomic_update_expr_bitxor_x.c/atomic_update_expr_bitxor_x.c0 /home/exouser/Testsuite/Tests/atomic_update_expr_bitxor_x.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/atomic_update_expr_bitxor_x.c\", line 51: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.21688182558864355
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.016884232871234417,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "atomic_update_expr_divided_x.F90": [
            {
                "compilation": {
                    "command": "nvfortran -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/atomic_update_expr_divided_x.F90/atomic_update_expr_divided_x.F900 /home/exouser/Testsuite/Tests/atomic_update_expr_divided_x.F90",
                    "config": 1,
                    "errors": "",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 0.4792866031639278
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "Failed to complete within timeout",
                    "export": false,
                    "output": "",
                    "result": -1,
                    "runtime": -1,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvfortran -fast -acc -ta=multicore -DT1 -o /home/exouser/Testsuite/build/atomic_update_expr_divided_x.F90/atomic_update_expr_divided_x.F901 /home/exouser/Testsuite/Tests/atomic_update_expr_divided_x.F90",
                    "config": 1,
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.42899607587605715
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.040768292266875505,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "atomic_update_expr_divided_x.c": [
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/atomic_update_expr_divided_x.c/atomic_update_expr_divided_x.c0 /home/exouser/Testsuite/Tests/atomic_update_expr_divided_x.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/atomic_update_expr_divided_x.c\", line 77: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.16672877501696348
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.009711153339594603,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "atomic_update_expr_divided_x_end.F90": [
            {
                "compilation": {
                    "command": "nvfortran -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/atomic_update_expr_divided_x_end.F90/atomic_update_expr_divided_x_end.F900 /home/exouser/Testsuite/Tests/atomic_update_expr_divided_x_end.F90",
                    "config": 1,
                    "errors": "",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 0.484347699675709
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "Failed to complete within timeout",
                    "export": false,
                    "output": "",
                    "result": -1,
                    "runtime": -1,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvfortran -fast -acc -ta=multicore -DT1 -o /home/exouser/Testsuite/build/atomic_update_expr_divided_x_end.F90/atomic_update_expr_divided_x_end.F901 /home/exouser/Testsuite/Tests/atomic_update_expr_divided_x_end.F90",
                    "config": 1,
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.43278623605147004
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.04484915407374501,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "atomic_update_expr_eqv_x.F90": [
            {
                "compilation": {
                    "command": "nvfortran -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/atomic_update_expr_eqv_x.F90/atomic_update_expr_eqv_x.F900 /home/exouser/Testsuite/Tests/atomic_update_expr_eqv_x.F90",
                    "config": 1,
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.6306205550208688
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.07314908411353827,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "atomic_update_expr_eqv_x_end.F90": [
            {
                "compilation": {
                    "command": "nvfortran -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/atomic_update_expr_eqv_x_end.F90/atomic_update_expr_eqv_x_end.F900 /home/exouser/Testsuite/Tests/atomic_update_expr_eqv_x_end.F90",
                    "config": 1,
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.630522957071662
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.12667811010032892,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "atomic_update_expr_lshift_x.c": [
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/atomic_update_expr_lshift_x.c/atomic_update_expr_lshift_x.c0 /home/exouser/Testsuite/Tests/atomic_update_expr_lshift_x.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/atomic_update_expr_lshift_x.c\", line 55: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n/tmp/nvcpgzgT1mO7aJq.o: In function `__nv_test1_F1L20_1':\n/home/exouser/Testsuite/Tests/atomic_update_expr_lshift_x.c:28: undefined reference to `atomiclshiftu'\n/home/exouser/Testsuite/Tests/atomic_update_expr_lshift_x.c:28: undefined reference to `atomiclshiftu'\n/home/exouser/Testsuite/Tests/atomic_update_expr_lshift_x.c:28: undefined reference to `atomiclshiftu'\npgacclnk: child process exit status 1: /usr/bin/ld\n",
                    "export": false,
                    "output": "",
                    "result": 2,
                    "runtime": 0.16624465212225914
                },
                "post-compile commands": [],
                "pre-compile commands": [],
                "runtime": {
                    "export": false,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -DT1 -o /home/exouser/Testsuite/build/atomic_update_expr_lshift_x.c/atomic_update_expr_lshift_x.c1 /home/exouser/Testsuite/Tests/atomic_update_expr_lshift_x.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/atomic_update_expr_lshift_x.c\", line 55: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n\"/home/exouser/Testsuite/Tests/atomic_update_expr_lshift_x.c\", line 56: warning: variable \"failed\" was declared but never referenced\n      int failed;\n          ^\n\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.16687800828367472
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.004961579106748104,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "atomic_update_expr_minus_x.F90": [
            {
                "compilation": {
                    "command": "nvfortran -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/atomic_update_expr_minus_x.F90/atomic_update_expr_minus_x.F900 /home/exouser/Testsuite/Tests/atomic_update_expr_minus_x.F90",
                    "config": 1,
                    "errors": "",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 0.48442043317481875
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "Failed to complete within timeout",
                    "export": false,
                    "output": "",
                    "result": -1,
                    "runtime": -1,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvfortran -fast -acc -ta=multicore -DT1 -o /home/exouser/Testsuite/build/atomic_update_expr_minus_x.F90/atomic_update_expr_minus_x.F901 /home/exouser/Testsuite/Tests/atomic_update_expr_minus_x.F90",
                    "config": 1,
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.6107444679364562
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.02697024680674076,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "atomic_update_expr_minus_x.c": [
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/atomic_update_expr_minus_x.c/atomic_update_expr_minus_x.c0 /home/exouser/Testsuite/Tests/atomic_update_expr_minus_x.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/atomic_update_expr_minus_x.c\", line 73: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.21673888200893998
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.009613645728677511,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "atomic_update_expr_minus_x_end.F90": [
            {
                "compilation": {
                    "command": "nvfortran -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/atomic_update_expr_minus_x_end.F90/atomic_update_expr_minus_x_end.F900 /home/exouser/Testsuite/Tests/atomic_update_expr_minus_x_end.F90",
                    "config": 1,
                    "errors": "",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 0.6271044719032943
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "Failed to complete within timeout",
                    "export": false,
                    "output": "",
                    "result": -1,
                    "runtime": -1,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvfortran -fast -acc -ta=multicore -DT1 -o /home/exouser/Testsuite/build/atomic_update_expr_minus_x_end.F90/atomic_update_expr_minus_x_end.F901 /home/exouser/Testsuite/Tests/atomic_update_expr_minus_x_end.F90",
                    "config": 1,
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.4332266552373767
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.0531051279976964,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "atomic_update_expr_multiply_x.c": [
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/atomic_update_expr_multiply_x.c/atomic_update_expr_multiply_x.c0 /home/exouser/Testsuite/Tests/atomic_update_expr_multiply_x.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/atomic_update_expr_multiply_x.c\", line 49: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.2172285239212215
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.017109917011111975,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "atomic_update_expr_neqv_x.F90": [
            {
                "compilation": {
                    "command": "nvfortran -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/atomic_update_expr_neqv_x.F90/atomic_update_expr_neqv_x.F900 /home/exouser/Testsuite/Tests/atomic_update_expr_neqv_x.F90",
                    "config": 1,
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.6963774771429598
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.12496760580688715,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "atomic_update_expr_neqv_x_end.F90": [
            {
                "compilation": {
                    "command": "nvfortran -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/atomic_update_expr_neqv_x_end.F90/atomic_update_expr_neqv_x_end.F900 /home/exouser/Testsuite/Tests/atomic_update_expr_neqv_x_end.F90",
                    "config": 1,
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.6226101820357144
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.08529396681115031,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "atomic_update_expr_or_x.F90": [
            {
                "compilation": {
                    "command": "nvfortran -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/atomic_update_expr_or_x.F90/atomic_update_expr_or_x.F900 /home/exouser/Testsuite/Tests/atomic_update_expr_or_x.F90",
                    "config": 1,
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.7768184249289334
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.12477147905156016,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "atomic_update_expr_or_x_end.F90": [
            {
                "compilation": {
                    "command": "nvfortran -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/atomic_update_expr_or_x_end.F90/atomic_update_expr_or_x_end.F900 /home/exouser/Testsuite/Tests/atomic_update_expr_or_x_end.F90",
                    "config": 1,
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.7386817340739071
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.08515967102721334,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "atomic_update_expr_plus_x.F90": [
            {
                "compilation": {
                    "command": "nvfortran -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/atomic_update_expr_plus_x.F90/atomic_update_expr_plus_x.F900 /home/exouser/Testsuite/Tests/atomic_update_expr_plus_x.F90",
                    "config": 1,
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.5845428109169006
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.07531820610165596,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "atomic_update_expr_plus_x.c": [
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/atomic_update_expr_plus_x.c/atomic_update_expr_plus_x.c0 /home/exouser/Testsuite/Tests/atomic_update_expr_plus_x.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/atomic_update_expr_plus_x.c\", line 54: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.16668205568566918
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.017780156806111336,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "atomic_update_expr_plus_x_end.F90": [
            {
                "compilation": {
                    "command": "nvfortran -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/atomic_update_expr_plus_x_end.F90/atomic_update_expr_plus_x_end.F900 /home/exouser/Testsuite/Tests/atomic_update_expr_plus_x_end.F90",
                    "config": 1,
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.591964399907738
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.1253597028553486,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "atomic_update_expr_rshift_x.c": [
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/atomic_update_expr_rshift_x.c/atomic_update_expr_rshift_x.c0 /home/exouser/Testsuite/Tests/atomic_update_expr_rshift_x.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/atomic_update_expr_rshift_x.c\", line 55: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n/tmp/nvc2BAgINt6Aj1K.o: In function `__nv_test1_F1L20_1':\n/home/exouser/Testsuite/Tests/atomic_update_expr_rshift_x.c:28: undefined reference to `atomicrshiftu'\n/home/exouser/Testsuite/Tests/atomic_update_expr_rshift_x.c:28: undefined reference to `atomicrshiftu'\n/home/exouser/Testsuite/Tests/atomic_update_expr_rshift_x.c:28: undefined reference to `atomicrshiftu'\npgacclnk: child process exit status 1: /usr/bin/ld\n",
                    "export": false,
                    "output": "",
                    "result": 2,
                    "runtime": 0.21635313099250197
                },
                "post-compile commands": [],
                "pre-compile commands": [],
                "runtime": {
                    "export": false,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -DT1 -o /home/exouser/Testsuite/build/atomic_update_expr_rshift_x.c/atomic_update_expr_rshift_x.c1 /home/exouser/Testsuite/Tests/atomic_update_expr_rshift_x.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/atomic_update_expr_rshift_x.c\", line 55: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n\"/home/exouser/Testsuite/Tests/atomic_update_expr_rshift_x.c\", line 56: warning: variable \"failed\" was declared but never referenced\n      int failed;\n          ^\n\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.16681216610595584
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.005044867284595966,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "atomic_update_expr_times_x.F90": [
            {
                "compilation": {
                    "command": "nvfortran -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/atomic_update_expr_times_x.F90/atomic_update_expr_times_x.F900 /home/exouser/Testsuite/Tests/atomic_update_expr_times_x.F90",
                    "config": 1,
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.6881996840238571
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.125155130866915,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "atomic_update_expr_times_x_end.F90": [
            {
                "compilation": {
                    "command": "nvfortran -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/atomic_update_expr_times_x_end.F90/atomic_update_expr_times_x_end.F900 /home/exouser/Testsuite/Tests/atomic_update_expr_times_x_end.F90",
                    "config": 1,
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.38790696719661355
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.12207139283418655,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "atomic_update_iand_expr_x.F90": [
            {
                "compilation": {
                    "command": "nvfortran -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/atomic_update_iand_expr_x.F90/atomic_update_iand_expr_x.F900 /home/exouser/Testsuite/Tests/atomic_update_iand_expr_x.F90",
                    "config": 1,
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.4762608832679689
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.1255262796767056,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "atomic_update_iand_expr_x_end.F90": [
            {
                "compilation": {
                    "command": "nvfortran -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/atomic_update_iand_expr_x_end.F90/atomic_update_iand_expr_x_end.F900 /home/exouser/Testsuite/Tests/atomic_update_iand_expr_x_end.F90",
                    "config": 1,
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.47216311981901526
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.1374249360524118,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "atomic_update_iand_x_expr.F90": [
            {
                "compilation": {
                    "command": "nvfortran -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/atomic_update_iand_x_expr.F90/atomic_update_iand_x_expr.F900 /home/exouser/Testsuite/Tests/atomic_update_iand_x_expr.F90",
                    "config": 1,
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.38832092797383666
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.12504140613600612,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "atomic_update_iand_x_expr_end.F90": [
            {
                "compilation": {
                    "command": "nvfortran -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/atomic_update_iand_x_expr_end.F90/atomic_update_iand_x_expr_end.F900 /home/exouser/Testsuite/Tests/atomic_update_iand_x_expr_end.F90",
                    "config": 1,
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.47635433776304126
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.12544394005089998,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "atomic_update_ior_expr_x.F90": [
            {
                "compilation": {
                    "command": "nvfortran -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/atomic_update_ior_expr_x.F90/atomic_update_ior_expr_x.F900 /home/exouser/Testsuite/Tests/atomic_update_ior_expr_x.F90",
                    "config": 1,
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.6005329727195203
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.09008498210459948,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "atomic_update_ior_expr_x_end.F90": [
            {
                "compilation": {
                    "command": "nvfortran -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/atomic_update_ior_expr_x_end.F90/atomic_update_ior_expr_x_end.F900 /home/exouser/Testsuite/Tests/atomic_update_ior_expr_x_end.F90",
                    "config": 1,
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.5811600941233337
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.08659163629636168,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "atomic_update_ior_x_expr.F90": [
            {
                "compilation": {
                    "command": "nvfortran -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/atomic_update_ior_x_expr.F90/atomic_update_ior_x_expr.F900 /home/exouser/Testsuite/Tests/atomic_update_ior_x_expr.F90",
                    "config": 1,
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.4259225847199559
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.12346433894708753,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "atomic_update_ior_x_expr_end.F90": [
            {
                "compilation": {
                    "command": "nvfortran -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/atomic_update_ior_x_expr_end.F90/atomic_update_ior_x_expr_end.F900 /home/exouser/Testsuite/Tests/atomic_update_ior_x_expr_end.F90",
                    "config": 1,
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.4880014853551984
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.12556448485702276,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "atomic_update_ixor_expr_x.F90": [
            {
                "compilation": {
                    "command": "nvfortran -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/atomic_update_ixor_expr_x.F90/atomic_update_ixor_expr_x.F900 /home/exouser/Testsuite/Tests/atomic_update_ixor_expr_x.F90",
                    "config": 1,
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.4427912840619683
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.12719631381332874,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "atomic_update_ixor_expr_x_end.F90": [
            {
                "compilation": {
                    "command": "nvfortran -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/atomic_update_ixor_expr_x_end.F90/atomic_update_ixor_expr_x_end.F900 /home/exouser/Testsuite/Tests/atomic_update_ixor_expr_x_end.F90",
                    "config": 1,
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.5231784931384027
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.17103917291387916,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "atomic_update_ixor_x_expr.F90": [
            {
                "compilation": {
                    "command": "nvfortran -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/atomic_update_ixor_x_expr.F90/atomic_update_ixor_x_expr.F900 /home/exouser/Testsuite/Tests/atomic_update_ixor_x_expr.F90",
                    "config": 1,
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.5384664628654718
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.08509182510897517,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "atomic_update_ixor_x_expr_end.F90": [
            {
                "compilation": {
                    "command": "nvfortran -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/atomic_update_ixor_x_expr_end.F90/atomic_update_ixor_x_expr_end.F900 /home/exouser/Testsuite/Tests/atomic_update_ixor_x_expr_end.F90",
                    "config": 1,
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.4763279580511153
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.12546864012256265,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "atomic_update_lshift_equals.c": [
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/atomic_update_lshift_equals.c/atomic_update_lshift_equals.c0 /home/exouser/Testsuite/Tests/atomic_update_lshift_equals.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/atomic_update_lshift_equals.c\", line 53: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n/tmp/nvcDXAgxXsA519M.o: In function `__nv_test1_F1L20_1':\n/home/exouser/Testsuite/Tests/atomic_update_lshift_equals.c:29: undefined reference to `atomiclshiftu'\n/home/exouser/Testsuite/Tests/atomic_update_lshift_equals.c:29: undefined reference to `atomiclshiftu'\n/home/exouser/Testsuite/Tests/atomic_update_lshift_equals.c:29: undefined reference to `atomiclshiftu'\n/home/exouser/Testsuite/Tests/atomic_update_lshift_equals.c:29: undefined reference to `atomiclshiftu'\n/home/exouser/Testsuite/Tests/atomic_update_lshift_equals.c:29: undefined reference to `atomiclshiftu'\n/tmp/nvcDXAgxXsA519M.o:/home/exouser/Testsuite/Tests/atomic_update_lshift_equals.c:29: more undefined references to `atomiclshiftu' follow\npgacclnk: child process exit status 1: /usr/bin/ld\n",
                    "export": false,
                    "output": "",
                    "result": 2,
                    "runtime": 0.16666395589709282
                },
                "post-compile commands": [],
                "pre-compile commands": [],
                "runtime": {
                    "export": false,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -DT1 -o /home/exouser/Testsuite/build/atomic_update_lshift_equals.c/atomic_update_lshift_equals.c1 /home/exouser/Testsuite/Tests/atomic_update_lshift_equals.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/atomic_update_lshift_equals.c\", line 53: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n\"/home/exouser/Testsuite/Tests/atomic_update_lshift_equals.c\", line 54: warning: variable \"failed\" was declared but never referenced\n      int failed;\n          ^\n\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.16663031512871385
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.005093492101877928,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "atomic_update_max_expr_list_x.F90": [
            {
                "compilation": {
                    "command": "nvfortran -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/atomic_update_max_expr_list_x.F90/atomic_update_max_expr_list_x.F900 /home/exouser/Testsuite/Tests/atomic_update_max_expr_list_x.F90",
                    "config": 1,
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.5307257818058133
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.13882311806082726,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "atomic_update_max_expr_list_x_end.F90": [
            {
                "compilation": {
                    "command": "nvfortran -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/atomic_update_max_expr_list_x_end.F90/atomic_update_max_expr_list_x_end.F900 /home/exouser/Testsuite/Tests/atomic_update_max_expr_list_x_end.F90",
                    "config": 1,
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.4225277425721288
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.12349698599427938,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "atomic_update_max_expr_x.F90": [
            {
                "compilation": {
                    "command": "nvfortran -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/atomic_update_max_expr_x.F90/atomic_update_max_expr_x.F900 /home/exouser/Testsuite/Tests/atomic_update_max_expr_x.F90",
                    "config": 1,
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.48829602589830756
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.1336351172067225,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "atomic_update_max_expr_x_end.F90": [
            {
                "compilation": {
                    "command": "nvfortran -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/atomic_update_max_expr_x_end.F90/atomic_update_max_expr_x_end.F900 /home/exouser/Testsuite/Tests/atomic_update_max_expr_x_end.F90",
                    "config": 1,
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.5924694091081619
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.13357698870822787,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "atomic_update_max_x_expr.F90": [
            {
                "compilation": {
                    "command": "nvfortran -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/atomic_update_max_x_expr.F90/atomic_update_max_x_expr.F900 /home/exouser/Testsuite/Tests/atomic_update_max_x_expr.F90",
                    "config": 1,
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.4342650421895087
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.12743769213557243,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "atomic_update_max_x_expr_end.F90": [
            {
                "compilation": {
                    "command": "nvfortran -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/atomic_update_max_x_expr_end.F90/atomic_update_max_x_expr_end.F900 /home/exouser/Testsuite/Tests/atomic_update_max_x_expr_end.F90",
                    "config": 1,
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.4958968120627105
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.12534513231366873,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "atomic_update_max_x_expr_list.F90": [
            {
                "compilation": {
                    "command": "nvfortran -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/atomic_update_max_x_expr_list.F90/atomic_update_max_x_expr_list.F900 /home/exouser/Testsuite/Tests/atomic_update_max_x_expr_list.F90",
                    "config": 1,
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.43132874509319663
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.1310863750986755,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "atomic_update_max_x_expr_list_end.F90": [
            {
                "compilation": {
                    "command": "nvfortran -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/atomic_update_max_x_expr_list_end.F90/atomic_update_max_x_expr_list_end.F900 /home/exouser/Testsuite/Tests/atomic_update_max_x_expr_list_end.F90",
                    "config": 1,
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.5264912000857294
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.1310982839204371,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "atomic_update_min_expr_list_x.F90": [
            {
                "compilation": {
                    "command": "nvfortran -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/atomic_update_min_expr_list_x.F90/atomic_update_min_expr_list_x.F900 /home/exouser/Testsuite/Tests/atomic_update_min_expr_list_x.F90",
                    "config": 1,
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.5463542067445815
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.12302785320207477,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "atomic_update_min_expr_list_x_end.F90": [
            {
                "compilation": {
                    "command": "nvfortran -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/atomic_update_min_expr_list_x_end.F90/atomic_update_min_expr_list_x_end.F900 /home/exouser/Testsuite/Tests/atomic_update_min_expr_list_x_end.F90",
                    "config": 1,
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.5308954198844731
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.07263319613412023,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "atomic_update_min_expr_x.F90": [
            {
                "compilation": {
                    "command": "nvfortran -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/atomic_update_min_expr_x.F90/atomic_update_min_expr_x.F900 /home/exouser/Testsuite/Tests/atomic_update_min_expr_x.F90",
                    "config": 1,
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.49234152864664793
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.10369593789801002,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "atomic_update_min_expr_x_end.F90": [
            {
                "compilation": {
                    "command": "nvfortran -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/atomic_update_min_expr_x_end.F90/atomic_update_min_expr_x_end.F900 /home/exouser/Testsuite/Tests/atomic_update_min_expr_x_end.F90",
                    "config": 1,
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.4421690278686583
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.07707480108365417,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "atomic_update_min_x_expr.F90": [
            {
                "compilation": {
                    "command": "nvfortran -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/atomic_update_min_x_expr.F90/atomic_update_min_x_expr.F900 /home/exouser/Testsuite/Tests/atomic_update_min_x_expr.F90",
                    "config": 1,
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.545133710373193
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.1285124598070979,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "atomic_update_min_x_expr_end.F90": [
            {
                "compilation": {
                    "command": "nvfortran -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/atomic_update_min_x_expr_end.F90/atomic_update_min_x_expr_end.F900 /home/exouser/Testsuite/Tests/atomic_update_min_x_expr_end.F90",
                    "config": 1,
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.5922178439795971
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.12947383197024465,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "atomic_update_min_x_expr_list.F90": [
            {
                "compilation": {
                    "command": "nvfortran -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/atomic_update_min_x_expr_list.F90/atomic_update_min_x_expr_list.F900 /home/exouser/Testsuite/Tests/atomic_update_min_x_expr_list.F90",
                    "config": 1,
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.5763433058746159
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.1294694012030959,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "atomic_update_min_x_expr_list_end.F90": [
            {
                "compilation": {
                    "command": "nvfortran -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/atomic_update_min_x_expr_list_end.F90/atomic_update_min_x_expr_list_end.F900 /home/exouser/Testsuite/Tests/atomic_update_min_x_expr_list_end.F90",
                    "config": 1,
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.43821679428219795
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.12141527188941836,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "atomic_update_minus_equals.c": [
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/atomic_update_minus_equals.c/atomic_update_minus_equals.c0 /home/exouser/Testsuite/Tests/atomic_update_minus_equals.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/atomic_update_minus_equals.c\", line 47: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.1668547736480832
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.009718532208353281,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "atomic_update_multiply_equals.c": [
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/atomic_update_multiply_equals.c/atomic_update_multiply_equals.c0 /home/exouser/Testsuite/Tests/atomic_update_multiply_equals.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/atomic_update_multiply_equals.c\", line 49: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.21737313689664006
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.009553859941661358,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "atomic_update_plus_equals.c": [
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/atomic_update_plus_equals.c/atomic_update_plus_equals.c0 /home/exouser/Testsuite/Tests/atomic_update_plus_equals.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/atomic_update_plus_equals.c\", line 49: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.2169503732584417
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.008751191198825836,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "atomic_update_postdecrement.c": [
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/atomic_update_postdecrement.c/atomic_update_postdecrement.c0 /home/exouser/Testsuite/Tests/atomic_update_postdecrement.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/atomic_update_postdecrement.c\", line 49: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.16607286874204874
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.009994409047067165,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "atomic_update_postincrement.c": [
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/atomic_update_postincrement.c/atomic_update_postincrement.c0 /home/exouser/Testsuite/Tests/atomic_update_postincrement.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/atomic_update_postincrement.c\", line 54: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.16609026165679097
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.009880667086690664,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "atomic_update_predecrement.c": [
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/atomic_update_predecrement.c/atomic_update_predecrement.c0 /home/exouser/Testsuite/Tests/atomic_update_predecrement.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/atomic_update_predecrement.c\", line 54: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.1656773262657225
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.01740017207339406,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "atomic_update_preincrement.c": [
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/atomic_update_preincrement.c/atomic_update_preincrement.c0 /home/exouser/Testsuite/Tests/atomic_update_preincrement.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/atomic_update_preincrement.c\", line 54: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.16688140481710434
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.009053356945514679,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "atomic_update_rshift_equals.c": [
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/atomic_update_rshift_equals.c/atomic_update_rshift_equals.c0 /home/exouser/Testsuite/Tests/atomic_update_rshift_equals.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/atomic_update_rshift_equals.c\", line 53: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n/tmp/nvceADgmBTIyIzy.o: In function `__nv_test1_F1L20_1':\n/home/exouser/Testsuite/Tests/atomic_update_rshift_equals.c:29: undefined reference to `atomicrshiftu'\n/home/exouser/Testsuite/Tests/atomic_update_rshift_equals.c:29: undefined reference to `atomicrshiftu'\n/home/exouser/Testsuite/Tests/atomic_update_rshift_equals.c:29: undefined reference to `atomicrshiftu'\n/home/exouser/Testsuite/Tests/atomic_update_rshift_equals.c:29: undefined reference to `atomicrshiftu'\n/home/exouser/Testsuite/Tests/atomic_update_rshift_equals.c:29: undefined reference to `atomicrshiftu'\n/tmp/nvceADgmBTIyIzy.o:/home/exouser/Testsuite/Tests/atomic_update_rshift_equals.c:29: more undefined references to `atomicrshiftu' follow\npgacclnk: child process exit status 1: /usr/bin/ld\n",
                    "export": false,
                    "output": "",
                    "result": 2,
                    "runtime": 0.16632514027878642
                },
                "post-compile commands": [],
                "pre-compile commands": [],
                "runtime": {
                    "export": false,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -DT1 -o /home/exouser/Testsuite/build/atomic_update_rshift_equals.c/atomic_update_rshift_equals.c1 /home/exouser/Testsuite/Tests/atomic_update_rshift_equals.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/atomic_update_rshift_equals.c\", line 53: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n\"/home/exouser/Testsuite/Tests/atomic_update_rshift_equals.c\", line 54: warning: variable \"failed\" was declared but never referenced\n      int failed;\n          ^\n\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.16648717783391476
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.004826752003282309,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "atomic_update_x_and_expr.F90": [
            {
                "compilation": {
                    "command": "nvfortran -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/atomic_update_x_and_expr.F90/atomic_update_x_and_expr.F900 /home/exouser/Testsuite/Tests/atomic_update_x_and_expr.F90",
                    "config": 1,
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.8429083032533526
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.13914148835465312,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "atomic_update_x_and_expr_end.F90": [
            {
                "compilation": {
                    "command": "nvfortran -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/atomic_update_x_and_expr_end.F90/atomic_update_x_and_expr_end.F900 /home/exouser/Testsuite/Tests/atomic_update_x_and_expr_end.F90",
                    "config": 1,
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.7727730441838503
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.14926747186109424,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "atomic_update_x_bitand_expr.c": [
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/atomic_update_x_bitand_expr.c/atomic_update_x_bitand_expr.c0 /home/exouser/Testsuite/Tests/atomic_update_x_bitand_expr.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/atomic_update_x_bitand_expr.c\", line 53: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.21650257194414735
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.009536678902804852,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "atomic_update_x_bitor_expr.c": [
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/atomic_update_x_bitor_expr.c/atomic_update_x_bitor_expr.c0 /home/exouser/Testsuite/Tests/atomic_update_x_bitor_expr.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/atomic_update_x_bitor_expr.c\", line 51: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.16677252016961575
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.00946260429918766,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "atomic_update_x_bitxor_expr.c": [
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/atomic_update_x_bitxor_expr.c/atomic_update_x_bitxor_expr.c0 /home/exouser/Testsuite/Tests/atomic_update_x_bitxor_expr.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/atomic_update_x_bitxor_expr.c\", line 51: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.2168168043717742
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.009309961926192045,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "atomic_update_x_divided_expr.F90": [
            {
                "compilation": {
                    "command": "nvfortran -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/atomic_update_x_divided_expr.F90/atomic_update_x_divided_expr.F900 /home/exouser/Testsuite/Tests/atomic_update_x_divided_expr.F90",
                    "config": 1,
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.5765858041122556
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.08298526098951697,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "atomic_update_x_divided_expr.c": [
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/atomic_update_x_divided_expr.c/atomic_update_x_divided_expr.c0 /home/exouser/Testsuite/Tests/atomic_update_x_divided_expr.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/atomic_update_x_divided_expr.c\", line 49: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.31663749599829316
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.009450477082282305,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "atomic_update_x_divided_expr_end.F90": [
            {
                "compilation": {
                    "command": "nvfortran -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/atomic_update_x_divided_expr_end.F90/atomic_update_x_divided_expr_end.F900 /home/exouser/Testsuite/Tests/atomic_update_x_divided_expr_end.F90",
                    "config": 1,
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.5920107970014215
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.19734673015773296,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "atomic_update_x_eqv_expr.F90": [
            {
                "compilation": {
                    "command": "nvfortran -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/atomic_update_x_eqv_expr.F90/atomic_update_x_eqv_expr.F900 /home/exouser/Testsuite/Tests/atomic_update_x_eqv_expr.F90",
                    "config": 1,
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.5885272389277816
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.12546653486788273,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "atomic_update_x_eqv_expr_end.F90": [
            {
                "compilation": {
                    "command": "nvfortran -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/atomic_update_x_eqv_expr_end.F90/atomic_update_x_eqv_expr_end.F900 /home/exouser/Testsuite/Tests/atomic_update_x_eqv_expr_end.F90",
                    "config": 1,
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.7346065910533071
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.13555265171453357,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "atomic_update_x_lshift_expr.c": [
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/atomic_update_x_lshift_expr.c/atomic_update_x_lshift_expr.c0 /home/exouser/Testsuite/Tests/atomic_update_x_lshift_expr.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/atomic_update_x_lshift_expr.c\", line 53: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n/tmp/nvcAeFgoyfVwZVt.o: In function `__nv_test1_F1L20_1':\n/home/exouser/Testsuite/Tests/atomic_update_x_lshift_expr.c:29: undefined reference to `atomiclshiftu'\n/home/exouser/Testsuite/Tests/atomic_update_x_lshift_expr.c:29: undefined reference to `atomiclshiftu'\n/home/exouser/Testsuite/Tests/atomic_update_x_lshift_expr.c:29: undefined reference to `atomiclshiftu'\n/home/exouser/Testsuite/Tests/atomic_update_x_lshift_expr.c:29: undefined reference to `atomiclshiftu'\n/home/exouser/Testsuite/Tests/atomic_update_x_lshift_expr.c:29: undefined reference to `atomiclshiftu'\n/tmp/nvcAeFgoyfVwZVt.o:/home/exouser/Testsuite/Tests/atomic_update_x_lshift_expr.c:29: more undefined references to `atomiclshiftu' follow\npgacclnk: child process exit status 1: /usr/bin/ld\n",
                    "export": false,
                    "output": "",
                    "result": 2,
                    "runtime": 0.16644675005227327
                },
                "post-compile commands": [],
                "pre-compile commands": [],
                "runtime": {
                    "export": false,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -DT1 -o /home/exouser/Testsuite/build/atomic_update_x_lshift_expr.c/atomic_update_x_lshift_expr.c1 /home/exouser/Testsuite/Tests/atomic_update_x_lshift_expr.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/atomic_update_x_lshift_expr.c\", line 53: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n\"/home/exouser/Testsuite/Tests/atomic_update_x_lshift_expr.c\", line 54: warning: variable \"failed\" was declared but never referenced\n      int failed;\n          ^\n\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.1665445719845593
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.005441430024802685,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "atomic_update_x_minus_expr.F90": [
            {
                "compilation": {
                    "command": "nvfortran -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/atomic_update_x_minus_expr.F90/atomic_update_x_minus_expr.F900 /home/exouser/Testsuite/Tests/atomic_update_x_minus_expr.F90",
                    "config": 1,
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.5420624008402228
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.12421293556690216,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "atomic_update_x_minus_expr.c": [
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/atomic_update_x_minus_expr.c/atomic_update_x_minus_expr.c0 /home/exouser/Testsuite/Tests/atomic_update_x_minus_expr.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/atomic_update_x_minus_expr.c\", line 48: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.21638009790331125
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.009747965261340141,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "atomic_update_x_minus_expr_end.F90": [
            {
                "compilation": {
                    "command": "nvfortran -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/atomic_update_x_minus_expr_end.F90/atomic_update_x_minus_expr_end.F900 /home/exouser/Testsuite/Tests/atomic_update_x_minus_expr_end.F90",
                    "config": 1,
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.5806083399802446
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.07513997284695506,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "atomic_update_x_multiply_expr.c": [
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/atomic_update_x_multiply_expr.c/atomic_update_x_multiply_expr.c0 /home/exouser/Testsuite/Tests/atomic_update_x_multiply_expr.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/atomic_update_x_multiply_expr.c\", line 49: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.21696624904870987
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.010701564140617847,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "atomic_update_x_neqv_expr.F90": [
            {
                "compilation": {
                    "command": "nvfortran -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/atomic_update_x_neqv_expr.F90/atomic_update_x_neqv_expr.F900 /home/exouser/Testsuite/Tests/atomic_update_x_neqv_expr.F90",
                    "config": 1,
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.6327249272726476
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.12508713826537132,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "atomic_update_x_neqv_expr_end.F90": [
            {
                "compilation": {
                    "command": "nvfortran -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/atomic_update_x_neqv_expr_end.F90/atomic_update_x_neqv_expr_end.F900 /home/exouser/Testsuite/Tests/atomic_update_x_neqv_expr_end.F90",
                    "config": 1,
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.6801870493218303
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.13364030187949538,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "atomic_update_x_or_expr.F90": [
            {
                "compilation": {
                    "command": "nvfortran -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/atomic_update_x_or_expr.F90/atomic_update_x_or_expr.F900 /home/exouser/Testsuite/Tests/atomic_update_x_or_expr.F90",
                    "config": 1,
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.6569477636367083
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.12893316382542253,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "atomic_update_x_or_expr_end.F90": [
            {
                "compilation": {
                    "command": "nvfortran -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/atomic_update_x_or_expr_end.F90/atomic_update_x_or_expr_end.F900 /home/exouser/Testsuite/Tests/atomic_update_x_or_expr_end.F90",
                    "config": 1,
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.5756850149482489
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.12135651893913746,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "atomic_update_x_plus_expr.F90": [
            {
                "compilation": {
                    "command": "nvfortran -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/atomic_update_x_plus_expr.F90/atomic_update_x_plus_expr.F900 /home/exouser/Testsuite/Tests/atomic_update_x_plus_expr.F90",
                    "config": 1,
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.5923341871239245
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.12622185982763767,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "atomic_update_x_plus_expr.c": [
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/atomic_update_x_plus_expr.c/atomic_update_x_plus_expr.c0 /home/exouser/Testsuite/Tests/atomic_update_x_plus_expr.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/atomic_update_x_plus_expr.c\", line 54: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.16635918291285634
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.03375718276947737,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "atomic_update_x_plus_expr_end.F90": [
            {
                "compilation": {
                    "command": "nvfortran -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/atomic_update_x_plus_expr_end.F90/atomic_update_x_plus_expr_end.F900 /home/exouser/Testsuite/Tests/atomic_update_x_plus_expr_end.F90",
                    "config": 1,
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.5903370487503707
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.1354459752328694,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "atomic_update_x_rshift_expr.c": [
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/atomic_update_x_rshift_expr.c/atomic_update_x_rshift_expr.c0 /home/exouser/Testsuite/Tests/atomic_update_x_rshift_expr.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/atomic_update_x_rshift_expr.c\", line 53: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n/tmp/nvcbFGgdIAR1BfH.o: In function `__nv_test1_F1L20_1':\n/home/exouser/Testsuite/Tests/atomic_update_x_rshift_expr.c:29: undefined reference to `atomicrshiftu'\n/home/exouser/Testsuite/Tests/atomic_update_x_rshift_expr.c:29: undefined reference to `atomicrshiftu'\n/home/exouser/Testsuite/Tests/atomic_update_x_rshift_expr.c:29: undefined reference to `atomicrshiftu'\n/home/exouser/Testsuite/Tests/atomic_update_x_rshift_expr.c:29: undefined reference to `atomicrshiftu'\n/home/exouser/Testsuite/Tests/atomic_update_x_rshift_expr.c:29: undefined reference to `atomicrshiftu'\n/tmp/nvcbFGgdIAR1BfH.o:/home/exouser/Testsuite/Tests/atomic_update_x_rshift_expr.c:29: more undefined references to `atomicrshiftu' follow\npgacclnk: child process exit status 1: /usr/bin/ld\n",
                    "export": false,
                    "output": "",
                    "result": 2,
                    "runtime": 0.1669434062205255
                },
                "post-compile commands": [],
                "pre-compile commands": [],
                "runtime": {
                    "export": false,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -DT1 -o /home/exouser/Testsuite/build/atomic_update_x_rshift_expr.c/atomic_update_x_rshift_expr.c1 /home/exouser/Testsuite/Tests/atomic_update_x_rshift_expr.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/atomic_update_x_rshift_expr.c\", line 53: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n\"/home/exouser/Testsuite/Tests/atomic_update_x_rshift_expr.c\", line 54: warning: variable \"failed\" was declared but never referenced\n      int failed;\n          ^\n\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.16626611817628145
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.009603824932128191,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "atomic_update_x_times_expr.F90": [
            {
                "compilation": {
                    "command": "nvfortran -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/atomic_update_x_times_expr.F90/atomic_update_x_times_expr.F900 /home/exouser/Testsuite/Tests/atomic_update_x_times_expr.F90",
                    "config": 1,
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.5304446630179882
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.1434107250533998,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "atomic_update_x_times_expr_end.F90": [
            {
                "compilation": {
                    "command": "nvfortran -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/atomic_update_x_times_expr_end.F90/atomic_update_x_times_expr_end.F900 /home/exouser/Testsuite/Tests/atomic_update_x_times_expr_end.F90",
                    "config": 1,
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.6427546180784702
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.07308581471443176,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "atomic_x_and_expr.F90": [
            {
                "compilation": {
                    "command": "nvfortran -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/atomic_x_and_expr.F90/atomic_x_and_expr.F900 /home/exouser/Testsuite/Tests/atomic_x_and_expr.F90",
                    "config": 1,
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.5805690460838377
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.16146128484979272,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "atomic_x_and_expr_end.F90": [
            {
                "compilation": {
                    "command": "nvfortran -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/atomic_x_and_expr_end.F90/atomic_x_and_expr_end.F900 /home/exouser/Testsuite/Tests/atomic_x_and_expr_end.F90",
                    "config": 1,
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.6933491262607276
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.12820122111588717,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "atomic_x_bitand_expr.c": [
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/atomic_x_bitand_expr.c/atomic_x_bitand_expr.c0 /home/exouser/Testsuite/Tests/atomic_x_bitand_expr.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/atomic_x_bitand_expr.c\", line 53: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.21688038669526577
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.010401646140962839,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "atomic_x_bitor_expr.c": [
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/atomic_x_bitor_expr.c/atomic_x_bitor_expr.c0 /home/exouser/Testsuite/Tests/atomic_x_bitor_expr.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/atomic_x_bitor_expr.c\", line 51: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.16655780328437686
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.009813412092626095,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "atomic_x_bitxor_expr.c": [
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/atomic_x_bitxor_expr.c/atomic_x_bitxor_expr.c0 /home/exouser/Testsuite/Tests/atomic_x_bitxor_expr.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/atomic_x_bitxor_expr.c\", line 51: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.2161361495964229
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.017057988792657852,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "atomic_x_divided_expr.F90": [
            {
                "compilation": {
                    "command": "nvfortran -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/atomic_x_divided_expr.F90/atomic_x_divided_expr.F900 /home/exouser/Testsuite/Tests/atomic_x_divided_expr.F90",
                    "config": 1,
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.5765548320487142
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.13784652715548873,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "atomic_x_divided_expr.c": [
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/atomic_x_divided_expr.c/atomic_x_divided_expr.c0 /home/exouser/Testsuite/Tests/atomic_x_divided_expr.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/atomic_x_divided_expr.c\", line 49: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.21637241961434484
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.009536029770970345,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "atomic_x_divided_expr_end.F90": [
            {
                "compilation": {
                    "command": "nvfortran -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/atomic_x_divided_expr_end.F90/atomic_x_divided_expr_end.F900 /home/exouser/Testsuite/Tests/atomic_x_divided_expr_end.F90",
                    "config": 1,
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.5887478599324822
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.12543162191286683,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "atomic_x_eqv_expr.F90": [
            {
                "compilation": {
                    "command": "nvfortran -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/atomic_x_eqv_expr.F90/atomic_x_eqv_expr.F900 /home/exouser/Testsuite/Tests/atomic_x_eqv_expr.F90",
                    "config": 1,
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.6926157749257982
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.1258981367573142,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "atomic_x_eqv_expr_end.F90": [
            {
                "compilation": {
                    "command": "nvfortran -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/atomic_x_eqv_expr_end.F90/atomic_x_eqv_expr_end.F900 /home/exouser/Testsuite/Tests/atomic_x_eqv_expr_end.F90",
                    "config": 1,
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.6847080918960273
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.12926820013672113,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "atomic_x_lshift_expr.c": [
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/atomic_x_lshift_expr.c/atomic_x_lshift_expr.c0 /home/exouser/Testsuite/Tests/atomic_x_lshift_expr.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/atomic_x_lshift_expr.c\", line 52: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n/tmp/nvcujIg8bjECC69.o: In function `__nv_test1_F1L20_1':\n/home/exouser/Testsuite/Tests/atomic_x_lshift_expr.c:29: undefined reference to `atomiclshiftu'\n/home/exouser/Testsuite/Tests/atomic_x_lshift_expr.c:29: undefined reference to `atomiclshiftu'\n/home/exouser/Testsuite/Tests/atomic_x_lshift_expr.c:29: undefined reference to `atomiclshiftu'\n/home/exouser/Testsuite/Tests/atomic_x_lshift_expr.c:29: undefined reference to `atomiclshiftu'\n/home/exouser/Testsuite/Tests/atomic_x_lshift_expr.c:29: undefined reference to `atomiclshiftu'\n/tmp/nvcujIg8bjECC69.o:/home/exouser/Testsuite/Tests/atomic_x_lshift_expr.c:29: more undefined references to `atomiclshiftu' follow\npgacclnk: child process exit status 1: /usr/bin/ld\n",
                    "export": false,
                    "output": "",
                    "result": 2,
                    "runtime": 0.1673733820207417
                },
                "post-compile commands": [],
                "pre-compile commands": [],
                "runtime": {
                    "export": false,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -DT1 -o /home/exouser/Testsuite/build/atomic_x_lshift_expr.c/atomic_x_lshift_expr.c1 /home/exouser/Testsuite/Tests/atomic_x_lshift_expr.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/atomic_x_lshift_expr.c\", line 52: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n\"/home/exouser/Testsuite/Tests/atomic_x_lshift_expr.c\", line 53: warning: variable \"failed\" was declared but never referenced\n      int failed;\n          ^\n\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.16654830565676093
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.005686596967279911,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "atomic_x_minus_expr.F90": [
            {
                "compilation": {
                    "command": "nvfortran -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/atomic_x_minus_expr.F90/atomic_x_minus_expr.F900 /home/exouser/Testsuite/Tests/atomic_x_minus_expr.F90",
                    "config": 1,
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.6914789429865777
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.12440057890489697,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "atomic_x_minus_expr.c": [
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/atomic_x_minus_expr.c/atomic_x_minus_expr.c0 /home/exouser/Testsuite/Tests/atomic_x_minus_expr.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/atomic_x_minus_expr.c\", line 48: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.16635379707440734
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.0105206910520792,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "atomic_x_minus_expr_end.F90": [
            {
                "compilation": {
                    "command": "nvfortran -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/atomic_x_minus_expr_end.F90/atomic_x_minus_expr_end.F900 /home/exouser/Testsuite/Tests/atomic_x_minus_expr_end.F90",
                    "config": 1,
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.6998617998324335
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.08341255877166986,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "atomic_x_multiply_expr.c": [
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/atomic_x_multiply_expr.c/atomic_x_multiply_expr.c0 /home/exouser/Testsuite/Tests/atomic_x_multiply_expr.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/atomic_x_multiply_expr.c\", line 49: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.21670867083594203
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.009617575909942389,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "atomic_x_neqv_expr.F90": [
            {
                "compilation": {
                    "command": "nvfortran -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/atomic_x_neqv_expr.F90/atomic_x_neqv_expr.F900 /home/exouser/Testsuite/Tests/atomic_x_neqv_expr.F90",
                    "config": 1,
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.7272037649527192
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.1229647290892899,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "atomic_x_neqv_expr_end.F90": [
            {
                "compilation": {
                    "command": "nvfortran -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/atomic_x_neqv_expr_end.F90/atomic_x_neqv_expr_end.F900 /home/exouser/Testsuite/Tests/atomic_x_neqv_expr_end.F90",
                    "config": 1,
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.5754371001385152
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.12246608315035701,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "atomic_x_or_expr.F90": [
            {
                "compilation": {
                    "command": "nvfortran -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/atomic_x_or_expr.F90/atomic_x_or_expr.F900 /home/exouser/Testsuite/Tests/atomic_x_or_expr.F90",
                    "config": 1,
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.6381474169902503
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.18587617902085185,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "atomic_x_or_expr_end.F90": [
            {
                "compilation": {
                    "command": "nvfortran -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/atomic_x_or_expr_end.F90/atomic_x_or_expr_end.F900 /home/exouser/Testsuite/Tests/atomic_x_or_expr_end.F90",
                    "config": 1,
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.7427810202352703
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.13514279294759035,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "atomic_x_plus_expr.F90": [
            {
                "compilation": {
                    "command": "nvfortran -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/atomic_x_plus_expr.F90/atomic_x_plus_expr.F900 /home/exouser/Testsuite/Tests/atomic_x_plus_expr.F90",
                    "config": 1,
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.5804296811111271
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.1449928842484951,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "atomic_x_plus_expr.c": [
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/atomic_x_plus_expr.c/atomic_x_plus_expr.c0 /home/exouser/Testsuite/Tests/atomic_x_plus_expr.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/atomic_x_plus_expr.c\", line 54: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.16588487103581429
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.01758706895634532,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "atomic_x_plus_expr_end.F90": [
            {
                "compilation": {
                    "command": "nvfortran -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/atomic_x_plus_expr_end.F90/atomic_x_plus_expr_end.F900 /home/exouser/Testsuite/Tests/atomic_x_plus_expr_end.F90",
                    "config": 1,
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.5343568162061274
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.12358729867264628,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "atomic_x_rshift_expr.c": [
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/atomic_x_rshift_expr.c/atomic_x_rshift_expr.c0 /home/exouser/Testsuite/Tests/atomic_x_rshift_expr.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/atomic_x_rshift_expr.c\", line 53: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n/tmp/nvc7EJgXNRD7Y1r.o: In function `__nv_test1_F1L20_1':\n/home/exouser/Testsuite/Tests/atomic_x_rshift_expr.c:29: undefined reference to `atomicrshiftu'\n/home/exouser/Testsuite/Tests/atomic_x_rshift_expr.c:29: undefined reference to `atomicrshiftu'\n/home/exouser/Testsuite/Tests/atomic_x_rshift_expr.c:29: undefined reference to `atomicrshiftu'\n/home/exouser/Testsuite/Tests/atomic_x_rshift_expr.c:29: undefined reference to `atomicrshiftu'\n/home/exouser/Testsuite/Tests/atomic_x_rshift_expr.c:29: undefined reference to `atomicrshiftu'\n/tmp/nvc7EJgXNRD7Y1r.o:/home/exouser/Testsuite/Tests/atomic_x_rshift_expr.c:29: more undefined references to `atomicrshiftu' follow\npgacclnk: child process exit status 1: /usr/bin/ld\n",
                    "export": false,
                    "output": "",
                    "result": 2,
                    "runtime": 0.16707629384472966
                },
                "post-compile commands": [],
                "pre-compile commands": [],
                "runtime": {
                    "export": false,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -DT1 -o /home/exouser/Testsuite/build/atomic_x_rshift_expr.c/atomic_x_rshift_expr.c1 /home/exouser/Testsuite/Tests/atomic_x_rshift_expr.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/atomic_x_rshift_expr.c\", line 53: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n\"/home/exouser/Testsuite/Tests/atomic_x_rshift_expr.c\", line 54: warning: variable \"failed\" was declared but never referenced\n      int failed;\n          ^\n\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.16701512318104506
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.005391906015574932,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "atomic_x_times_expr.F90": [
            {
                "compilation": {
                    "command": "nvfortran -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/atomic_x_times_expr.F90/atomic_x_times_expr.F900 /home/exouser/Testsuite/Tests/atomic_x_times_expr.F90",
                    "config": 1,
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.5542522519826889
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.1238205786794424,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "atomic_x_times_expr_end.F90": [
            {
                "compilation": {
                    "command": "nvfortran -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/atomic_x_times_expr_end.F90/atomic_x_times_expr_end.F900 /home/exouser/Testsuite/Tests/atomic_x_times_expr_end.F90",
                    "config": 1,
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.6236236291006207
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.08810698799788952,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "data_copy_no_lower_bound.F90": [
            {
                "compilation": {
                    "command": "nvfortran -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/data_copy_no_lower_bound.F90/data_copy_no_lower_bound.F900 /home/exouser/Testsuite/Tests/data_copy_no_lower_bound.F90",
                    "config": 1,
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.48800695687532425
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.12573825055733323,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "data_copy_no_lower_bound.c": [
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/data_copy_no_lower_bound.c/data_copy_no_lower_bound.c0 /home/exouser/Testsuite/Tests/data_copy_no_lower_bound.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/data_copy_no_lower_bound.c\", line 40: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.2174896141514182
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.009920301847159863,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "data_copyin_no_lower_bound.F90": [
            {
                "compilation": {
                    "command": "nvfortran -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/data_copyin_no_lower_bound.F90/data_copyin_no_lower_bound.F900 /home/exouser/Testsuite/Tests/data_copyin_no_lower_bound.F90",
                    "config": 1,
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.48042002273723483
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.12583574699237943,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "data_copyin_no_lower_bound.c": [
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/data_copyin_no_lower_bound.c/data_copyin_no_lower_bound.c0 /home/exouser/Testsuite/Tests/data_copyin_no_lower_bound.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/data_copyin_no_lower_bound.c\", line 40: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.1668568211607635
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.017764043994247913,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "data_copyout_no_lower_bound.F90": [
            {
                "compilation": {
                    "command": "nvfortran -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/data_copyout_no_lower_bound.F90/data_copyout_no_lower_bound.F900 /home/exouser/Testsuite/Tests/data_copyout_no_lower_bound.F90",
                    "config": 1,
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.4722032770514488
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.12564088497310877,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "data_copyout_no_lower_bound.c": [
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/data_copyout_no_lower_bound.c/data_copyout_no_lower_bound.c0 /home/exouser/Testsuite/Tests/data_copyout_no_lower_bound.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/data_copyout_no_lower_bound.c\", line 40: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.2163415951654315
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.010008724872022867,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "data_copyout_reference_counts.F90": [
            {
                "compilation": {
                    "command": "nvfortran -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/data_copyout_reference_counts.F90/data_copyout_reference_counts.F900 /home/exouser/Testsuite/Tests/data_copyout_reference_counts.F90",
                    "config": 1,
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.6850921530276537
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.1288826740346849,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "data_copyout_reference_counts.c": [
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/data_copyout_reference_counts.c/data_copyout_reference_counts.c0 /home/exouser/Testsuite/Tests/data_copyout_reference_counts.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/data_copyout_reference_counts.c\", line 152: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.2173788328655064
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.009365764912217855,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "data_create.F90": [
            {
                "compilation": {
                    "command": "nvfortran -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/data_create.F90/data_create.F900 /home/exouser/Testsuite/Tests/data_create.F90",
                    "config": 1,
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.4838942768983543
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.07961754221469164,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "data_create.c": [
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/data_create.c/data_create.c0 /home/exouser/Testsuite/Tests/data_create.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/data_create.c\", line 154: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.21711272513493896
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.009623706806451082,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "data_create_no_lower_bound.F90": [
            {
                "compilation": {
                    "command": "nvfortran -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/data_create_no_lower_bound.F90/data_create_no_lower_bound.F900 /home/exouser/Testsuite/Tests/data_create_no_lower_bound.F90",
                    "config": 1,
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.5304932659491897
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.12755872076377273,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "data_create_no_lower_bound.c": [
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/data_create_no_lower_bound.c/data_create_no_lower_bound.c0 /home/exouser/Testsuite/Tests/data_create_no_lower_bound.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/data_create_no_lower_bound.c\", line 48: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.21733177592977881
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.009391230065375566,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "data_present_no_lower_bound.F90": [
            {
                "compilation": {
                    "command": "nvfortran -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/data_present_no_lower_bound.F90/data_present_no_lower_bound.F900 /home/exouser/Testsuite/Tests/data_present_no_lower_bound.F90",
                    "config": 1,
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.48449861304834485
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.12516356399282813,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "data_present_no_lower_bound.c": [
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/data_present_no_lower_bound.c/data_present_no_lower_bound.c0 /home/exouser/Testsuite/Tests/data_present_no_lower_bound.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/data_present_no_lower_bound.c\", line 42: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.16760630393400788
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.010608812794089317,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "data_with_changing_subscript.F90": [
            {
                "compilation": {
                    "command": "nvfortran -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/data_with_changing_subscript.F90/data_with_changing_subscript.F900 /home/exouser/Testsuite/Tests/data_with_changing_subscript.F90",
                    "config": 1,
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.43828194309026003
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.12382620899006724,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "data_with_changing_subscript.c": [
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/data_with_changing_subscript.c/data_with_changing_subscript.c0 /home/exouser/Testsuite/Tests/data_with_changing_subscript.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/data_with_changing_subscript.c\", line 42: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.16660583391785622
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.010075912345200777,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "data_with_derived_type.F90": [
            {
                "compilation": {
                    "command": "nvfortran -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/data_with_derived_type.F90/data_with_derived_type.F900 /home/exouser/Testsuite/Tests/data_with_derived_type.F90",
                    "config": 1,
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.3881737790070474
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.12204924132674932,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "data_with_structs.c": [
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/data_with_structs.c/data_with_structs.c0 /home/exouser/Testsuite/Tests/data_with_structs.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/data_with_structs.c\", line 44: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.1674360241740942
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.010518018156290054,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "declare_copyin.F90": [
            {
                "compilation": {
                    "command": "nvfortran -fast -acc -ta=multicore -DT1 -DT2 -DT3 -DT4 -o /home/exouser/Testsuite/build/declare_copyin.F90/declare_copyin.F900 /home/exouser/Testsuite/Tests/declare_copyin.F90",
                    "config": 1,
                    "errors": "",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 0.43078018072992563
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 0.0365028721280396,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvfortran -fast -acc -ta=multicore -DT2 -DT3 -DT4 -o /home/exouser/Testsuite/build/declare_copyin.F90/declare_copyin.F901 /home/exouser/Testsuite/Tests/declare_copyin.F90",
                    "config": 1,
                    "errors": "NVFORTRAN-F-0004-Unable to open MODULE file declare_copyin_mod.mod (/home/exouser/Testsuite/Tests/declare_copyin.F90: 15)\nNVFORTRAN/x86-64 Linux 21.5-0: compilation aborted\n",
                    "export": false,
                    "output": "",
                    "result": 2,
                    "runtime": 0.12895144009962678
                },
                "post-compile commands": [],
                "pre-compile commands": [],
                "runtime": {
                    "export": false,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvfortran -fast -acc -ta=multicore -DT1 -DT3 -DT4 -o /home/exouser/Testsuite/build/declare_copyin.F90/declare_copyin.F902 /home/exouser/Testsuite/Tests/declare_copyin.F90",
                    "config": 1,
                    "errors": "NVFORTRAN-F-0004-Unable to open MODULE file declare_copyin_mod.mod (/home/exouser/Testsuite/Tests/declare_copyin.F90: 58)\nNVFORTRAN/x86-64 Linux 21.5-0: compilation aborted\n",
                    "export": false,
                    "output": "",
                    "result": 2,
                    "runtime": 0.1280297148041427
                },
                "post-compile commands": [],
                "pre-compile commands": [],
                "runtime": {
                    "export": false,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvfortran -fast -acc -ta=multicore -DT1 -DT2 -DT4 -o /home/exouser/Testsuite/build/declare_copyin.F90/declare_copyin.F903 /home/exouser/Testsuite/Tests/declare_copyin.F90",
                    "config": 1,
                    "errors": "NVFORTRAN-F-0004-Unable to open MODULE file declare_copyin_mod.mod (/home/exouser/Testsuite/Tests/declare_copyin.F90: 100)\nNVFORTRAN/x86-64 Linux 21.5-0: compilation aborted\n",
                    "export": false,
                    "output": "",
                    "result": 2,
                    "runtime": 0.13521486474201083
                },
                "post-compile commands": [],
                "pre-compile commands": [],
                "runtime": {
                    "export": false,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvfortran -fast -acc -ta=multicore -DT1 -DT2 -DT3 -o /home/exouser/Testsuite/build/declare_copyin.F90/declare_copyin.F904 /home/exouser/Testsuite/Tests/declare_copyin.F90",
                    "config": 1,
                    "errors": "NVFORTRAN-F-0004-Unable to open MODULE file declare_copyin_mod.mod (/home/exouser/Testsuite/Tests/declare_copyin.F90: 142)\nNVFORTRAN/x86-64 Linux 21.5-0: compilation aborted\n",
                    "export": false,
                    "output": "",
                    "result": 2,
                    "runtime": 0.123989162966609
                },
                "post-compile commands": [],
                "pre-compile commands": [],
                "runtime": {
                    "export": false,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvfortran -fast -acc -ta=multicore -DT1 -DT2 -DT3 -DT4 -o /home/exouser/Testsuite/build/declare_copyin.F90/declare_copyin.F905 /home/exouser/Testsuite/Tests/declare_copyin.F90",
                    "config": 1,
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.4527692161500454
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.08835220383480191,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "declare_copyin.c": [
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -DT1 -DT2 -DT3 -DT4 -DT5 -o /home/exouser/Testsuite/build/declare_copyin.c/declare_copyin.c0 /home/exouser/Testsuite/Tests/declare_copyin.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/acc_testsuite_declare.h\", line 128: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n\"/home/exouser/Testsuite/Tests/acc_testsuite_declare.h\", line 129: warning: variable \"failed\" was declared but never referenced\n      int failed;\n          ^\n\n\"/home/exouser/Testsuite/Tests/declare_copyin.c\", line 7: error: identifier \"fixed_size_array\" is undefined\n  #pragma acc declare copyin(fixed_size_array)\n                             ^\n\n\"/home/exouser/Testsuite/Tests/declare_copyin.c\", line 8: error: identifier \"scalar\" is undefined\n  #pragma acc declare copyin(scalar)\n                             ^\n\n\"/home/exouser/Testsuite/Tests/declare_copyin.c\", line 9: error: identifier \"datapointer\" is undefined\n  #pragma acc declare copyin(datapointer)\n                             ^\n\n\"/home/exouser/Testsuite/Tests/declare_copyin.c\", line 201: error: function \"main\" has already been defined\n  int main(){\n      ^\n\n\"/home/exouser/Testsuite/Tests/declare_copyin.c\", line 203: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n\"/home/exouser/Testsuite/Tests/declare_copyin.c\", line 204: warning: variable \"failed\" was declared but never referenced\n      int failed;\n          ^\n\n4 errors detected in the compilation of \"/home/exouser/Testsuite/Tests/declare_copyin.c\".\n",
                    "export": false,
                    "output": "",
                    "result": 2,
                    "runtime": 0.0663025788962841
                },
                "post-compile commands": [],
                "pre-compile commands": [],
                "runtime": {
                    "export": false,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -DT2 -DT3 -DT4 -DT5 -o /home/exouser/Testsuite/build/declare_copyin.c/declare_copyin.c1 /home/exouser/Testsuite/Tests/declare_copyin.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/acc_testsuite_declare.h\", line 128: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n\"/home/exouser/Testsuite/Tests/acc_testsuite_declare.h\", line 129: warning: variable \"failed\" was declared but never referenced\n      int failed;\n          ^\n\n\"/home/exouser/Testsuite/Tests/declare_copyin.c\", line 7: error: identifier \"fixed_size_array\" is undefined\n  #pragma acc declare copyin(fixed_size_array)\n                             ^\n\n\"/home/exouser/Testsuite/Tests/declare_copyin.c\", line 8: error: identifier \"scalar\" is undefined\n  #pragma acc declare copyin(scalar)\n                             ^\n\n\"/home/exouser/Testsuite/Tests/declare_copyin.c\", line 9: error: identifier \"datapointer\" is undefined\n  #pragma acc declare copyin(datapointer)\n                             ^\n\n\"/home/exouser/Testsuite/Tests/declare_copyin.c\", line 32: error: identifier \"fixed_size_array\" is undefined\n      #pragma acc data copyin(a[0:n]) copyout(b[0:n]) present(fixed_size_array)\n                                                              ^\n\n\"/home/exouser/Testsuite/Tests/declare_copyin.c\", line 38: error: identifier \"fixed_size_array\" is undefined\n                  b[x] = a[x] + fixed_size_array[x%10];\n                                ^\n\n\"/home/exouser/Testsuite/Tests/declare_copyin.c\", line 44: error: identifier \"fixed_size_array\" is undefined\n          if (fabs(b[x] - (a[x] + fixed_size_array[x%10])) > PRECISION){\n                                  ^\n\n\"/home/exouser/Testsuite/Tests/declare_copyin.c\", line 26: warning: variable \"mult\" was declared but never referenced\n      int mult = 2;\n          ^\n\n\"/home/exouser/Testsuite/Tests/declare_copyin.c\", line 201: error: function \"main\" has already been defined\n  int main(){\n      ^\n\n\"/home/exouser/Testsuite/Tests/declare_copyin.c\", line 203: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n7 errors detected in the compilation of \"/home/exouser/Testsuite/Tests/declare_copyin.c\".\n",
                    "export": false,
                    "output": "",
                    "result": 2,
                    "runtime": 0.06678113900125027
                },
                "post-compile commands": [],
                "pre-compile commands": [],
                "runtime": {
                    "export": false,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -DT1 -DT3 -DT4 -DT5 -o /home/exouser/Testsuite/build/declare_copyin.c/declare_copyin.c2 /home/exouser/Testsuite/Tests/declare_copyin.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/acc_testsuite_declare.h\", line 128: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n\"/home/exouser/Testsuite/Tests/acc_testsuite_declare.h\", line 129: warning: variable \"failed\" was declared but never referenced\n      int failed;\n          ^\n\n\"/home/exouser/Testsuite/Tests/declare_copyin.c\", line 7: error: identifier \"fixed_size_array\" is undefined\n  #pragma acc declare copyin(fixed_size_array)\n                             ^\n\n\"/home/exouser/Testsuite/Tests/declare_copyin.c\", line 8: error: identifier \"scalar\" is undefined\n  #pragma acc declare copyin(scalar)\n                             ^\n\n\"/home/exouser/Testsuite/Tests/declare_copyin.c\", line 9: error: identifier \"datapointer\" is undefined\n  #pragma acc declare copyin(datapointer)\n                             ^\n\n\"/home/exouser/Testsuite/Tests/declare_copyin.c\", line 68: error: identifier \"scalar\" is undefined\n      #pragma acc data copyin(a[0:n]) copyout(b[0:n]) present(scalar)\n                                                              ^\n\n\"/home/exouser/Testsuite/Tests/declare_copyin.c\", line 74: error: identifier \"scalar\" is undefined\n                  b[x] = a[x] + scalar;\n                                ^\n\n\"/home/exouser/Testsuite/Tests/declare_copyin.c\", line 80: error: identifier \"scalar\" is undefined\n          if (fabs(b[x] - (a[x] + scalar)) > PRECISION){\n                                  ^\n\n\"/home/exouser/Testsuite/Tests/declare_copyin.c\", line 61: warning: variable \"mult\" was declared but never referenced\n      int mult = 2;\n          ^\n\n\"/home/exouser/Testsuite/Tests/declare_copyin.c\", line 201: error: function \"main\" has already been defined\n  int main(){\n      ^\n\n\"/home/exouser/Testsuite/Tests/declare_copyin.c\", line 203: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n7 errors detected in the compilation of \"/home/exouser/Testsuite/Tests/declare_copyin.c\".\n",
                    "export": false,
                    "output": "",
                    "result": 2,
                    "runtime": 0.06697515910491347
                },
                "post-compile commands": [],
                "pre-compile commands": [],
                "runtime": {
                    "export": false,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -DT1 -DT2 -DT4 -DT5 -o /home/exouser/Testsuite/build/declare_copyin.c/declare_copyin.c3 /home/exouser/Testsuite/Tests/declare_copyin.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/acc_testsuite_declare.h\", line 128: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n\"/home/exouser/Testsuite/Tests/acc_testsuite_declare.h\", line 129: warning: variable \"failed\" was declared but never referenced\n      int failed;\n          ^\n\n\"/home/exouser/Testsuite/Tests/declare_copyin.c\", line 7: error: identifier \"fixed_size_array\" is undefined\n  #pragma acc declare copyin(fixed_size_array)\n                             ^\n\n\"/home/exouser/Testsuite/Tests/declare_copyin.c\", line 8: error: identifier \"scalar\" is undefined\n  #pragma acc declare copyin(scalar)\n                             ^\n\n\"/home/exouser/Testsuite/Tests/declare_copyin.c\", line 9: error: identifier \"datapointer\" is undefined\n  #pragma acc declare copyin(datapointer)\n                             ^\n\n\"/home/exouser/Testsuite/Tests/declare_copyin.c\", line 110: warning: function \"extern_multiplyData_copyin\" declared implicitly\n                  extern_multiplyData_copyin(a, n);\n                  ^\n\n\"/home/exouser/Testsuite/Tests/declare_copyin.c\", line 97: warning: variable \"mult\" was declared but never referenced\n      int mult = 2;\n          ^\n\n\"/home/exouser/Testsuite/Tests/declare_copyin.c\", line 201: error: function \"main\" has already been defined\n  int main(){\n      ^\n\n\"/home/exouser/Testsuite/Tests/declare_copyin.c\", line 203: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n4 errors detected in the compilation of \"/home/exouser/Testsuite/Tests/declare_copyin.c\".\n",
                    "export": false,
                    "output": "",
                    "result": 2,
                    "runtime": 0.06703442940488458
                },
                "post-compile commands": [],
                "pre-compile commands": [],
                "runtime": {
                    "export": false,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -DT1 -DT2 -DT3 -DT5 -o /home/exouser/Testsuite/build/declare_copyin.c/declare_copyin.c4 /home/exouser/Testsuite/Tests/declare_copyin.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/acc_testsuite_declare.h\", line 128: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n\"/home/exouser/Testsuite/Tests/acc_testsuite_declare.h\", line 129: warning: variable \"failed\" was declared but never referenced\n      int failed;\n          ^\n\n\"/home/exouser/Testsuite/Tests/declare_copyin.c\", line 7: error: identifier \"fixed_size_array\" is undefined\n  #pragma acc declare copyin(fixed_size_array)\n                             ^\n\n\"/home/exouser/Testsuite/Tests/declare_copyin.c\", line 8: error: identifier \"scalar\" is undefined\n  #pragma acc declare copyin(scalar)\n                             ^\n\n\"/home/exouser/Testsuite/Tests/declare_copyin.c\", line 9: error: identifier \"datapointer\" is undefined\n  #pragma acc declare copyin(datapointer)\n                             ^\n\n\"/home/exouser/Testsuite/Tests/declare_copyin.c\", line 133: warning: variable \"mult\" was declared but never referenced\n      int mult = 2;\n          ^\n\n\"/home/exouser/Testsuite/Tests/declare_copyin.c\", line 201: error: function \"main\" has already been defined\n  int main(){\n      ^\n\n\"/home/exouser/Testsuite/Tests/declare_copyin.c\", line 203: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n4 errors detected in the compilation of \"/home/exouser/Testsuite/Tests/declare_copyin.c\".\n",
                    "export": false,
                    "output": "",
                    "result": 2,
                    "runtime": 0.0665289550088346
                },
                "post-compile commands": [],
                "pre-compile commands": [],
                "runtime": {
                    "export": false,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -DT1 -DT2 -DT3 -DT4 -o /home/exouser/Testsuite/build/declare_copyin.c/declare_copyin.c5 /home/exouser/Testsuite/Tests/declare_copyin.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/acc_testsuite_declare.h\", line 128: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n\"/home/exouser/Testsuite/Tests/acc_testsuite_declare.h\", line 129: warning: variable \"failed\" was declared but never referenced\n      int failed;\n          ^\n\n\"/home/exouser/Testsuite/Tests/declare_copyin.c\", line 7: error: identifier \"fixed_size_array\" is undefined\n  #pragma acc declare copyin(fixed_size_array)\n                             ^\n\n\"/home/exouser/Testsuite/Tests/declare_copyin.c\", line 8: error: identifier \"scalar\" is undefined\n  #pragma acc declare copyin(scalar)\n                             ^\n\n\"/home/exouser/Testsuite/Tests/declare_copyin.c\", line 9: error: identifier \"datapointer\" is undefined\n  #pragma acc declare copyin(datapointer)\n                             ^\n\n\"/home/exouser/Testsuite/Tests/declare_copyin.c\", line 176: error: identifier \"datapointer\" is undefined\n      datapointer = a;\n      ^\n\n\"/home/exouser/Testsuite/Tests/declare_copyin.c\", line 177: error: non variable found in parallel pragma list\n      #pragma acc enter data copyin(a[0:n]) attach(datapointer)\n                                                   ^\n\n\"/home/exouser/Testsuite/Tests/declare_copyin.c\", line 178: error: non variable found in parallel pragma list\n      #pragma acc data present(datapointer[0:n])\n                               ^\n\n\"/home/exouser/Testsuite/Tests/declare_copyin.c\", line 178: error: non variable found in parallel pragma list\n      #pragma acc data present(datapointer[0:n])\n                                          ^\n\n\"/home/exouser/Testsuite/Tests/declare_copyin.c\", line 169: warning: variable \"mult\" was declared but never referenced\n      int mult = 2;\n          ^\n\n\"/home/exouser/Testsuite/Tests/declare_copyin.c\", line 201: error: function \"main\" has already been defined\n  int main(){\n      ^\n\n\"/home/exouser/Testsuite/Tests/declare_copyin.c\", line 203: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n8 errors detected in the compilation of \"/home/exouser/Testsuite/Tests/declare_copyin.c\".\n",
                    "export": false,
                    "output": "",
                    "result": 2,
                    "runtime": 0.11693549901247025
                },
                "post-compile commands": [],
                "pre-compile commands": [],
                "runtime": {
                    "export": false,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -DT5 -DT1 -DT2 -DT3 -DT4 -DT5 -o /home/exouser/Testsuite/build/declare_copyin.c/declare_copyin.c6 /home/exouser/Testsuite/Tests/declare_copyin.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/acc_testsuite_declare.h\", line 128: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n\"/home/exouser/Testsuite/Tests/acc_testsuite_declare.h\", line 129: warning: variable \"failed\" was declared but never referenced\n      int failed;\n          ^\n\n\"/home/exouser/Testsuite/Tests/declare_copyin.c\", line 7: error: identifier \"fixed_size_array\" is undefined\n  #pragma acc declare copyin(fixed_size_array)\n                             ^\n\n\"/home/exouser/Testsuite/Tests/declare_copyin.c\", line 8: error: identifier \"scalar\" is undefined\n  #pragma acc declare copyin(scalar)\n                             ^\n\n\"/home/exouser/Testsuite/Tests/declare_copyin.c\", line 9: error: identifier \"datapointer\" is undefined\n  #pragma acc declare copyin(datapointer)\n                             ^\n\n\"/home/exouser/Testsuite/Tests/declare_copyin.c\", line 201: error: function \"main\" has already been defined\n  int main(){\n      ^\n\n\"/home/exouser/Testsuite/Tests/declare_copyin.c\", line 203: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n\"/home/exouser/Testsuite/Tests/declare_copyin.c\", line 204: warning: variable \"failed\" was declared but never referenced\n      int failed;\n          ^\n\n4 errors detected in the compilation of \"/home/exouser/Testsuite/Tests/declare_copyin.c\".\n",
                    "export": true,
                    "output": "",
                    "result": 2,
                    "runtime": 0.06649120524525642
                },
                "post-compile commands": [],
                "pre-compile commands": [],
                "runtime": {
                    "export": true,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "declare_copyin_mod.F90": [
            {
                "compilation": {
                    "command": "nvfortran -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/declare_copyin_mod.F90/declare_copyin_mod.F900 /home/exouser/Testsuite/Tests/declare_copyin_mod.F90",
                    "config": 1,
                    "errors": "/opt/nvidia/hpc_sdk/Linux_x86_64/21.5/compilers/lib/f90main.o: In function `main':\nnvcRTnjbbHTr8Cve.ll:(.text+0x2f): undefined reference to `MAIN_'\npgacclnk: child process exit status 1: /usr/bin/ld\n",
                    "export": true,
                    "output": "",
                    "result": 2,
                    "runtime": 0.4262541770003736
                },
                "post-compile commands": [],
                "pre-compile commands": [],
                "runtime": {
                    "export": true,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "declare_create.F90": [
            {
                "compilation": {
                    "command": "nvfortran -fast -acc -ta=multicore -DT1 -DT2 -DT3 -DT4 -o /home/exouser/Testsuite/build/declare_create.F90/declare_create.F900 /home/exouser/Testsuite/Tests/declare_create.F90",
                    "config": 1,
                    "errors": "NVFORTRAN-S-0070-Incorrect sequence of statements  (/home/exouser/Testsuite/Tests/declare_create.F90: 6)\n  0 inform,   0 warnings,   1 severes, 0 fatal for multiplydata\n",
                    "export": false,
                    "output": "",
                    "result": 2,
                    "runtime": 0.12980694510042667
                },
                "post-compile commands": [],
                "pre-compile commands": [],
                "runtime": {
                    "export": false,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvfortran -fast -acc -ta=multicore -DT2 -DT3 -DT4 -o /home/exouser/Testsuite/build/declare_create.F90/declare_create.F901 /home/exouser/Testsuite/Tests/declare_create.F90",
                    "config": 1,
                    "errors": "NVFORTRAN-S-0070-Incorrect sequence of statements  (/home/exouser/Testsuite/Tests/declare_create.F90: 6)\n  0 inform,   0 warnings,   1 severes, 0 fatal for multiplydata\nNVFORTRAN-W-0155-Constant or Parameter used in data clause - n (/home/exouser/Testsuite/Tests/declare_create.F90: 32)\nNVFORTRAN-S-0038-Symbol, fixed_size_array, has not been explicitly declared (/home/exouser/Testsuite/Tests/declare_create.F90: 33)\nNVFORTRAN-S-0076-Subscripts specified for non-array variable fixed_size_array (/home/exouser/Testsuite/Tests/declare_create.F90: 37)\nNVFORTRAN-W-0103-Type conversion of subscript expression for b (/home/exouser/Testsuite/Tests/declare_create.F90: 43)\nNVFORTRAN-W-0103-Type conversion of subscript expression for a (/home/exouser/Testsuite/Tests/declare_create.F90: 43)\nNVFORTRAN-W-0093-Type conversion of expression performed (/home/exouser/Testsuite/Tests/declare_create.F90: 43)\nNVFORTRAN-S-0076-Subscripts specified for non-array variable fixed_size_array (/home/exouser/Testsuite/Tests/declare_create.F90: 43)\nNVFORTRAN-W-0103-Type conversion of subscript expression for b (/home/exouser/Testsuite/Tests/declare_create.F90: 49)\nNVFORTRAN-W-0103-Type conversion of subscript expression for a (/home/exouser/Testsuite/Tests/declare_create.F90: 49)\nNVFORTRAN-W-0093-Type conversion of expression performed (/home/exouser/Testsuite/Tests/declare_create.F90: 49)\nNVFORTRAN-W-0093-Type conversion of expression performed (/home/exouser/Testsuite/Tests/declare_create.F90: 49)\nNVFORTRAN-S-0038-Symbol, x, has not been explicitly declared (/home/exouser/Testsuite/Tests/declare_create.F90)\n  0 inform,   8 warnings,   4 severes, 0 fatal for test1\n",
                    "export": false,
                    "output": "",
                    "result": 2,
                    "runtime": 0.12368224188685417
                },
                "post-compile commands": [],
                "pre-compile commands": [],
                "runtime": {
                    "export": false,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvfortran -fast -acc -ta=multicore -DT1 -DT3 -DT4 -o /home/exouser/Testsuite/build/declare_create.F90/declare_create.F902 /home/exouser/Testsuite/Tests/declare_create.F90",
                    "config": 1,
                    "errors": "NVFORTRAN-S-0070-Incorrect sequence of statements  (/home/exouser/Testsuite/Tests/declare_create.F90: 6)\n  0 inform,   0 warnings,   1 severes, 0 fatal for multiplydata\nNVFORTRAN-S-0038-Symbol, scalar, has not been explicitly declared (/home/exouser/Testsuite/Tests/declare_create.F90: 80)\nNVFORTRAN-W-0103-Type conversion of subscript expression for b (/home/exouser/Testsuite/Tests/declare_create.F90: 85)\nNVFORTRAN-W-0103-Type conversion of subscript expression for a (/home/exouser/Testsuite/Tests/declare_create.F90: 85)\nNVFORTRAN-W-0103-Type conversion of subscript expression for b (/home/exouser/Testsuite/Tests/declare_create.F90: 91)\nNVFORTRAN-W-0103-Type conversion of subscript expression for a (/home/exouser/Testsuite/Tests/declare_create.F90: 91)\nNVFORTRAN-S-0038-Symbol, x, has not been explicitly declared (/home/exouser/Testsuite/Tests/declare_create.F90)\n  0 inform,   4 warnings,   2 severes, 0 fatal for test2\n",
                    "export": false,
                    "output": "",
                    "result": 2,
                    "runtime": 0.12301291525363922
                },
                "post-compile commands": [],
                "pre-compile commands": [],
                "runtime": {
                    "export": false,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvfortran -fast -acc -ta=multicore -DT1 -DT2 -DT4 -o /home/exouser/Testsuite/build/declare_create.F90/declare_create.F903 /home/exouser/Testsuite/Tests/declare_create.F90",
                    "config": 1,
                    "errors": "NVFORTRAN-S-0070-Incorrect sequence of statements  (/home/exouser/Testsuite/Tests/declare_create.F90: 6)\n  0 inform,   0 warnings,   1 severes, 0 fatal for multiplydata\nNVFORTRAN-S-0034-Syntax error at or near end of line (/home/exouser/Testsuite/Tests/declare_create.F90: 121)\n  0 inform,   0 warnings,   1 severes, 0 fatal for test3\n",
                    "export": false,
                    "output": "",
                    "result": 2,
                    "runtime": 0.1398000242188573
                },
                "post-compile commands": [],
                "pre-compile commands": [],
                "runtime": {
                    "export": false,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvfortran -fast -acc -ta=multicore -DT1 -DT2 -DT3 -o /home/exouser/Testsuite/build/declare_create.F90/declare_create.F904 /home/exouser/Testsuite/Tests/declare_create.F90",
                    "config": 1,
                    "errors": "NVFORTRAN-S-0070-Incorrect sequence of statements  (/home/exouser/Testsuite/Tests/declare_create.F90: 6)\n  0 inform,   0 warnings,   1 severes, 0 fatal for multiplydata\nNVFORTRAN-W-0103-Type conversion of subscript expression for a (/home/exouser/Testsuite/Tests/declare_create.F90: 173)\nNVFORTRAN-W-0103-Type conversion of subscript expression for b (/home/exouser/Testsuite/Tests/declare_create.F90: 173)\nNVFORTRAN-S-0038-Symbol, x, has not been explicitly declared (/home/exouser/Testsuite/Tests/declare_create.F90)\n  0 inform,   2 warnings,   1 severes, 0 fatal for test4\n",
                    "export": false,
                    "output": "",
                    "result": 2,
                    "runtime": 0.12354571092873812
                },
                "post-compile commands": [],
                "pre-compile commands": [],
                "runtime": {
                    "export": false,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvfortran -fast -acc -ta=multicore -DT4 -DT1 -DT2 -DT3 -DT4 -o /home/exouser/Testsuite/build/declare_create.F90/declare_create.F905 /home/exouser/Testsuite/Tests/declare_create.F90",
                    "config": 1,
                    "errors": "NVFORTRAN-S-0070-Incorrect sequence of statements  (/home/exouser/Testsuite/Tests/declare_create.F90: 6)\n  0 inform,   0 warnings,   1 severes, 0 fatal for multiplydata\n",
                    "export": true,
                    "output": "",
                    "result": 2,
                    "runtime": 0.1397708859294653
                },
                "post-compile commands": [],
                "pre-compile commands": [],
                "runtime": {
                    "export": true,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "declare_create.c": [
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -DT1 -DT2 -DT3 -DT4 -DT5 -o /home/exouser/Testsuite/build/declare_create.c/declare_create.c0 /home/exouser/Testsuite/Tests/declare_create.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/acc_testsuite_declare.h\", line 128: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n\"/home/exouser/Testsuite/Tests/acc_testsuite_declare.h\", line 129: warning: variable \"failed\" was declared but never referenced\n      int failed;\n          ^\n\n\"/home/exouser/Testsuite/Tests/declare_create.c\", line 5: error: identifier \"fixed_size_array\" is undefined\n  #pragma acc declare create(fixed_size_array)\n                             ^\n\n\"/home/exouser/Testsuite/Tests/declare_create.c\", line 6: error: identifier \"scalar\" is undefined\n  #pragma acc declare create(scalar)\n                             ^\n\n\"/home/exouser/Testsuite/Tests/declare_create.c\", line 7: error: identifier \"datapointer\" is undefined\n  #pragma acc declare create(datapointer)\n                             ^\n\n\"/home/exouser/Testsuite/Tests/declare_create.c\", line 215: error: function \"main\" has already been defined\n  int main(){\n      ^\n\n\"/home/exouser/Testsuite/Tests/declare_create.c\", line 217: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n\"/home/exouser/Testsuite/Tests/declare_create.c\", line 218: warning: variable \"failed\" was declared but never referenced\n      int failed;\n          ^\n\n4 errors detected in the compilation of \"/home/exouser/Testsuite/Tests/declare_create.c\".\n",
                    "export": false,
                    "output": "",
                    "result": 2,
                    "runtime": 0.06693908479064703
                },
                "post-compile commands": [],
                "pre-compile commands": [],
                "runtime": {
                    "export": false,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -DT2 -DT3 -DT4 -DT5 -o /home/exouser/Testsuite/build/declare_create.c/declare_create.c1 /home/exouser/Testsuite/Tests/declare_create.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/acc_testsuite_declare.h\", line 128: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n\"/home/exouser/Testsuite/Tests/acc_testsuite_declare.h\", line 129: warning: variable \"failed\" was declared but never referenced\n      int failed;\n          ^\n\n\"/home/exouser/Testsuite/Tests/declare_create.c\", line 5: error: identifier \"fixed_size_array\" is undefined\n  #pragma acc declare create(fixed_size_array)\n                             ^\n\n\"/home/exouser/Testsuite/Tests/declare_create.c\", line 6: error: identifier \"scalar\" is undefined\n  #pragma acc declare create(scalar)\n                             ^\n\n\"/home/exouser/Testsuite/Tests/declare_create.c\", line 7: error: identifier \"datapointer\" is undefined\n  #pragma acc declare create(datapointer)\n                             ^\n\n\"/home/exouser/Testsuite/Tests/declare_create.c\", line 34: error: identifier \"fixed_size_array\" is undefined\n      #pragma acc data copyin(a[0:n]) copyout(b[0:n]) present(fixed_size_array)\n                                                              ^\n\n\"/home/exouser/Testsuite/Tests/declare_create.c\", line 40: error: identifier \"fixed_size_array\" is undefined\n                  fixed_size_array[x] = x*x;\n                  ^\n\n\"/home/exouser/Testsuite/Tests/declare_create.c\", line 47: error: identifier \"fixed_size_array\" is undefined\n                  b[x] = a[x] + fixed_size_array[x%10];\n                                ^\n\n\"/home/exouser/Testsuite/Tests/declare_create.c\", line 26: warning: variable \"mult\" was declared but never referenced\n      int mult = 2;\n          ^\n\n\"/home/exouser/Testsuite/Tests/declare_create.c\", line 215: error: function \"main\" has already been defined\n  int main(){\n      ^\n\n\"/home/exouser/Testsuite/Tests/declare_create.c\", line 217: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n7 errors detected in the compilation of \"/home/exouser/Testsuite/Tests/declare_create.c\".\n",
                    "export": false,
                    "output": "",
                    "result": 2,
                    "runtime": 0.06691859103739262
                },
                "post-compile commands": [],
                "pre-compile commands": [],
                "runtime": {
                    "export": false,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -DT1 -DT3 -DT4 -DT5 -o /home/exouser/Testsuite/build/declare_create.c/declare_create.c2 /home/exouser/Testsuite/Tests/declare_create.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/acc_testsuite_declare.h\", line 128: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n\"/home/exouser/Testsuite/Tests/acc_testsuite_declare.h\", line 129: warning: variable \"failed\" was declared but never referenced\n      int failed;\n          ^\n\n\"/home/exouser/Testsuite/Tests/declare_create.c\", line 5: error: identifier \"fixed_size_array\" is undefined\n  #pragma acc declare create(fixed_size_array)\n                             ^\n\n\"/home/exouser/Testsuite/Tests/declare_create.c\", line 6: error: identifier \"scalar\" is undefined\n  #pragma acc declare create(scalar)\n                             ^\n\n\"/home/exouser/Testsuite/Tests/declare_create.c\", line 7: error: identifier \"datapointer\" is undefined\n  #pragma acc declare create(datapointer)\n                             ^\n\n\"/home/exouser/Testsuite/Tests/declare_create.c\", line 78: error: identifier \"scalar\" is undefined\n      scalar = 10;\n      ^\n\n\"/home/exouser/Testsuite/Tests/declare_create.c\", line 79: error: non variable found in parallel pragma list\n      #pragma acc update device(scalar)\n                                ^\n\n\"/home/exouser/Testsuite/Tests/declare_create.c\", line 70: warning: variable \"mult\" was declared but never referenced\n      int mult = 2;\n          ^\n\n\"/home/exouser/Testsuite/Tests/declare_create.c\", line 215: error: function \"main\" has already been defined\n  int main(){\n      ^\n\n\"/home/exouser/Testsuite/Tests/declare_create.c\", line 217: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n6 errors detected in the compilation of \"/home/exouser/Testsuite/Tests/declare_create.c\".\n",
                    "export": false,
                    "output": "",
                    "result": 2,
                    "runtime": 0.06742731528356671
                },
                "post-compile commands": [],
                "pre-compile commands": [],
                "runtime": {
                    "export": false,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -DT1 -DT2 -DT4 -DT5 -o /home/exouser/Testsuite/build/declare_create.c/declare_create.c3 /home/exouser/Testsuite/Tests/declare_create.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/acc_testsuite_declare.h\", line 128: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n\"/home/exouser/Testsuite/Tests/acc_testsuite_declare.h\", line 129: warning: variable \"failed\" was declared but never referenced\n      int failed;\n          ^\n\n\"/home/exouser/Testsuite/Tests/declare_create.c\", line 5: error: identifier \"fixed_size_array\" is undefined\n  #pragma acc declare create(fixed_size_array)\n                             ^\n\n\"/home/exouser/Testsuite/Tests/declare_create.c\", line 6: error: identifier \"scalar\" is undefined\n  #pragma acc declare create(scalar)\n                             ^\n\n\"/home/exouser/Testsuite/Tests/declare_create.c\", line 7: error: identifier \"datapointer\" is undefined\n  #pragma acc declare create(datapointer)\n                             ^\n\n\"/home/exouser/Testsuite/Tests/declare_create.c\", line 124: warning: function \"extern_multiplyData_create\" declared implicitly\n                  extern_multiplyData_create(a, n);\n                  ^\n\n\"/home/exouser/Testsuite/Tests/declare_create.c\", line 109: warning: variable \"mult\" was declared but never referenced\n      int mult = 2;\n          ^\n\n\"/home/exouser/Testsuite/Tests/declare_create.c\", line 215: error: function \"main\" has already been defined\n  int main(){\n      ^\n\n\"/home/exouser/Testsuite/Tests/declare_create.c\", line 217: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n4 errors detected in the compilation of \"/home/exouser/Testsuite/Tests/declare_create.c\".\n",
                    "export": false,
                    "output": "",
                    "result": 2,
                    "runtime": 0.06697093788534403
                },
                "post-compile commands": [],
                "pre-compile commands": [],
                "runtime": {
                    "export": false,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -DT1 -DT2 -DT3 -DT5 -o /home/exouser/Testsuite/build/declare_create.c/declare_create.c4 /home/exouser/Testsuite/Tests/declare_create.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/acc_testsuite_declare.h\", line 128: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n\"/home/exouser/Testsuite/Tests/acc_testsuite_declare.h\", line 129: warning: variable \"failed\" was declared but never referenced\n      int failed;\n          ^\n\n\"/home/exouser/Testsuite/Tests/declare_create.c\", line 5: error: identifier \"fixed_size_array\" is undefined\n  #pragma acc declare create(fixed_size_array)\n                             ^\n\n\"/home/exouser/Testsuite/Tests/declare_create.c\", line 6: error: identifier \"scalar\" is undefined\n  #pragma acc declare create(scalar)\n                             ^\n\n\"/home/exouser/Testsuite/Tests/declare_create.c\", line 7: error: identifier \"datapointer\" is undefined\n  #pragma acc declare create(datapointer)\n                             ^\n\n\"/home/exouser/Testsuite/Tests/declare_create.c\", line 147: warning: variable \"mult\" was declared but never referenced\n      int mult = 2;\n          ^\n\n\"/home/exouser/Testsuite/Tests/declare_create.c\", line 215: error: function \"main\" has already been defined\n  int main(){\n      ^\n\n\"/home/exouser/Testsuite/Tests/declare_create.c\", line 217: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n4 errors detected in the compilation of \"/home/exouser/Testsuite/Tests/declare_create.c\".\n",
                    "export": false,
                    "output": "",
                    "result": 2,
                    "runtime": 0.06700430531054735
                },
                "post-compile commands": [],
                "pre-compile commands": [],
                "runtime": {
                    "export": false,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -DT1 -DT2 -DT3 -DT4 -o /home/exouser/Testsuite/build/declare_create.c/declare_create.c5 /home/exouser/Testsuite/Tests/declare_create.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/acc_testsuite_declare.h\", line 128: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n\"/home/exouser/Testsuite/Tests/acc_testsuite_declare.h\", line 129: warning: variable \"failed\" was declared but never referenced\n      int failed;\n          ^\n\n\"/home/exouser/Testsuite/Tests/declare_create.c\", line 5: error: identifier \"fixed_size_array\" is undefined\n  #pragma acc declare create(fixed_size_array)\n                             ^\n\n\"/home/exouser/Testsuite/Tests/declare_create.c\", line 6: error: identifier \"scalar\" is undefined\n  #pragma acc declare create(scalar)\n                             ^\n\n\"/home/exouser/Testsuite/Tests/declare_create.c\", line 7: error: identifier \"datapointer\" is undefined\n  #pragma acc declare create(datapointer)\n                             ^\n\n\"/home/exouser/Testsuite/Tests/declare_create.c\", line 190: error: identifier \"datapointer\" is undefined\n      datapointer = a;\n      ^\n\n\"/home/exouser/Testsuite/Tests/declare_create.c\", line 192: error: non variable found in parallel pragma list\n      #pragma acc data copyin(a[0:n]) attach(datapointer)\n                                             ^\n\n\"/home/exouser/Testsuite/Tests/declare_create.c\", line 194: error: non variable found in parallel pragma list\n          #pragma acc parallel present(datapointer[0:n])\n                                       ^\n\n\"/home/exouser/Testsuite/Tests/declare_create.c\", line 194: error: non variable found in parallel pragma list\n          #pragma acc parallel present(datapointer[0:n])\n                                                  ^\n\n\"/home/exouser/Testsuite/Tests/declare_create.c\", line 183: warning: variable \"mult\" was declared but never referenced\n      int mult = 2;\n          ^\n\n\"/home/exouser/Testsuite/Tests/declare_create.c\", line 215: error: function \"main\" has already been defined\n  int main(){\n      ^\n\n\"/home/exouser/Testsuite/Tests/declare_create.c\", line 217: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n8 errors detected in the compilation of \"/home/exouser/Testsuite/Tests/declare_create.c\".\n",
                    "export": false,
                    "output": "",
                    "result": 2,
                    "runtime": 0.06670168321579695
                },
                "post-compile commands": [],
                "pre-compile commands": [],
                "runtime": {
                    "export": false,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -DT5 -DT1 -DT2 -DT3 -DT4 -DT5 -o /home/exouser/Testsuite/build/declare_create.c/declare_create.c6 /home/exouser/Testsuite/Tests/declare_create.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/acc_testsuite_declare.h\", line 128: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n\"/home/exouser/Testsuite/Tests/acc_testsuite_declare.h\", line 129: warning: variable \"failed\" was declared but never referenced\n      int failed;\n          ^\n\n\"/home/exouser/Testsuite/Tests/declare_create.c\", line 5: error: identifier \"fixed_size_array\" is undefined\n  #pragma acc declare create(fixed_size_array)\n                             ^\n\n\"/home/exouser/Testsuite/Tests/declare_create.c\", line 6: error: identifier \"scalar\" is undefined\n  #pragma acc declare create(scalar)\n                             ^\n\n\"/home/exouser/Testsuite/Tests/declare_create.c\", line 7: error: identifier \"datapointer\" is undefined\n  #pragma acc declare create(datapointer)\n                             ^\n\n\"/home/exouser/Testsuite/Tests/declare_create.c\", line 215: error: function \"main\" has already been defined\n  int main(){\n      ^\n\n\"/home/exouser/Testsuite/Tests/declare_create.c\", line 217: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n\"/home/exouser/Testsuite/Tests/declare_create.c\", line 218: warning: variable \"failed\" was declared but never referenced\n      int failed;\n          ^\n\n4 errors detected in the compilation of \"/home/exouser/Testsuite/Tests/declare_create.c\".\n",
                    "export": true,
                    "output": "",
                    "result": 2,
                    "runtime": 0.06694200308993459
                },
                "post-compile commands": [],
                "pre-compile commands": [],
                "runtime": {
                    "export": true,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "declare_device_resident.c": [
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/declare_device_resident.c/declare_device_resident.c0 /home/exouser/Testsuite/Tests/declare_device_resident.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/acc_testsuite_declare.h\", line 128: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n\"/home/exouser/Testsuite/Tests/acc_testsuite_declare.h\", line 129: warning: variable \"failed\" was declared but never referenced\n      int failed;\n          ^\n\n\"/home/exouser/Testsuite/Tests/declare_device_resident.c\", line 5: error: identifier \"fixed_size_array\" is undefined\n  #pragma acc declare device_resident(fixed_size_array)\n                                      ^\n\n\"/home/exouser/Testsuite/Tests/declare_device_resident.c\", line 6: error: identifier \"scalar\" is undefined\n  #pragma acc declare device_resident(scalar)\n                                      ^\n\n\"/home/exouser/Testsuite/Tests/declare_device_resident.c\", line 7: error: identifier \"datapointer\" is undefined\n  #pragma acc declare device_resident(datapointer)\n                                      ^\n\n\"/home/exouser/Testsuite/Tests/declare_device_resident.c\", line 23: error: identifier \"scalar\" is undefined\n        scalar = 10;\n        ^\n\n\"/home/exouser/Testsuite/Tests/declare_device_resident.c\", line 25: error: identifier \"fixed_size_array\" is undefined\n          fixed_size_array[x] = x*x;\n          ^\n\n\"/home/exouser/Testsuite/Tests/declare_device_resident.c\", line 34: error: identifier \"fixed_size_array\" is undefined\n      #pragma acc data copyin(a[0:n]) copyout(b[0:n]) present(fixed_size_array)\n                                                              ^\n\n\"/home/exouser/Testsuite/Tests/declare_device_resident.c\", line 40: error: identifier \"fixed_size_array\" is undefined\n                  fixed_size_array[x] = x*x;\n                  ^\n\n\"/home/exouser/Testsuite/Tests/declare_device_resident.c\", line 47: error: identifier \"fixed_size_array\" is undefined\n                  b[x] = a[x] + fixed_size_array[x%10];\n                                ^\n\n\"/home/exouser/Testsuite/Tests/declare_device_resident.c\", line 18: warning: variable \"mult\" was declared but never referenced\n      int mult = 2;\n          ^\n\n\"/home/exouser/Testsuite/Tests/declare_device_resident.c\", line 75: error: identifier \"scalar\" is undefined\n        scalar = 10;\n        ^\n\n\"/home/exouser/Testsuite/Tests/declare_device_resident.c\", line 77: error: identifier \"fixed_size_array\" is undefined\n          fixed_size_array[x] = x*x;\n          ^\n\n\"/home/exouser/Testsuite/Tests/declare_device_resident.c\", line 92: error: identifier \"scalar\" is undefined\n                  b[x] = a[x] + scalar;\n                                ^\n\n\"/home/exouser/Testsuite/Tests/declare_device_resident.c\", line 70: warning: variable \"mult\" was declared but never referenced\n      int mult = 2;\n          ^\n\n\"/home/exouser/Testsuite/Tests/declare_device_resident.c\", line 120: error: identifier \"scalar\" is undefined\n        scalar = 10;\n        ^\n\n\"/home/exouser/Testsuite/Tests/declare_device_resident.c\", line 122: error: identifier \"fixed_size_array\" is undefined\n          fixed_size_array[x] = x*x;\n          ^\n\n\"/home/exouser/Testsuite/Tests/declare_device_resident.c\", line 137: warning: function \"extern_multiplyData_device_resident\" declared implicitly\n                  extern_multiplyData_device_resident(a, n);\n                  ^\n\n\"/home/exouser/Testsuite/Tests/declare_device_resident.c\", line 115: warning: variable \"mult\" was declared but never referenced\n      int mult = 2;\n          ^\n\n\"/home/exouser/Testsuite/Tests/declare_device_resident.c\", line 153: error: function \"main\" has already been defined\n  int main(){\n      ^\n\n\"/home/exouser/Testsuite/Tests/declare_device_resident.c\", line 155: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n14 errors detected in the compilation of \"/home/exouser/Testsuite/Tests/declare_device_resident.c\".\n",
                    "export": false,
                    "output": "",
                    "result": 2,
                    "runtime": 0.06699783634394407
                },
                "post-compile commands": [],
                "pre-compile commands": [],
                "runtime": {
                    "export": false,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -DT1 -o /home/exouser/Testsuite/build/declare_device_resident.c/declare_device_resident.c1 /home/exouser/Testsuite/Tests/declare_device_resident.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/acc_testsuite_declare.h\", line 128: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n\"/home/exouser/Testsuite/Tests/acc_testsuite_declare.h\", line 129: warning: variable \"failed\" was declared but never referenced\n      int failed;\n          ^\n\n\"/home/exouser/Testsuite/Tests/declare_device_resident.c\", line 5: error: identifier \"fixed_size_array\" is undefined\n  #pragma acc declare device_resident(fixed_size_array)\n                                      ^\n\n\"/home/exouser/Testsuite/Tests/declare_device_resident.c\", line 6: error: identifier \"scalar\" is undefined\n  #pragma acc declare device_resident(scalar)\n                                      ^\n\n\"/home/exouser/Testsuite/Tests/declare_device_resident.c\", line 7: error: identifier \"datapointer\" is undefined\n  #pragma acc declare device_resident(datapointer)\n                                      ^\n\n\"/home/exouser/Testsuite/Tests/declare_device_resident.c\", line 75: error: identifier \"scalar\" is undefined\n        scalar = 10;\n        ^\n\n\"/home/exouser/Testsuite/Tests/declare_device_resident.c\", line 77: error: identifier \"fixed_size_array\" is undefined\n          fixed_size_array[x] = x*x;\n          ^\n\n\"/home/exouser/Testsuite/Tests/declare_device_resident.c\", line 92: error: identifier \"scalar\" is undefined\n                  b[x] = a[x] + scalar;\n                                ^\n\n\"/home/exouser/Testsuite/Tests/declare_device_resident.c\", line 70: warning: variable \"mult\" was declared but never referenced\n      int mult = 2;\n          ^\n\n\"/home/exouser/Testsuite/Tests/declare_device_resident.c\", line 120: error: identifier \"scalar\" is undefined\n        scalar = 10;\n        ^\n\n\"/home/exouser/Testsuite/Tests/declare_device_resident.c\", line 122: error: identifier \"fixed_size_array\" is undefined\n          fixed_size_array[x] = x*x;\n          ^\n\n\"/home/exouser/Testsuite/Tests/declare_device_resident.c\", line 137: warning: function \"extern_multiplyData_device_resident\" declared implicitly\n                  extern_multiplyData_device_resident(a, n);\n                  ^\n\n\"/home/exouser/Testsuite/Tests/declare_device_resident.c\", line 115: warning: variable \"mult\" was declared but never referenced\n      int mult = 2;\n          ^\n\n\"/home/exouser/Testsuite/Tests/declare_device_resident.c\", line 153: error: function \"main\" has already been defined\n  int main(){\n      ^\n\n\"/home/exouser/Testsuite/Tests/declare_device_resident.c\", line 155: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n9 errors detected in the compilation of \"/home/exouser/Testsuite/Tests/declare_device_resident.c\".\n",
                    "export": false,
                    "output": "",
                    "result": 2,
                    "runtime": 0.06672843405976892
                },
                "post-compile commands": [],
                "pre-compile commands": [],
                "runtime": {
                    "export": false,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -DT2 -o /home/exouser/Testsuite/build/declare_device_resident.c/declare_device_resident.c2 /home/exouser/Testsuite/Tests/declare_device_resident.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/acc_testsuite_declare.h\", line 128: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n\"/home/exouser/Testsuite/Tests/acc_testsuite_declare.h\", line 129: warning: variable \"failed\" was declared but never referenced\n      int failed;\n          ^\n\n\"/home/exouser/Testsuite/Tests/declare_device_resident.c\", line 5: error: identifier \"fixed_size_array\" is undefined\n  #pragma acc declare device_resident(fixed_size_array)\n                                      ^\n\n\"/home/exouser/Testsuite/Tests/declare_device_resident.c\", line 6: error: identifier \"scalar\" is undefined\n  #pragma acc declare device_resident(scalar)\n                                      ^\n\n\"/home/exouser/Testsuite/Tests/declare_device_resident.c\", line 7: error: identifier \"datapointer\" is undefined\n  #pragma acc declare device_resident(datapointer)\n                                      ^\n\n\"/home/exouser/Testsuite/Tests/declare_device_resident.c\", line 23: error: identifier \"scalar\" is undefined\n        scalar = 10;\n        ^\n\n\"/home/exouser/Testsuite/Tests/declare_device_resident.c\", line 25: error: identifier \"fixed_size_array\" is undefined\n          fixed_size_array[x] = x*x;\n          ^\n\n\"/home/exouser/Testsuite/Tests/declare_device_resident.c\", line 34: error: identifier \"fixed_size_array\" is undefined\n      #pragma acc data copyin(a[0:n]) copyout(b[0:n]) present(fixed_size_array)\n                                                              ^\n\n\"/home/exouser/Testsuite/Tests/declare_device_resident.c\", line 40: error: identifier \"fixed_size_array\" is undefined\n                  fixed_size_array[x] = x*x;\n                  ^\n\n\"/home/exouser/Testsuite/Tests/declare_device_resident.c\", line 47: error: identifier \"fixed_size_array\" is undefined\n                  b[x] = a[x] + fixed_size_array[x%10];\n                                ^\n\n\"/home/exouser/Testsuite/Tests/declare_device_resident.c\", line 18: warning: variable \"mult\" was declared but never referenced\n      int mult = 2;\n          ^\n\n\"/home/exouser/Testsuite/Tests/declare_device_resident.c\", line 120: error: identifier \"scalar\" is undefined\n        scalar = 10;\n        ^\n\n\"/home/exouser/Testsuite/Tests/declare_device_resident.c\", line 122: error: identifier \"fixed_size_array\" is undefined\n          fixed_size_array[x] = x*x;\n          ^\n\n\"/home/exouser/Testsuite/Tests/declare_device_resident.c\", line 137: warning: function \"extern_multiplyData_device_resident\" declared implicitly\n                  extern_multiplyData_device_resident(a, n);\n                  ^\n\n\"/home/exouser/Testsuite/Tests/declare_device_resident.c\", line 115: warning: variable \"mult\" was declared but never referenced\n      int mult = 2;\n          ^\n\n\"/home/exouser/Testsuite/Tests/declare_device_resident.c\", line 153: error: function \"main\" has already been defined\n  int main(){\n      ^\n\n\"/home/exouser/Testsuite/Tests/declare_device_resident.c\", line 155: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n11 errors detected in the compilation of \"/home/exouser/Testsuite/Tests/declare_device_resident.c\".\n",
                    "export": false,
                    "output": "",
                    "result": 2,
                    "runtime": 0.06633149087429047
                },
                "post-compile commands": [],
                "pre-compile commands": [],
                "runtime": {
                    "export": false,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -DT1 -o /home/exouser/Testsuite/build/declare_device_resident.c/declare_device_resident.c3 /home/exouser/Testsuite/Tests/declare_device_resident.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/acc_testsuite_declare.h\", line 128: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n\"/home/exouser/Testsuite/Tests/acc_testsuite_declare.h\", line 129: warning: variable \"failed\" was declared but never referenced\n      int failed;\n          ^\n\n\"/home/exouser/Testsuite/Tests/declare_device_resident.c\", line 5: error: identifier \"fixed_size_array\" is undefined\n  #pragma acc declare device_resident(fixed_size_array)\n                                      ^\n\n\"/home/exouser/Testsuite/Tests/declare_device_resident.c\", line 6: error: identifier \"scalar\" is undefined\n  #pragma acc declare device_resident(scalar)\n                                      ^\n\n\"/home/exouser/Testsuite/Tests/declare_device_resident.c\", line 7: error: identifier \"datapointer\" is undefined\n  #pragma acc declare device_resident(datapointer)\n                                      ^\n\n\"/home/exouser/Testsuite/Tests/declare_device_resident.c\", line 75: error: identifier \"scalar\" is undefined\n        scalar = 10;\n        ^\n\n\"/home/exouser/Testsuite/Tests/declare_device_resident.c\", line 77: error: identifier \"fixed_size_array\" is undefined\n          fixed_size_array[x] = x*x;\n          ^\n\n\"/home/exouser/Testsuite/Tests/declare_device_resident.c\", line 92: error: identifier \"scalar\" is undefined\n                  b[x] = a[x] + scalar;\n                                ^\n\n\"/home/exouser/Testsuite/Tests/declare_device_resident.c\", line 70: warning: variable \"mult\" was declared but never referenced\n      int mult = 2;\n          ^\n\n\"/home/exouser/Testsuite/Tests/declare_device_resident.c\", line 120: error: identifier \"scalar\" is undefined\n        scalar = 10;\n        ^\n\n\"/home/exouser/Testsuite/Tests/declare_device_resident.c\", line 122: error: identifier \"fixed_size_array\" is undefined\n          fixed_size_array[x] = x*x;\n          ^\n\n\"/home/exouser/Testsuite/Tests/declare_device_resident.c\", line 137: warning: function \"extern_multiplyData_device_resident\" declared implicitly\n                  extern_multiplyData_device_resident(a, n);\n                  ^\n\n\"/home/exouser/Testsuite/Tests/declare_device_resident.c\", line 115: warning: variable \"mult\" was declared but never referenced\n      int mult = 2;\n          ^\n\n\"/home/exouser/Testsuite/Tests/declare_device_resident.c\", line 153: error: function \"main\" has already been defined\n  int main(){\n      ^\n\n\"/home/exouser/Testsuite/Tests/declare_device_resident.c\", line 155: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n9 errors detected in the compilation of \"/home/exouser/Testsuite/Tests/declare_device_resident.c\".\n",
                    "export": false,
                    "output": "",
                    "result": 2,
                    "runtime": 0.066846271045506
                },
                "post-compile commands": [],
                "pre-compile commands": [],
                "runtime": {
                    "export": false,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -DT3 -o /home/exouser/Testsuite/build/declare_device_resident.c/declare_device_resident.c4 /home/exouser/Testsuite/Tests/declare_device_resident.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/acc_testsuite_declare.h\", line 128: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n\"/home/exouser/Testsuite/Tests/acc_testsuite_declare.h\", line 129: warning: variable \"failed\" was declared but never referenced\n      int failed;\n          ^\n\n\"/home/exouser/Testsuite/Tests/declare_device_resident.c\", line 5: error: identifier \"fixed_size_array\" is undefined\n  #pragma acc declare device_resident(fixed_size_array)\n                                      ^\n\n\"/home/exouser/Testsuite/Tests/declare_device_resident.c\", line 6: error: identifier \"scalar\" is undefined\n  #pragma acc declare device_resident(scalar)\n                                      ^\n\n\"/home/exouser/Testsuite/Tests/declare_device_resident.c\", line 7: error: identifier \"datapointer\" is undefined\n  #pragma acc declare device_resident(datapointer)\n                                      ^\n\n\"/home/exouser/Testsuite/Tests/declare_device_resident.c\", line 23: error: identifier \"scalar\" is undefined\n        scalar = 10;\n        ^\n\n\"/home/exouser/Testsuite/Tests/declare_device_resident.c\", line 25: error: identifier \"fixed_size_array\" is undefined\n          fixed_size_array[x] = x*x;\n          ^\n\n\"/home/exouser/Testsuite/Tests/declare_device_resident.c\", line 34: error: identifier \"fixed_size_array\" is undefined\n      #pragma acc data copyin(a[0:n]) copyout(b[0:n]) present(fixed_size_array)\n                                                              ^\n\n\"/home/exouser/Testsuite/Tests/declare_device_resident.c\", line 40: error: identifier \"fixed_size_array\" is undefined\n                  fixed_size_array[x] = x*x;\n                  ^\n\n\"/home/exouser/Testsuite/Tests/declare_device_resident.c\", line 47: error: identifier \"fixed_size_array\" is undefined\n                  b[x] = a[x] + fixed_size_array[x%10];\n                                ^\n\n\"/home/exouser/Testsuite/Tests/declare_device_resident.c\", line 18: warning: variable \"mult\" was declared but never referenced\n      int mult = 2;\n          ^\n\n\"/home/exouser/Testsuite/Tests/declare_device_resident.c\", line 75: error: identifier \"scalar\" is undefined\n        scalar = 10;\n        ^\n\n\"/home/exouser/Testsuite/Tests/declare_device_resident.c\", line 77: error: identifier \"fixed_size_array\" is undefined\n          fixed_size_array[x] = x*x;\n          ^\n\n\"/home/exouser/Testsuite/Tests/declare_device_resident.c\", line 92: error: identifier \"scalar\" is undefined\n                  b[x] = a[x] + scalar;\n                                ^\n\n\"/home/exouser/Testsuite/Tests/declare_device_resident.c\", line 70: warning: variable \"mult\" was declared but never referenced\n      int mult = 2;\n          ^\n\n\"/home/exouser/Testsuite/Tests/declare_device_resident.c\", line 153: error: function \"main\" has already been defined\n  int main(){\n      ^\n\n\"/home/exouser/Testsuite/Tests/declare_device_resident.c\", line 155: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n12 errors detected in the compilation of \"/home/exouser/Testsuite/Tests/declare_device_resident.c\".\n",
                    "export": false,
                    "output": "",
                    "result": 2,
                    "runtime": 0.06690565356984735
                },
                "post-compile commands": [],
                "pre-compile commands": [],
                "runtime": {
                    "export": false,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -DT1 -o /home/exouser/Testsuite/build/declare_device_resident.c/declare_device_resident.c5 /home/exouser/Testsuite/Tests/declare_device_resident.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/acc_testsuite_declare.h\", line 128: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n\"/home/exouser/Testsuite/Tests/acc_testsuite_declare.h\", line 129: warning: variable \"failed\" was declared but never referenced\n      int failed;\n          ^\n\n\"/home/exouser/Testsuite/Tests/declare_device_resident.c\", line 5: error: identifier \"fixed_size_array\" is undefined\n  #pragma acc declare device_resident(fixed_size_array)\n                                      ^\n\n\"/home/exouser/Testsuite/Tests/declare_device_resident.c\", line 6: error: identifier \"scalar\" is undefined\n  #pragma acc declare device_resident(scalar)\n                                      ^\n\n\"/home/exouser/Testsuite/Tests/declare_device_resident.c\", line 7: error: identifier \"datapointer\" is undefined\n  #pragma acc declare device_resident(datapointer)\n                                      ^\n\n\"/home/exouser/Testsuite/Tests/declare_device_resident.c\", line 75: error: identifier \"scalar\" is undefined\n        scalar = 10;\n        ^\n\n\"/home/exouser/Testsuite/Tests/declare_device_resident.c\", line 77: error: identifier \"fixed_size_array\" is undefined\n          fixed_size_array[x] = x*x;\n          ^\n\n\"/home/exouser/Testsuite/Tests/declare_device_resident.c\", line 92: error: identifier \"scalar\" is undefined\n                  b[x] = a[x] + scalar;\n                                ^\n\n\"/home/exouser/Testsuite/Tests/declare_device_resident.c\", line 70: warning: variable \"mult\" was declared but never referenced\n      int mult = 2;\n          ^\n\n\"/home/exouser/Testsuite/Tests/declare_device_resident.c\", line 120: error: identifier \"scalar\" is undefined\n        scalar = 10;\n        ^\n\n\"/home/exouser/Testsuite/Tests/declare_device_resident.c\", line 122: error: identifier \"fixed_size_array\" is undefined\n          fixed_size_array[x] = x*x;\n          ^\n\n\"/home/exouser/Testsuite/Tests/declare_device_resident.c\", line 137: warning: function \"extern_multiplyData_device_resident\" declared implicitly\n                  extern_multiplyData_device_resident(a, n);\n                  ^\n\n\"/home/exouser/Testsuite/Tests/declare_device_resident.c\", line 115: warning: variable \"mult\" was declared but never referenced\n      int mult = 2;\n          ^\n\n\"/home/exouser/Testsuite/Tests/declare_device_resident.c\", line 153: error: function \"main\" has already been defined\n  int main(){\n      ^\n\n\"/home/exouser/Testsuite/Tests/declare_device_resident.c\", line 155: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n9 errors detected in the compilation of \"/home/exouser/Testsuite/Tests/declare_device_resident.c\".\n",
                    "export": false,
                    "output": "",
                    "result": 2,
                    "runtime": 0.06705396296456456
                },
                "post-compile commands": [],
                "pre-compile commands": [],
                "runtime": {
                    "export": false,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -DT2 -o /home/exouser/Testsuite/build/declare_device_resident.c/declare_device_resident.c6 /home/exouser/Testsuite/Tests/declare_device_resident.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/acc_testsuite_declare.h\", line 128: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n\"/home/exouser/Testsuite/Tests/acc_testsuite_declare.h\", line 129: warning: variable \"failed\" was declared but never referenced\n      int failed;\n          ^\n\n\"/home/exouser/Testsuite/Tests/declare_device_resident.c\", line 5: error: identifier \"fixed_size_array\" is undefined\n  #pragma acc declare device_resident(fixed_size_array)\n                                      ^\n\n\"/home/exouser/Testsuite/Tests/declare_device_resident.c\", line 6: error: identifier \"scalar\" is undefined\n  #pragma acc declare device_resident(scalar)\n                                      ^\n\n\"/home/exouser/Testsuite/Tests/declare_device_resident.c\", line 7: error: identifier \"datapointer\" is undefined\n  #pragma acc declare device_resident(datapointer)\n                                      ^\n\n\"/home/exouser/Testsuite/Tests/declare_device_resident.c\", line 23: error: identifier \"scalar\" is undefined\n        scalar = 10;\n        ^\n\n\"/home/exouser/Testsuite/Tests/declare_device_resident.c\", line 25: error: identifier \"fixed_size_array\" is undefined\n          fixed_size_array[x] = x*x;\n          ^\n\n\"/home/exouser/Testsuite/Tests/declare_device_resident.c\", line 34: error: identifier \"fixed_size_array\" is undefined\n      #pragma acc data copyin(a[0:n]) copyout(b[0:n]) present(fixed_size_array)\n                                                              ^\n\n\"/home/exouser/Testsuite/Tests/declare_device_resident.c\", line 40: error: identifier \"fixed_size_array\" is undefined\n                  fixed_size_array[x] = x*x;\n                  ^\n\n\"/home/exouser/Testsuite/Tests/declare_device_resident.c\", line 47: error: identifier \"fixed_size_array\" is undefined\n                  b[x] = a[x] + fixed_size_array[x%10];\n                                ^\n\n\"/home/exouser/Testsuite/Tests/declare_device_resident.c\", line 18: warning: variable \"mult\" was declared but never referenced\n      int mult = 2;\n          ^\n\n\"/home/exouser/Testsuite/Tests/declare_device_resident.c\", line 120: error: identifier \"scalar\" is undefined\n        scalar = 10;\n        ^\n\n\"/home/exouser/Testsuite/Tests/declare_device_resident.c\", line 122: error: identifier \"fixed_size_array\" is undefined\n          fixed_size_array[x] = x*x;\n          ^\n\n\"/home/exouser/Testsuite/Tests/declare_device_resident.c\", line 137: warning: function \"extern_multiplyData_device_resident\" declared implicitly\n                  extern_multiplyData_device_resident(a, n);\n                  ^\n\n\"/home/exouser/Testsuite/Tests/declare_device_resident.c\", line 115: warning: variable \"mult\" was declared but never referenced\n      int mult = 2;\n          ^\n\n\"/home/exouser/Testsuite/Tests/declare_device_resident.c\", line 153: error: function \"main\" has already been defined\n  int main(){\n      ^\n\n\"/home/exouser/Testsuite/Tests/declare_device_resident.c\", line 155: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n11 errors detected in the compilation of \"/home/exouser/Testsuite/Tests/declare_device_resident.c\".\n",
                    "export": false,
                    "output": "",
                    "result": 2,
                    "runtime": 0.06562370294705033
                },
                "post-compile commands": [],
                "pre-compile commands": [],
                "runtime": {
                    "export": false,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -DT1 -o /home/exouser/Testsuite/build/declare_device_resident.c/declare_device_resident.c7 /home/exouser/Testsuite/Tests/declare_device_resident.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/acc_testsuite_declare.h\", line 128: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n\"/home/exouser/Testsuite/Tests/acc_testsuite_declare.h\", line 129: warning: variable \"failed\" was declared but never referenced\n      int failed;\n          ^\n\n\"/home/exouser/Testsuite/Tests/declare_device_resident.c\", line 5: error: identifier \"fixed_size_array\" is undefined\n  #pragma acc declare device_resident(fixed_size_array)\n                                      ^\n\n\"/home/exouser/Testsuite/Tests/declare_device_resident.c\", line 6: error: identifier \"scalar\" is undefined\n  #pragma acc declare device_resident(scalar)\n                                      ^\n\n\"/home/exouser/Testsuite/Tests/declare_device_resident.c\", line 7: error: identifier \"datapointer\" is undefined\n  #pragma acc declare device_resident(datapointer)\n                                      ^\n\n\"/home/exouser/Testsuite/Tests/declare_device_resident.c\", line 75: error: identifier \"scalar\" is undefined\n        scalar = 10;\n        ^\n\n\"/home/exouser/Testsuite/Tests/declare_device_resident.c\", line 77: error: identifier \"fixed_size_array\" is undefined\n          fixed_size_array[x] = x*x;\n          ^\n\n\"/home/exouser/Testsuite/Tests/declare_device_resident.c\", line 92: error: identifier \"scalar\" is undefined\n                  b[x] = a[x] + scalar;\n                                ^\n\n\"/home/exouser/Testsuite/Tests/declare_device_resident.c\", line 70: warning: variable \"mult\" was declared but never referenced\n      int mult = 2;\n          ^\n\n\"/home/exouser/Testsuite/Tests/declare_device_resident.c\", line 120: error: identifier \"scalar\" is undefined\n        scalar = 10;\n        ^\n\n\"/home/exouser/Testsuite/Tests/declare_device_resident.c\", line 122: error: identifier \"fixed_size_array\" is undefined\n          fixed_size_array[x] = x*x;\n          ^\n\n\"/home/exouser/Testsuite/Tests/declare_device_resident.c\", line 137: warning: function \"extern_multiplyData_device_resident\" declared implicitly\n                  extern_multiplyData_device_resident(a, n);\n                  ^\n\n\"/home/exouser/Testsuite/Tests/declare_device_resident.c\", line 115: warning: variable \"mult\" was declared but never referenced\n      int mult = 2;\n          ^\n\n\"/home/exouser/Testsuite/Tests/declare_device_resident.c\", line 153: error: function \"main\" has already been defined\n  int main(){\n      ^\n\n\"/home/exouser/Testsuite/Tests/declare_device_resident.c\", line 155: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n9 errors detected in the compilation of \"/home/exouser/Testsuite/Tests/declare_device_resident.c\".\n",
                    "export": true,
                    "output": "",
                    "result": 2,
                    "runtime": 0.06582577899098396
                },
                "post-compile commands": [],
                "pre-compile commands": [],
                "runtime": {
                    "export": true,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "declare_function_scope_copy.F90": [
            {
                "compilation": {
                    "command": "nvfortran -fast -acc -ta=multicore -DT1 -DT2 -DT3 -DT4 -o /home/exouser/Testsuite/build/declare_function_scope_copy.F90/declare_function_scope_copy.F900 /home/exouser/Testsuite/Tests/declare_function_scope_copy.F90",
                    "config": 1,
                    "errors": "",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 0.4758723205886781
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 0.04734829626977444,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvfortran -fast -acc -ta=multicore -DT2 -DT3 -DT4 -o /home/exouser/Testsuite/build/declare_function_scope_copy.F90/declare_function_scope_copy.F901 /home/exouser/Testsuite/Tests/declare_function_scope_copy.F90",
                    "config": 1,
                    "errors": "",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 0.48864553682506084
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 0.7800525091588497,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvfortran -fast -acc -ta=multicore -DT1 -DT3 -DT4 -o /home/exouser/Testsuite/build/declare_function_scope_copy.F90/declare_function_scope_copy.F902 /home/exouser/Testsuite/Tests/declare_function_scope_copy.F90",
                    "config": 1,
                    "errors": "",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 0.5303589599207044
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 1.6767933960072696,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvfortran -fast -acc -ta=multicore -DT1 -DT2 -DT4 -o /home/exouser/Testsuite/build/declare_function_scope_copy.F90/declare_function_scope_copy.F903 /home/exouser/Testsuite/Tests/declare_function_scope_copy.F90",
                    "config": 1,
                    "errors": "",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 0.6422355603426695
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 0.08110733982175589,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvfortran -fast -acc -ta=multicore -DT1 -DT2 -DT3 -o /home/exouser/Testsuite/build/declare_function_scope_copy.F90/declare_function_scope_copy.F904 /home/exouser/Testsuite/Tests/declare_function_scope_copy.F90",
                    "config": 1,
                    "errors": "",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 0.6266621728427708
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 0.03207501210272312,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvfortran -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/declare_function_scope_copy.F90/declare_function_scope_copy.F905 /home/exouser/Testsuite/Tests/declare_function_scope_copy.F90",
                    "config": 1,
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.6947208899073303
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 3.679920893162489,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "declare_function_scope_copy.c": [
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -DT1 -DT2 -DT3 -DT4 -o /home/exouser/Testsuite/build/declare_function_scope_copy.c/declare_function_scope_copy.c0 /home/exouser/Testsuite/Tests/declare_function_scope_copy.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/declare_function_scope_copy.c\", line 194: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n\"/home/exouser/Testsuite/Tests/declare_function_scope_copy.c\", line 195: warning: variable \"failed\" was declared but never referenced\n      int failed;\n          ^\n\n",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 0.1674960097298026
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 0.005574352107942104,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -DT2 -DT3 -DT4 -o /home/exouser/Testsuite/build/declare_function_scope_copy.c/declare_function_scope_copy.c1 /home/exouser/Testsuite/Tests/declare_function_scope_copy.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/declare_function_scope_copy.c\", line 194: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 0.2172938077710569
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 0.010146427899599075,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -DT1 -DT3 -DT4 -o /home/exouser/Testsuite/build/declare_function_scope_copy.c/declare_function_scope_copy.c2 /home/exouser/Testsuite/Tests/declare_function_scope_copy.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/declare_function_scope_copy.c\", line 194: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 0.21747737331315875
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "Segmentation fault (core dumped)\n",
                    "export": false,
                    "output": "",
                    "result": 139,
                    "runtime": 0.16670155059546232,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -DT1 -DT2 -DT4 -o /home/exouser/Testsuite/build/declare_function_scope_copy.c/declare_function_scope_copy.c3 /home/exouser/Testsuite/Tests/declare_function_scope_copy.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/declare_function_scope_copy.c\", line 194: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 0.16702351020649076
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 0.006199510768055916,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -DT1 -DT2 -DT3 -o /home/exouser/Testsuite/build/declare_function_scope_copy.c/declare_function_scope_copy.c4 /home/exouser/Testsuite/Tests/declare_function_scope_copy.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/declare_function_scope_copy.c\", line 194: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 0.16764557315036654
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 0.006550897844135761,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -DT2 -o /home/exouser/Testsuite/build/declare_function_scope_copy.c/declare_function_scope_copy.c5 /home/exouser/Testsuite/Tests/declare_function_scope_copy.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/declare_function_scope_copy.c\", line 194: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.2171382922679186
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.010703695006668568,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "declare_function_scope_copyin.F90": [
            {
                "compilation": {
                    "command": "nvfortran -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/declare_function_scope_copyin.F90/declare_function_scope_copyin.F900 /home/exouser/Testsuite/Tests/declare_function_scope_copyin.F90",
                    "config": 1,
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.7805007016286254
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 4.6908845519647,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "declare_function_scope_copyin.c": [
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/declare_function_scope_copyin.c/declare_function_scope_copyin.c0 /home/exouser/Testsuite/Tests/declare_function_scope_copyin.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/declare_function_scope_copyin.c\", line 181: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.21686241030693054
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.010575382970273495,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "declare_function_scope_copyout.F90": [
            {
                "compilation": {
                    "command": "nvfortran -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/declare_function_scope_copyout.F90/declare_function_scope_copyout.F900 /home/exouser/Testsuite/Tests/declare_function_scope_copyout.F90",
                    "config": 1,
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.6384024587459862
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 8.184519515372813,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "declare_function_scope_copyout.c": [
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -DT1 -DT2 -DT3 -DT4 -o /home/exouser/Testsuite/build/declare_function_scope_copyout.c/declare_function_scope_copyout.c0 /home/exouser/Testsuite/Tests/declare_function_scope_copyout.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/declare_function_scope_copyout.c\", line 194: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n\"/home/exouser/Testsuite/Tests/declare_function_scope_copyout.c\", line 195: warning: variable \"failed\" was declared but never referenced\n      int failed;\n          ^\n\n",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 0.16690523782745004
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 0.006028047762811184,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -DT2 -DT3 -DT4 -o /home/exouser/Testsuite/build/declare_function_scope_copyout.c/declare_function_scope_copyout.c1 /home/exouser/Testsuite/Tests/declare_function_scope_copyout.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/declare_function_scope_copyout.c\", line 194: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 0.21770878322422504
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 0.01028636610135436,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -DT1 -DT3 -DT4 -o /home/exouser/Testsuite/build/declare_function_scope_copyout.c/declare_function_scope_copyout.c2 /home/exouser/Testsuite/Tests/declare_function_scope_copyout.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/declare_function_scope_copyout.c\", line 194: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 0.21750741312280297
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "Segmentation fault (core dumped)\n",
                    "export": false,
                    "output": "",
                    "result": 139,
                    "runtime": 0.11718879081308842,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -DT1 -DT2 -DT4 -o /home/exouser/Testsuite/build/declare_function_scope_copyout.c/declare_function_scope_copyout.c3 /home/exouser/Testsuite/Tests/declare_function_scope_copyout.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/declare_function_scope_copyout.c\", line 194: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 0.16742807999253273
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 0.006445873063057661,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -DT1 -DT2 -DT3 -o /home/exouser/Testsuite/build/declare_function_scope_copyout.c/declare_function_scope_copyout.c4 /home/exouser/Testsuite/Tests/declare_function_scope_copyout.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/declare_function_scope_copyout.c\", line 194: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 0.16719370195642114
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 0.006321649998426437,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -DT2 -o /home/exouser/Testsuite/build/declare_function_scope_copyout.c/declare_function_scope_copyout.c5 /home/exouser/Testsuite/Tests/declare_function_scope_copyout.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/declare_function_scope_copyout.c\", line 194: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.21724604768678546
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.010374493896961212,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "declare_function_scope_create.F90": [
            {
                "compilation": {
                    "command": "nvfortran -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/declare_function_scope_create.F90/declare_function_scope_create.F900 /home/exouser/Testsuite/Tests/declare_function_scope_create.F90",
                    "config": 1,
                    "errors": "NVFORTRAN-S-0309-Incorrect name, function_test, specified in END statement (/home/exouser/Testsuite/Tests/declare_function_scope_create.F90: 18)\n  0 inform,   0 warnings,   1 severes, 0 fatal for create_test\nNVFORTRAN-S-0309-Incorrect name, function_test_dev_only, specified in END statement (/home/exouser/Testsuite/Tests/declare_function_scope_create.F90: 37)\n  0 inform,   0 warnings,   1 severes, 0 fatal for create_as_present\nNVFORTRAN-W-0155-The number of subscripts is less than the rank of a (/home/exouser/Testsuite/Tests/declare_function_scope_create.F90: 70)\nNVFORTRAN-W-0155-The number of subscripts is less than the rank of b (/home/exouser/Testsuite/Tests/declare_function_scope_create.F90: 70)\nNVFORTRAN-W-0155-The number of subscripts is less than the rank of c (/home/exouser/Testsuite/Tests/declare_function_scope_create.F90: 70)\nNVFORTRAN-W-0155-The number of subscripts is less than the rank of d (/home/exouser/Testsuite/Tests/declare_function_scope_create.F90: 70)\n  0 inform,   4 warnings,   0 severes, 0 fatal for test1\nNVFORTRAN-W-0155-The number of subscripts is less than the rank of a (/home/exouser/Testsuite/Tests/declare_function_scope_create.F90: 120)\nNVFORTRAN-W-0155-The number of subscripts is less than the rank of b (/home/exouser/Testsuite/Tests/declare_function_scope_create.F90: 120)\nNVFORTRAN-W-0155-The number of subscripts is less than the rank of c (/home/exouser/Testsuite/Tests/declare_function_scope_create.F90: 120)\nNVFORTRAN-W-0155-The number of subscripts is less than the rank of d (/home/exouser/Testsuite/Tests/declare_function_scope_create.F90: 120)\n  0 inform,   4 warnings,   0 severes, 0 fatal for test2\nNVFORTRAN-W-0155-The number of subscripts is less than the rank of a (/home/exouser/Testsuite/Tests/declare_function_scope_create.F90: 174)\nNVFORTRAN-W-0155-The number of subscripts is less than the rank of b (/home/exouser/Testsuite/Tests/declare_function_scope_create.F90: 174)\nNVFORTRAN-W-0155-The number of subscripts is less than the rank of c (/home/exouser/Testsuite/Tests/declare_function_scope_create.F90: 174)\nNVFORTRAN-W-0155-The number of subscripts is less than the rank of d (/home/exouser/Testsuite/Tests/declare_function_scope_create.F90: 174)\n  0 inform,   4 warnings,   0 severes, 0 fatal for test3\n",
                    "export": false,
                    "output": "",
                    "result": 2,
                    "runtime": 0.19105966575443745
                },
                "post-compile commands": [],
                "pre-compile commands": [],
                "runtime": {
                    "export": false,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvfortran -fast -acc -ta=multicore -DT1 -o /home/exouser/Testsuite/build/declare_function_scope_create.F90/declare_function_scope_create.F901 /home/exouser/Testsuite/Tests/declare_function_scope_create.F90",
                    "config": 1,
                    "errors": "NVFORTRAN-S-0309-Incorrect name, function_test, specified in END statement (/home/exouser/Testsuite/Tests/declare_function_scope_create.F90: 18)\n  0 inform,   0 warnings,   1 severes, 0 fatal for create_test\nNVFORTRAN-S-0309-Incorrect name, function_test_dev_only, specified in END statement (/home/exouser/Testsuite/Tests/declare_function_scope_create.F90: 37)\n  0 inform,   0 warnings,   1 severes, 0 fatal for create_as_present\nNVFORTRAN-W-0155-The number of subscripts is less than the rank of a (/home/exouser/Testsuite/Tests/declare_function_scope_create.F90: 120)\nNVFORTRAN-W-0155-The number of subscripts is less than the rank of b (/home/exouser/Testsuite/Tests/declare_function_scope_create.F90: 120)\nNVFORTRAN-W-0155-The number of subscripts is less than the rank of c (/home/exouser/Testsuite/Tests/declare_function_scope_create.F90: 120)\nNVFORTRAN-W-0155-The number of subscripts is less than the rank of d (/home/exouser/Testsuite/Tests/declare_function_scope_create.F90: 120)\n  0 inform,   4 warnings,   0 severes, 0 fatal for test2\nNVFORTRAN-W-0155-The number of subscripts is less than the rank of a (/home/exouser/Testsuite/Tests/declare_function_scope_create.F90: 174)\nNVFORTRAN-W-0155-The number of subscripts is less than the rank of b (/home/exouser/Testsuite/Tests/declare_function_scope_create.F90: 174)\nNVFORTRAN-W-0155-The number of subscripts is less than the rank of c (/home/exouser/Testsuite/Tests/declare_function_scope_create.F90: 174)\nNVFORTRAN-W-0155-The number of subscripts is less than the rank of d (/home/exouser/Testsuite/Tests/declare_function_scope_create.F90: 174)\n  0 inform,   4 warnings,   0 severes, 0 fatal for test3\n",
                    "export": false,
                    "output": "",
                    "result": 2,
                    "runtime": 0.17997786402702332
                },
                "post-compile commands": [],
                "pre-compile commands": [],
                "runtime": {
                    "export": false,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvfortran -fast -acc -ta=multicore -DT2 -o /home/exouser/Testsuite/build/declare_function_scope_create.F90/declare_function_scope_create.F902 /home/exouser/Testsuite/Tests/declare_function_scope_create.F90",
                    "config": 1,
                    "errors": "NVFORTRAN-S-0309-Incorrect name, function_test, specified in END statement (/home/exouser/Testsuite/Tests/declare_function_scope_create.F90: 18)\n  0 inform,   0 warnings,   1 severes, 0 fatal for create_test\nNVFORTRAN-S-0309-Incorrect name, function_test_dev_only, specified in END statement (/home/exouser/Testsuite/Tests/declare_function_scope_create.F90: 37)\n  0 inform,   0 warnings,   1 severes, 0 fatal for create_as_present\nNVFORTRAN-W-0155-The number of subscripts is less than the rank of a (/home/exouser/Testsuite/Tests/declare_function_scope_create.F90: 70)\nNVFORTRAN-W-0155-The number of subscripts is less than the rank of b (/home/exouser/Testsuite/Tests/declare_function_scope_create.F90: 70)\nNVFORTRAN-W-0155-The number of subscripts is less than the rank of c (/home/exouser/Testsuite/Tests/declare_function_scope_create.F90: 70)\nNVFORTRAN-W-0155-The number of subscripts is less than the rank of d (/home/exouser/Testsuite/Tests/declare_function_scope_create.F90: 70)\n  0 inform,   4 warnings,   0 severes, 0 fatal for test1\nNVFORTRAN-W-0155-The number of subscripts is less than the rank of a (/home/exouser/Testsuite/Tests/declare_function_scope_create.F90: 174)\nNVFORTRAN-W-0155-The number of subscripts is less than the rank of b (/home/exouser/Testsuite/Tests/declare_function_scope_create.F90: 174)\nNVFORTRAN-W-0155-The number of subscripts is less than the rank of c (/home/exouser/Testsuite/Tests/declare_function_scope_create.F90: 174)\nNVFORTRAN-W-0155-The number of subscripts is less than the rank of d (/home/exouser/Testsuite/Tests/declare_function_scope_create.F90: 174)\n  0 inform,   4 warnings,   0 severes, 0 fatal for test3\n",
                    "export": false,
                    "output": "",
                    "result": 2,
                    "runtime": 0.1373207583092153
                },
                "post-compile commands": [],
                "pre-compile commands": [],
                "runtime": {
                    "export": false,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvfortran -fast -acc -ta=multicore -DT1 -o /home/exouser/Testsuite/build/declare_function_scope_create.F90/declare_function_scope_create.F903 /home/exouser/Testsuite/Tests/declare_function_scope_create.F90",
                    "config": 1,
                    "errors": "NVFORTRAN-S-0309-Incorrect name, function_test, specified in END statement (/home/exouser/Testsuite/Tests/declare_function_scope_create.F90: 18)\n  0 inform,   0 warnings,   1 severes, 0 fatal for create_test\nNVFORTRAN-S-0309-Incorrect name, function_test_dev_only, specified in END statement (/home/exouser/Testsuite/Tests/declare_function_scope_create.F90: 37)\n  0 inform,   0 warnings,   1 severes, 0 fatal for create_as_present\nNVFORTRAN-W-0155-The number of subscripts is less than the rank of a (/home/exouser/Testsuite/Tests/declare_function_scope_create.F90: 120)\nNVFORTRAN-W-0155-The number of subscripts is less than the rank of b (/home/exouser/Testsuite/Tests/declare_function_scope_create.F90: 120)\nNVFORTRAN-W-0155-The number of subscripts is less than the rank of c (/home/exouser/Testsuite/Tests/declare_function_scope_create.F90: 120)\nNVFORTRAN-W-0155-The number of subscripts is less than the rank of d (/home/exouser/Testsuite/Tests/declare_function_scope_create.F90: 120)\n  0 inform,   4 warnings,   0 severes, 0 fatal for test2\nNVFORTRAN-W-0155-The number of subscripts is less than the rank of a (/home/exouser/Testsuite/Tests/declare_function_scope_create.F90: 174)\nNVFORTRAN-W-0155-The number of subscripts is less than the rank of b (/home/exouser/Testsuite/Tests/declare_function_scope_create.F90: 174)\nNVFORTRAN-W-0155-The number of subscripts is less than the rank of c (/home/exouser/Testsuite/Tests/declare_function_scope_create.F90: 174)\nNVFORTRAN-W-0155-The number of subscripts is less than the rank of d (/home/exouser/Testsuite/Tests/declare_function_scope_create.F90: 174)\n  0 inform,   4 warnings,   0 severes, 0 fatal for test3\n",
                    "export": false,
                    "output": "",
                    "result": 2,
                    "runtime": 0.12429072428494692
                },
                "post-compile commands": [],
                "pre-compile commands": [],
                "runtime": {
                    "export": false,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvfortran -fast -acc -ta=multicore -DT3 -o /home/exouser/Testsuite/build/declare_function_scope_create.F90/declare_function_scope_create.F904 /home/exouser/Testsuite/Tests/declare_function_scope_create.F90",
                    "config": 1,
                    "errors": "NVFORTRAN-S-0309-Incorrect name, function_test, specified in END statement (/home/exouser/Testsuite/Tests/declare_function_scope_create.F90: 18)\n  0 inform,   0 warnings,   1 severes, 0 fatal for create_test\nNVFORTRAN-S-0309-Incorrect name, function_test_dev_only, specified in END statement (/home/exouser/Testsuite/Tests/declare_function_scope_create.F90: 37)\n  0 inform,   0 warnings,   1 severes, 0 fatal for create_as_present\nNVFORTRAN-W-0155-The number of subscripts is less than the rank of a (/home/exouser/Testsuite/Tests/declare_function_scope_create.F90: 70)\nNVFORTRAN-W-0155-The number of subscripts is less than the rank of b (/home/exouser/Testsuite/Tests/declare_function_scope_create.F90: 70)\nNVFORTRAN-W-0155-The number of subscripts is less than the rank of c (/home/exouser/Testsuite/Tests/declare_function_scope_create.F90: 70)\nNVFORTRAN-W-0155-The number of subscripts is less than the rank of d (/home/exouser/Testsuite/Tests/declare_function_scope_create.F90: 70)\n  0 inform,   4 warnings,   0 severes, 0 fatal for test1\nNVFORTRAN-W-0155-The number of subscripts is less than the rank of a (/home/exouser/Testsuite/Tests/declare_function_scope_create.F90: 120)\nNVFORTRAN-W-0155-The number of subscripts is less than the rank of b (/home/exouser/Testsuite/Tests/declare_function_scope_create.F90: 120)\nNVFORTRAN-W-0155-The number of subscripts is less than the rank of c (/home/exouser/Testsuite/Tests/declare_function_scope_create.F90: 120)\nNVFORTRAN-W-0155-The number of subscripts is less than the rank of d (/home/exouser/Testsuite/Tests/declare_function_scope_create.F90: 120)\n  0 inform,   4 warnings,   0 severes, 0 fatal for test2\n",
                    "export": false,
                    "output": "",
                    "result": 2,
                    "runtime": 0.1730021731927991
                },
                "post-compile commands": [],
                "pre-compile commands": [],
                "runtime": {
                    "export": false,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvfortran -fast -acc -ta=multicore -DT1 -o /home/exouser/Testsuite/build/declare_function_scope_create.F90/declare_function_scope_create.F905 /home/exouser/Testsuite/Tests/declare_function_scope_create.F90",
                    "config": 1,
                    "errors": "NVFORTRAN-S-0309-Incorrect name, function_test, specified in END statement (/home/exouser/Testsuite/Tests/declare_function_scope_create.F90: 18)\n  0 inform,   0 warnings,   1 severes, 0 fatal for create_test\nNVFORTRAN-S-0309-Incorrect name, function_test_dev_only, specified in END statement (/home/exouser/Testsuite/Tests/declare_function_scope_create.F90: 37)\n  0 inform,   0 warnings,   1 severes, 0 fatal for create_as_present\nNVFORTRAN-W-0155-The number of subscripts is less than the rank of a (/home/exouser/Testsuite/Tests/declare_function_scope_create.F90: 120)\nNVFORTRAN-W-0155-The number of subscripts is less than the rank of b (/home/exouser/Testsuite/Tests/declare_function_scope_create.F90: 120)\nNVFORTRAN-W-0155-The number of subscripts is less than the rank of c (/home/exouser/Testsuite/Tests/declare_function_scope_create.F90: 120)\nNVFORTRAN-W-0155-The number of subscripts is less than the rank of d (/home/exouser/Testsuite/Tests/declare_function_scope_create.F90: 120)\n  0 inform,   4 warnings,   0 severes, 0 fatal for test2\nNVFORTRAN-W-0155-The number of subscripts is less than the rank of a (/home/exouser/Testsuite/Tests/declare_function_scope_create.F90: 174)\nNVFORTRAN-W-0155-The number of subscripts is less than the rank of b (/home/exouser/Testsuite/Tests/declare_function_scope_create.F90: 174)\nNVFORTRAN-W-0155-The number of subscripts is less than the rank of c (/home/exouser/Testsuite/Tests/declare_function_scope_create.F90: 174)\nNVFORTRAN-W-0155-The number of subscripts is less than the rank of d (/home/exouser/Testsuite/Tests/declare_function_scope_create.F90: 174)\n  0 inform,   4 warnings,   0 severes, 0 fatal for test3\n",
                    "export": false,
                    "output": "",
                    "result": 2,
                    "runtime": 0.17920597176998854
                },
                "post-compile commands": [],
                "pre-compile commands": [],
                "runtime": {
                    "export": false,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvfortran -fast -acc -ta=multicore -DT2 -o /home/exouser/Testsuite/build/declare_function_scope_create.F90/declare_function_scope_create.F906 /home/exouser/Testsuite/Tests/declare_function_scope_create.F90",
                    "config": 1,
                    "errors": "NVFORTRAN-S-0309-Incorrect name, function_test, specified in END statement (/home/exouser/Testsuite/Tests/declare_function_scope_create.F90: 18)\n  0 inform,   0 warnings,   1 severes, 0 fatal for create_test\nNVFORTRAN-S-0309-Incorrect name, function_test_dev_only, specified in END statement (/home/exouser/Testsuite/Tests/declare_function_scope_create.F90: 37)\n  0 inform,   0 warnings,   1 severes, 0 fatal for create_as_present\nNVFORTRAN-W-0155-The number of subscripts is less than the rank of a (/home/exouser/Testsuite/Tests/declare_function_scope_create.F90: 70)\nNVFORTRAN-W-0155-The number of subscripts is less than the rank of b (/home/exouser/Testsuite/Tests/declare_function_scope_create.F90: 70)\nNVFORTRAN-W-0155-The number of subscripts is less than the rank of c (/home/exouser/Testsuite/Tests/declare_function_scope_create.F90: 70)\nNVFORTRAN-W-0155-The number of subscripts is less than the rank of d (/home/exouser/Testsuite/Tests/declare_function_scope_create.F90: 70)\n  0 inform,   4 warnings,   0 severes, 0 fatal for test1\nNVFORTRAN-W-0155-The number of subscripts is less than the rank of a (/home/exouser/Testsuite/Tests/declare_function_scope_create.F90: 174)\nNVFORTRAN-W-0155-The number of subscripts is less than the rank of b (/home/exouser/Testsuite/Tests/declare_function_scope_create.F90: 174)\nNVFORTRAN-W-0155-The number of subscripts is less than the rank of c (/home/exouser/Testsuite/Tests/declare_function_scope_create.F90: 174)\nNVFORTRAN-W-0155-The number of subscripts is less than the rank of d (/home/exouser/Testsuite/Tests/declare_function_scope_create.F90: 174)\n  0 inform,   4 warnings,   0 severes, 0 fatal for test3\n",
                    "export": false,
                    "output": "",
                    "result": 2,
                    "runtime": 0.1925627002492547
                },
                "post-compile commands": [],
                "pre-compile commands": [],
                "runtime": {
                    "export": false,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvfortran -fast -acc -ta=multicore -DT1 -o /home/exouser/Testsuite/build/declare_function_scope_create.F90/declare_function_scope_create.F907 /home/exouser/Testsuite/Tests/declare_function_scope_create.F90",
                    "config": 1,
                    "errors": "NVFORTRAN-S-0309-Incorrect name, function_test, specified in END statement (/home/exouser/Testsuite/Tests/declare_function_scope_create.F90: 18)\n  0 inform,   0 warnings,   1 severes, 0 fatal for create_test\nNVFORTRAN-S-0309-Incorrect name, function_test_dev_only, specified in END statement (/home/exouser/Testsuite/Tests/declare_function_scope_create.F90: 37)\n  0 inform,   0 warnings,   1 severes, 0 fatal for create_as_present\nNVFORTRAN-W-0155-The number of subscripts is less than the rank of a (/home/exouser/Testsuite/Tests/declare_function_scope_create.F90: 120)\nNVFORTRAN-W-0155-The number of subscripts is less than the rank of b (/home/exouser/Testsuite/Tests/declare_function_scope_create.F90: 120)\nNVFORTRAN-W-0155-The number of subscripts is less than the rank of c (/home/exouser/Testsuite/Tests/declare_function_scope_create.F90: 120)\nNVFORTRAN-W-0155-The number of subscripts is less than the rank of d (/home/exouser/Testsuite/Tests/declare_function_scope_create.F90: 120)\n  0 inform,   4 warnings,   0 severes, 0 fatal for test2\nNVFORTRAN-W-0155-The number of subscripts is less than the rank of a (/home/exouser/Testsuite/Tests/declare_function_scope_create.F90: 174)\nNVFORTRAN-W-0155-The number of subscripts is less than the rank of b (/home/exouser/Testsuite/Tests/declare_function_scope_create.F90: 174)\nNVFORTRAN-W-0155-The number of subscripts is less than the rank of c (/home/exouser/Testsuite/Tests/declare_function_scope_create.F90: 174)\nNVFORTRAN-W-0155-The number of subscripts is less than the rank of d (/home/exouser/Testsuite/Tests/declare_function_scope_create.F90: 174)\n  0 inform,   4 warnings,   0 severes, 0 fatal for test3\n",
                    "export": true,
                    "output": "",
                    "result": 2,
                    "runtime": 0.18426157115027308
                },
                "post-compile commands": [],
                "pre-compile commands": [],
                "runtime": {
                    "export": true,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "declare_function_scope_create.c": [
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/declare_function_scope_create.c/declare_function_scope_create.c0 /home/exouser/Testsuite/Tests/declare_function_scope_create.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/declare_function_scope_create.c\", line 168: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 0.31746929697692394
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "Segmentation fault (core dumped)\n",
                    "export": false,
                    "output": "",
                    "result": 139,
                    "runtime": 0.11682160012423992,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -DT1 -o /home/exouser/Testsuite/build/declare_function_scope_create.c/declare_function_scope_create.c1 /home/exouser/Testsuite/Tests/declare_function_scope_create.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/declare_function_scope_create.c\", line 168: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 0.26816770527511835
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "Segmentation fault (core dumped)\n",
                    "export": false,
                    "output": "",
                    "result": 139,
                    "runtime": 0.11735054990276694,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -DT2 -o /home/exouser/Testsuite/build/declare_function_scope_create.c/declare_function_scope_create.c2 /home/exouser/Testsuite/Tests/declare_function_scope_create.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/declare_function_scope_create.c\", line 168: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.2680774559266865
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.011078340001404285,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "declare_function_scope_deviceptr.c": [
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/declare_function_scope_deviceptr.c/declare_function_scope_deviceptr.c0 /home/exouser/Testsuite/Tests/declare_function_scope_deviceptr.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/declare_function_scope_deviceptr.c\", line 121: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.21706876810640097
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.010172088164836168,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "declare_function_scope_present.F90": [
            {
                "compilation": {
                    "command": "nvfortran -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/declare_function_scope_present.F90/declare_function_scope_present.F900 /home/exouser/Testsuite/Tests/declare_function_scope_present.F90",
                    "config": 1,
                    "errors": "NVFORTRAN-S-0309-Incorrect name, function_test, specified in END statement (/home/exouser/Testsuite/Tests/declare_function_scope_present.F90: 18)\n  0 inform,   0 warnings,   1 severes, 0 fatal for present\nNVFORTRAN-W-0155-The number of subscripts is less than the rank of a (/home/exouser/Testsuite/Tests/declare_function_scope_present.F90: 52)\nNVFORTRAN-W-0155-The number of subscripts is less than the rank of b (/home/exouser/Testsuite/Tests/declare_function_scope_present.F90: 52)\nNVFORTRAN-W-0155-The number of subscripts is less than the rank of c (/home/exouser/Testsuite/Tests/declare_function_scope_present.F90: 52)\nNVFORTRAN-W-0155-The number of subscripts is less than the rank of d (/home/exouser/Testsuite/Tests/declare_function_scope_present.F90: 52)\n  0 inform,   4 warnings,   0 severes, 0 fatal for test1\nNVFORTRAN-W-0155-The number of subscripts is less than the rank of a (/home/exouser/Testsuite/Tests/declare_function_scope_present.F90: 107)\nNVFORTRAN-W-0155-The number of subscripts is less than the rank of b (/home/exouser/Testsuite/Tests/declare_function_scope_present.F90: 107)\nNVFORTRAN-W-0155-The number of subscripts is less than the rank of c (/home/exouser/Testsuite/Tests/declare_function_scope_present.F90: 107)\nNVFORTRAN-W-0155-The number of subscripts is less than the rank of d (/home/exouser/Testsuite/Tests/declare_function_scope_present.F90: 107)\n  0 inform,   4 warnings,   0 severes, 0 fatal for test2\n",
                    "export": false,
                    "output": "",
                    "result": 2,
                    "runtime": 0.19732867227867246
                },
                "post-compile commands": [],
                "pre-compile commands": [],
                "runtime": {
                    "export": false,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvfortran -fast -acc -ta=multicore -DT1 -o /home/exouser/Testsuite/build/declare_function_scope_present.F90/declare_function_scope_present.F901 /home/exouser/Testsuite/Tests/declare_function_scope_present.F90",
                    "config": 1,
                    "errors": "NVFORTRAN-S-0309-Incorrect name, function_test, specified in END statement (/home/exouser/Testsuite/Tests/declare_function_scope_present.F90: 18)\n  0 inform,   0 warnings,   1 severes, 0 fatal for present\nNVFORTRAN-W-0155-The number of subscripts is less than the rank of a (/home/exouser/Testsuite/Tests/declare_function_scope_present.F90: 107)\nNVFORTRAN-W-0155-The number of subscripts is less than the rank of b (/home/exouser/Testsuite/Tests/declare_function_scope_present.F90: 107)\nNVFORTRAN-W-0155-The number of subscripts is less than the rank of c (/home/exouser/Testsuite/Tests/declare_function_scope_present.F90: 107)\nNVFORTRAN-W-0155-The number of subscripts is less than the rank of d (/home/exouser/Testsuite/Tests/declare_function_scope_present.F90: 107)\n  0 inform,   4 warnings,   0 severes, 0 fatal for test2\n",
                    "export": false,
                    "output": "",
                    "result": 2,
                    "runtime": 0.20366843091323972
                },
                "post-compile commands": [],
                "pre-compile commands": [],
                "runtime": {
                    "export": false,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvfortran -fast -acc -ta=multicore -DT2 -o /home/exouser/Testsuite/build/declare_function_scope_present.F90/declare_function_scope_present.F902 /home/exouser/Testsuite/Tests/declare_function_scope_present.F90",
                    "config": 1,
                    "errors": "NVFORTRAN-S-0309-Incorrect name, function_test, specified in END statement (/home/exouser/Testsuite/Tests/declare_function_scope_present.F90: 18)\n  0 inform,   0 warnings,   1 severes, 0 fatal for present\nNVFORTRAN-W-0155-The number of subscripts is less than the rank of a (/home/exouser/Testsuite/Tests/declare_function_scope_present.F90: 52)\nNVFORTRAN-W-0155-The number of subscripts is less than the rank of b (/home/exouser/Testsuite/Tests/declare_function_scope_present.F90: 52)\nNVFORTRAN-W-0155-The number of subscripts is less than the rank of c (/home/exouser/Testsuite/Tests/declare_function_scope_present.F90: 52)\nNVFORTRAN-W-0155-The number of subscripts is less than the rank of d (/home/exouser/Testsuite/Tests/declare_function_scope_present.F90: 52)\n  0 inform,   4 warnings,   0 severes, 0 fatal for test1\n",
                    "export": false,
                    "output": "",
                    "result": 2,
                    "runtime": 0.1413536872714758
                },
                "post-compile commands": [],
                "pre-compile commands": [],
                "runtime": {
                    "export": false,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvfortran -fast -acc -ta=multicore -DT1 -o /home/exouser/Testsuite/build/declare_function_scope_present.F90/declare_function_scope_present.F903 /home/exouser/Testsuite/Tests/declare_function_scope_present.F90",
                    "config": 1,
                    "errors": "NVFORTRAN-S-0309-Incorrect name, function_test, specified in END statement (/home/exouser/Testsuite/Tests/declare_function_scope_present.F90: 18)\n  0 inform,   0 warnings,   1 severes, 0 fatal for present\nNVFORTRAN-W-0155-The number of subscripts is less than the rank of a (/home/exouser/Testsuite/Tests/declare_function_scope_present.F90: 107)\nNVFORTRAN-W-0155-The number of subscripts is less than the rank of b (/home/exouser/Testsuite/Tests/declare_function_scope_present.F90: 107)\nNVFORTRAN-W-0155-The number of subscripts is less than the rank of c (/home/exouser/Testsuite/Tests/declare_function_scope_present.F90: 107)\nNVFORTRAN-W-0155-The number of subscripts is less than the rank of d (/home/exouser/Testsuite/Tests/declare_function_scope_present.F90: 107)\n  0 inform,   4 warnings,   0 severes, 0 fatal for test2\n",
                    "export": true,
                    "output": "",
                    "result": 2,
                    "runtime": 0.14329125080257654
                },
                "post-compile commands": [],
                "pre-compile commands": [],
                "runtime": {
                    "export": true,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "declare_function_scope_present.c": [
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/declare_function_scope_present.c/declare_function_scope_present.c0 /home/exouser/Testsuite/Tests/declare_function_scope_present.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/declare_function_scope_present.c\", line 119: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.217612081207335
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.01024774694815278,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "enter_data_copyin_no_lower_bound.F90": [
            {
                "compilation": {
                    "command": "nvfortran -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/enter_data_copyin_no_lower_bound.F90/enter_data_copyin_no_lower_bound.F900 /home/exouser/Testsuite/Tests/enter_data_copyin_no_lower_bound.F90",
                    "config": 1,
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.5261928453110158
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.136122636962682,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "enter_data_copyin_no_lower_bound.c": [
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/enter_data_copyin_no_lower_bound.c/enter_data_copyin_no_lower_bound.c0 /home/exouser/Testsuite/Tests/enter_data_copyin_no_lower_bound.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/enter_data_copyin_no_lower_bound.c\", line 39: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.1673688441514969
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.010452008806169033,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "enter_data_create.F90": [
            {
                "compilation": {
                    "command": "nvfortran -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/enter_data_create.F90/enter_data_create.F900 /home/exouser/Testsuite/Tests/enter_data_create.F90",
                    "config": 1,
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.5796469482593238
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.1906323079019785,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "enter_data_create.c": [
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/enter_data_create.c/enter_data_create.c0 /home/exouser/Testsuite/Tests/enter_data_create.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/enter_data_create.c\", line 149: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.21731867315247655
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.010491590946912766,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "enter_data_create_no_lower_bound.F90": [
            {
                "compilation": {
                    "command": "nvfortran -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/enter_data_create_no_lower_bound.F90/enter_data_create_no_lower_bound.F900 /home/exouser/Testsuite/Tests/enter_data_create_no_lower_bound.F90",
                    "config": 1,
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.43458453472703695
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.1312781092710793,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "enter_data_create_no_lower_bound.c": [
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/enter_data_create_no_lower_bound.c/enter_data_create_no_lower_bound.c0 /home/exouser/Testsuite/Tests/enter_data_create_no_lower_bound.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/enter_data_create_no_lower_bound.c\", line 39: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.21727641392499208
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.01073999423533678,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "enter_data_if.F90": [
            {
                "compilation": {
                    "command": "nvfortran -fast -acc -ta=multicore -DT1 -DT2 -DT3 -DT4 -DT5 -o /home/exouser/Testsuite/build/enter_data_if.F90/enter_data_if.F900 /home/exouser/Testsuite/Tests/enter_data_if.F90",
                    "config": 1,
                    "errors": "",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 0.3805726710706949
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 0.07581673702225089,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvfortran -fast -acc -ta=multicore -DT2 -DT3 -DT4 -DT5 -o /home/exouser/Testsuite/build/enter_data_if.F90/enter_data_if.F901 /home/exouser/Testsuite/Tests/enter_data_if.F90",
                    "config": 1,
                    "errors": "",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 0.4228812921792269
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 0.12333473516628146,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvfortran -fast -acc -ta=multicore -DT1 -DT3 -DT4 -DT5 -o /home/exouser/Testsuite/build/enter_data_if.F90/enter_data_if.F902 /home/exouser/Testsuite/Tests/enter_data_if.F90",
                    "config": 1,
                    "errors": "",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 0.4881390109658241
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 0.07936864299699664,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvfortran -fast -acc -ta=multicore -DT1 -DT2 -DT4 -DT5 -o /home/exouser/Testsuite/build/enter_data_if.F90/enter_data_if.F903 /home/exouser/Testsuite/Tests/enter_data_if.F90",
                    "config": 1,
                    "errors": "",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 0.5383070111274719
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 0.05705529032275081,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvfortran -fast -acc -ta=multicore -DT1 -DT2 -DT3 -DT5 -o /home/exouser/Testsuite/build/enter_data_if.F90/enter_data_if.F904 /home/exouser/Testsuite/Tests/enter_data_if.F90",
                    "config": 1,
                    "errors": "",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 0.4768016398884356
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 0.07483656983822584,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvfortran -fast -acc -ta=multicore -DT1 -DT2 -DT3 -DT4 -o /home/exouser/Testsuite/build/enter_data_if.F90/enter_data_if.F905 /home/exouser/Testsuite/Tests/enter_data_if.F90",
                    "config": 1,
                    "errors": "",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 0.5304090180434287
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 0.07319916319102049,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvfortran -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/enter_data_if.F90/enter_data_if.F906 /home/exouser/Testsuite/Tests/enter_data_if.F90",
                    "config": 1,
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.6843354939483106
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.133747735992074,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "enter_exit_data_if.c": [
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -DT1 -DT2 -DT3 -DT4 -DT5 -o /home/exouser/Testsuite/build/enter_exit_data_if.c/enter_exit_data_if.c0 /home/exouser/Testsuite/Tests/enter_exit_data_if.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/enter_exit_data_if.c\", line 252: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n\"/home/exouser/Testsuite/Tests/enter_exit_data_if.c\", line 253: warning: variable \"failed\" was declared but never referenced\n      int failed;\n          ^\n\n",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 0.16707413969561458
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 0.006092295050621033,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -DT2 -DT3 -DT4 -DT5 -o /home/exouser/Testsuite/build/enter_exit_data_if.c/enter_exit_data_if.c1 /home/exouser/Testsuite/Tests/enter_exit_data_if.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/enter_exit_data_if.c\", line 11: warning: variable \"host\" was declared but never referenced\n      int host = 0;\n          ^\n\n\"/home/exouser/Testsuite/Tests/enter_exit_data_if.c\", line 252: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 0.21662352187559009
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 0.01053135609254241,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -DT1 -DT3 -DT4 -DT5 -o /home/exouser/Testsuite/build/enter_exit_data_if.c/enter_exit_data_if.c2 /home/exouser/Testsuite/Tests/enter_exit_data_if.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/enter_exit_data_if.c\", line 50: warning: variable \"dev\" was declared but never referenced\n      int dev = 1;\n          ^\n\n\"/home/exouser/Testsuite/Tests/enter_exit_data_if.c\", line 252: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 0.21677808230742812
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 0.0095666260458529,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -DT1 -DT2 -DT4 -DT5 -o /home/exouser/Testsuite/build/enter_exit_data_if.c/enter_exit_data_if.c3 /home/exouser/Testsuite/Tests/enter_exit_data_if.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/enter_exit_data_if.c\", line 93: warning: variable \"host\" was declared but never referenced\n      int host = 0;\n          ^\n\n\"/home/exouser/Testsuite/Tests/enter_exit_data_if.c\", line 252: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 0.16739705111831427
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 0.005825303960591555,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -DT1 -DT2 -DT3 -DT5 -o /home/exouser/Testsuite/build/enter_exit_data_if.c/enter_exit_data_if.c4 /home/exouser/Testsuite/Tests/enter_exit_data_if.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/enter_exit_data_if.c\", line 150: warning: variable \"dev\" was declared but never referenced\n      int dev = 1;\n          ^\n\n\"/home/exouser/Testsuite/Tests/enter_exit_data_if.c\", line 252: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 0.16681458707898855
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 0.0063154855743050575,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -DT1 -DT2 -DT3 -DT4 -o /home/exouser/Testsuite/build/enter_exit_data_if.c/enter_exit_data_if.c5 /home/exouser/Testsuite/Tests/enter_exit_data_if.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/enter_exit_data_if.c\", line 208: warning: variable \"dev\" was declared but never referenced\n      int dev = 1;\n          ^\n\n\"/home/exouser/Testsuite/Tests/enter_exit_data_if.c\", line 252: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 0.16674846410751343
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 0.005496738012880087,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/enter_exit_data_if.c/enter_exit_data_if.c6 /home/exouser/Testsuite/Tests/enter_exit_data_if.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/enter_exit_data_if.c\", line 11: warning: variable \"host\" was declared but never referenced\n      int host = 0;\n          ^\n\n\"/home/exouser/Testsuite/Tests/enter_exit_data_if.c\", line 50: warning: variable \"dev\" was declared but never referenced\n      int dev = 1;\n          ^\n\n\"/home/exouser/Testsuite/Tests/enter_exit_data_if.c\", line 93: warning: variable \"host\" was declared but never referenced\n      int host = 0;\n          ^\n\n\"/home/exouser/Testsuite/Tests/enter_exit_data_if.c\", line 150: warning: variable \"dev\" was declared but never referenced\n      int dev = 1;\n          ^\n\n\"/home/exouser/Testsuite/Tests/enter_exit_data_if.c\", line 208: warning: variable \"dev\" was declared but never referenced\n      int dev = 1;\n          ^\n\n\"/home/exouser/Testsuite/Tests/enter_exit_data_if.c\", line 252: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.26716446317732334
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.009982926771044731,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "exit_data.F90": [
            {
                "compilation": {
                    "command": "nvfortran -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/exit_data.F90/exit_data.F900 /home/exouser/Testsuite/Tests/exit_data.F90",
                    "config": 1,
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.5727869062684476
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.1326895309612155,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "exit_data.c": [
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/exit_data.c/exit_data.c0 /home/exouser/Testsuite/Tests/exit_data.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/exit_data.c\", line 80: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.1660628728568554
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.009779943153262138,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "exit_data_copyout_no_lower_bound.F90": [
            {
                "compilation": {
                    "command": "nvfortran -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/exit_data_copyout_no_lower_bound.F90/exit_data_copyout_no_lower_bound.F900 /home/exouser/Testsuite/Tests/exit_data_copyout_no_lower_bound.F90",
                    "config": 1,
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.4502323679625988
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.14788054022938013,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "exit_data_copyout_no_lower_bound.c": [
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/exit_data_copyout_no_lower_bound.c/exit_data_copyout_no_lower_bound.c0 /home/exouser/Testsuite/Tests/exit_data_copyout_no_lower_bound.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/exit_data_copyout_no_lower_bound.c\", line 39: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.21638316987082362
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.010229420848190784,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "exit_data_copyout_reference_counts.F90": [
            {
                "compilation": {
                    "command": "nvfortran -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/exit_data_copyout_reference_counts.F90/exit_data_copyout_reference_counts.F900 /home/exouser/Testsuite/Tests/exit_data_copyout_reference_counts.F90",
                    "config": 1,
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.6764560122974217
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.128932427149266,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "exit_data_copyout_reference_counts.c": [
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/exit_data_copyout_reference_counts.c/exit_data_copyout_reference_counts.c0 /home/exouser/Testsuite/Tests/exit_data_copyout_reference_counts.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/exit_data_copyout_reference_counts.c\", line 129: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.21651313174515963
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.009533018805086613,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "exit_data_delete_no_lower_bound.F90": [
            {
                "compilation": {
                    "command": "nvfortran -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/exit_data_delete_no_lower_bound.F90/exit_data_delete_no_lower_bound.F900 /home/exouser/Testsuite/Tests/exit_data_delete_no_lower_bound.F90",
                    "config": 1,
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.5844767279922962
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.1286035510711372,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "exit_data_delete_no_lower_bound.c": [
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/exit_data_delete_no_lower_bound.c/exit_data_delete_no_lower_bound.c0 /home/exouser/Testsuite/Tests/exit_data_delete_no_lower_bound.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/exit_data_delete_no_lower_bound.c\", line 33: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.16647564619779587
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.010265071876347065,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "exit_data_finalize.F90": [
            {
                "compilation": {
                    "command": "nvfortran -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/exit_data_finalize.F90/exit_data_finalize.F900 /home/exouser/Testsuite/Tests/exit_data_finalize.F90",
                    "config": 1,
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.5841945568099618
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.1454596109688282,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "exit_data_finalize.c": [
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/exit_data_finalize.c/exit_data_finalize.c0 /home/exouser/Testsuite/Tests/exit_data_finalize.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/exit_data_finalize.c\", line 90: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.21622320916503668
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.010287926997989416,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "host_data.c": [
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/host_data.c/host_data.c0 /home/exouser/Testsuite/Tests/host_data.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/host_data.c\", line 56: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.21646294509992003
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.009899185970425606,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "init.F90": [
            {
                "compilation": {
                    "command": "nvfortran -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/init.F90/init.F900 /home/exouser/Testsuite/Tests/init.F90",
                    "config": 1,
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.434402406681329
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.04881055699661374,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "init.c": [
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/init.c/init.c0 /home/exouser/Testsuite/Tests/init.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/init.c\", line 16: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.16741584613919258
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.0064447359181940556,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "init_device_num.F90": [
            {
                "compilation": {
                    "command": "nvfortran -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/init_device_num.F90/init_device_num.F900 /home/exouser/Testsuite/Tests/init_device_num.F90",
                    "config": 1,
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.4268533638678491
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.04384611779823899,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "init_device_num.c": [
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/init_device_num.c/init_device_num.c0 /home/exouser/Testsuite/Tests/init_device_num.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/init_device_num.c\", line 17: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.16687964415177703
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.005567125976085663,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "init_device_type.F90": [
            {
                "compilation": {
                    "command": "nvfortran -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/init_device_type.F90/init_device_type.F900 /home/exouser/Testsuite/Tests/init_device_type.F90",
                    "config": 1,
                    "errors": "NVFORTRAN-S-1072-Specified device type is not a valid device type. Currently accepted device types are 'nvidia, host, multicore, and default' - device_type (/home/exouser/Testsuite/Tests/init_device_type.F90: 11)\n  0 inform,   0 warnings,   1 severes, 0 fatal for test1\n",
                    "export": false,
                    "output": "",
                    "result": 2,
                    "runtime": 0.13392690615728498
                },
                "post-compile commands": [],
                "pre-compile commands": [],
                "runtime": {
                    "export": false,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvfortran -fast -acc -ta=multicore -DT1 -o /home/exouser/Testsuite/build/init_device_type.F90/init_device_type.F901 /home/exouser/Testsuite/Tests/init_device_type.F90",
                    "config": 1,
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.3857578099705279
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.02706316579133272,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "init_device_type.c": [
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/init_device_type.c/init_device_type.c0 /home/exouser/Testsuite/Tests/init_device_type.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/init_device_type.c\", line 9: error: Specified device type is not a valid device type. Currently accepted device types are 'nvidia, host, multicore, and default'\n      #pragma acc init device_type(device_type)\n                                   ^\n\n\"/home/exouser/Testsuite/Tests/init_device_type.c\", line 17: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n1 error detected in the compilation of \"/home/exouser/Testsuite/Tests/init_device_type.c\".\n",
                    "export": false,
                    "output": "",
                    "result": 2,
                    "runtime": 0.0657061473466456
                },
                "post-compile commands": [],
                "pre-compile commands": [],
                "runtime": {
                    "export": false,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -DT1 -o /home/exouser/Testsuite/build/init_device_type.c/init_device_type.c1 /home/exouser/Testsuite/Tests/init_device_type.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/init_device_type.c\", line 17: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n\"/home/exouser/Testsuite/Tests/init_device_type.c\", line 18: warning: variable \"failed\" was declared but never referenced\n      int failed;\n          ^\n\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.16659713303670287
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.005932960659265518,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "init_device_type_num.F90": [
            {
                "compilation": {
                    "command": "nvfortran -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/init_device_type_num.F90/init_device_type_num.F900 /home/exouser/Testsuite/Tests/init_device_type_num.F90",
                    "config": 1,
                    "errors": "NVFORTRAN-S-1072-Specified device type is not a valid device type. Currently accepted device types are 'nvidia, host, multicore, and default' - device_num (/home/exouser/Testsuite/Tests/init_device_type_num.F90: 13)\n  0 inform,   0 warnings,   1 severes, 0 fatal for test1\n",
                    "export": false,
                    "output": "",
                    "result": 2,
                    "runtime": 0.14260912034660578
                },
                "post-compile commands": [],
                "pre-compile commands": [],
                "runtime": {
                    "export": false,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvfortran -fast -acc -ta=multicore -DT1 -o /home/exouser/Testsuite/build/init_device_type_num.F90/init_device_type_num.F901 /home/exouser/Testsuite/Tests/init_device_type_num.F90",
                    "config": 1,
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.40574710723012686
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.04357740515843034,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "init_device_type_num.c": [
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/init_device_type_num.c/init_device_type_num.c0 /home/exouser/Testsuite/Tests/init_device_type_num.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/init_device_type_num.c\", line 8: warning: enumerated type mixed with another type\n      int device_num = acc_get_device_num(device_type);\n                                          ^\n\n\"/home/exouser/Testsuite/Tests/init_device_type_num.c\", line 10: error: Specified device type is not a valid device type. Currently accepted device types are 'nvidia, host, multicore, and default'\n      #pragma acc init device_type(device_type) device_num(device_num)\n                                   ^\n\n\"/home/exouser/Testsuite/Tests/init_device_type_num.c\", line 18: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n1 error detected in the compilation of \"/home/exouser/Testsuite/Tests/init_device_type_num.c\".\n",
                    "export": false,
                    "output": "",
                    "result": 2,
                    "runtime": 0.06565053761005402
                },
                "post-compile commands": [],
                "pre-compile commands": [],
                "runtime": {
                    "export": false,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -DT1 -o /home/exouser/Testsuite/build/init_device_type_num.c/init_device_type_num.c1 /home/exouser/Testsuite/Tests/init_device_type_num.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/init_device_type_num.c\", line 18: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n\"/home/exouser/Testsuite/Tests/init_device_type_num.c\", line 19: warning: variable \"failed\" was declared but never referenced\n      int failed;\n          ^\n\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.16638432117179036
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.006044226232916117,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "kernels_async.F90": [
            {
                "compilation": {
                    "command": "nvfortran -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/kernels_async.F90/kernels_async.F900 /home/exouser/Testsuite/Tests/kernels_async.F90",
                    "config": 1,
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.5920533249154687
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.12898374674841762,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "kernels_async.c": [
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/kernels_async.c/kernels_async.c0 /home/exouser/Testsuite/Tests/kernels_async.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/kernels_async.c\", line 74: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.21687913732603192
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.01765486318618059,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "kernels_copy.F90": [
            {
                "compilation": {
                    "command": "nvfortran -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/kernels_copy.F90/kernels_copy.F900 /home/exouser/Testsuite/Tests/kernels_copy.F90",
                    "config": 1,
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.4923296710476279
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.1254217498935759,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "kernels_copy.c": [
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/kernels_copy.c/kernels_copy.c0 /home/exouser/Testsuite/Tests/kernels_copy.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/kernels_copy.c\", line 136: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.217207795009017
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.009657199960201979,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "kernels_copyin.F90": [
            {
                "compilation": {
                    "command": "nvfortran -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/kernels_copyin.F90/kernels_copyin.F900 /home/exouser/Testsuite/Tests/kernels_copyin.F90",
                    "config": 1,
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.5889385920017958
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.09883087174966931,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "kernels_copyin.c": [
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/kernels_copyin.c/kernels_copyin.c0 /home/exouser/Testsuite/Tests/kernels_copyin.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/kernels_copyin.c\", line 91: error: identifier \"devtest\" is undefined\n      if (devtest[0] == 1){\n          ^\n\n\"/home/exouser/Testsuite/Tests/kernels_copyin.c\", line 117: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n1 error detected in the compilation of \"/home/exouser/Testsuite/Tests/kernels_copyin.c\".\n",
                    "export": false,
                    "output": "",
                    "result": 2,
                    "runtime": 0.06616178387776017
                },
                "post-compile commands": [],
                "pre-compile commands": [],
                "runtime": {
                    "export": false,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -DT1 -o /home/exouser/Testsuite/build/kernels_copyin.c/kernels_copyin.c1 /home/exouser/Testsuite/Tests/kernels_copyin.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/kernels_copyin.c\", line 91: error: identifier \"devtest\" is undefined\n      if (devtest[0] == 1){\n          ^\n\n\"/home/exouser/Testsuite/Tests/kernels_copyin.c\", line 117: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n1 error detected in the compilation of \"/home/exouser/Testsuite/Tests/kernels_copyin.c\".\n",
                    "export": false,
                    "output": "",
                    "result": 2,
                    "runtime": 0.06699122907593846
                },
                "post-compile commands": [],
                "pre-compile commands": [],
                "runtime": {
                    "export": false,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -DT2 -o /home/exouser/Testsuite/build/kernels_copyin.c/kernels_copyin.c2 /home/exouser/Testsuite/Tests/kernels_copyin.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/kernels_copyin.c\", line 91: error: identifier \"devtest\" is undefined\n      if (devtest[0] == 1){\n          ^\n\n\"/home/exouser/Testsuite/Tests/kernels_copyin.c\", line 117: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n1 error detected in the compilation of \"/home/exouser/Testsuite/Tests/kernels_copyin.c\".\n",
                    "export": false,
                    "output": "",
                    "result": 2,
                    "runtime": 0.0669326982460916
                },
                "post-compile commands": [],
                "pre-compile commands": [],
                "runtime": {
                    "export": false,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -DT1 -o /home/exouser/Testsuite/build/kernels_copyin.c/kernels_copyin.c3 /home/exouser/Testsuite/Tests/kernels_copyin.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/kernels_copyin.c\", line 91: error: identifier \"devtest\" is undefined\n      if (devtest[0] == 1){\n          ^\n\n\"/home/exouser/Testsuite/Tests/kernels_copyin.c\", line 117: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n1 error detected in the compilation of \"/home/exouser/Testsuite/Tests/kernels_copyin.c\".\n",
                    "export": false,
                    "output": "",
                    "result": 2,
                    "runtime": 0.06716383202001452
                },
                "post-compile commands": [],
                "pre-compile commands": [],
                "runtime": {
                    "export": false,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -DT3 -o /home/exouser/Testsuite/build/kernels_copyin.c/kernels_copyin.c4 /home/exouser/Testsuite/Tests/kernels_copyin.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/kernels_copyin.c\", line 117: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.1694548148661852
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.006109864916652441,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "kernels_copyout.F90": [
            {
                "compilation": {
                    "command": "nvfortran -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/kernels_copyout.F90/kernels_copyout.F900 /home/exouser/Testsuite/Tests/kernels_copyout.F90",
                    "config": 1,
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.5348513452336192
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.0885706408880651,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "kernels_copyout.c": [
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/kernels_copyout.c/kernels_copyout.c0 /home/exouser/Testsuite/Tests/kernels_copyout.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/kernels_copyout.c\", line 81: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.16654315870255232
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.0060787140391767025,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "kernels_create.F90": [
            {
                "compilation": {
                    "command": "nvfortran -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/kernels_create.F90/kernels_create.F900 /home/exouser/Testsuite/Tests/kernels_create.F90",
                    "config": 1,
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.6345324600115418
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.08957054279744625,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "kernels_create.c": [
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/kernels_create.c/kernels_create.c0 /home/exouser/Testsuite/Tests/kernels_create.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/kernels_create.c\", line 121: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.16673848824575543
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.00607638992369175,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "kernels_default_copy.F90": [
            {
                "compilation": {
                    "command": "nvfortran -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/kernels_default_copy.F90/kernels_default_copy.F900 /home/exouser/Testsuite/Tests/kernels_default_copy.F90",
                    "config": 1,
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.5301963048987091
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.13128716312348843,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "kernels_default_copy.c": [
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/kernels_default_copy.c/kernels_default_copy.c0 /home/exouser/Testsuite/Tests/kernels_default_copy.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/kernels_default_copy.c\", line 98: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.2162047210149467
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.005892290733754635,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "kernels_default_present.F90": [
            {
                "compilation": {
                    "command": "nvfortran -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/kernels_default_present.F90/kernels_default_present.F900 /home/exouser/Testsuite/Tests/kernels_default_present.F90",
                    "config": 1,
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.4842973011545837
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.12506522797048092,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "kernels_default_present.c": [
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/kernels_default_present.c/kernels_default_present.c0 /home/exouser/Testsuite/Tests/kernels_default_present.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/kernels_default_present.c\", line 37: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.16653778916224837
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.009571401868015528,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "kernels_if.F90": [
            {
                "compilation": {
                    "command": "nvfortran -fast -acc -ta=multicore -DT1 -DT2 -DT3 -DT4 -o /home/exouser/Testsuite/build/kernels_if.F90/kernels_if.F900 /home/exouser/Testsuite/Tests/kernels_if.F90",
                    "config": 1,
                    "errors": "",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 0.43828877387568355
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 0.05334335099905729,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvfortran -fast -acc -ta=multicore -DT2 -DT3 -DT4 -o /home/exouser/Testsuite/build/kernels_if.F90/kernels_if.F901 /home/exouser/Testsuite/Tests/kernels_if.F90",
                    "config": 1,
                    "errors": "",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 0.3843080070801079
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 0.0787434340454638,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvfortran -fast -acc -ta=multicore -DT1 -DT3 -DT4 -o /home/exouser/Testsuite/build/kernels_if.F90/kernels_if.F902 /home/exouser/Testsuite/Tests/kernels_if.F90",
                    "config": 1,
                    "errors": "",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 0.4341403036378324
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 0.13197140162810683,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvfortran -fast -acc -ta=multicore -DT1 -DT2 -DT4 -o /home/exouser/Testsuite/build/kernels_if.F90/kernels_if.F903 /home/exouser/Testsuite/Tests/kernels_if.F90",
                    "config": 1,
                    "errors": "",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 0.4763788511045277
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 0.042919158935546875,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvfortran -fast -acc -ta=multicore -DT1 -DT2 -DT3 -o /home/exouser/Testsuite/build/kernels_if.F90/kernels_if.F904 /home/exouser/Testsuite/Tests/kernels_if.F90",
                    "config": 1,
                    "errors": "",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 0.42643096297979355
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 0.052922927774488926,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvfortran -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/kernels_if.F90/kernels_if.F905 /home/exouser/Testsuite/Tests/kernels_if.F90",
                    "config": 1,
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.6566980639472604
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.1247931681573391,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "kernels_if.c": [
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -DT1 -DT2 -DT3 -DT4 -o /home/exouser/Testsuite/build/kernels_if.c/kernels_if.c0 /home/exouser/Testsuite/Tests/kernels_if.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/kernels_if.c\", line 174: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n\"/home/exouser/Testsuite/Tests/kernels_if.c\", line 175: warning: variable \"failed\" was declared but never referenced\n      int failed;\n          ^\n\n",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 0.1663851640187204
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 0.005425519309937954,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -DT2 -DT3 -DT4 -o /home/exouser/Testsuite/build/kernels_if.c/kernels_if.c1 /home/exouser/Testsuite/Tests/kernels_if.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/kernels_if.c\", line 174: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 0.16628727596253157
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 0.005919886287301779,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -DT1 -DT3 -DT4 -o /home/exouser/Testsuite/build/kernels_if.c/kernels_if.c2 /home/exouser/Testsuite/Tests/kernels_if.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/kernels_if.c\", line 49: error: identifier \"data_on_device\" is undefined\n      data_on_device = 1;\n      ^\n\n\"/home/exouser/Testsuite/Tests/kernels_if.c\", line 174: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n1 error detected in the compilation of \"/home/exouser/Testsuite/Tests/kernels_if.c\".\n",
                    "export": false,
                    "output": "",
                    "result": 2,
                    "runtime": 0.06574956374242902
                },
                "post-compile commands": [],
                "pre-compile commands": [],
                "runtime": {
                    "export": false,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -DT1 -DT2 -DT4 -o /home/exouser/Testsuite/build/kernels_if.c/kernels_if.c3 /home/exouser/Testsuite/Tests/kernels_if.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/kernels_if.c\", line 174: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 0.16766066057607532
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 0.006222907919436693,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -DT1 -DT2 -DT3 -o /home/exouser/Testsuite/build/kernels_if.c/kernels_if.c4 /home/exouser/Testsuite/Tests/kernels_if.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/kernels_if.c\", line 174: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 0.16569716576486826
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 0.0056259469129145145,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -DT2 -o /home/exouser/Testsuite/build/kernels_if.c/kernels_if.c5 /home/exouser/Testsuite/Tests/kernels_if.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/kernels_if.c\", line 174: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.16701486008241773
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.010175556875765324,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "kernels_loop.F90": [
            {
                "compilation": {
                    "command": "nvfortran -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/kernels_loop.F90/kernels_loop.F900 /home/exouser/Testsuite/Tests/kernels_loop.F90",
                    "config": 1,
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 1.128595340065658
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.3301065657287836,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "kernels_loop.c": [
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/kernels_loop.c/kernels_loop.c0 /home/exouser/Testsuite/Tests/kernels_loop.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/kernels_loop.c\", line 60: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.5690537351183593
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.006142728962004185,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "kernels_loop_independent.F90": [
            {
                "compilation": {
                    "command": "nvfortran -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/kernels_loop_independent.F90/kernels_loop_independent.F900 /home/exouser/Testsuite/Tests/kernels_loop_independent.F90",
                    "config": 1,
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.43009447678923607
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.12317106826230884,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "kernels_loop_independent.c": [
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/kernels_loop_independent.c/kernels_loop_independent.c0 /home/exouser/Testsuite/Tests/kernels_loop_independent.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/kernels_loop_independent.c\", line 35: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.16698707174509764
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.018308072816580534,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "kernels_loop_reduction_add_general.F90": [
            {
                "compilation": {
                    "command": "nvfortran -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/kernels_loop_reduction_add_general.F90/kernels_loop_reduction_add_general.F900 /home/exouser/Testsuite/Tests/kernels_loop_reduction_add_general.F90",
                    "config": 1,
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.5303885233588517
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.1352499658241868,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "kernels_loop_reduction_add_general.c": [
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/kernels_loop_reduction_add_general.c/kernels_loop_reduction_add_general.c0 /home/exouser/Testsuite/Tests/kernels_loop_reduction_add_general.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/kernels_loop_reduction_add_general.c\", line 36: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.165728528983891
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.01019750302657485,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "kernels_loop_reduction_add_loop.F90": [
            {
                "compilation": {
                    "command": "nvfortran -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/kernels_loop_reduction_add_loop.F90/kernels_loop_reduction_add_loop.F900 /home/exouser/Testsuite/Tests/kernels_loop_reduction_add_loop.F90",
                    "config": 1,
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.4842525701969862
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.07217798102647066,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "kernels_loop_reduction_add_loop.c": [
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/kernels_loop_reduction_add_loop.c/kernels_loop_reduction_add_loop.c0 /home/exouser/Testsuite/Tests/kernels_loop_reduction_add_loop.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/kernels_loop_reduction_add_loop.c\", line 56: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.2169798701070249
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.00602055573835969,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "kernels_loop_reduction_add_vector_loop.F90": [
            {
                "compilation": {
                    "command": "nvfortran -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/kernels_loop_reduction_add_vector_loop.F90/kernels_loop_reduction_add_vector_loop.F900 /home/exouser/Testsuite/Tests/kernels_loop_reduction_add_vector_loop.F90",
                    "config": 1,
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.48038748605176806
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.12519820779561996,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "kernels_loop_reduction_add_vector_loop.c": [
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/kernels_loop_reduction_add_vector_loop.c/kernels_loop_reduction_add_vector_loop.c0 /home/exouser/Testsuite/Tests/kernels_loop_reduction_add_vector_loop.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/kernels_loop_reduction_add_vector_loop.c\", line 43: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.1657714331522584
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.005684959702193737,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "kernels_loop_reduction_and_general.F90": [
            {
                "compilation": {
                    "command": "nvfortran -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/kernels_loop_reduction_and_general.F90/kernels_loop_reduction_and_general.F900 /home/exouser/Testsuite/Tests/kernels_loop_reduction_and_general.F90",
                    "config": 1,
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.5268500191159546
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.07695685885846615,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "kernels_loop_reduction_and_general.c": [
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/kernels_loop_reduction_and_general.c/kernels_loop_reduction_and_general.c0 /home/exouser/Testsuite/Tests/kernels_loop_reduction_and_general.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/kernels_loop_reduction_and_general.c\", line 47: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.16665288619697094
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.010786446277052164,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "kernels_loop_reduction_and_loop.F90": [
            {
                "compilation": {
                    "command": "nvfortran -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/kernels_loop_reduction_and_loop.F90/kernels_loop_reduction_and_loop.F900 /home/exouser/Testsuite/Tests/kernels_loop_reduction_and_loop.F90",
                    "config": 1,
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.42603273829445243
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.042204387951642275,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "kernels_loop_reduction_and_loop.c": [
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/kernels_loop_reduction_and_loop.c/kernels_loop_reduction_and_loop.c0 /home/exouser/Testsuite/Tests/kernels_loop_reduction_and_loop.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/kernels_loop_reduction_and_loop.c\", line 72: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.16665601078420877
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.006397014018148184,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "kernels_loop_reduction_and_vector_loop.F90": [
            {
                "compilation": {
                    "command": "nvfortran -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/kernels_loop_reduction_and_vector_loop.F90/kernels_loop_reduction_and_vector_loop.F900 /home/exouser/Testsuite/Tests/kernels_loop_reduction_and_vector_loop.F90",
                    "config": 1,
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.48434777930378914
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.14100614516064525,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "kernels_loop_reduction_and_vector_loop.c": [
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/kernels_loop_reduction_and_vector_loop.c/kernels_loop_reduction_and_vector_loop.c0 /home/exouser/Testsuite/Tests/kernels_loop_reduction_and_vector_loop.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/kernels_loop_reduction_and_vector_loop.c\", line 49: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.16642156289890409
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.006266885902732611,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "kernels_loop_reduction_bitand_general.F90": [
            {
                "compilation": {
                    "command": "nvfortran -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/kernels_loop_reduction_bitand_general.F90/kernels_loop_reduction_bitand_general.F900 /home/exouser/Testsuite/Tests/kernels_loop_reduction_bitand_general.F90",
                    "config": 1,
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.5224316278472543
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.12346201343461871,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "kernels_loop_reduction_bitand_general.c": [
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/kernels_loop_reduction_bitand_general.c/kernels_loop_reduction_bitand_general.c0 /home/exouser/Testsuite/Tests/kernels_loop_reduction_bitand_general.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/kernels_loop_reduction_bitand_general.c\", line 53: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.2166526853106916
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.009871808346360922,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "kernels_loop_reduction_bitand_loop.F90": [
            {
                "compilation": {
                    "command": "nvfortran -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/kernels_loop_reduction_bitand_loop.F90/kernels_loop_reduction_bitand_loop.F900 /home/exouser/Testsuite/Tests/kernels_loop_reduction_bitand_loop.F90",
                    "config": 1,
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.5845189122483134
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.03155361069366336,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "kernels_loop_reduction_bitand_loop.c": [
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/kernels_loop_reduction_bitand_loop.c/kernels_loop_reduction_bitand_loop.c0 /home/exouser/Testsuite/Tests/kernels_loop_reduction_bitand_loop.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/kernels_loop_reduction_bitand_loop.c\", line 69: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.2168610547669232
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.006246482953429222,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "kernels_loop_reduction_bitand_vector_loop.F90": [
            {
                "compilation": {
                    "command": "nvfortran -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/kernels_loop_reduction_bitand_vector_loop.F90/kernels_loop_reduction_bitand_vector_loop.F900 /home/exouser/Testsuite/Tests/kernels_loop_reduction_bitand_vector_loop.F90",
                    "config": 1,
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.5340974810533226
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.14758838107809424,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "kernels_loop_reduction_bitand_vector_loop.c": [
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/kernels_loop_reduction_bitand_vector_loop.c/kernels_loop_reduction_bitand_vector_loop.c0 /home/exouser/Testsuite/Tests/kernels_loop_reduction_bitand_vector_loop.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/kernels_loop_reduction_bitand_vector_loop.c\", line 55: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.16646988224238157
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.006358528975397348,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "kernels_loop_reduction_bitor_general.F90": [
            {
                "compilation": {
                    "command": "nvfortran -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/kernels_loop_reduction_bitor_general.F90/kernels_loop_reduction_bitor_general.F900 /home/exouser/Testsuite/Tests/kernels_loop_reduction_bitor_general.F90",
                    "config": 1,
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.5263788029551506
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.13081638095900416,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "kernels_loop_reduction_bitor_general.c": [
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/kernels_loop_reduction_bitor_general.c/kernels_loop_reduction_bitor_general.c0 /home/exouser/Testsuite/Tests/kernels_loop_reduction_bitor_general.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/kernels_loop_reduction_bitor_general.c\", line 47: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.16705520218238235
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 1,
                    "runtime": 0.009514184202998877,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "kernels_loop_reduction_bitor_loop.F90": [
            {
                "compilation": {
                    "command": "nvfortran -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/kernels_loop_reduction_bitor_loop.F90/kernels_loop_reduction_bitor_loop.F900 /home/exouser/Testsuite/Tests/kernels_loop_reduction_bitor_loop.F90",
                    "config": 1,
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.4763971557840705
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.03593597514554858,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "kernels_loop_reduction_bitor_loop.c": [
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/kernels_loop_reduction_bitor_loop.c/kernels_loop_reduction_bitor_loop.c0 /home/exouser/Testsuite/Tests/kernels_loop_reduction_bitor_loop.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/kernels_loop_reduction_bitor_loop.c\", line 69: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.21638535894453526
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.010077089071273804,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "kernels_loop_reduction_bitor_vector_loop.F90": [
            {
                "compilation": {
                    "command": "nvfortran -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/kernels_loop_reduction_bitor_vector_loop.F90/kernels_loop_reduction_bitor_vector_loop.F900 /home/exouser/Testsuite/Tests/kernels_loop_reduction_bitor_vector_loop.F90",
                    "config": 1,
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.5930571989156306
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.1484001367352903,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "kernels_loop_reduction_bitor_vector_loop.c": [
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/kernels_loop_reduction_bitor_vector_loop.c/kernels_loop_reduction_bitor_vector_loop.c0 /home/exouser/Testsuite/Tests/kernels_loop_reduction_bitor_vector_loop.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/kernels_loop_reduction_bitor_vector_loop.c\", line 55: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.16591061418876052
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.0058238450437784195,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "kernels_loop_reduction_bitxor_general.F90": [
            {
                "compilation": {
                    "command": "nvfortran -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/kernels_loop_reduction_bitxor_general.F90/kernels_loop_reduction_bitxor_general.F900 /home/exouser/Testsuite/Tests/kernels_loop_reduction_bitxor_general.F90",
                    "config": 1,
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.4841431463137269
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.13376782508566976,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "kernels_loop_reduction_bitxor_general.c": [
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/kernels_loop_reduction_bitxor_general.c/kernels_loop_reduction_bitxor_general.c0 /home/exouser/Testsuite/Tests/kernels_loop_reduction_bitxor_general.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/kernels_loop_reduction_bitxor_general.c\", line 37: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.16730862809345126
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 1,
                    "runtime": 0.010220751632004976,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "kernels_loop_reduction_bitxor_loop.F90": [
            {
                "compilation": {
                    "command": "nvfortran -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/kernels_loop_reduction_bitxor_loop.F90/kernels_loop_reduction_bitxor_loop.F900 /home/exouser/Testsuite/Tests/kernels_loop_reduction_bitxor_loop.F90",
                    "config": 1,
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.6762847271747887
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.05065865209326148,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "kernels_loop_reduction_bitxor_loop.c": [
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/kernels_loop_reduction_bitxor_loop.c/kernels_loop_reduction_bitxor_loop.c0 /home/exouser/Testsuite/Tests/kernels_loop_reduction_bitxor_loop.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/kernels_loop_reduction_bitxor_loop.c\", line 60: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.21752298530191183
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.006152621936053038,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "kernels_loop_reduction_bitxor_vector_loop.F90": [
            {
                "compilation": {
                    "command": "nvfortran -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/kernels_loop_reduction_bitxor_vector_loop.F90/kernels_loop_reduction_bitxor_vector_loop.F900 /home/exouser/Testsuite/Tests/kernels_loop_reduction_bitxor_vector_loop.F90",
                    "config": 1,
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.4383769170381129
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.12343148794025183,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "kernels_loop_reduction_bitxor_vector_loop.c": [
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/kernels_loop_reduction_bitxor_vector_loop.c/kernels_loop_reduction_bitxor_vector_loop.c0 /home/exouser/Testsuite/Tests/kernels_loop_reduction_bitxor_vector_loop.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/kernels_loop_reduction_bitxor_vector_loop.c\", line 46: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.16660039080306888
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.006099649239331484,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "kernels_loop_reduction_max_general.F90": [
            {
                "compilation": {
                    "command": "nvfortran -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/kernels_loop_reduction_max_general.F90/kernels_loop_reduction_max_general.F900 /home/exouser/Testsuite/Tests/kernels_loop_reduction_max_general.F90",
                    "config": 1,
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.5304278489202261
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.13143634190782905,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "kernels_loop_reduction_max_general.c": [
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/kernels_loop_reduction_max_general.c/kernels_loop_reduction_max_general.c0 /home/exouser/Testsuite/Tests/kernels_loop_reduction_max_general.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/kernels_loop_reduction_max_general.c\", line 32: warning: use of \"=\" where \"==\" may have been intended\n      if (found = 0){\n          ^\n\n\"/home/exouser/Testsuite/Tests/kernels_loop_reduction_max_general.c\", line 10: warning: variable \"found\" was set but never used\n      int found = 0;\n          ^\n\n\"/home/exouser/Testsuite/Tests/kernels_loop_reduction_max_general.c\", line 42: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.16661311779171228
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.00967860734090209,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "kernels_loop_reduction_max_loop.F90": [
            {
                "compilation": {
                    "command": "nvfortran -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/kernels_loop_reduction_max_loop.F90/kernels_loop_reduction_max_loop.F900 /home/exouser/Testsuite/Tests/kernels_loop_reduction_max_loop.F90",
                    "config": 1,
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.5272235227748752
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.02871295576915145,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "kernels_loop_reduction_max_loop.c": [
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/kernels_loop_reduction_max_loop.c/kernels_loop_reduction_max_loop.c0 /home/exouser/Testsuite/Tests/kernels_loop_reduction_max_loop.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/kernels_loop_reduction_max_loop.c\", line 12: warning: variable \"max\" was declared but never referenced\n      real_t max = 0.0;\n             ^\n\n\"/home/exouser/Testsuite/Tests/kernels_loop_reduction_max_loop.c\", line 60: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.21649838518351316
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.0058457087725400925,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "kernels_loop_reduction_max_vector_loop.F90": [
            {
                "compilation": {
                    "command": "nvfortran -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/kernels_loop_reduction_max_vector_loop.F90/kernels_loop_reduction_max_vector_loop.F900 /home/exouser/Testsuite/Tests/kernels_loop_reduction_max_vector_loop.F90",
                    "config": 1,
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.5468153096735477
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.0847701421007514,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "kernels_loop_reduction_max_vector_loop.c": [
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/kernels_loop_reduction_max_vector_loop.c/kernels_loop_reduction_max_vector_loop.c0 /home/exouser/Testsuite/Tests/kernels_loop_reduction_max_vector_loop.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/kernels_loop_reduction_max_vector_loop.c\", line 47: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.16648346511647105
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.0058890460059046745,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "kernels_loop_reduction_min_general.F90": [
            {
                "compilation": {
                    "command": "nvfortran -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/kernels_loop_reduction_min_general.F90/kernels_loop_reduction_min_general.F900 /home/exouser/Testsuite/Tests/kernels_loop_reduction_min_general.F90",
                    "config": 1,
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.534529531840235
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.08111670194193721,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "kernels_loop_reduction_min_general.c": [
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/kernels_loop_reduction_min_general.c/kernels_loop_reduction_min_general.c0 /home/exouser/Testsuite/Tests/kernels_loop_reduction_min_general.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/kernels_loop_reduction_min_general.c\", line 44: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.1666197655722499
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.010090721771121025,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "kernels_loop_reduction_min_loop.F90": [
            {
                "compilation": {
                    "command": "nvfortran -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/kernels_loop_reduction_min_loop.F90/kernels_loop_reduction_min_loop.F900 /home/exouser/Testsuite/Tests/kernels_loop_reduction_min_loop.F90",
                    "config": 1,
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.5922708930447698
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.13727435795590281,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "kernels_loop_reduction_min_loop.c": [
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/kernels_loop_reduction_min_loop.c/kernels_loop_reduction_min_loop.c0 /home/exouser/Testsuite/Tests/kernels_loop_reduction_min_loop.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/kernels_loop_reduction_min_loop.c\", line 57: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.21680687088519335
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.01026327395811677,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "kernels_loop_reduction_min_vector_loop.F90": [
            {
                "compilation": {
                    "command": "nvfortran -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/kernels_loop_reduction_min_vector_loop.F90/kernels_loop_reduction_min_vector_loop.F900 /home/exouser/Testsuite/Tests/kernels_loop_reduction_min_vector_loop.F90",
                    "config": 1,
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.4803059119731188
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.13399885222315788,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "kernels_loop_reduction_min_vector_loop.c": [
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/kernels_loop_reduction_min_vector_loop.c/kernels_loop_reduction_min_vector_loop.c0 /home/exouser/Testsuite/Tests/kernels_loop_reduction_min_vector_loop.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/kernels_loop_reduction_min_vector_loop.c\", line 48: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.1666897521354258
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.010188547894358635,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "kernels_loop_reduction_multiply_general.F90": [
            {
                "compilation": {
                    "command": "nvfortran -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/kernels_loop_reduction_multiply_general.F90/kernels_loop_reduction_multiply_general.F900 /home/exouser/Testsuite/Tests/kernels_loop_reduction_multiply_general.F90",
                    "config": 1,
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.4844081150367856
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.129153560847044,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "kernels_loop_reduction_multiply_general.c": [
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/kernels_loop_reduction_multiply_general.c/kernels_loop_reduction_multiply_general.c0 /home/exouser/Testsuite/Tests/kernels_loop_reduction_multiply_general.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/kernels_loop_reduction_multiply_general.c\", line 39: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.16576867597177625
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.010239959228783846,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "kernels_loop_reduction_multiply_loop.F90": [
            {
                "compilation": {
                    "command": "nvfortran -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/kernels_loop_reduction_multiply_loop.F90/kernels_loop_reduction_multiply_loop.F900 /home/exouser/Testsuite/Tests/kernels_loop_reduction_multiply_loop.F90",
                    "config": 1,
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.5466287322342396
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.06604258110746741,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "kernels_loop_reduction_multiply_loop.c": [
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/kernels_loop_reduction_multiply_loop.c/kernels_loop_reduction_multiply_loop.c0 /home/exouser/Testsuite/Tests/kernels_loop_reduction_multiply_loop.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/kernels_loop_reduction_multiply_loop.c\", line 58: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.2168890037573874
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.006251182872802019,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "kernels_loop_reduction_multiply_vector_loop.F90": [
            {
                "compilation": {
                    "command": "nvfortran -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/kernels_loop_reduction_multiply_vector_loop.F90/kernels_loop_reduction_multiply_vector_loop.F900 /home/exouser/Testsuite/Tests/kernels_loop_reduction_multiply_vector_loop.F90",
                    "config": 1,
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.48819795064628124
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.09114616876468062,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "kernels_loop_reduction_multiply_vector_loop.c": [
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/kernels_loop_reduction_multiply_vector_loop.c/kernels_loop_reduction_multiply_vector_loop.c0 /home/exouser/Testsuite/Tests/kernels_loop_reduction_multiply_vector_loop.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/kernels_loop_reduction_multiply_vector_loop.c\", line 49: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.16681683901697397
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.006175205111503601,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "kernels_loop_reduction_or_general.F90": [
            {
                "compilation": {
                    "command": "nvfortran -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/kernels_loop_reduction_or_general.F90/kernels_loop_reduction_or_general.F900 /home/exouser/Testsuite/Tests/kernels_loop_reduction_or_general.F90",
                    "config": 1,
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.5345268789678812
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.0968129369430244,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "kernels_loop_reduction_or_general.c": [
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/kernels_loop_reduction_or_general.c/kernels_loop_reduction_or_general.c0 /home/exouser/Testsuite/Tests/kernels_loop_reduction_or_general.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/kernels_loop_reduction_or_general.c\", line 45: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.166730135679245
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.010332217905670404,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "kernels_loop_reduction_or_loop.F90": [
            {
                "compilation": {
                    "command": "nvfortran -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/kernels_loop_reduction_or_loop.F90/kernels_loop_reduction_or_loop.F900 /home/exouser/Testsuite/Tests/kernels_loop_reduction_or_loop.F90",
                    "config": 1,
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.5834259553812444
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.03965621069073677,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "kernels_loop_reduction_or_loop.c": [
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/kernels_loop_reduction_or_loop.c/kernels_loop_reduction_or_loop.c0 /home/exouser/Testsuite/Tests/kernels_loop_reduction_or_loop.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/kernels_loop_reduction_or_loop.c\", line 74: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.21725560072809458
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.0059733279049396515,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "kernels_loop_reduction_or_vector_loop.F90": [
            {
                "compilation": {
                    "command": "nvfortran -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/kernels_loop_reduction_or_vector_loop.F90/kernels_loop_reduction_or_vector_loop.F900 /home/exouser/Testsuite/Tests/kernels_loop_reduction_or_vector_loop.F90",
                    "config": 1,
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.48047494189813733
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.1283911601640284,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "kernels_loop_reduction_or_vector_loop.c": [
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/kernels_loop_reduction_or_vector_loop.c/kernels_loop_reduction_or_vector_loop.c0 /home/exouser/Testsuite/Tests/kernels_loop_reduction_or_vector_loop.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/kernels_loop_reduction_or_vector_loop.c\", line 51: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.1671728710643947
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.010098190046846867,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "kernels_loop_seq.F90": [
            {
                "compilation": {
                    "command": "nvfortran -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/kernels_loop_seq.F90/kernels_loop_seq.F900 /home/exouser/Testsuite/Tests/kernels_loop_seq.F90",
                    "config": 1,
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.3875894621014595
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.09152548899874091,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "kernels_loop_seq.c": [
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/kernels_loop_seq.c/kernels_loop_seq.c0 /home/exouser/Testsuite/Tests/kernels_loop_seq.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/kernels_loop_seq.c\", line 37: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.16631789086386561
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.005090183112770319,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "kernels_loop_tile.F90": [
            {
                "compilation": {
                    "command": "nvfortran -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/kernels_loop_tile.F90/kernels_loop_tile.F900 /home/exouser/Testsuite/Tests/kernels_loop_tile.F90",
                    "config": 1,
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.47997490502893925
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.12216803897172213,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "kernels_loop_tile.c": [
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/kernels_loop_tile.c/kernels_loop_tile.c0 /home/exouser/Testsuite/Tests/kernels_loop_tile.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/kernels_loop_tile.c\", line 58: warning: variable \"temp\" was declared but never referenced\n    real_t temp = 0.0;\n           ^\n\n\"/home/exouser/Testsuite/Tests/kernels_loop_tile.c\", line 94: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.21686567412689328
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.11619907943531871,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "kernels_loop_vector_blocking.F90": [
            {
                "compilation": {
                    "command": "nvfortran -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/kernels_loop_vector_blocking.F90/kernels_loop_vector_blocking.F900 /home/exouser/Testsuite/Tests/kernels_loop_vector_blocking.F90",
                    "config": 1,
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.48051403602585196
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.04277291428297758,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "kernels_loop_vector_blocking.c": [
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/kernels_loop_vector_blocking.c/kernels_loop_vector_blocking.c0 /home/exouser/Testsuite/Tests/kernels_loop_vector_blocking.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/kernels_loop_vector_blocking.c\", line 36: warning: expression has no effect\n        err + 1;\n        ^\n\n\"/home/exouser/Testsuite/Tests/kernels_loop_vector_blocking.c\", line 47: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.16745684295892715
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.01003913814201951,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "kernels_loop_worker_blocking.F90": [
            {
                "compilation": {
                    "command": "nvfortran -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/kernels_loop_worker_blocking.F90/kernels_loop_worker_blocking.F900 /home/exouser/Testsuite/Tests/kernels_loop_worker_blocking.F90",
                    "config": 1,
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.49732368206605315
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.0426372061483562,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "kernels_loop_worker_blocking.c": [
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/kernels_loop_worker_blocking.c/kernels_loop_worker_blocking.c0 /home/exouser/Testsuite/Tests/kernels_loop_worker_blocking.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/kernels_loop_worker_blocking.c\", line 36: warning: expression has no effect\n        err + 1;\n        ^\n\n\"/home/exouser/Testsuite/Tests/kernels_loop_worker_blocking.c\", line 47: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.16728142695501447
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.00597273139283061,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "kernels_num_gangs.F90": [
            {
                "compilation": {
                    "command": "nvfortran -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/kernels_num_gangs.F90/kernels_num_gangs.F900 /home/exouser/Testsuite/Tests/kernels_num_gangs.F90",
                    "config": 1,
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.4834023779258132
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.1454594968818128,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "kernels_num_gangs.c": [
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/kernels_num_gangs.c/kernels_num_gangs.c0 /home/exouser/Testsuite/Tests/kernels_num_gangs.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/kernels_num_gangs.c\", line 35: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.16669319104403257
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.033172786701470613,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "kernels_num_workers.F90": [
            {
                "compilation": {
                    "command": "nvfortran -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/kernels_num_workers.F90/kernels_num_workers.F900 /home/exouser/Testsuite/Tests/kernels_num_workers.F90",
                    "config": 1,
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.47655838215723634
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.1290336879901588,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "kernels_num_workers.c": [
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/kernels_num_workers.c/kernels_num_workers.c0 /home/exouser/Testsuite/Tests/kernels_num_workers.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/kernels_num_workers.c\", line 35: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.16684918012470007
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.009045829065144062,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "kernels_present.F90": [
            {
                "compilation": {
                    "command": "nvfortran -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/kernels_present.F90/kernels_present.F900 /home/exouser/Testsuite/Tests/kernels_present.F90",
                    "config": 1,
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.4880587528459728
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.1263160710223019,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "kernels_present.c": [
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/kernels_present.c/kernels_present.c0 /home/exouser/Testsuite/Tests/kernels_present.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/kernels_present.c\", line 37: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.1672902018763125
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.009957609232515097,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "kernels_scalar_default_copy.F90": [
            {
                "compilation": {
                    "command": "nvfortran -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/kernels_scalar_default_copy.F90/kernels_scalar_default_copy.F900 /home/exouser/Testsuite/Tests/kernels_scalar_default_copy.F90",
                    "config": 1,
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.4962241342291236
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.07112007308751345,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "kernels_scalar_default_copy.c": [
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/kernels_scalar_default_copy.c/kernels_scalar_default_copy.c0 /home/exouser/Testsuite/Tests/kernels_scalar_default_copy.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/kernels_scalar_default_copy.c\", line 53: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.16678362293168902
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.005816053133457899,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "kernels_vector_length.F90": [
            {
                "compilation": {
                    "command": "nvfortran -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/kernels_vector_length.F90/kernels_vector_length.F900 /home/exouser/Testsuite/Tests/kernels_vector_length.F90",
                    "config": 1,
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.47595500759780407
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.070545535068959,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "kernels_vector_length.c": [
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/kernels_vector_length.c/kernels_vector_length.c0 /home/exouser/Testsuite/Tests/kernels_vector_length.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/kernels_vector_length.c\", line 38: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.1674197562970221
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.01000301307067275,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "kernels_wait.F90": [
            {
                "compilation": {
                    "command": "nvfortran -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/kernels_wait.F90/kernels_wait.F900 /home/exouser/Testsuite/Tests/kernels_wait.F90",
                    "config": 1,
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.49634888488799334
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.14135310798883438,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "kernels_wait.c": [
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/kernels_wait.c/kernels_wait.c0 /home/exouser/Testsuite/Tests/kernels_wait.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/kernels_wait.c\", line 40: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.16698551271110773
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.010019348934292793,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "loop_collapse.F90": [
            {
                "compilation": {
                    "command": "nvfortran -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/loop_collapse.F90/loop_collapse.F900 /home/exouser/Testsuite/Tests/loop_collapse.F90",
                    "config": 1,
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.5767308007925749
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.13280567107722163,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "loop_collapse.c": [
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/loop_collapse.c/loop_collapse.c0 /home/exouser/Testsuite/Tests/loop_collapse.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/loop_collapse.c\", line 88: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.26663123024627566
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.009927364066243172,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "loop_no_collapse.F90": [
            {
                "compilation": {
                    "command": "nvfortran -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/loop_no_collapse.F90/loop_no_collapse.F900 /home/exouser/Testsuite/Tests/loop_no_collapse.F90",
                    "config": 1,
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.6886272779665887
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.12165854079648852,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "loop_no_collapse_default.c": [
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/loop_no_collapse_default.c/loop_no_collapse_default.c0 /home/exouser/Testsuite/Tests/loop_no_collapse_default.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/loop_no_collapse_default.c\", line 49: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.21743649523705244
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.010266273748129606,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "parallel.F90": [
            {
                "compilation": {
                    "command": "nvfortran -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/parallel.F90/parallel.F900 /home/exouser/Testsuite/Tests/parallel.F90",
                    "config": 1,
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 3.1802844032645226
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.12159822508692741,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "parallel.c": [
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/parallel.c/parallel.c0 /home/exouser/Testsuite/Tests/parallel.c",
                    "config": 1,
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.6203393489122391
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.010463804006576538,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "parallel_async.F90": [
            {
                "compilation": {
                    "command": "nvfortran -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/parallel_async.F90/parallel_async.F900 /home/exouser/Testsuite/Tests/parallel_async.F90",
                    "config": 1,
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.5912105944007635
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.1388327688910067,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "parallel_async.c": [
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/parallel_async.c/parallel_async.c0 /home/exouser/Testsuite/Tests/parallel_async.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/parallel_async.c\", line 78: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.2666849158704281
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.00971435522660613,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "parallel_copy.F90": [
            {
                "compilation": {
                    "command": "nvfortran -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/parallel_copy.F90/parallel_copy.F900 /home/exouser/Testsuite/Tests/parallel_copy.F90",
                    "config": 1,
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.4870905829593539
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.12690768763422966,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "parallel_copy.c": [
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/parallel_copy.c/parallel_copy.c0 /home/exouser/Testsuite/Tests/parallel_copy.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/parallel_copy.c\", line 35: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.16564527014270425
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.00964922085404396,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "parallel_copyin.F90": [
            {
                "compilation": {
                    "command": "nvfortran -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/parallel_copyin.F90/parallel_copyin.F900 /home/exouser/Testsuite/Tests/parallel_copyin.F90",
                    "config": 1,
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.5222481433302164
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.12331786705181003,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "parallel_copyin.c": [
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/parallel_copyin.c/parallel_copyin.c0 /home/exouser/Testsuite/Tests/parallel_copyin.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/parallel_copyin.c\", line 77: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.16579037718474865
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.009128514677286148,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "parallel_copyout.F90": [
            {
                "compilation": {
                    "command": "nvfortran -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/parallel_copyout.F90/parallel_copyout.F900 /home/exouser/Testsuite/Tests/parallel_copyout.F90",
                    "config": 1,
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.6044961796142161
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.12146165687590837,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "parallel_copyout.c": [
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/parallel_copyout.c/parallel_copyout.c0 /home/exouser/Testsuite/Tests/parallel_copyout.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/parallel_copyout.c\", line 122: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.21823241794481874
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.009545625187456608,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "parallel_create.F90": [
            {
                "compilation": {
                    "command": "nvfortran -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/parallel_create.F90/parallel_create.F900 /home/exouser/Testsuite/Tests/parallel_create.F90",
                    "config": 1,
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.4424242493696511
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.08113148808479309,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "parallel_create.c": [
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/parallel_create.c/parallel_create.c0 /home/exouser/Testsuite/Tests/parallel_create.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/parallel_create.c\", line 44: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.16608821786940098
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.010213833767920732,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "parallel_default_copy.F90": [
            {
                "compilation": {
                    "command": "nvfortran -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/parallel_default_copy.F90/parallel_default_copy.F900 /home/exouser/Testsuite/Tests/parallel_default_copy.F90",
                    "config": 1,
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.5307289967313409
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.1265004756860435,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "parallel_default_copy.c": [
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/parallel_default_copy.c/parallel_default_copy.c0 /home/exouser/Testsuite/Tests/parallel_default_copy.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/parallel_default_copy.c\", line 98: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.21636550594121218
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.009944857098162174,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "parallel_default_present.F90": [
            {
                "compilation": {
                    "command": "nvfortran -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/parallel_default_present.F90/parallel_default_present.F900 /home/exouser/Testsuite/Tests/parallel_default_present.F90",
                    "config": 1,
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.4761818409897387
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.09407229721546173,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "parallel_default_present.c": [
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/parallel_default_present.c/parallel_default_present.c0 /home/exouser/Testsuite/Tests/parallel_default_present.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/parallel_default_present.c\", line 34: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.16662327479571104
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.009873538743704557,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "parallel_deviceptr.c": [
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/parallel_deviceptr.c/parallel_deviceptr.c0 /home/exouser/Testsuite/Tests/parallel_deviceptr.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/parallel_deviceptr.c\", line 48: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.16603332199156284
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.009629080072045326,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "parallel_firstprivate.F90": [
            {
                "compilation": {
                    "command": "nvfortran -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/parallel_firstprivate.F90/parallel_firstprivate.F900 /home/exouser/Testsuite/Tests/parallel_firstprivate.F90",
                    "config": 1,
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.576547680888325
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 1,
                    "runtime": 0.08328303787857294,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "parallel_firstprivate.c": [
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/parallel_firstprivate.c/parallel_firstprivate.c0 /home/exouser/Testsuite/Tests/parallel_firstprivate.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/parallel_firstprivate.c\", line 98: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.2672505774535239
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.009657199960201979,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "parallel_if.F90": [
            {
                "compilation": {
                    "command": "nvfortran -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/parallel_if.F90/parallel_if.F900 /home/exouser/Testsuite/Tests/parallel_if.F90",
                    "config": 1,
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.739181773737073
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.1300299079157412,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "parallel_if.c": [
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/parallel_if.c/parallel_if.c0 /home/exouser/Testsuite/Tests/parallel_if.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/parallel_if.c\", line 10: warning: variable \"accel\" was declared but never referenced\n      int accel = 1;\n          ^\n\n\"/home/exouser/Testsuite/Tests/parallel_if.c\", line 55: error: identifier \"devtest\" is undefined\n      if (devtest[0] != 0){\n          ^\n\n\"/home/exouser/Testsuite/Tests/parallel_if.c\", line 45: warning: variable \"accel\" was declared but never referenced\n      int accel = 1;\n          ^\n\n\"/home/exouser/Testsuite/Tests/parallel_if.c\", line 92: warning: variable \"host\" was declared but never referenced\n      int host = 0;\n          ^\n\n\"/home/exouser/Testsuite/Tests/parallel_if.c\", line 124: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n1 error detected in the compilation of \"/home/exouser/Testsuite/Tests/parallel_if.c\".\n",
                    "export": false,
                    "output": "",
                    "result": 2,
                    "runtime": 0.06614040257409215
                },
                "post-compile commands": [],
                "pre-compile commands": [],
                "runtime": {
                    "export": false,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -DT1 -o /home/exouser/Testsuite/build/parallel_if.c/parallel_if.c1 /home/exouser/Testsuite/Tests/parallel_if.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/parallel_if.c\", line 55: error: identifier \"devtest\" is undefined\n      if (devtest[0] != 0){\n          ^\n\n\"/home/exouser/Testsuite/Tests/parallel_if.c\", line 45: warning: variable \"accel\" was declared but never referenced\n      int accel = 1;\n          ^\n\n\"/home/exouser/Testsuite/Tests/parallel_if.c\", line 92: warning: variable \"host\" was declared but never referenced\n      int host = 0;\n          ^\n\n\"/home/exouser/Testsuite/Tests/parallel_if.c\", line 124: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n1 error detected in the compilation of \"/home/exouser/Testsuite/Tests/parallel_if.c\".\n",
                    "export": false,
                    "output": "",
                    "result": 2,
                    "runtime": 0.06635664124041796
                },
                "post-compile commands": [],
                "pre-compile commands": [],
                "runtime": {
                    "export": false,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -DT2 -o /home/exouser/Testsuite/build/parallel_if.c/parallel_if.c2 /home/exouser/Testsuite/Tests/parallel_if.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/parallel_if.c\", line 10: warning: variable \"accel\" was declared but never referenced\n      int accel = 1;\n          ^\n\n\"/home/exouser/Testsuite/Tests/parallel_if.c\", line 92: warning: variable \"host\" was declared but never referenced\n      int host = 0;\n          ^\n\n\"/home/exouser/Testsuite/Tests/parallel_if.c\", line 124: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.216574524063617
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.009637082926928997,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "parallel_loop.F90": [
            {
                "compilation": {
                    "command": "nvfortran -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/parallel_loop.F90/parallel_loop.F900 /home/exouser/Testsuite/Tests/parallel_loop.F90",
                    "config": 1,
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.5418583611026406
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.12821819400414824,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "parallel_loop.c": [
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/parallel_loop.c/parallel_loop.c0 /home/exouser/Testsuite/Tests/parallel_loop.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/parallel_loop.c\", line 74: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.2169884331524372
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.010261954739689827,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "parallel_loop_async.F90": [
            {
                "compilation": {
                    "command": "nvfortran -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/parallel_loop_async.F90/parallel_loop_async.F900 /home/exouser/Testsuite/Tests/parallel_loop_async.F90",
                    "config": 1,
                    "errors": "NVFORTRAN-S-0034-Syntax error at or near ( (/home/exouser/Testsuite/Tests/parallel_loop_async.F90: 30)\n  0 inform,   0 warnings,   1 severes, 0 fatal for test1\n",
                    "export": false,
                    "output": "",
                    "result": 2,
                    "runtime": 0.1292467792518437
                },
                "post-compile commands": [],
                "pre-compile commands": [],
                "runtime": {
                    "export": false,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvfortran -fast -acc -ta=multicore -DT1 -o /home/exouser/Testsuite/build/parallel_loop_async.F90/parallel_loop_async.F901 /home/exouser/Testsuite/Tests/parallel_loop_async.F90",
                    "config": 1,
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.4869803860783577
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.042868351098150015,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "parallel_loop_async.c": [
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/parallel_loop_async.c/parallel_loop_async.c0 /home/exouser/Testsuite/Tests/parallel_loop_async.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/parallel_loop_async.c\", line 51: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\nNVC++-S-1002-Reduction type not supported for this variable datatype - errors (/home/exouser/Testsuite/Tests/parallel_loop_async.c: 30)\nNVC++-F-0000-Internal compiler error. Unexpected datatype in reduction       0  (/home/exouser/Testsuite/Tests/parallel_loop_async.c: 25)\nNVC++/x86-64 Linux 21.5-0: compilation aborted\n",
                    "export": false,
                    "output": "",
                    "result": 2,
                    "runtime": 0.06517356401309371
                },
                "post-compile commands": [],
                "pre-compile commands": [],
                "runtime": {
                    "export": false,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -DT1 -o /home/exouser/Testsuite/build/parallel_loop_async.c/parallel_loop_async.c1 /home/exouser/Testsuite/Tests/parallel_loop_async.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/parallel_loop_async.c\", line 51: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n\"/home/exouser/Testsuite/Tests/parallel_loop_async.c\", line 52: warning: variable \"failed\" was declared but never referenced\n      int failed;\n          ^\n\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.1661157119087875
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.0052489303052425385,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "parallel_loop_auto.F90": [
            {
                "compilation": {
                    "command": "nvfortran -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/parallel_loop_auto.F90/parallel_loop_auto.F900 /home/exouser/Testsuite/Tests/parallel_loop_auto.F90",
                    "config": 1,
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.4843469518236816
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.14140302501618862,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "parallel_loop_auto.c": [
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/parallel_loop_auto.c/parallel_loop_auto.c0 /home/exouser/Testsuite/Tests/parallel_loop_auto.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/parallel_loop_auto.c\", line 70: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.16683147195726633
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.005480139050632715,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "parallel_loop_gang.F90": [
            {
                "compilation": {
                    "command": "nvfortran -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/parallel_loop_gang.F90/parallel_loop_gang.F900 /home/exouser/Testsuite/Tests/parallel_loop_gang.F90",
                    "config": 1,
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.492276637814939
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.14138982677832246,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "parallel_loop_gang.c": [
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/parallel_loop_gang.c/parallel_loop_gang.c0 /home/exouser/Testsuite/Tests/parallel_loop_gang.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/parallel_loop_gang.c\", line 37: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.1667244890704751
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.009296122938394547,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "parallel_loop_reduction_add_general.F90": [
            {
                "compilation": {
                    "command": "nvfortran -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/parallel_loop_reduction_add_general.F90/parallel_loop_reduction_add_general.F900 /home/exouser/Testsuite/Tests/parallel_loop_reduction_add_general.F90",
                    "config": 1,
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.4843416619114578
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.1373802642337978,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "parallel_loop_reduction_add_general.c": [
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -DT2 -o /home/exouser/Testsuite/build/parallel_loop_reduction_add_general.c/parallel_loop_reduction_add_general.c0 /home/exouser/Testsuite/Tests/parallel_loop_reduction_add_general.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/parallel_loop_reduction_add_general.c\", line 83: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.1659990418702364
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.009543667081743479,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "parallel_loop_reduction_add_general_type_check_pt1.c": [
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -DT1 -DT2 -DT3 -DT4 -DT5 -DT6 -DT7 -DT8 -o /home/exouser/Testsuite/build/parallel_loop_reduction_add_general_type_check_pt1.c/parallel_loop_reduction_add_general_type_check_pt1.c0 /home/exouser/Testsuite/Tests/parallel_loop_reduction_add_general_type_check_pt1.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/parallel_loop_reduction_add_general_type_check_pt1.c\", line 291: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n\"/home/exouser/Testsuite/Tests/parallel_loop_reduction_add_general_type_check_pt1.c\", line 292: warning: variable \"failed\" was declared but never referenced\n      int failed;\n          ^\n\n",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 0.16555642988532782
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 0.009623263962566853,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -DT2 -DT3 -DT4 -DT5 -DT6 -DT7 -DT8 -o /home/exouser/Testsuite/build/parallel_loop_reduction_add_general_type_check_pt1.c/parallel_loop_reduction_add_general_type_check_pt1.c1 /home/exouser/Testsuite/Tests/parallel_loop_reduction_add_general_type_check_pt1.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/parallel_loop_reduction_add_general_type_check_pt1.c\", line 291: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 0.16649367520585656
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": false,
                    "output": "",
                    "result": 1,
                    "runtime": 0.00951338093727827,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -DT1 -DT3 -DT4 -DT5 -DT6 -DT7 -DT8 -o /home/exouser/Testsuite/build/parallel_loop_reduction_add_general_type_check_pt1.c/parallel_loop_reduction_add_general_type_check_pt1.c2 /home/exouser/Testsuite/Tests/parallel_loop_reduction_add_general_type_check_pt1.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/parallel_loop_reduction_add_general_type_check_pt1.c\", line 291: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 0.16663677291944623
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 0.01007377402856946,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -DT1 -DT2 -DT4 -DT5 -DT6 -DT7 -DT8 -o /home/exouser/Testsuite/build/parallel_loop_reduction_add_general_type_check_pt1.c/parallel_loop_reduction_add_general_type_check_pt1.c3 /home/exouser/Testsuite/Tests/parallel_loop_reduction_add_general_type_check_pt1.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/parallel_loop_reduction_add_general_type_check_pt1.c\", line 291: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 0.16682724421843886
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 0.009256563615053892,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -DT1 -DT2 -DT3 -DT5 -DT6 -DT7 -DT8 -o /home/exouser/Testsuite/build/parallel_loop_reduction_add_general_type_check_pt1.c/parallel_loop_reduction_add_general_type_check_pt1.c4 /home/exouser/Testsuite/Tests/parallel_loop_reduction_add_general_type_check_pt1.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/parallel_loop_reduction_add_general_type_check_pt1.c\", line 291: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 0.1666055046953261
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 0.009466498158872128,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -DT1 -DT2 -DT3 -DT4 -DT6 -DT7 -DT8 -o /home/exouser/Testsuite/build/parallel_loop_reduction_add_general_type_check_pt1.c/parallel_loop_reduction_add_general_type_check_pt1.c5 /home/exouser/Testsuite/Tests/parallel_loop_reduction_add_general_type_check_pt1.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/parallel_loop_reduction_add_general_type_check_pt1.c\", line 291: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 0.16657619969919324
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 0.009639803785830736,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -DT1 -DT2 -DT3 -DT4 -DT5 -DT7 -DT8 -o /home/exouser/Testsuite/build/parallel_loop_reduction_add_general_type_check_pt1.c/parallel_loop_reduction_add_general_type_check_pt1.c6 /home/exouser/Testsuite/Tests/parallel_loop_reduction_add_general_type_check_pt1.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/parallel_loop_reduction_add_general_type_check_pt1.c\", line 291: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 0.16535322973504663
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 0.009499957785010338,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -DT1 -DT2 -DT3 -DT4 -DT5 -DT6 -DT8 -o /home/exouser/Testsuite/build/parallel_loop_reduction_add_general_type_check_pt1.c/parallel_loop_reduction_add_general_type_check_pt1.c7 /home/exouser/Testsuite/Tests/parallel_loop_reduction_add_general_type_check_pt1.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/parallel_loop_reduction_add_general_type_check_pt1.c\", line 291: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 0.16636452404782176
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 0.009874675422906876,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -DT1 -DT2 -DT3 -DT4 -DT5 -DT6 -DT7 -o /home/exouser/Testsuite/build/parallel_loop_reduction_add_general_type_check_pt1.c/parallel_loop_reduction_add_general_type_check_pt1.c8 /home/exouser/Testsuite/Tests/parallel_loop_reduction_add_general_type_check_pt1.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/parallel_loop_reduction_add_general_type_check_pt1.c\", line 291: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 0.1663018479011953
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 0.00999268563464284,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/parallel_loop_reduction_add_general_type_check_pt1.c/parallel_loop_reduction_add_general_type_check_pt1.c9 /home/exouser/Testsuite/Tests/parallel_loop_reduction_add_general_type_check_pt1.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/parallel_loop_reduction_add_general_type_check_pt1.c\", line 291: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.31710618967190385
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 1,
                    "runtime": 0.009418698027729988,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "parallel_loop_reduction_add_general_type_check_pt2.c": [
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -DT1 -DT2 -DT3 -DT4 -DT5 -DT6 -DT7 -DT8 -o /home/exouser/Testsuite/build/parallel_loop_reduction_add_general_type_check_pt2.c/parallel_loop_reduction_add_general_type_check_pt2.c0 /home/exouser/Testsuite/Tests/parallel_loop_reduction_add_general_type_check_pt2.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/parallel_loop_reduction_add_general_type_check_pt2.c\", line 288: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n\"/home/exouser/Testsuite/Tests/parallel_loop_reduction_add_general_type_check_pt2.c\", line 289: warning: variable \"failed\" was declared but never referenced\n      int failed;\n          ^\n\n",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 0.16658927267417312
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 0.009549285750836134,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -DT2 -DT3 -DT4 -DT5 -DT6 -DT7 -DT8 -o /home/exouser/Testsuite/build/parallel_loop_reduction_add_general_type_check_pt2.c/parallel_loop_reduction_add_general_type_check_pt2.c1 /home/exouser/Testsuite/Tests/parallel_loop_reduction_add_general_type_check_pt2.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/parallel_loop_reduction_add_general_type_check_pt2.c\", line 288: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 0.16668156208470464
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 0.009475089143961668,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -DT1 -DT3 -DT4 -DT5 -DT6 -DT7 -DT8 -o /home/exouser/Testsuite/build/parallel_loop_reduction_add_general_type_check_pt2.c/parallel_loop_reduction_add_general_type_check_pt2.c2 /home/exouser/Testsuite/Tests/parallel_loop_reduction_add_general_type_check_pt2.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/parallel_loop_reduction_add_general_type_check_pt2.c\", line 288: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 0.1661784229800105
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 0.009822329971939325,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -DT1 -DT2 -DT4 -DT5 -DT6 -DT7 -DT8 -o /home/exouser/Testsuite/build/parallel_loop_reduction_add_general_type_check_pt2.c/parallel_loop_reduction_add_general_type_check_pt2.c3 /home/exouser/Testsuite/Tests/parallel_loop_reduction_add_general_type_check_pt2.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/parallel_loop_reduction_add_general_type_check_pt2.c\", line 288: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 0.16588947596028447
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 0.00946867000311613,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -DT1 -DT2 -DT3 -DT5 -DT6 -DT7 -DT8 -o /home/exouser/Testsuite/build/parallel_loop_reduction_add_general_type_check_pt2.c/parallel_loop_reduction_add_general_type_check_pt2.c4 /home/exouser/Testsuite/Tests/parallel_loop_reduction_add_general_type_check_pt2.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/parallel_loop_reduction_add_general_type_check_pt2.c\", line 288: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 0.16593931196257472
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 0.009678855072706938,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -DT1 -DT2 -DT3 -DT4 -DT6 -DT7 -DT8 -o /home/exouser/Testsuite/build/parallel_loop_reduction_add_general_type_check_pt2.c/parallel_loop_reduction_add_general_type_check_pt2.c5 /home/exouser/Testsuite/Tests/parallel_loop_reduction_add_general_type_check_pt2.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/parallel_loop_reduction_add_general_type_check_pt2.c\", line 288: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 0.16764998016878963
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 0.010768745094537735,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -DT1 -DT2 -DT3 -DT4 -DT5 -DT7 -DT8 -o /home/exouser/Testsuite/build/parallel_loop_reduction_add_general_type_check_pt2.c/parallel_loop_reduction_add_general_type_check_pt2.c6 /home/exouser/Testsuite/Tests/parallel_loop_reduction_add_general_type_check_pt2.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/parallel_loop_reduction_add_general_type_check_pt2.c\", line 288: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 0.16637205192819238
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 0.009977166075259447,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -DT1 -DT2 -DT3 -DT4 -DT5 -DT6 -DT8 -o /home/exouser/Testsuite/build/parallel_loop_reduction_add_general_type_check_pt2.c/parallel_loop_reduction_add_general_type_check_pt2.c7 /home/exouser/Testsuite/Tests/parallel_loop_reduction_add_general_type_check_pt2.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/parallel_loop_reduction_add_general_type_check_pt2.c\", line 288: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 0.16599015705287457
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 0.005862959194928408,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -DT1 -DT2 -DT3 -DT4 -DT5 -DT6 -DT7 -o /home/exouser/Testsuite/build/parallel_loop_reduction_add_general_type_check_pt2.c/parallel_loop_reduction_add_general_type_check_pt2.c8 /home/exouser/Testsuite/Tests/parallel_loop_reduction_add_general_type_check_pt2.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/parallel_loop_reduction_add_general_type_check_pt2.c\", line 288: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 0.16905913408845663
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": false,
                    "output": "",
                    "result": 128,
                    "runtime": 0.010603814851492643,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/parallel_loop_reduction_add_general_type_check_pt2.c/parallel_loop_reduction_add_general_type_check_pt2.c9 /home/exouser/Testsuite/Tests/parallel_loop_reduction_add_general_type_check_pt2.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/parallel_loop_reduction_add_general_type_check_pt2.c\", line 288: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.3677624617703259
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 128,
                    "runtime": 0.009936173912137747,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "parallel_loop_reduction_add_general_type_check_pt3.c": [
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/parallel_loop_reduction_add_general_type_check_pt3.c/parallel_loop_reduction_add_general_type_check_pt3.c0 /home/exouser/Testsuite/Tests/parallel_loop_reduction_add_general_type_check_pt3.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/parallel_loop_reduction_add_general_type_check_pt3.c\", line 81: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.21727349609136581
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.0105336201377213,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "parallel_loop_reduction_add_loop.F90": [
            {
                "compilation": {
                    "command": "nvfortran -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/parallel_loop_reduction_add_loop.F90/parallel_loop_reduction_add_loop.F900 /home/exouser/Testsuite/Tests/parallel_loop_reduction_add_loop.F90",
                    "config": 1,
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.5424249740317464
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.13904082123190165,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "parallel_loop_reduction_add_loop.c": [
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -DT2 -o /home/exouser/Testsuite/build/parallel_loop_reduction_add_loop.c/parallel_loop_reduction_add_loop.c0 /home/exouser/Testsuite/Tests/parallel_loop_reduction_add_loop.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/parallel_loop_reduction_add_loop.c\", line 121: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.21656889794394374
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.010470978915691376,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "parallel_loop_reduction_add_loop_type_check_pt1.c": [
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/parallel_loop_reduction_add_loop_type_check_pt1.c/parallel_loop_reduction_add_loop_type_check_pt1.c0 /home/exouser/Testsuite/Tests/parallel_loop_reduction_add_loop_type_check_pt1.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/parallel_loop_reduction_add_loop_type_check_pt1.c\", line 11: warning: variable \"total\" was declared but never referenced\n      _Bool total = 1;\n            ^\n\n\"/home/exouser/Testsuite/Tests/parallel_loop_reduction_add_loop_type_check_pt1.c\", line 79: warning: variable \"temp\" was set but never used\n      char temp;\n           ^\n\n\"/home/exouser/Testsuite/Tests/parallel_loop_reduction_add_loop_type_check_pt1.c\", line 129: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.21667243679985404
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "Error location x: 1 \t y: 0\n-127 != 129\nError location x: 1 \t y: 2\n-128 != 128\nError location x: 1 \t y: 3\n-128 != 128\nError location x: 1 \t y: 6\n-128 != 128\nError location x: 1 \t y: 9\n-127 != 129\nError location x: 1 \t y: 10\n-128 != 128\nError location x: 1 \t y: 18\n-128 != 128\nError location x: 1 \t y: 20\n-128 != 128\nError location x: 1 \t y: 22\n-127 != 129\nError location x: 1 \t y: 28\n-128 != 128\nError location x: 1 \t y: 30\n-128 != 128\nError location x: 1 \t y: 35\n-128 != 128\nError location x: 1 \t y: 40\n-128 != 128\nError location x: 1 \t y: 41\n-128 != 128\nError location x: 1 \t y: 53\n-128 != 128\nError location x: 1 \t y: 55\n-128 != 128\nError location x: 1 \t y: 66\n-128 != 128\nError location x: 1 \t y: 68\n-128 != 128\nError location x: 1 \t y: 69\n-127 != 129\nError location x: 1 \t y: 72\n-128 != 128\nError location x: 1 \t y: 73\n-127 != 129\nError location x: 1 \t y: 74\n-128 != 128\nError location x: 1 \t y: 78\n-128 != 128\nError location x: 1 \t y: 82\n-128 != 128\nError location x: 1 \t y: 84\n-128 != 128\nError location x: 1 \t y: 89\n-127 != 129\nError location x: 1 \t y: 93\n-128 != 128\nError location x: 1 \t y: 94\n-128 != 128\nError location x: 1 \t y: 96\n-127 != 129\nError location x: 1 \t y: 97\n-127 != 129\n30 out of 1000 failed\n",
                    "result": 3,
                    "runtime": 0.009620185010135174,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "parallel_loop_reduction_add_vector_loop.F90": [
            {
                "compilation": {
                    "command": "nvfortran -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/parallel_loop_reduction_add_vector_loop.F90/parallel_loop_reduction_add_vector_loop.F900 /home/exouser/Testsuite/Tests/parallel_loop_reduction_add_vector_loop.F90",
                    "config": 1,
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.4885180830024183
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.13314568204805255,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "parallel_loop_reduction_add_vector_loop.c": [
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -DT2 -o /home/exouser/Testsuite/build/parallel_loop_reduction_add_vector_loop.c/parallel_loop_reduction_add_vector_loop.c0 /home/exouser/Testsuite/Tests/parallel_loop_reduction_add_vector_loop.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/parallel_loop_reduction_add_vector_loop.c\", line 97: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.16661080298945308
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.010365227237343788,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "parallel_loop_reduction_and_general.F90": [
            {
                "compilation": {
                    "command": "nvfortran -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/parallel_loop_reduction_and_general.F90/parallel_loop_reduction_and_general.F900 /home/exouser/Testsuite/Tests/parallel_loop_reduction_and_general.F90",
                    "config": 1,
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.47613636404275894
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.1329311467707157,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "parallel_loop_reduction_and_general.c": [
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -DT2 -o /home/exouser/Testsuite/build/parallel_loop_reduction_and_general.c/parallel_loop_reduction_and_general.c0 /home/exouser/Testsuite/Tests/parallel_loop_reduction_and_general.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/parallel_loop_reduction_and_general.c\", line 92: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.16627674596384168
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.017982081044465303,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "parallel_loop_reduction_and_loop.F90": [
            {
                "compilation": {
                    "command": "nvfortran -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/parallel_loop_reduction_and_loop.F90/parallel_loop_reduction_and_loop.F900 /home/exouser/Testsuite/Tests/parallel_loop_reduction_and_loop.F90",
                    "config": 1,
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.5383875649422407
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.12343932315707207,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "parallel_loop_reduction_and_loop.c": [
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -DT2 -o /home/exouser/Testsuite/build/parallel_loop_reduction_and_loop.c/parallel_loop_reduction_and_loop.c0 /home/exouser/Testsuite/Tests/parallel_loop_reduction_and_loop.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/parallel_loop_reduction_and_loop.c\", line 134: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.21599595621228218
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.00991008011624217,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "parallel_loop_reduction_and_vector_loop.F90": [
            {
                "compilation": {
                    "command": "nvfortran -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/parallel_loop_reduction_and_vector_loop.F90/parallel_loop_reduction_and_vector_loop.F900 /home/exouser/Testsuite/Tests/parallel_loop_reduction_and_vector_loop.F90",
                    "config": 1,
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.638670836109668
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.13903384702280164,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "parallel_loop_reduction_and_vector_loop.c": [
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -DT2 -o /home/exouser/Testsuite/build/parallel_loop_reduction_and_vector_loop.c/parallel_loop_reduction_and_vector_loop.c0 /home/exouser/Testsuite/Tests/parallel_loop_reduction_and_vector_loop.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/parallel_loop_reduction_and_vector_loop.c\", line 108: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.1670088730752468
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.01049666479229927,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "parallel_loop_reduction_bitand_general.F90": [
            {
                "compilation": {
                    "command": "nvfortran -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/parallel_loop_reduction_bitand_general.F90/parallel_loop_reduction_bitand_general.F900 /home/exouser/Testsuite/Tests/parallel_loop_reduction_bitand_general.F90",
                    "config": 1,
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.48814095510169864
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.1255253069102764,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "parallel_loop_reduction_bitand_general.c": [
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -DT2 -o /home/exouser/Testsuite/build/parallel_loop_reduction_bitand_general.c/parallel_loop_reduction_bitand_general.c0 /home/exouser/Testsuite/Tests/parallel_loop_reduction_bitand_general.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/parallel_loop_reduction_bitand_general.c\", line 101: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.16685688635334373
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.010196140967309475,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "parallel_loop_reduction_bitand_loop.F90": [
            {
                "compilation": {
                    "command": "nvfortran -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/parallel_loop_reduction_bitand_loop.F90/parallel_loop_reduction_bitand_loop.F900 /home/exouser/Testsuite/Tests/parallel_loop_reduction_bitand_loop.F90",
                    "config": 1,
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.5766755556687713
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.12904819333925843,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "parallel_loop_reduction_bitand_loop.c": [
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -DT2 -o /home/exouser/Testsuite/build/parallel_loop_reduction_bitand_loop.c/parallel_loop_reduction_bitand_loop.c0 /home/exouser/Testsuite/Tests/parallel_loop_reduction_bitand_loop.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/parallel_loop_reduction_bitand_loop.c\", line 135: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.21752149006351829
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.010022799950093031,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "parallel_loop_reduction_bitand_vector_loop.F90": [
            {
                "compilation": {
                    "command": "nvfortran -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/parallel_loop_reduction_bitand_vector_loop.F90/parallel_loop_reduction_bitand_vector_loop.F900 /home/exouser/Testsuite/Tests/parallel_loop_reduction_bitand_vector_loop.F90",
                    "config": 1,
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.5303528821095824
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.1398772019892931,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "parallel_loop_reduction_bitand_vector_loop.c": [
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -DT2 -o /home/exouser/Testsuite/build/parallel_loop_reduction_bitand_vector_loop.c/parallel_loop_reduction_bitand_vector_loop.c0 /home/exouser/Testsuite/Tests/parallel_loop_reduction_bitand_vector_loop.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/parallel_loop_reduction_bitand_vector_loop.c\", line 11: warning: variable \"temp\" was declared but never referenced\n      unsigned int temp = 1;\n                   ^\n\n\"/home/exouser/Testsuite/Tests/parallel_loop_reduction_bitand_vector_loop.c\", line 108: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.21588175790384412
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.009806496091187,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "parallel_loop_reduction_bitor_general.F90": [
            {
                "compilation": {
                    "command": "nvfortran -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/parallel_loop_reduction_bitor_general.F90/parallel_loop_reduction_bitor_general.F900 /home/exouser/Testsuite/Tests/parallel_loop_reduction_bitor_general.F90",
                    "config": 1,
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.5883639049716294
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.08691288577392697,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "parallel_loop_reduction_bitor_general.c": [
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -DT2 -o /home/exouser/Testsuite/build/parallel_loop_reduction_bitor_general.c/parallel_loop_reduction_bitor_general.c0 /home/exouser/Testsuite/Tests/parallel_loop_reduction_bitor_general.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/parallel_loop_reduction_bitor_general.c\", line 9: warning: variable \"temp\" was declared but never referenced\n      unsigned int temp = 1;\n                   ^\n\n\"/home/exouser/Testsuite/Tests/parallel_loop_reduction_bitor_general.c\", line 91: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.1657485910691321
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.009612453170120716,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "parallel_loop_reduction_bitor_loop.F90": [
            {
                "compilation": {
                    "command": "nvfortran -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/parallel_loop_reduction_bitor_loop.F90/parallel_loop_reduction_bitor_loop.F900 /home/exouser/Testsuite/Tests/parallel_loop_reduction_bitor_loop.F90",
                    "config": 1,
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.673732993658632
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.14440502505749464,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "parallel_loop_reduction_bitor_loop.c": [
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -DT2 -o /home/exouser/Testsuite/build/parallel_loop_reduction_bitor_loop.c/parallel_loop_reduction_bitor_loop.c0 /home/exouser/Testsuite/Tests/parallel_loop_reduction_bitor_loop.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/parallel_loop_reduction_bitor_loop.c\", line 130: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.21596207562834024
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.010036355815827847,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "parallel_loop_reduction_bitor_vector_loop.F90": [
            {
                "compilation": {
                    "command": "nvfortran -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/parallel_loop_reduction_bitor_vector_loop.F90/parallel_loop_reduction_bitor_vector_loop.F900 /home/exouser/Testsuite/Tests/parallel_loop_reduction_bitor_vector_loop.F90",
                    "config": 1,
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.4883276103064418
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.08325382182374597,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "parallel_loop_reduction_bitor_vector_loop.c": [
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -DT2 -o /home/exouser/Testsuite/build/parallel_loop_reduction_bitor_vector_loop.c/parallel_loop_reduction_bitor_vector_loop.c0 /home/exouser/Testsuite/Tests/parallel_loop_reduction_bitor_vector_loop.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/parallel_loop_reduction_bitor_vector_loop.c\", line 110: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.21614387864246964
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.010071470867842436,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "parallel_loop_reduction_bitxor_general.F90": [
            {
                "compilation": {
                    "command": "nvfortran -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/parallel_loop_reduction_bitxor_general.F90/parallel_loop_reduction_bitxor_general.F900 /home/exouser/Testsuite/Tests/parallel_loop_reduction_bitxor_general.F90",
                    "config": 1,
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.4879906461574137
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.07504734396934509,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "parallel_loop_reduction_bitxor_general.c": [
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -DT2 -o /home/exouser/Testsuite/build/parallel_loop_reduction_bitxor_general.c/parallel_loop_reduction_bitxor_general.c0 /home/exouser/Testsuite/Tests/parallel_loop_reduction_bitxor_general.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/parallel_loop_reduction_bitxor_general.c\", line 76: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.16647341568022966
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.01836827304214239,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "parallel_loop_reduction_bitxor_loop.F90": [
            {
                "compilation": {
                    "command": "nvfortran -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/parallel_loop_reduction_bitxor_loop.F90/parallel_loop_reduction_bitxor_loop.F900 /home/exouser/Testsuite/Tests/parallel_loop_reduction_bitxor_loop.F90",
                    "config": 1,
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.5725592081435025
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.12523786490783095,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "parallel_loop_reduction_bitxor_loop.c": [
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -DT2 -o /home/exouser/Testsuite/build/parallel_loop_reduction_bitxor_loop.c/parallel_loop_reduction_bitxor_loop.c0 /home/exouser/Testsuite/Tests/parallel_loop_reduction_bitxor_loop.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/parallel_loop_reduction_bitxor_loop.c\", line 121: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.2163088689558208
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.009541815146803856,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "parallel_loop_reduction_bitxor_vector_loop.F90": [
            {
                "compilation": {
                    "command": "nvfortran -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/parallel_loop_reduction_bitxor_vector_loop.F90/parallel_loop_reduction_bitxor_vector_loop.F900 /home/exouser/Testsuite/Tests/parallel_loop_reduction_bitxor_vector_loop.F90",
                    "config": 1,
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.5264846137724817
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.1273676068522036,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "parallel_loop_reduction_bitxor_vector_loop.c": [
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -DT2 -o /home/exouser/Testsuite/build/parallel_loop_reduction_bitxor_vector_loop.c/parallel_loop_reduction_bitxor_vector_loop.c0 /home/exouser/Testsuite/Tests/parallel_loop_reduction_bitxor_vector_loop.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/parallel_loop_reduction_bitxor_vector_loop.c\", line 95: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.16553810611367226
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.010134999174624681,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "parallel_loop_reduction_max_general.F90": [
            {
                "compilation": {
                    "command": "nvfortran -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/parallel_loop_reduction_max_general.F90/parallel_loop_reduction_max_general.F900 /home/exouser/Testsuite/Tests/parallel_loop_reduction_max_general.F90",
                    "config": 1,
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.47333844890818
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.12856331374496222,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "parallel_loop_reduction_max_general.c": [
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -DT2 -o /home/exouser/Testsuite/build/parallel_loop_reduction_max_general.c/parallel_loop_reduction_max_general.c0 /home/exouser/Testsuite/Tests/parallel_loop_reduction_max_general.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/parallel_loop_reduction_max_general.c\", line 32: warning: use of \"=\" where \"==\" may have been intended\n      if (found = 0){\n          ^\n\n\"/home/exouser/Testsuite/Tests/parallel_loop_reduction_max_general.c\", line 10: warning: variable \"found\" was set but never used\n      int found = 0;\n          ^\n\n\"/home/exouser/Testsuite/Tests/parallel_loop_reduction_max_general.c\", line 84: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.16607104614377022
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.010205567814409733,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "parallel_loop_reduction_max_loop.F90": [
            {
                "compilation": {
                    "command": "nvfortran -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/parallel_loop_reduction_max_loop.F90/parallel_loop_reduction_max_loop.F900 /home/exouser/Testsuite/Tests/parallel_loop_reduction_max_loop.F90",
                    "config": 1,
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.48173873219639063
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.12449997756630182,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "parallel_loop_reduction_max_loop.c": [
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -DT2 -o /home/exouser/Testsuite/build/parallel_loop_reduction_max_loop.c/parallel_loop_reduction_max_loop.c0 /home/exouser/Testsuite/Tests/parallel_loop_reduction_max_loop.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/parallel_loop_reduction_max_loop.c\", line 12: warning: variable \"max\" was declared but never referenced\n      real_t max = 0.0;\n             ^\n\n\"/home/exouser/Testsuite/Tests/parallel_loop_reduction_max_loop.c\", line 125: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.21715928707271814
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.009847044944763184,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "parallel_loop_reduction_max_vector_loop.F90": [
            {
                "compilation": {
                    "command": "nvfortran -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/parallel_loop_reduction_max_vector_loop.F90/parallel_loop_reduction_max_vector_loop.F900 /home/exouser/Testsuite/Tests/parallel_loop_reduction_max_vector_loop.F90",
                    "config": 1,
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.4287934456951916
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.13281609723344445,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "parallel_loop_reduction_max_vector_loop.c": [
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -DT2 -o /home/exouser/Testsuite/build/parallel_loop_reduction_max_vector_loop.c/parallel_loop_reduction_max_vector_loop.c0 /home/exouser/Testsuite/Tests/parallel_loop_reduction_max_vector_loop.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/parallel_loop_reduction_max_vector_loop.c\", line 101: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.16654575383290648
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.010496733710169792,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "parallel_loop_reduction_min_general.F90": [
            {
                "compilation": {
                    "command": "nvfortran -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/parallel_loop_reduction_min_general.F90/parallel_loop_reduction_min_general.F900 /home/exouser/Testsuite/Tests/parallel_loop_reduction_min_general.F90",
                    "config": 1,
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.43832249799743295
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.08168074581772089,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "parallel_loop_reduction_min_general.c": [
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -DT2 -o /home/exouser/Testsuite/build/parallel_loop_reduction_min_general.c/parallel_loop_reduction_min_general.c0 /home/exouser/Testsuite/Tests/parallel_loop_reduction_min_general.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/parallel_loop_reduction_min_general.c\", line 86: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.16655607940629125
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.009397811256349087,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "parallel_loop_reduction_min_loop.F90": [
            {
                "compilation": {
                    "command": "nvfortran -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/parallel_loop_reduction_min_loop.F90/parallel_loop_reduction_min_loop.F900 /home/exouser/Testsuite/Tests/parallel_loop_reduction_min_loop.F90",
                    "config": 1,
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.49918292416259646
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.1221254556439817,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "parallel_loop_reduction_min_loop.c": [
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -DT2 -o /home/exouser/Testsuite/build/parallel_loop_reduction_min_loop.c/parallel_loop_reduction_min_loop.c0 /home/exouser/Testsuite/Tests/parallel_loop_reduction_min_loop.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/parallel_loop_reduction_min_loop.c\", line 120: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.21624657697975636
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.01824105391278863,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "parallel_loop_reduction_min_vector_loop.F90": [
            {
                "compilation": {
                    "command": "nvfortran -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/parallel_loop_reduction_min_vector_loop.F90/parallel_loop_reduction_min_vector_loop.F900 /home/exouser/Testsuite/Tests/parallel_loop_reduction_min_vector_loop.F90",
                    "config": 1,
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.5041669551283121
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.1259169108234346,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "parallel_loop_reduction_min_vector_loop.c": [
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -DT2 -o /home/exouser/Testsuite/build/parallel_loop_reduction_min_vector_loop.c/parallel_loop_reduction_min_vector_loop.c0 /home/exouser/Testsuite/Tests/parallel_loop_reduction_min_vector_loop.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/parallel_loop_reduction_min_vector_loop.c\", line 98: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.16618692222982645
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.009564979933202267,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "parallel_loop_reduction_multiply_general.F90": [
            {
                "compilation": {
                    "command": "nvfortran -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/parallel_loop_reduction_multiply_general.F90/parallel_loop_reduction_multiply_general.F900 /home/exouser/Testsuite/Tests/parallel_loop_reduction_multiply_general.F90",
                    "config": 1,
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.5344785219058394
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.12690746318548918,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "parallel_loop_reduction_multiply_general.c": [
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -DT2 -o /home/exouser/Testsuite/build/parallel_loop_reduction_multiply_general.c/parallel_loop_reduction_multiply_general.c0 /home/exouser/Testsuite/Tests/parallel_loop_reduction_multiply_general.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/parallel_loop_reduction_multiply_general.c\", line 81: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.1659048250876367
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.009555435739457607,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "parallel_loop_reduction_multiply_loop.F90": [
            {
                "compilation": {
                    "command": "nvfortran -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/parallel_loop_reduction_multiply_loop.F90/parallel_loop_reduction_multiply_loop.F900 /home/exouser/Testsuite/Tests/parallel_loop_reduction_multiply_loop.F90",
                    "config": 1,
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.5726663800887764
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.12563129607588053,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "parallel_loop_reduction_multiply_loop.c": [
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -DT2 -o /home/exouser/Testsuite/build/parallel_loop_reduction_multiply_loop.c/parallel_loop_reduction_multiply_loop.c0 /home/exouser/Testsuite/Tests/parallel_loop_reduction_multiply_loop.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/parallel_loop_reduction_multiply_loop.c\", line 121: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.21629324462264776
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.009552136063575745,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "parallel_loop_reduction_multiply_vector_loop.F90": [
            {
                "compilation": {
                    "command": "nvfortran -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/parallel_loop_reduction_multiply_vector_loop.F90/parallel_loop_reduction_multiply_vector_loop.F900 /home/exouser/Testsuite/Tests/parallel_loop_reduction_multiply_vector_loop.F90",
                    "config": 1,
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.48843503883108497
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.08331213518977165,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "parallel_loop_reduction_multiply_vector_loop.c": [
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -DT2 -DT3 -o /home/exouser/Testsuite/build/parallel_loop_reduction_multiply_vector_loop.c/parallel_loop_reduction_multiply_vector_loop.c0 /home/exouser/Testsuite/Tests/parallel_loop_reduction_multiply_vector_loop.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/parallel_loop_reduction_multiply_vector_loop.c\", line 130: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.1656765672378242
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.017533455975353718,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "parallel_loop_reduction_or_general.F90": [
            {
                "compilation": {
                    "command": "nvfortran -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/parallel_loop_reduction_or_general.F90/parallel_loop_reduction_or_general.F900 /home/exouser/Testsuite/Tests/parallel_loop_reduction_or_general.F90",
                    "config": 1,
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.49218661384657025
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.12562438705936074,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "parallel_loop_reduction_or_general.c": [
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -DT2 -o /home/exouser/Testsuite/build/parallel_loop_reduction_or_general.c/parallel_loop_reduction_or_general.c0 /home/exouser/Testsuite/Tests/parallel_loop_reduction_or_general.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/parallel_loop_reduction_or_general.c\", line 91: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.165599649772048
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.009510604199022055,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "parallel_loop_reduction_or_loop.F90": [
            {
                "compilation": {
                    "command": "nvfortran -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/parallel_loop_reduction_or_loop.F90/parallel_loop_reduction_or_loop.F900 /home/exouser/Testsuite/Tests/parallel_loop_reduction_or_loop.F90",
                    "config": 1,
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.5384607617743313
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.12384616490453482,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "parallel_loop_reduction_or_loop.c": [
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/parallel_loop_reduction_or_loop.c/parallel_loop_reduction_or_loop.c0 /home/exouser/Testsuite/Tests/parallel_loop_reduction_or_loop.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/parallel_loop_reduction_or_loop.c\", line 74: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.2160507459193468
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.009562724735587835,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "parallel_loop_reduction_or_vector_loop.F90": [
            {
                "compilation": {
                    "command": "nvfortran -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/parallel_loop_reduction_or_vector_loop.F90/parallel_loop_reduction_or_vector_loop.F900 /home/exouser/Testsuite/Tests/parallel_loop_reduction_or_vector_loop.F90",
                    "config": 1,
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.49221593607217073
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.12972842901945114,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "parallel_loop_reduction_or_vector_loop.c": [
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/parallel_loop_reduction_or_vector_loop.c/parallel_loop_reduction_or_vector_loop.c0 /home/exouser/Testsuite/Tests/parallel_loop_reduction_or_vector_loop.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/parallel_loop_reduction_or_vector_loop.c\", line 51: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.1658390569500625
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.009580006822943687,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "parallel_loop_seq.F90": [
            {
                "compilation": {
                    "command": "nvfortran -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/parallel_loop_seq.F90/parallel_loop_seq.F900 /home/exouser/Testsuite/Tests/parallel_loop_seq.F90",
                    "config": 1,
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.5302214990369976
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.025816132314503193,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "parallel_loop_seq.c": [
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/parallel_loop_seq.c/parallel_loop_seq.c0 /home/exouser/Testsuite/Tests/parallel_loop_seq.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/parallel_loop_seq.c\", line 37: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.16609946079552174
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.005391542799770832,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "parallel_loop_tile.F90": [
            {
                "compilation": {
                    "command": "nvfortran -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/parallel_loop_tile.F90/parallel_loop_tile.F900 /home/exouser/Testsuite/Tests/parallel_loop_tile.F90",
                    "config": 1,
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.47732664085924625
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.07483463920652866,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "parallel_loop_tile.c": [
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/parallel_loop_tile.c/parallel_loop_tile.c0 /home/exouser/Testsuite/Tests/parallel_loop_tile.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/parallel_loop_tile.c\", line 58: warning: variable \"temp\" was declared but never referenced\n      real_t temp = 0.0;\n             ^\n\n\"/home/exouser/Testsuite/Tests/parallel_loop_tile.c\", line 94: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.21588134299963713
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.017639809288084507,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "parallel_loop_vector.F90": [
            {
                "compilation": {
                    "command": "nvfortran -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/parallel_loop_vector.F90/parallel_loop_vector.F900 /home/exouser/Testsuite/Tests/parallel_loop_vector.F90",
                    "config": 1,
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.4812945928424597
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.03055855305865407,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "parallel_loop_vector.c": [
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/parallel_loop_vector.c/parallel_loop_vector.c0 /home/exouser/Testsuite/Tests/parallel_loop_vector.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/parallel_loop_vector.c\", line 37: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.16569931991398335
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.005412005819380283,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "parallel_loop_vector_blocking.F90": [
            {
                "compilation": {
                    "command": "nvfortran -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/parallel_loop_vector_blocking.F90/parallel_loop_vector_blocking.F900 /home/exouser/Testsuite/Tests/parallel_loop_vector_blocking.F90",
                    "config": 1,
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.3903292752802372
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.034456606954336166,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "parallel_loop_vector_blocking.c": [
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/parallel_loop_vector_blocking.c/parallel_loop_vector_blocking.c0 /home/exouser/Testsuite/Tests/parallel_loop_vector_blocking.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/parallel_loop_vector_blocking.c\", line 36: warning: expression has no effect\n        err + 1;\n        ^\n\n\"/home/exouser/Testsuite/Tests/parallel_loop_vector_blocking.c\", line 47: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.16554246097803116
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.005390324164181948,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "parallel_loop_worker.F90": [
            {
                "compilation": {
                    "command": "nvfortran -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/parallel_loop_worker.F90/parallel_loop_worker.F900 /home/exouser/Testsuite/Tests/parallel_loop_worker.F90",
                    "config": 1,
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.49628857197239995
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.04310888610780239,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "parallel_loop_worker.c": [
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/parallel_loop_worker.c/parallel_loop_worker.c0 /home/exouser/Testsuite/Tests/parallel_loop_worker.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/parallel_loop_worker.c\", line 37: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.16573829296976328
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.009645114187151194,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "parallel_loop_worker_blocking.F90": [
            {
                "compilation": {
                    "command": "nvfortran -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/parallel_loop_worker_blocking.F90/parallel_loop_worker_blocking.F900 /home/exouser/Testsuite/Tests/parallel_loop_worker_blocking.F90",
                    "config": 1,
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.48118489887565374
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.042581165209412575,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "parallel_loop_worker_blocking.c": [
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/parallel_loop_worker_blocking.c/parallel_loop_worker_blocking.c0 /home/exouser/Testsuite/Tests/parallel_loop_worker_blocking.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/parallel_loop_worker_blocking.c\", line 36: warning: expression has no effect\n          err + 1;\n          ^\n\n\"/home/exouser/Testsuite/Tests/parallel_loop_worker_blocking.c\", line 47: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.16571752121672034
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.005290595348924398,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "parallel_present.F90": [
            {
                "compilation": {
                    "command": "nvfortran -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/parallel_present.F90/parallel_present.F900 /home/exouser/Testsuite/Tests/parallel_present.F90",
                    "config": 1,
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.5386239015497267
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.13886399613693357,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "parallel_present.c": [
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/parallel_present.c/parallel_present.c0 /home/exouser/Testsuite/Tests/parallel_present.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/parallel_present.c\", line 39: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.21584746008738875
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.009453396778553724,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "parallel_private.F90": [
            {
                "compilation": {
                    "command": "nvfortran -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/parallel_private.F90/parallel_private.F900 /home/exouser/Testsuite/Tests/parallel_private.F90",
                    "config": 1,
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.5846086037345231
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.14065968710929155,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "parallel_private.c": [
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/parallel_private.c/parallel_private.c0 /home/exouser/Testsuite/Tests/parallel_private.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/parallel_private.c\", line 55: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.21578136505559087
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.017622089944779873,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "parallel_reduction.F90": [
            {
                "compilation": {
                    "command": "nvfortran -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/parallel_reduction.F90/parallel_reduction.F900 /home/exouser/Testsuite/Tests/parallel_reduction.F90",
                    "config": 1,
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.4340146677568555
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.12765405187383294,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "parallel_reduction.c": [
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/parallel_reduction.c/parallel_reduction.c0 /home/exouser/Testsuite/Tests/parallel_reduction.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/parallel_reduction.c\", line 35: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.1657082070596516
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.01752324029803276,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "parallel_scalar_default_firstprivate.F90": [
            {
                "compilation": {
                    "command": "nvfortran -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/parallel_scalar_default_firstprivate.F90/parallel_scalar_default_firstprivate.F900 /home/exouser/Testsuite/Tests/parallel_scalar_default_firstprivate.F90",
                    "config": 1,
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.5721531887538731
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.12537660589441657,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "parallel_scalar_default_firstprivate.c": [
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/parallel_scalar_default_firstprivate.c/parallel_scalar_default_firstprivate.c0 /home/exouser/Testsuite/Tests/parallel_scalar_default_firstprivate.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/parallel_scalar_default_firstprivate.c\", line 43: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.16571007808670402
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.009557864163070917,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "parallel_switch.F90": [
            {
                "compilation": {
                    "command": "nvfortran -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/parallel_switch.F90/parallel_switch.F900 /home/exouser/Testsuite/Tests/parallel_switch.F90",
                    "config": 1,
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.5265013007447124
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.13073048694059253,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "parallel_switch.c": [
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/parallel_switch.c/parallel_switch.c0 /home/exouser/Testsuite/Tests/parallel_switch.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/parallel_switch.c\", line 66: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.1659775609150529
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.009649022947996855,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "parallel_wait.F90": [
            {
                "compilation": {
                    "command": "nvfortran -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/parallel_wait.F90/parallel_wait.F900 /home/exouser/Testsuite/Tests/parallel_wait.F90",
                    "config": 1,
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.5310385557822883
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.13455953868106008,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "parallel_wait.c": [
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/parallel_wait.c/parallel_wait.c0 /home/exouser/Testsuite/Tests/parallel_wait.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/parallel_wait.c\", line 37: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.16570630203932524
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.0175561448559165,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "parallel_while_loop.F90": [
            {
                "compilation": {
                    "command": "nvfortran -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/parallel_while_loop.F90/parallel_while_loop.F900 /home/exouser/Testsuite/Tests/parallel_while_loop.F90",
                    "config": 1,
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.4965749070979655
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.12935116095468402,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "parallel_while_loop.c": [
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/parallel_while_loop.c/parallel_while_loop.c0 /home/exouser/Testsuite/Tests/parallel_while_loop.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/parallel_while_loop.c\", line 50: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.16573783988133073
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.009637235198169947,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "routine_bind.c": [
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -DT1 -DT2 -DT3 -DT4 -o /home/exouser/Testsuite/build/routine_bind.c/routine_bind.c0 /home/exouser/Testsuite/Tests/routine_bind.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/routine_bind.c\", line 250: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n\"/home/exouser/Testsuite/Tests/routine_bind.c\", line 251: warning: variable \"failed\" was declared but never referenced\n      int failed;\n          ^\n\n",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 0.21610980480909348
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 0.005367094650864601,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -DT2 -DT3 -DT4 -o /home/exouser/Testsuite/build/routine_bind.c/routine_bind.c1 /home/exouser/Testsuite/Tests/routine_bind.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/routine_bind.c\", line 250: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 0.2661489909514785
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": false,
                    "output": "",
                    "result": 1,
                    "runtime": 0.0095918751321733,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -DT1 -DT3 -DT4 -o /home/exouser/Testsuite/build/routine_bind.c/routine_bind.c2 /home/exouser/Testsuite/Tests/routine_bind.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/routine_bind.c\", line 250: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 0.2162134530954063
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": false,
                    "output": "",
                    "result": 2,
                    "runtime": 0.009496357757598162,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -DT1 -DT2 -DT4 -o /home/exouser/Testsuite/build/routine_bind.c/routine_bind.c3 /home/exouser/Testsuite/Tests/routine_bind.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/routine_bind.c\", line 250: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 0.21628950629383326
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": false,
                    "output": "",
                    "result": 4,
                    "runtime": 0.009687090292572975,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -DT1 -DT2 -DT3 -o /home/exouser/Testsuite/build/routine_bind.c/routine_bind.c4 /home/exouser/Testsuite/Tests/routine_bind.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/routine_bind.c\", line 250: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 0.2159059657715261
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": false,
                    "output": "",
                    "result": 8,
                    "runtime": 0.009562399704009295,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/routine_bind.c/routine_bind.c5 /home/exouser/Testsuite/Tests/routine_bind.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/routine_bind.c\", line 250: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.3669885038398206
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 15,
                    "runtime": 0.009639631025493145,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "routine_gang.c": [
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -DT1 -DT2 -DT3 -DT4 -DT5 -DT6 -DT7 -DT8 -DT9 -DT10 -o /home/exouser/Testsuite/build/routine_gang.c/routine_gang.c0 /home/exouser/Testsuite/Tests/routine_gang.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/routine_gang.c\", line 502: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n\"/home/exouser/Testsuite/Tests/routine_gang.c\", line 503: warning: variable \"failed\" was declared but never referenced\n      int failed;\n          ^\n\n",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 0.26616498082876205
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 0.009722672868520021,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -DT2 -DT3 -DT4 -DT5 -DT6 -DT7 -DT8 -DT9 -DT10 -o /home/exouser/Testsuite/build/routine_gang.c/routine_gang.c1 /home/exouser/Testsuite/Tests/routine_gang.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/routine_gang.c\", line 175: error: identifier \"x\" is undefined\n          b[x] = 0;\n            ^\n\n\"/home/exouser/Testsuite/Tests/routine_gang.c\", line 176: warning: missing return statement at end of non-void function \"test1\"\n      }\n      ^\n\n\"/home/exouser/Testsuite/Tests/routine_gang.c\", line 163: warning: variable \"err\" was declared but never referenced\n      int err = 0;\n          ^\n\n\"/home/exouser/Testsuite/Tests/routine_gang.c\", line 179: error: expected a declaration\n      {\n      ^\n\n\"/home/exouser/Testsuite/Tests/routine_gang.c\", line 186: error: expected a declaration\n      if (validate_data(a, b)){\n      ^\n\n\"/home/exouser/Testsuite/Tests/routine_gang.c\", line 190: warning: parsing restarts here after previous syntax error\n      return err;\n                ^\n\n\"/home/exouser/Testsuite/Tests/routine_gang.c\", line 191: error: expected a declaration\n  }\n  ^\n\n\"/home/exouser/Testsuite/Tests/routine_gang.c\", line 594: warning: parsing restarts here after previous syntax error\n      return failcode;\n                     ^\n\n\"/home/exouser/Testsuite/Tests/routine_gang.c\", line 595: error: expected a declaration\n  }\n  ^\n\n5 errors detected in the compilation of \"/home/exouser/Testsuite/Tests/routine_gang.c\".\n",
                    "export": false,
                    "output": "",
                    "result": 2,
                    "runtime": 0.06540166027843952
                },
                "post-compile commands": [],
                "pre-compile commands": [],
                "runtime": {
                    "export": false,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -DT1 -DT3 -DT4 -DT5 -DT6 -DT7 -DT8 -DT9 -DT10 -o /home/exouser/Testsuite/build/routine_gang.c/routine_gang.c2 /home/exouser/Testsuite/Tests/routine_gang.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/routine_gang.c\", line 502: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 0.31688988534733653
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 0.005434537306427956,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -DT1 -DT2 -DT4 -DT5 -DT6 -DT7 -DT8 -DT9 -DT10 -o /home/exouser/Testsuite/build/routine_gang.c/routine_gang.c3 /home/exouser/Testsuite/Tests/routine_gang.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/routine_gang.c\", line 502: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 0.3163897260092199
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 0.018145300913602114,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -DT1 -DT2 -DT3 -DT5 -DT6 -DT7 -DT8 -DT9 -DT10 -o /home/exouser/Testsuite/build/routine_gang.c/routine_gang.c4 /home/exouser/Testsuite/Tests/routine_gang.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/routine_gang.c\", line 502: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 0.3167646052315831
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 0.00963982380926609,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -DT1 -DT2 -DT3 -DT4 -DT6 -DT7 -DT8 -DT9 -DT10 -o /home/exouser/Testsuite/build/routine_gang.c/routine_gang.c5 /home/exouser/Testsuite/Tests/routine_gang.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/routine_gang.c\", line 502: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 0.3163792579434812
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 0.009725118987262249,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -DT1 -DT2 -DT3 -DT4 -DT5 -DT7 -DT8 -DT9 -DT10 -o /home/exouser/Testsuite/build/routine_gang.c/routine_gang.c6 /home/exouser/Testsuite/Tests/routine_gang.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/routine_gang.c\", line 502: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 0.31666247081011534
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 0.011354433372616768,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -DT1 -DT2 -DT3 -DT4 -DT5 -DT6 -DT8 -DT9 -DT10 -o /home/exouser/Testsuite/build/routine_gang.c/routine_gang.c7 /home/exouser/Testsuite/Tests/routine_gang.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/routine_gang.c\", line 502: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 0.31678841495886445
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 0.00962007138878107,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -DT1 -DT2 -DT3 -DT4 -DT5 -DT6 -DT7 -DT9 -DT10 -o /home/exouser/Testsuite/build/routine_gang.c/routine_gang.c8 /home/exouser/Testsuite/Tests/routine_gang.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/routine_gang.c\", line 502: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 0.3160402840003371
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 0.009730439633131027,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -DT1 -DT2 -DT3 -DT4 -DT5 -DT6 -DT7 -DT8 -DT10 -o /home/exouser/Testsuite/build/routine_gang.c/routine_gang.c9 /home/exouser/Testsuite/Tests/routine_gang.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/routine_gang.c\", line 502: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 0.31641994323581457
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 0.009722532238811255,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -DT1 -DT2 -DT3 -DT4 -DT5 -DT6 -DT7 -DT8 -DT9 -o /home/exouser/Testsuite/build/routine_gang.c/routine_gang.c10 /home/exouser/Testsuite/Tests/routine_gang.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/routine_gang.c\", line 502: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 0.3166004605591297
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 0.009701305069029331,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -DT1 -o /home/exouser/Testsuite/build/routine_gang.c/routine_gang.c11 /home/exouser/Testsuite/Tests/routine_gang.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/routine_gang.c\", line 502: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.5669271717779338
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.009744311682879925,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "routine_nohost.c": [
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/routine_nohost.c/routine_nohost.c0 /home/exouser/Testsuite/Tests/routine_nohost.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/routine_nohost.c\", line 56: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n/opt/nvidia/hpc_sdk/Linux_x86_64/21.5/compilers/share/llvm/bin/opt: /tmp/nvcKvChS9zr4k6n.ll:328:21: error: use of undefined value '@function'\n        %29 = call double  @function (double*  %27, i64  %28) nounwind, !dbg !78\n                           ^\n",
                    "export": false,
                    "output": "",
                    "result": 2,
                    "runtime": 0.11559936823323369
                },
                "post-compile commands": [],
                "pre-compile commands": [],
                "runtime": {
                    "export": false,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -DT1 -o /home/exouser/Testsuite/build/routine_nohost.c/routine_nohost.c1 /home/exouser/Testsuite/Tests/routine_nohost.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/routine_nohost.c\", line 56: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n\"/home/exouser/Testsuite/Tests/routine_nohost.c\", line 57: warning: variable \"failed\" was declared but never referenced\n      int failed;\n          ^\n\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.16939993994310498
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.00544185983017087,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "routine_seq.c": [
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -DT1 -DT2 -DT3 -DT4 -o /home/exouser/Testsuite/build/routine_seq.c/routine_seq.c0 /home/exouser/Testsuite/Tests/routine_seq.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/routine_seq.c\", line 206: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n\"/home/exouser/Testsuite/Tests/routine_seq.c\", line 207: warning: variable \"failed\" was declared but never referenced\n      int failed;\n          ^\n\n",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 0.21629869611933827
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 0.005468466784805059,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -DT2 -DT3 -DT4 -o /home/exouser/Testsuite/build/routine_seq.c/routine_seq.c1 /home/exouser/Testsuite/Tests/routine_seq.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/routine_seq.c\", line 206: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 0.2156676324084401
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 0.005435482133179903,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -DT1 -DT3 -DT4 -o /home/exouser/Testsuite/build/routine_seq.c/routine_seq.c2 /home/exouser/Testsuite/Tests/routine_seq.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/routine_seq.c\", line 206: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 0.2160558202303946
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 0.0054106987081468105,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -DT1 -DT2 -DT4 -o /home/exouser/Testsuite/build/routine_seq.c/routine_seq.c3 /home/exouser/Testsuite/Tests/routine_seq.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/routine_seq.c\", line 206: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 0.2161648883484304
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 0.017681530211120844,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -DT1 -DT2 -DT3 -o /home/exouser/Testsuite/build/routine_seq.c/routine_seq.c4 /home/exouser/Testsuite/Tests/routine_seq.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/routine_seq.c\", line 206: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 0.2160492232069373
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 0.009594175964593887,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/routine_seq.c/routine_seq.c5 /home/exouser/Testsuite/Tests/routine_seq.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/routine_seq.c\", line 206: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.3164360229857266
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.020645481999963522,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "routine_vector.c": [
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -DT1 -DT2 -DT3 -DT4 -DT5 -DT6 -o /home/exouser/Testsuite/build/routine_vector.c/routine_vector.c0 /home/exouser/Testsuite/Tests/routine_vector.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/routine_vector.c\", line 301: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n\"/home/exouser/Testsuite/Tests/routine_vector.c\", line 302: warning: variable \"failed\" was declared but never referenced\n      int failed;\n          ^\n\n",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 0.215770754031837
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 0.005476081278175116,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -DT2 -DT3 -DT4 -DT5 -DT6 -o /home/exouser/Testsuite/build/routine_vector.c/routine_vector.c1 /home/exouser/Testsuite/Tests/routine_vector.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/routine_vector.c\", line 301: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 0.21611867612227798
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 0.00961798382923007,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -DT1 -DT3 -DT4 -DT5 -DT6 -o /home/exouser/Testsuite/build/routine_vector.c/routine_vector.c2 /home/exouser/Testsuite/Tests/routine_vector.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/routine_vector.c\", line 301: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 0.2163007752969861
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 0.009698874317109585,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -DT1 -DT2 -DT4 -DT5 -DT6 -o /home/exouser/Testsuite/build/routine_vector.c/routine_vector.c3 /home/exouser/Testsuite/Tests/routine_vector.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/routine_vector.c\", line 301: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 0.2666885950602591
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 0.010198066011071205,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -DT1 -DT2 -DT3 -DT5 -DT6 -o /home/exouser/Testsuite/build/routine_vector.c/routine_vector.c4 /home/exouser/Testsuite/Tests/routine_vector.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/routine_vector.c\", line 301: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 0.26692694518715143
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 0.010257722809910774,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -DT1 -DT2 -DT3 -DT4 -DT6 -o /home/exouser/Testsuite/build/routine_vector.c/routine_vector.c5 /home/exouser/Testsuite/Tests/routine_vector.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/routine_vector.c\", line 301: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 0.2665726481936872
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 0.01000924501568079,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -DT1 -DT2 -DT3 -DT4 -DT5 -o /home/exouser/Testsuite/build/routine_vector.c/routine_vector.c6 /home/exouser/Testsuite/Tests/routine_vector.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/routine_vector.c\", line 301: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 0.2665392360650003
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 0.00975224794819951,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/routine_vector.c/routine_vector.c7 /home/exouser/Testsuite/Tests/routine_vector.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/routine_vector.c\", line 301: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.3669160809367895
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.017724393866956234,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "routine_worker.c": [
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -DT1 -DT2 -DT3 -DT4 -DT5 -DT6 -DT7 -DT8 -o /home/exouser/Testsuite/build/routine_worker.c/routine_worker.c0 /home/exouser/Testsuite/Tests/routine_worker.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/routine_worker.c\", line 397: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n\"/home/exouser/Testsuite/Tests/routine_worker.c\", line 398: warning: variable \"failed\" was declared but never referenced\n      int failed;\n          ^\n\n",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 0.2659608949907124
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 0.005626414902508259,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -DT2 -DT3 -DT4 -DT5 -DT6 -DT7 -DT8 -o /home/exouser/Testsuite/build/routine_worker.c/routine_worker.c1 /home/exouser/Testsuite/Tests/routine_worker.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/routine_worker.c\", line 397: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 0.2660957151092589
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 0.009824571199715137,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -DT1 -DT3 -DT4 -DT5 -DT6 -DT7 -DT8 -o /home/exouser/Testsuite/build/routine_worker.c/routine_worker.c2 /home/exouser/Testsuite/Tests/routine_worker.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/routine_worker.c\", line 397: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 0.2659287778660655
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 0.005560791119933128,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -DT1 -DT2 -DT4 -DT5 -DT6 -DT7 -DT8 -o /home/exouser/Testsuite/build/routine_worker.c/routine_worker.c3 /home/exouser/Testsuite/Tests/routine_worker.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/routine_worker.c\", line 397: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 0.26601205999031663
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 0.009688145015388727,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -DT1 -DT2 -DT3 -DT5 -DT6 -DT7 -DT8 -o /home/exouser/Testsuite/build/routine_worker.c/routine_worker.c4 /home/exouser/Testsuite/Tests/routine_worker.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/routine_worker.c\", line 397: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 0.26602531410753727
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 0.00979062495753169,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -DT1 -DT2 -DT3 -DT4 -DT6 -DT7 -DT8 -o /home/exouser/Testsuite/build/routine_worker.c/routine_worker.c5 /home/exouser/Testsuite/Tests/routine_worker.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/routine_worker.c\", line 397: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 0.26603775890544057
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 0.009630255866795778,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -DT1 -DT2 -DT3 -DT4 -DT5 -DT7 -DT8 -o /home/exouser/Testsuite/build/routine_worker.c/routine_worker.c6 /home/exouser/Testsuite/Tests/routine_worker.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/routine_worker.c\", line 397: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 0.26671954384073615
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 0.009721038863062859,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -DT1 -DT2 -DT3 -DT4 -DT5 -DT6 -DT8 -o /home/exouser/Testsuite/build/routine_worker.c/routine_worker.c7 /home/exouser/Testsuite/Tests/routine_worker.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/routine_worker.c\", line 397: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 0.2663635006174445
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 0.00976291997358203,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -DT1 -DT2 -DT3 -DT4 -DT5 -DT6 -DT7 -o /home/exouser/Testsuite/build/routine_worker.c/routine_worker.c8 /home/exouser/Testsuite/Tests/routine_worker.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/routine_worker.c\", line 397: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 0.2658693208359182
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": false,
                    "output": "",
                    "result": 0,
                    "runtime": 0.009706883691251278,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/routine_worker.c/routine_worker.c9 /home/exouser/Testsuite/Tests/routine_worker.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/routine_worker.c\", line 397: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.41723066894337535
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.017958943732082844,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "serial.F90": [
            {
                "compilation": {
                    "command": "nvfortran -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/serial.F90/serial.F900 /home/exouser/Testsuite/Tests/serial.F90",
                    "config": 1,
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 2.9456813377328217
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.07404784392565489,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "serial.c": [
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/serial.c/serial.c0 /home/exouser/Testsuite/Tests/serial.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/serial.c\", line 69: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.7688317182473838
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.005484584718942642,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "serial_async.F90": [
            {
                "compilation": {
                    "command": "nvfortran -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/serial_async.F90/serial_async.F900 /home/exouser/Testsuite/Tests/serial_async.F90",
                    "config": 1,
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.5464023118838668
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.05334343807771802,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "serial_async.c": [
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/serial_async.c/serial_async.c0 /home/exouser/Testsuite/Tests/serial_async.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/serial_async.c\", line 78: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.2159719979390502
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.005585546139627695,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "serial_copy.F90": [
            {
                "compilation": {
                    "command": "nvfortran -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/serial_copy.F90/serial_copy.F900 /home/exouser/Testsuite/Tests/serial_copy.F90",
                    "config": 1,
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.4262970290146768
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.07349228579550982,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "serial_copy.c": [
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/serial_copy.c/serial_copy.c0 /home/exouser/Testsuite/Tests/serial_copy.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/serial_copy.c\", line 35: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.1659491779282689
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.005485164001584053,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "serial_copyin.F90": [
            {
                "compilation": {
                    "command": "nvfortran -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/serial_copyin.F90/serial_copyin.F900 /home/exouser/Testsuite/Tests/serial_copyin.F90",
                    "config": 1,
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.4302868079394102
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.05330842500552535,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "serial_copyin.c": [
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/serial_copyin.c/serial_copyin.c0 /home/exouser/Testsuite/Tests/serial_copyin.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/serial_copyin.c\", line 78: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.1656135763041675
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.005496317986398935,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "serial_copyout.F90": [
            {
                "compilation": {
                    "command": "nvfortran -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/serial_copyout.F90/serial_copyout.F900 /home/exouser/Testsuite/Tests/serial_copyout.F90",
                    "config": 1,
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.5384114547632635
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.05710595520213246,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "serial_copyout.c": [
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/serial_copyout.c/serial_copyout.c0 /home/exouser/Testsuite/Tests/serial_copyout.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/serial_copyout.c\", line 134: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.16587182600051165
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.005498168058693409,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "serial_create.F90": [
            {
                "compilation": {
                    "command": "nvfortran -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/serial_create.F90/serial_create.F900 /home/exouser/Testsuite/Tests/serial_create.F90",
                    "config": 1,
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.48837841721251607
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.027629476971924305,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "serial_create.c": [
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/serial_create.c/serial_create.c0 /home/exouser/Testsuite/Tests/serial_create.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/serial_create.c\", line 44: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.16579353110864758
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.005408368073403835,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "serial_default_copy.F90": [
            {
                "compilation": {
                    "command": "nvfortran -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/serial_default_copy.F90/serial_default_copy.F900 /home/exouser/Testsuite/Tests/serial_default_copy.F90",
                    "config": 1,
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.5883051832206547
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.034813561011105776,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "serial_default_copy.c": [
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/serial_default_copy.c/serial_default_copy.c0 /home/exouser/Testsuite/Tests/serial_default_copy.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/serial_default_copy.c\", line 98: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.1658923509530723
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.005511424969881773,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "serial_default_present.F90": [
            {
                "compilation": {
                    "command": "nvfortran -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/serial_default_present.F90/serial_default_present.F900 /home/exouser/Testsuite/Tests/serial_default_present.F90",
                    "config": 1,
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.38010194385424256
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.04297095397487283,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "serial_default_present.c": [
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/serial_default_present.c/serial_default_present.c0 /home/exouser/Testsuite/Tests/serial_default_present.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/serial_default_present.c\", line 34: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.16566522093489766
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.005551600828766823,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "serial_deviceptr.c": [
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/serial_deviceptr.c/serial_deviceptr.c0 /home/exouser/Testsuite/Tests/serial_deviceptr.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/serial_deviceptr.c\", line 48: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.16600520303472877
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.005435924045741558,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "serial_firstprivate.F90": [
            {
                "compilation": {
                    "command": "nvfortran -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/serial_firstprivate.F90/serial_firstprivate.F900 /home/exouser/Testsuite/Tests/serial_firstprivate.F90",
                    "config": 1,
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.5390945188701153
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.045005750842392445,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "serial_firstprivate.c": [
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/serial_firstprivate.c/serial_firstprivate.c0 /home/exouser/Testsuite/Tests/serial_firstprivate.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/serial_firstprivate.c\", line 98: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.21590526774525642
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.005537054967135191,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "serial_if.F90": [
            {
                "compilation": {
                    "command": "nvfortran -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/serial_if.F90/serial_if.F900 /home/exouser/Testsuite/Tests/serial_if.F90",
                    "config": 1,
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.6357126920484006
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.04420071793720126,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "serial_if.c": [
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/serial_if.c/serial_if.c0 /home/exouser/Testsuite/Tests/serial_if.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/serial_if.c\", line 10: warning: variable \"accel\" was declared but never referenced\n      int accel = 1;\n          ^\n\n\"/home/exouser/Testsuite/Tests/serial_if.c\", line 44: warning: variable \"accel\" was declared but never referenced\n      int accel = 1;\n          ^\n\n\"/home/exouser/Testsuite/Tests/serial_if.c\", line 90: warning: variable \"host\" was declared but never referenced\n      int host = 0;\n          ^\n\n\"/home/exouser/Testsuite/Tests/serial_if.c\", line 120: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.21702522598206997
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.009804219007492065,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "serial_loop.F90": [
            {
                "compilation": {
                    "command": "nvfortran -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/serial_loop.F90/serial_loop.F900 /home/exouser/Testsuite/Tests/serial_loop.F90",
                    "config": 1,
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.5303840809501708
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.08542081480845809,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "serial_loop.c": [
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/serial_loop.c/serial_loop.c0 /home/exouser/Testsuite/Tests/serial_loop.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/serial_loop.c\", line 74: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.16581024089828134
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.0054334248416125774,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "serial_loop_async.F90": [
            {
                "compilation": {
                    "command": "nvfortran -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/serial_loop_async.F90/serial_loop_async.F900 /home/exouser/Testsuite/Tests/serial_loop_async.F90",
                    "config": 1,
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.6261987048201263
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.040994757786393166,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "serial_loop_async.c": [
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/serial_loop_async.c/serial_loop_async.c0 /home/exouser/Testsuite/Tests/serial_loop_async.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/serial_loop_async.c\", line 51: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.16562446393072605
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.0055984309874475,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "serial_loop_auto.F90": [
            {
                "compilation": {
                    "command": "nvfortran -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/serial_loop_auto.F90/serial_loop_auto.F900 /home/exouser/Testsuite/Tests/serial_loop_auto.F90",
                    "config": 1,
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.438252582680434
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.04558984562754631,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "serial_loop_auto.c": [
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/serial_loop_auto.c/serial_loop_auto.c0 /home/exouser/Testsuite/Tests/serial_loop_auto.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/serial_loop_auto.c\", line 10: warning: variable \"rolling_total\" was declared but never referenced\n      real_t rolling_total = 0.0;\n             ^\n\n\"/home/exouser/Testsuite/Tests/serial_loop_auto.c\", line 71: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.16594993136823177
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.0054956781677901745,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "serial_loop_gang.F90": [
            {
                "compilation": {
                    "command": "nvfortran -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/serial_loop_gang.F90/serial_loop_gang.F900 /home/exouser/Testsuite/Tests/serial_loop_gang.F90",
                    "config": 1,
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.49208633229136467
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.026705648750066757,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "serial_loop_gang.c": [
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/serial_loop_gang.c/serial_loop_gang.c0 /home/exouser/Testsuite/Tests/serial_loop_gang.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/serial_loop_gang.c\", line 19: error: invalid text in pragma\n          #pragma acc serial loop gang\n                                  ^\n\n\"/home/exouser/Testsuite/Tests/serial_loop_gang.c\", line 37: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n1 error detected in the compilation of \"/home/exouser/Testsuite/Tests/serial_loop_gang.c\".\n",
                    "export": false,
                    "output": "",
                    "result": 2,
                    "runtime": 0.06546312291175127
                },
                "post-compile commands": [],
                "pre-compile commands": [],
                "runtime": {
                    "export": false,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -DT1 -o /home/exouser/Testsuite/build/serial_loop_gang.c/serial_loop_gang.c1 /home/exouser/Testsuite/Tests/serial_loop_gang.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/serial_loop_gang.c\", line 37: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n\"/home/exouser/Testsuite/Tests/serial_loop_gang.c\", line 38: warning: variable \"failed\" was declared but never referenced\n      int failed;\n          ^\n\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.1654813508503139
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.005428092088550329,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "serial_loop_reduction_add_general.F90": [
            {
                "compilation": {
                    "command": "nvfortran -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/serial_loop_reduction_add_general.F90/serial_loop_reduction_add_general.F900 /home/exouser/Testsuite/Tests/serial_loop_reduction_add_general.F90",
                    "config": 1,
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.5266082952730358
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.060681619215756655,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "serial_loop_reduction_add_general.c": [
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/serial_loop_reduction_add_general.c/serial_loop_reduction_add_general.c0 /home/exouser/Testsuite/Tests/serial_loop_reduction_add_general.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/serial_loop_reduction_add_general.c\", line 36: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.1658587483689189
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.005506262183189392,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "serial_loop_reduction_add_loop.F90": [
            {
                "compilation": {
                    "command": "nvfortran -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/serial_loop_reduction_add_loop.F90/serial_loop_reduction_add_loop.F900 /home/exouser/Testsuite/Tests/serial_loop_reduction_add_loop.F90",
                    "config": 1,
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.4803223656490445
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.04341629194095731,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "serial_loop_reduction_add_loop.c": [
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/serial_loop_reduction_add_loop.c/serial_loop_reduction_add_loop.c0 /home/exouser/Testsuite/Tests/serial_loop_reduction_add_loop.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/serial_loop_reduction_add_loop.c\", line 21: error: invalid text in pragma\n          #pragma acc serial loop gang private(avg)\n                                  ^\n\n\"/home/exouser/Testsuite/Tests/serial_loop_reduction_add_loop.c\", line 56: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n1 error detected in the compilation of \"/home/exouser/Testsuite/Tests/serial_loop_reduction_add_loop.c\".\n",
                    "export": false,
                    "output": "",
                    "result": 2,
                    "runtime": 0.06541112530976534
                },
                "post-compile commands": [],
                "pre-compile commands": [],
                "runtime": {
                    "export": false,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -DT1 -o /home/exouser/Testsuite/build/serial_loop_reduction_add_loop.c/serial_loop_reduction_add_loop.c1 /home/exouser/Testsuite/Tests/serial_loop_reduction_add_loop.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/serial_loop_reduction_add_loop.c\", line 56: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n\"/home/exouser/Testsuite/Tests/serial_loop_reduction_add_loop.c\", line 57: warning: variable \"failed\" was declared but never referenced\n      int failed;\n          ^\n\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.16589087108150125
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.005525514949113131,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "serial_loop_reduction_add_vector_loop.F90": [
            {
                "compilation": {
                    "command": "nvfortran -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/serial_loop_reduction_add_vector_loop.F90/serial_loop_reduction_add_vector_loop.F900 /home/exouser/Testsuite/Tests/serial_loop_reduction_add_vector_loop.F90",
                    "config": 1,
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.49591550696641207
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.05178970377892256,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "serial_loop_reduction_add_vector_loop.c": [
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/serial_loop_reduction_add_vector_loop.c/serial_loop_reduction_add_vector_loop.c0 /home/exouser/Testsuite/Tests/serial_loop_reduction_add_vector_loop.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/serial_loop_reduction_add_vector_loop.c\", line 43: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.1656725318171084
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.005377014167606831,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "serial_loop_reduction_and_general.F90": [
            {
                "compilation": {
                    "command": "nvfortran -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/serial_loop_reduction_and_general.F90/serial_loop_reduction_and_general.F900 /home/exouser/Testsuite/Tests/serial_loop_reduction_and_general.F90",
                    "config": 1,
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.4803329729475081
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.04234959464520216,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "serial_loop_reduction_and_general.c": [
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/serial_loop_reduction_and_general.c/serial_loop_reduction_and_general.c0 /home/exouser/Testsuite/Tests/serial_loop_reduction_and_general.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/serial_loop_reduction_and_general.c\", line 45: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.1653095092624426
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.005496813915669918,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "serial_loop_reduction_and_loop.F90": [
            {
                "compilation": {
                    "command": "nvfortran -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/serial_loop_reduction_and_loop.F90/serial_loop_reduction_and_loop.F900 /home/exouser/Testsuite/Tests/serial_loop_reduction_and_loop.F90",
                    "config": 1,
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.5789756770245731
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 1,
                    "runtime": 0.04293733602389693,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "serial_loop_reduction_and_loop.c": [
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/serial_loop_reduction_and_loop.c/serial_loop_reduction_and_loop.c0 /home/exouser/Testsuite/Tests/serial_loop_reduction_and_loop.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/serial_loop_reduction_and_loop.c\", line 33: error: invalid text in pragma\n          #pragma acc serial loop gang private(temp)\n                                  ^\n\n\"/home/exouser/Testsuite/Tests/serial_loop_reduction_and_loop.c\", line 72: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n1 error detected in the compilation of \"/home/exouser/Testsuite/Tests/serial_loop_reduction_and_loop.c\".\n",
                    "export": false,
                    "output": "",
                    "result": 2,
                    "runtime": 0.06536738341674209
                },
                "post-compile commands": [],
                "pre-compile commands": [],
                "runtime": {
                    "export": false,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -DT1 -o /home/exouser/Testsuite/build/serial_loop_reduction_and_loop.c/serial_loop_reduction_and_loop.c1 /home/exouser/Testsuite/Tests/serial_loop_reduction_and_loop.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/serial_loop_reduction_and_loop.c\", line 72: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n\"/home/exouser/Testsuite/Tests/serial_loop_reduction_and_loop.c\", line 73: warning: variable \"failed\" was declared but never referenced\n      int failed;\n          ^\n\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.16565322410315275
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.005408918019384146,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "serial_loop_reduction_and_vector_loop.F90": [
            {
                "compilation": {
                    "command": "nvfortran -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/serial_loop_reduction_and_vector_loop.F90/serial_loop_reduction_and_vector_loop.F900 /home/exouser/Testsuite/Tests/serial_loop_reduction_and_vector_loop.F90",
                    "config": 1,
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.5376347922720015
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.05687329173088074,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "serial_loop_reduction_and_vector_loop.c": [
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/serial_loop_reduction_and_vector_loop.c/serial_loop_reduction_and_vector_loop.c0 /home/exouser/Testsuite/Tests/serial_loop_reduction_and_vector_loop.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/serial_loop_reduction_and_vector_loop.c\", line 49: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.16578954318538308
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.005537876859307289,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "serial_loop_reduction_bitand_general.F90": [
            {
                "compilation": {
                    "command": "nvfortran -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/serial_loop_reduction_bitand_general.F90/serial_loop_reduction_bitand_general.F900 /home/exouser/Testsuite/Tests/serial_loop_reduction_bitand_general.F90",
                    "config": 1,
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.48068580590188503
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.07535525178536773,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "serial_loop_reduction_bitand_general.c": [
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/serial_loop_reduction_bitand_general.c/serial_loop_reduction_bitand_general.c0 /home/exouser/Testsuite/Tests/serial_loop_reduction_bitand_general.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/serial_loop_reduction_bitand_general.c\", line 54: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.1656196010299027
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.014743922278285027,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "serial_loop_reduction_bitand_loop.F90": [
            {
                "compilation": {
                    "command": "nvfortran -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/serial_loop_reduction_bitand_loop.F90/serial_loop_reduction_bitand_loop.F900 /home/exouser/Testsuite/Tests/serial_loop_reduction_bitand_loop.F90",
                    "config": 1,
                    "errors": "NVFORTRAN-W-0155-The number of subscripts is less than the rank of b (/home/exouser/Testsuite/Tests/serial_loop_reduction_bitand_loop.F90: 25)\nNVFORTRAN-W-0155-The number of subscripts is less than the rank of a (/home/exouser/Testsuite/Tests/serial_loop_reduction_bitand_loop.F90: 28)\nNVFORTRAN-W-0155-The number of subscripts is less than the rank of a (/home/exouser/Testsuite/Tests/serial_loop_reduction_bitand_loop.F90: 28)\n  0 inform,   3 warnings,   0 severes, 0 fatal for test1\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.6377042471431196
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.07356036268174648,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "serial_loop_reduction_bitand_loop.c": [
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/serial_loop_reduction_bitand_loop.c/serial_loop_reduction_bitand_loop.c0 /home/exouser/Testsuite/Tests/serial_loop_reduction_bitand_loop.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/serial_loop_reduction_bitand_loop.c\", line 31: error: invalid text in pragma\n          #pragma acc serial loop gang private(temp)\n                                  ^\n\n\"/home/exouser/Testsuite/Tests/serial_loop_reduction_bitand_loop.c\", line 69: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n1 error detected in the compilation of \"/home/exouser/Testsuite/Tests/serial_loop_reduction_bitand_loop.c\".\n",
                    "export": false,
                    "output": "",
                    "result": 2,
                    "runtime": 0.06542863696813583
                },
                "post-compile commands": [],
                "pre-compile commands": [],
                "runtime": {
                    "export": false,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -DT1 -o /home/exouser/Testsuite/build/serial_loop_reduction_bitand_loop.c/serial_loop_reduction_bitand_loop.c1 /home/exouser/Testsuite/Tests/serial_loop_reduction_bitand_loop.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/serial_loop_reduction_bitand_loop.c\", line 69: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n\"/home/exouser/Testsuite/Tests/serial_loop_reduction_bitand_loop.c\", line 70: warning: variable \"failed\" was declared but never referenced\n      int failed;\n          ^\n\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.1657709050923586
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.00521728303283453,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "serial_loop_reduction_bitand_vector_loop.F90": [
            {
                "compilation": {
                    "command": "nvfortran -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/serial_loop_reduction_bitand_vector_loop.F90/serial_loop_reduction_bitand_vector_loop.F900 /home/exouser/Testsuite/Tests/serial_loop_reduction_bitand_vector_loop.F90",
                    "config": 1,
                    "errors": "NVFORTRAN-W-0103-Type conversion of subscript expression for randoms (/home/exouser/Testsuite/Tests/serial_loop_reduction_bitand_vector_loop.F90: 26)\nNVFORTRAN-S-0038-Symbol, z, has not been explicitly declared (/home/exouser/Testsuite/Tests/serial_loop_reduction_bitand_vector_loop.F90)\n  0 inform,   1 warnings,   1 severes, 0 fatal for test1\n",
                    "export": false,
                    "output": "",
                    "result": 2,
                    "runtime": 0.12188264867290854
                },
                "post-compile commands": [],
                "pre-compile commands": [],
                "runtime": {
                    "export": false,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvfortran -fast -acc -ta=multicore -DT1 -o /home/exouser/Testsuite/build/serial_loop_reduction_bitand_vector_loop.F90/serial_loop_reduction_bitand_vector_loop.F901 /home/exouser/Testsuite/Tests/serial_loop_reduction_bitand_vector_loop.F90",
                    "config": 1,
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.4284152267500758
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.056791920214891434,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "serial_loop_reduction_bitand_vector_loop.c": [
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/serial_loop_reduction_bitand_vector_loop.c/serial_loop_reduction_bitand_vector_loop.c0 /home/exouser/Testsuite/Tests/serial_loop_reduction_bitand_vector_loop.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/serial_loop_reduction_bitand_vector_loop.c\", line 55: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.16542459279298782
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.005424636881798506,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "serial_loop_reduction_bitor_general.F90": [
            {
                "compilation": {
                    "command": "nvfortran -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/serial_loop_reduction_bitor_general.F90/serial_loop_reduction_bitor_general.F900 /home/exouser/Testsuite/Tests/serial_loop_reduction_bitor_general.F90",
                    "config": 1,
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.5302885980345309
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.04527716292068362,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "serial_loop_reduction_bitor_general.c": [
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/serial_loop_reduction_bitor_general.c/serial_loop_reduction_bitor_general.c0 /home/exouser/Testsuite/Tests/serial_loop_reduction_bitor_general.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/serial_loop_reduction_bitor_general.c\", line 47: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.16571377217769623
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.005516461096704006,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "serial_loop_reduction_bitor_loop.F90": [
            {
                "compilation": {
                    "command": "nvfortran -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/serial_loop_reduction_bitor_loop.F90/serial_loop_reduction_bitor_loop.F900 /home/exouser/Testsuite/Tests/serial_loop_reduction_bitor_loop.F90",
                    "config": 1,
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.5223804865963757
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.0737339467741549,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "serial_loop_reduction_bitor_loop.c": [
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/serial_loop_reduction_bitor_loop.c/serial_loop_reduction_bitor_loop.c0 /home/exouser/Testsuite/Tests/serial_loop_reduction_bitor_loop.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/serial_loop_reduction_bitor_loop.c\", line 34: error: invalid text in pragma\n          #pragma acc serial loop gang private(temp)\n                                  ^\n\n\"/home/exouser/Testsuite/Tests/serial_loop_reduction_bitor_loop.c\", line 69: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n1 error detected in the compilation of \"/home/exouser/Testsuite/Tests/serial_loop_reduction_bitor_loop.c\".\n",
                    "export": false,
                    "output": "",
                    "result": 2,
                    "runtime": 0.06632310058921576
                },
                "post-compile commands": [],
                "pre-compile commands": [],
                "runtime": {
                    "export": false,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -DT1 -o /home/exouser/Testsuite/build/serial_loop_reduction_bitor_loop.c/serial_loop_reduction_bitor_loop.c1 /home/exouser/Testsuite/Tests/serial_loop_reduction_bitor_loop.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/serial_loop_reduction_bitor_loop.c\", line 69: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n\"/home/exouser/Testsuite/Tests/serial_loop_reduction_bitor_loop.c\", line 70: warning: variable \"failed\" was declared but never referenced\n      int failed;\n          ^\n\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.16691638808697462
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.005067348014563322,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "serial_loop_reduction_bitor_vector_loop.F90": [
            {
                "compilation": {
                    "command": "nvfortran -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/serial_loop_reduction_bitor_vector_loop.F90/serial_loop_reduction_bitor_vector_loop.F900 /home/exouser/Testsuite/Tests/serial_loop_reduction_bitor_vector_loop.F90",
                    "config": 1,
                    "errors": "/tmp/nvfortranPhmc76xwTRUW.o: In function `test1_':\n/home/exouser/Testsuite/Tests/serial_loop_reduction_bitor_vector_loop.F90:20: undefined reference to `random_numbers_'\npgacclnk: child process exit status 1: /usr/bin/ld\n",
                    "export": false,
                    "output": "",
                    "result": 2,
                    "runtime": 0.5270127765834332
                },
                "post-compile commands": [],
                "pre-compile commands": [],
                "runtime": {
                    "export": false,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvfortran -fast -acc -ta=multicore -DT1 -o /home/exouser/Testsuite/build/serial_loop_reduction_bitor_vector_loop.F90/serial_loop_reduction_bitor_vector_loop.F901 /home/exouser/Testsuite/Tests/serial_loop_reduction_bitor_vector_loop.F90",
                    "config": 1,
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.3774287146516144
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.02702807728201151,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "serial_loop_reduction_bitor_vector_loop.c": [
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/serial_loop_reduction_bitor_vector_loop.c/serial_loop_reduction_bitor_vector_loop.c0 /home/exouser/Testsuite/Tests/serial_loop_reduction_bitor_vector_loop.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/serial_loop_reduction_bitor_vector_loop.c\", line 55: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.1657302021048963
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.005314841400831938,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "serial_loop_reduction_bitxor_general.F90": [
            {
                "compilation": {
                    "command": "nvfortran -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/serial_loop_reduction_bitxor_general.F90/serial_loop_reduction_bitxor_general.F900 /home/exouser/Testsuite/Tests/serial_loop_reduction_bitxor_general.F90",
                    "config": 1,
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.5799379050731659
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.04362084809690714,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "serial_loop_reduction_bitxor_general.c": [
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/serial_loop_reduction_bitxor_general.c/serial_loop_reduction_bitxor_general.c0 /home/exouser/Testsuite/Tests/serial_loop_reduction_bitxor_general.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/serial_loop_reduction_bitxor_general.c\", line 38: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.16591835767030716
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.0053692529909312725,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "serial_loop_reduction_bitxor_loop.F90": [
            {
                "compilation": {
                    "command": "nvfortran -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/serial_loop_reduction_bitxor_loop.F90/serial_loop_reduction_bitxor_loop.F900 /home/exouser/Testsuite/Tests/serial_loop_reduction_bitxor_loop.F90",
                    "config": 1,
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.48876783065497875
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.04327460331842303,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "serial_loop_reduction_bitxor_loop.c": [
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/serial_loop_reduction_bitxor_loop.c/serial_loop_reduction_bitxor_loop.c0 /home/exouser/Testsuite/Tests/serial_loop_reduction_bitxor_loop.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/serial_loop_reduction_bitxor_loop.c\", line 24: error: invalid text in pragma\n          #pragma acc serial loop gang private(temp)\n                                  ^\n\n\"/home/exouser/Testsuite/Tests/serial_loop_reduction_bitxor_loop.c\", line 60: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n1 error detected in the compilation of \"/home/exouser/Testsuite/Tests/serial_loop_reduction_bitxor_loop.c\".\n",
                    "export": false,
                    "output": "",
                    "result": 2,
                    "runtime": 0.06507384683936834
                },
                "post-compile commands": [],
                "pre-compile commands": [],
                "runtime": {
                    "export": false,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -DT1 -o /home/exouser/Testsuite/build/serial_loop_reduction_bitxor_loop.c/serial_loop_reduction_bitxor_loop.c1 /home/exouser/Testsuite/Tests/serial_loop_reduction_bitxor_loop.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/serial_loop_reduction_bitxor_loop.c\", line 60: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n\"/home/exouser/Testsuite/Tests/serial_loop_reduction_bitxor_loop.c\", line 61: warning: variable \"failed\" was declared but never referenced\n      int failed;\n          ^\n\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.16585098579525948
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.005375945940613747,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "serial_loop_reduction_bitxor_vector_loop.F90": [
            {
                "compilation": {
                    "command": "nvfortran -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/serial_loop_reduction_bitxor_vector_loop.F90/serial_loop_reduction_bitxor_vector_loop.F900 /home/exouser/Testsuite/Tests/serial_loop_reduction_bitxor_vector_loop.F90",
                    "config": 1,
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.47632915480062366
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.04302287707105279,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "serial_loop_reduction_bitxor_vector_loop.c": [
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/serial_loop_reduction_bitxor_vector_loop.c/serial_loop_reduction_bitxor_vector_loop.c0 /home/exouser/Testsuite/Tests/serial_loop_reduction_bitxor_vector_loop.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/serial_loop_reduction_bitxor_vector_loop.c\", line 45: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.16573216579854488
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.005399631801992655,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "serial_loop_reduction_max_general.F90": [
            {
                "compilation": {
                    "command": "nvfortran -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/serial_loop_reduction_max_general.F90/serial_loop_reduction_max_general.F900 /home/exouser/Testsuite/Tests/serial_loop_reduction_max_general.F90",
                    "config": 1,
                    "errors": "NVFORTRAN-S-0074-Illegal number or type of arguments to max  (/home/exouser/Testsuite/Tests/serial_loop_reduction_max_general.F90: 32)\n  0 inform,   0 warnings,   1 severes, 0 fatal for test1\n",
                    "export": false,
                    "output": "",
                    "result": 2,
                    "runtime": 0.1322020092047751
                },
                "post-compile commands": [],
                "pre-compile commands": [],
                "runtime": {
                    "export": false,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvfortran -fast -acc -ta=multicore -DT1 -o /home/exouser/Testsuite/build/serial_loop_reduction_max_general.F90/serial_loop_reduction_max_general.F901 /home/exouser/Testsuite/Tests/serial_loop_reduction_max_general.F90",
                    "config": 1,
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.5405594119802117
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.04677044088020921,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "serial_loop_reduction_max_general.c": [
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/serial_loop_reduction_max_general.c/serial_loop_reduction_max_general.c0 /home/exouser/Testsuite/Tests/serial_loop_reduction_max_general.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/serial_loop_reduction_max_general.c\", line 32: warning: use of \"=\" where \"==\" may have been intended\n      if (found = 0){\n          ^\n\n\"/home/exouser/Testsuite/Tests/serial_loop_reduction_max_general.c\", line 10: warning: variable \"found\" was set but never used\n      int found = 0;\n          ^\n\n\"/home/exouser/Testsuite/Tests/serial_loop_reduction_max_general.c\", line 42: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.16568847699090838
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.005486533977091312,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "serial_loop_reduction_max_loop.F90": [
            {
                "compilation": {
                    "command": "nvfortran -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/serial_loop_reduction_max_loop.F90/serial_loop_reduction_max_loop.F900 /home/exouser/Testsuite/Tests/serial_loop_reduction_max_loop.F90",
                    "config": 1,
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.5840848940424621
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.050359532702714205,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "serial_loop_reduction_max_loop.c": [
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/serial_loop_reduction_max_loop.c/serial_loop_reduction_max_loop.c0 /home/exouser/Testsuite/Tests/serial_loop_reduction_max_loop.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/serial_loop_reduction_max_loop.c\", line 25: error: invalid text in pragma\n          #pragma acc serial loop gang private(temp)\n                                  ^\n\n\"/home/exouser/Testsuite/Tests/serial_loop_reduction_max_loop.c\", line 12: warning: variable \"max\" was declared but never referenced\n      real_t max = 0.0;\n             ^\n\n\"/home/exouser/Testsuite/Tests/serial_loop_reduction_max_loop.c\", line 60: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n1 error detected in the compilation of \"/home/exouser/Testsuite/Tests/serial_loop_reduction_max_loop.c\".\n",
                    "export": false,
                    "output": "",
                    "result": 2,
                    "runtime": 0.06544901803135872
                },
                "post-compile commands": [],
                "pre-compile commands": [],
                "runtime": {
                    "export": false,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -DT1 -o /home/exouser/Testsuite/build/serial_loop_reduction_max_loop.c/serial_loop_reduction_max_loop.c1 /home/exouser/Testsuite/Tests/serial_loop_reduction_max_loop.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/serial_loop_reduction_max_loop.c\", line 60: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n\"/home/exouser/Testsuite/Tests/serial_loop_reduction_max_loop.c\", line 61: warning: variable \"failed\" was declared but never referenced\n      int failed;\n          ^\n\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.16547464905306697
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.005271922796964645,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "serial_loop_reduction_max_vector_loop.F90": [
            {
                "compilation": {
                    "command": "nvfortran -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/serial_loop_reduction_max_vector_loop.F90/serial_loop_reduction_max_vector_loop.F900 /home/exouser/Testsuite/Tests/serial_loop_reduction_max_vector_loop.F90",
                    "config": 1,
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.5748831490054727
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.057616766542196274,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "serial_loop_reduction_max_vector_loop.c": [
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/serial_loop_reduction_max_vector_loop.c/serial_loop_reduction_max_vector_loop.c0 /home/exouser/Testsuite/Tests/serial_loop_reduction_max_vector_loop.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/serial_loop_reduction_max_vector_loop.c\", line 47: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.16582528222352266
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.005322939250618219,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "serial_loop_reduction_min_general.F90": [
            {
                "compilation": {
                    "command": "nvfortran -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/serial_loop_reduction_min_general.F90/serial_loop_reduction_min_general.F900 /home/exouser/Testsuite/Tests/serial_loop_reduction_min_general.F90",
                    "config": 1,
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.49629966681823134
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.03958067297935486,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "serial_loop_reduction_min_general.c": [
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/serial_loop_reduction_min_general.c/serial_loop_reduction_min_general.c0 /home/exouser/Testsuite/Tests/serial_loop_reduction_min_general.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/serial_loop_reduction_min_general.c\", line 44: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.16561072878539562
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.005527897737920284,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "serial_loop_reduction_min_loop.F90": [
            {
                "compilation": {
                    "command": "nvfortran -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/serial_loop_reduction_min_loop.F90/serial_loop_reduction_min_loop.F900 /home/exouser/Testsuite/Tests/serial_loop_reduction_min_loop.F90",
                    "config": 1,
                    "errors": "NVFORTRAN-S-0038-Symbol, mimimums, has not been explicitly declared (/home/exouser/Testsuite/Tests/serial_loop_reduction_min_loop.F90)\n  0 inform,   0 warnings,   1 severes, 0 fatal for test1\n",
                    "export": false,
                    "output": "",
                    "result": 2,
                    "runtime": 0.1303215529769659
                },
                "post-compile commands": [],
                "pre-compile commands": [],
                "runtime": {
                    "export": false,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvfortran -fast -acc -ta=multicore -DT1 -o /home/exouser/Testsuite/build/serial_loop_reduction_min_loop.F90/serial_loop_reduction_min_loop.F901 /home/exouser/Testsuite/Tests/serial_loop_reduction_min_loop.F90",
                    "config": 1,
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.4355745636858046
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.02486150525510311,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "serial_loop_reduction_min_loop.c": [
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/serial_loop_reduction_min_loop.c/serial_loop_reduction_min_loop.c0 /home/exouser/Testsuite/Tests/serial_loop_reduction_min_loop.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/serial_loop_reduction_min_loop.c\", line 21: error: invalid text in pragma\n          #pragma acc serial loop gang private(temp)\n                                  ^\n\n\"/home/exouser/Testsuite/Tests/serial_loop_reduction_min_loop.c\", line 57: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n1 error detected in the compilation of \"/home/exouser/Testsuite/Tests/serial_loop_reduction_min_loop.c\".\n",
                    "export": false,
                    "output": "",
                    "result": 2,
                    "runtime": 0.0654173456132412
                },
                "post-compile commands": [],
                "pre-compile commands": [],
                "runtime": {
                    "export": false,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -DT1 -o /home/exouser/Testsuite/build/serial_loop_reduction_min_loop.c/serial_loop_reduction_min_loop.c1 /home/exouser/Testsuite/Tests/serial_loop_reduction_min_loop.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/serial_loop_reduction_min_loop.c\", line 57: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n\"/home/exouser/Testsuite/Tests/serial_loop_reduction_min_loop.c\", line 58: warning: variable \"failed\" was declared but never referenced\n      int failed;\n          ^\n\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.11568376189097762
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.005311925429850817,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "serial_loop_reduction_min_vector_loop.F90": [
            {
                "compilation": {
                    "command": "nvfortran -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/serial_loop_reduction_min_vector_loop.F90/serial_loop_reduction_min_vector_loop.F900 /home/exouser/Testsuite/Tests/serial_loop_reduction_min_vector_loop.F90",
                    "config": 1,
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.44878865079954267
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.08321864018216729,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "serial_loop_reduction_min_vector_loop.c": [
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/serial_loop_reduction_min_vector_loop.c/serial_loop_reduction_min_vector_loop.c0 /home/exouser/Testsuite/Tests/serial_loop_reduction_min_vector_loop.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/serial_loop_reduction_min_vector_loop.c\", line 20: error: invalid text in pragma\n          #pragma acc serial loop gang private(temp)\n                                  ^\n\n\"/home/exouser/Testsuite/Tests/serial_loop_reduction_min_vector_loop.c\", line 48: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n1 error detected in the compilation of \"/home/exouser/Testsuite/Tests/serial_loop_reduction_min_vector_loop.c\".\n",
                    "export": false,
                    "output": "",
                    "result": 2,
                    "runtime": 0.06542120082303882
                },
                "post-compile commands": [],
                "pre-compile commands": [],
                "runtime": {
                    "export": false,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -DT1 -o /home/exouser/Testsuite/build/serial_loop_reduction_min_vector_loop.c/serial_loop_reduction_min_vector_loop.c1 /home/exouser/Testsuite/Tests/serial_loop_reduction_min_vector_loop.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/serial_loop_reduction_min_vector_loop.c\", line 48: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n\"/home/exouser/Testsuite/Tests/serial_loop_reduction_min_vector_loop.c\", line 49: warning: variable \"failed\" was declared but never referenced\n      int failed;\n          ^\n\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.165666779037565
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.0053770230151712894,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "serial_loop_reduction_multiply_general.F90": [
            {
                "compilation": {
                    "command": "nvfortran -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/serial_loop_reduction_multiply_general.F90/serial_loop_reduction_multiply_general.F900 /home/exouser/Testsuite/Tests/serial_loop_reduction_multiply_general.F90",
                    "config": 1,
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.5423588049598038
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.04133472591638565,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "serial_loop_reduction_multiply_general.c": [
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/serial_loop_reduction_multiply_general.c/serial_loop_reduction_multiply_general.c0 /home/exouser/Testsuite/Tests/serial_loop_reduction_multiply_general.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/serial_loop_reduction_multiply_general.c\", line 39: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.16668774792924523
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.005450796335935593,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "serial_loop_reduction_multiply_loop.F90": [
            {
                "compilation": {
                    "command": "nvfortran -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/serial_loop_reduction_multiply_loop.F90/serial_loop_reduction_multiply_loop.F900 /home/exouser/Testsuite/Tests/serial_loop_reduction_multiply_loop.F90",
                    "config": 1,
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.5472388509660959
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.040764071978628635,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "serial_loop_reduction_multiply_loop.c": [
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/serial_loop_reduction_multiply_loop.c/serial_loop_reduction_multiply_loop.c0 /home/exouser/Testsuite/Tests/serial_loop_reduction_multiply_loop.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/serial_loop_reduction_multiply_loop.c\", line 22: error: invalid text in pragma\n          #pragma acc serial loop gang private(temp)\n                                  ^\n\n\"/home/exouser/Testsuite/Tests/serial_loop_reduction_multiply_loop.c\", line 58: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n1 error detected in the compilation of \"/home/exouser/Testsuite/Tests/serial_loop_reduction_multiply_loop.c\".\n",
                    "export": false,
                    "output": "",
                    "result": 2,
                    "runtime": 0.0655625807121396
                },
                "post-compile commands": [],
                "pre-compile commands": [],
                "runtime": {
                    "export": false,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -DT1 -o /home/exouser/Testsuite/build/serial_loop_reduction_multiply_loop.c/serial_loop_reduction_multiply_loop.c1 /home/exouser/Testsuite/Tests/serial_loop_reduction_multiply_loop.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/serial_loop_reduction_multiply_loop.c\", line 58: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n\"/home/exouser/Testsuite/Tests/serial_loop_reduction_multiply_loop.c\", line 59: warning: variable \"failed\" was declared but never referenced\n      int failed;\n          ^\n\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.16541158594191074
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.005271755158901215,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "serial_loop_reduction_multiply_vector_loop.F90": [
            {
                "compilation": {
                    "command": "nvfortran -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/serial_loop_reduction_multiply_vector_loop.F90/serial_loop_reduction_multiply_vector_loop.F900 /home/exouser/Testsuite/Tests/serial_loop_reduction_multiply_vector_loop.F90",
                    "config": 1,
                    "errors": "NVFORTRAN-W-0103-Type conversion of subscript expression for host_totals (/home/exouser/Testsuite/Tests/serial_loop_reduction_multiply_vector_loop.F90: 25)\nNVFORTRAN-W-0103-Type conversion of subscript expression for host_totals (/home/exouser/Testsuite/Tests/serial_loop_reduction_multiply_vector_loop.F90: 25)\nNVFORTRAN-W-0103-Type conversion of subscript expression for a (/home/exouser/Testsuite/Tests/serial_loop_reduction_multiply_vector_loop.F90: 25)\nNVFORTRAN-W-0103-Type conversion of subscript expression for a (/home/exouser/Testsuite/Tests/serial_loop_reduction_multiply_vector_loop.F90: 25)\nNVFORTRAN-W-0103-Type conversion of subscript expression for b (/home/exouser/Testsuite/Tests/serial_loop_reduction_multiply_vector_loop.F90: 25)\nNVFORTRAN-W-0103-Type conversion of subscript expression for b (/home/exouser/Testsuite/Tests/serial_loop_reduction_multiply_vector_loop.F90: 25)\nNVFORTRAN-W-0103-Type conversion of subscript expression for a (/home/exouser/Testsuite/Tests/serial_loop_reduction_multiply_vector_loop.F90: 35)\nNVFORTRAN-W-0103-Type conversion of subscript expression for a (/home/exouser/Testsuite/Tests/serial_loop_reduction_multiply_vector_loop.F90: 35)\nNVFORTRAN-W-0103-Type conversion of subscript expression for b (/home/exouser/Testsuite/Tests/serial_loop_reduction_multiply_vector_loop.F90: 35)\nNVFORTRAN-W-0103-Type conversion of subscript expression for b (/home/exouser/Testsuite/Tests/serial_loop_reduction_multiply_vector_loop.F90: 35)\nNVFORTRAN-W-0103-Type conversion of subscript expression for totals (/home/exouser/Testsuite/Tests/serial_loop_reduction_multiply_vector_loop.F90: 37)\nNVFORTRAN-W-0103-Type conversion of subscript expression for host_totals (/home/exouser/Testsuite/Tests/serial_loop_reduction_multiply_vector_loop.F90: 42)\nNVFORTRAN-W-0103-Type conversion of subscript expression for totals (/home/exouser/Testsuite/Tests/serial_loop_reduction_multiply_vector_loop.F90: 42)\nNVFORTRAN-S-0038-Symbol, y, has not been explicitly declared (/home/exouser/Testsuite/Tests/serial_loop_reduction_multiply_vector_loop.F90)\nNVFORTRAN-S-0038-Symbol, x, has not been explicitly declared (/home/exouser/Testsuite/Tests/serial_loop_reduction_multiply_vector_loop.F90)\n  0 inform,  13 warnings,   2 severes, 0 fatal for test1\n",
                    "export": false,
                    "output": "",
                    "result": 2,
                    "runtime": 0.12128964811563492
                },
                "post-compile commands": [],
                "pre-compile commands": [],
                "runtime": {
                    "export": false,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvfortran -fast -acc -ta=multicore -DT1 -o /home/exouser/Testsuite/build/serial_loop_reduction_multiply_vector_loop.F90/serial_loop_reduction_multiply_vector_loop.F901 /home/exouser/Testsuite/Tests/serial_loop_reduction_multiply_vector_loop.F90",
                    "config": 1,
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.4778914703056216
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.058924897108227015,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "serial_loop_reduction_multiply_vector_loop.c": [
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/serial_loop_reduction_multiply_vector_loop.c/serial_loop_reduction_multiply_vector_loop.c0 /home/exouser/Testsuite/Tests/serial_loop_reduction_multiply_vector_loop.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/serial_loop_reduction_multiply_vector_loop.c\", line 49: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.1659884611144662
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.00531622301787138,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "serial_loop_reduction_or_general.F90": [
            {
                "compilation": {
                    "command": "nvfortran -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/serial_loop_reduction_or_general.F90/serial_loop_reduction_or_general.F900 /home/exouser/Testsuite/Tests/serial_loop_reduction_or_general.F90",
                    "config": 1,
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.49226374132558703
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.05142925912514329,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "serial_loop_reduction_or_general.c": [
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/serial_loop_reduction_or_general.c/serial_loop_reduction_or_general.c0 /home/exouser/Testsuite/Tests/serial_loop_reduction_or_general.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/serial_loop_reduction_or_general.c\", line 45: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.1668292391113937
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.004958631005138159,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "serial_loop_reduction_or_loop.F90": [
            {
                "compilation": {
                    "command": "nvfortran -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/serial_loop_reduction_or_loop.F90/serial_loop_reduction_or_loop.F900 /home/exouser/Testsuite/Tests/serial_loop_reduction_or_loop.F90",
                    "config": 1,
                    "errors": "NVFORTRAN-S-0104-Illegal control structure - unterminated ACC DATA REGION construct (/home/exouser/Testsuite/Tests/serial_loop_reduction_or_loop.F90: 55)\n  0 inform,   0 warnings,   1 severes, 0 fatal for test1\n",
                    "export": false,
                    "output": "",
                    "result": 2,
                    "runtime": 0.14230692107230425
                },
                "post-compile commands": [],
                "pre-compile commands": [],
                "runtime": {
                    "export": false,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvfortran -fast -acc -ta=multicore -DT1 -o /home/exouser/Testsuite/build/serial_loop_reduction_or_loop.F90/serial_loop_reduction_or_loop.F901 /home/exouser/Testsuite/Tests/serial_loop_reduction_or_loop.F90",
                    "config": 1,
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.47343332087621093
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.042916042264550924,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "serial_loop_reduction_or_loop.c": [
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/serial_loop_reduction_or_loop.c/serial_loop_reduction_or_loop.c0 /home/exouser/Testsuite/Tests/serial_loop_reduction_or_loop.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/serial_loop_reduction_or_loop.c\", line 25: error: invalid text in pragma\n          #pragma acc serial loop gang private(temp)\n                                  ^\n\n\"/home/exouser/Testsuite/Tests/serial_loop_reduction_or_loop.c\", line 74: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n1 error detected in the compilation of \"/home/exouser/Testsuite/Tests/serial_loop_reduction_or_loop.c\".\n",
                    "export": false,
                    "output": "",
                    "result": 2,
                    "runtime": 0.0660418369807303
                },
                "post-compile commands": [],
                "pre-compile commands": [],
                "runtime": {
                    "export": false,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -DT1 -o /home/exouser/Testsuite/build/serial_loop_reduction_or_loop.c/serial_loop_reduction_or_loop.c1 /home/exouser/Testsuite/Tests/serial_loop_reduction_or_loop.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/serial_loop_reduction_or_loop.c\", line 74: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n\"/home/exouser/Testsuite/Tests/serial_loop_reduction_or_loop.c\", line 75: warning: variable \"failed\" was declared but never referenced\n      int failed;\n          ^\n\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.16575853619724512
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.005206270143389702,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "serial_loop_reduction_or_vector_loop.F90": [
            {
                "compilation": {
                    "command": "nvfortran -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/serial_loop_reduction_or_vector_loop.F90/serial_loop_reduction_or_vector_loop.F900 /home/exouser/Testsuite/Tests/serial_loop_reduction_or_vector_loop.F90",
                    "config": 1,
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.5305709079839289
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.04131064098328352,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "serial_loop_reduction_or_vector_loop.c": [
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/serial_loop_reduction_or_vector_loop.c/serial_loop_reduction_or_vector_loop.c0 /home/exouser/Testsuite/Tests/serial_loop_reduction_or_vector_loop.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/serial_loop_reduction_or_vector_loop.c\", line 51: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.16572020901367068
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.00543995201587677,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "serial_loop_seq.F90": [
            {
                "compilation": {
                    "command": "nvfortran -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/serial_loop_seq.F90/serial_loop_seq.F900 /home/exouser/Testsuite/Tests/serial_loop_seq.F90",
                    "config": 1,
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.4883316420018673
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.031076300889253616,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "serial_loop_seq.c": [
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/serial_loop_seq.c/serial_loop_seq.c0 /home/exouser/Testsuite/Tests/serial_loop_seq.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/serial_loop_seq.c\", line 37: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.16620870679616928
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.005384932272136211,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "serial_loop_tile.F90": [
            {
                "compilation": {
                    "command": "nvfortran -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/serial_loop_tile.F90/serial_loop_tile.F900 /home/exouser/Testsuite/Tests/serial_loop_tile.F90",
                    "config": 1,
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.4309926419518888
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.04143864382058382,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "serial_loop_tile.c": [
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/serial_loop_tile.c/serial_loop_tile.c0 /home/exouser/Testsuite/Tests/serial_loop_tile.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/serial_loop_tile.c\", line 58: warning: variable \"temp\" was declared but never referenced\n      real_t temp = 0.0;\n             ^\n\n\"/home/exouser/Testsuite/Tests/serial_loop_tile.c\", line 94: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.21600458212196827
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.01718429522588849,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "serial_loop_vector.F90": [
            {
                "compilation": {
                    "command": "nvfortran -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/serial_loop_vector.F90/serial_loop_vector.F900 /home/exouser/Testsuite/Tests/serial_loop_vector.F90",
                    "config": 1,
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.44211046677082777
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.06931493617594242,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "serial_loop_vector.c": [
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/serial_loop_vector.c/serial_loop_vector.c0 /home/exouser/Testsuite/Tests/serial_loop_vector.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/serial_loop_vector.c\", line 19: error: invalid text in pragma\n          #pragma acc serial loop vector\n                                  ^\n\n\"/home/exouser/Testsuite/Tests/serial_loop_vector.c\", line 37: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n1 error detected in the compilation of \"/home/exouser/Testsuite/Tests/serial_loop_vector.c\".\n",
                    "export": false,
                    "output": "",
                    "result": 2,
                    "runtime": 0.06613608682528138
                },
                "post-compile commands": [],
                "pre-compile commands": [],
                "runtime": {
                    "export": false,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -DT1 -o /home/exouser/Testsuite/build/serial_loop_vector.c/serial_loop_vector.c1 /home/exouser/Testsuite/Tests/serial_loop_vector.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/serial_loop_vector.c\", line 37: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n\"/home/exouser/Testsuite/Tests/serial_loop_vector.c\", line 38: warning: variable \"failed\" was declared but never referenced\n      int failed;\n          ^\n\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.1659501981921494
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.004937809891998768,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "serial_loop_vector_blocking.F90": [
            {
                "compilation": {
                    "command": "nvfortran -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/serial_loop_vector_blocking.F90/serial_loop_vector_blocking.F900 /home/exouser/Testsuite/Tests/serial_loop_vector_blocking.F90",
                    "config": 1,
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.42315200669690967
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 1,
                    "runtime": 0.02501086611300707,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "serial_loop_vector_blocking.c": [
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/serial_loop_vector_blocking.c/serial_loop_vector_blocking.c0 /home/exouser/Testsuite/Tests/serial_loop_vector_blocking.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/serial_loop_vector_blocking.c\", line 36: warning: expression has no effect\n        err + 1;\n        ^\n\n\"/home/exouser/Testsuite/Tests/serial_loop_vector_blocking.c\", line 47: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.16558208083733916
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.005257302895188332,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "serial_loop_worker.F90": [
            {
                "compilation": {
                    "command": "nvfortran -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/serial_loop_worker.F90/serial_loop_worker.F900 /home/exouser/Testsuite/Tests/serial_loop_worker.F90",
                    "config": 1,
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.49698085617274046
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.030561367981135845,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "serial_loop_worker.c": [
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/serial_loop_worker.c/serial_loop_worker.c0 /home/exouser/Testsuite/Tests/serial_loop_worker.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/serial_loop_worker.c\", line 19: error: invalid text in pragma\n          #pragma acc serial loop worker\n                                  ^\n\n\"/home/exouser/Testsuite/Tests/serial_loop_worker.c\", line 37: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n1 error detected in the compilation of \"/home/exouser/Testsuite/Tests/serial_loop_worker.c\".\n",
                    "export": false,
                    "output": "",
                    "result": 2,
                    "runtime": 0.06534108426421881
                },
                "post-compile commands": [],
                "pre-compile commands": [],
                "runtime": {
                    "export": false,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -DT1 -o /home/exouser/Testsuite/build/serial_loop_worker.c/serial_loop_worker.c1 /home/exouser/Testsuite/Tests/serial_loop_worker.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/serial_loop_worker.c\", line 37: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n\"/home/exouser/Testsuite/Tests/serial_loop_worker.c\", line 38: warning: variable \"failed\" was declared but never referenced\n      int failed;\n          ^\n\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.1658514509908855
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.005474247969686985,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "serial_loop_worker_blocking.F90": [
            {
                "compilation": {
                    "command": "nvfortran -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/serial_loop_worker_blocking.F90/serial_loop_worker_blocking.F900 /home/exouser/Testsuite/Tests/serial_loop_worker_blocking.F90",
                    "config": 1,
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.525772163644433
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 1,
                    "runtime": 0.04541521519422531,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "serial_loop_worker_blocking.c": [
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/serial_loop_worker_blocking.c/serial_loop_worker_blocking.c0 /home/exouser/Testsuite/Tests/serial_loop_worker_blocking.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/serial_loop_worker_blocking.c\", line 36: warning: expression has no effect\n          err + 1;\n          ^\n\n\"/home/exouser/Testsuite/Tests/serial_loop_worker_blocking.c\", line 47: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.21585286688059568
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.005530272610485554,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "serial_present.F90": [
            {
                "compilation": {
                    "command": "nvfortran -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/serial_present.F90/serial_present.F900 /home/exouser/Testsuite/Tests/serial_present.F90",
                    "config": 1,
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.5345247662626207
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.04189832787960768,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "serial_present.c": [
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/serial_present.c/serial_present.c0 /home/exouser/Testsuite/Tests/serial_present.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/serial_present.c\", line 39: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.16534257493913174
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.005273368675261736,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "serial_private.F90": [
            {
                "compilation": {
                    "command": "nvfortran -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/serial_private.F90/serial_private.F900 /home/exouser/Testsuite/Tests/serial_private.F90",
                    "config": 1,
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.5266940360888839
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 1,
                    "runtime": 0.037354311905801296,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "serial_private.c": [
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/serial_private.c/serial_private.c0 /home/exouser/Testsuite/Tests/serial_private.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/serial_private.c\", line 56: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.21580879017710686
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.005303373094648123,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "serial_reduction.F90": [
            {
                "compilation": {
                    "command": "nvfortran -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/serial_reduction.F90/serial_reduction.F900 /home/exouser/Testsuite/Tests/serial_reduction.F90",
                    "config": 1,
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.38233524188399315
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.043056475929915905,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "serial_reduction.c": [
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/serial_reduction.c/serial_reduction.c0 /home/exouser/Testsuite/Tests/serial_reduction.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/serial_reduction.c\", line 35: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.16587452730163932
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.0053996741771698,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "serial_scalar_default_firstprivate.F90": [
            {
                "compilation": {
                    "command": "nvfortran -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/serial_scalar_default_firstprivate.F90/serial_scalar_default_firstprivate.F900 /home/exouser/Testsuite/Tests/serial_scalar_default_firstprivate.F90",
                    "config": 1,
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.3842168874107301
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.035611987579613924,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "serial_scalar_default_firstprivate.c": [
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/serial_scalar_default_firstprivate.c/serial_scalar_default_firstprivate.c0 /home/exouser/Testsuite/Tests/serial_scalar_default_firstprivate.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/serial_scalar_default_firstprivate.c\", line 43: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.1656707301735878
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.005071061663329601,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "serial_switch.F90": [
            {
                "compilation": {
                    "command": "nvfortran -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/serial_switch.F90/serial_switch.F900 /home/exouser/Testsuite/Tests/serial_switch.F90",
                    "config": 1,
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.4971986310556531
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.042984376195818186,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "serial_switch.c": [
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/serial_switch.c/serial_switch.c0 /home/exouser/Testsuite/Tests/serial_switch.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/serial_switch.c\", line 66: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.1656795791350305
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.005256990902125835,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "serial_wait.F90": [
            {
                "compilation": {
                    "command": "nvfortran -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/serial_wait.F90/serial_wait.F900 /home/exouser/Testsuite/Tests/serial_wait.F90",
                    "config": 1,
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.4897248619236052
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.043777989223599434,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "serial_wait.c": [
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/serial_wait.c/serial_wait.c0 /home/exouser/Testsuite/Tests/serial_wait.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/serial_wait.c\", line 37: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.16559649305418134
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.005374075844883919,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "serial_while_loop.F90": [
            {
                "compilation": {
                    "command": "nvfortran -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/serial_while_loop.F90/serial_while_loop.F900 /home/exouser/Testsuite/Tests/serial_while_loop.F90",
                    "config": 1,
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.4303185357712209
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.08130314061418176,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "serial_while_loop.c": [
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/serial_while_loop.c/serial_while_loop.c0 /home/exouser/Testsuite/Tests/serial_while_loop.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/serial_while_loop.c\", line 33: error: expected a \";\"\n      for (int y = 0 y < 10; ++y){\n                     ^\n\n\"/home/exouser/Testsuite/Tests/serial_while_loop.c\", line 33: error: expected a \";\"\n      for (int y = 0 y < 10; ++y){\n                                ^\n\n\"/home/exouser/Testsuite/Tests/serial_while_loop.c\", line 50: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n2 errors detected in the compilation of \"/home/exouser/Testsuite/Tests/serial_while_loop.c\".\n",
                    "export": false,
                    "output": "",
                    "result": 2,
                    "runtime": 0.06641611689701676
                },
                "post-compile commands": [],
                "pre-compile commands": [],
                "runtime": {
                    "export": false,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -DT1 -o /home/exouser/Testsuite/build/serial_while_loop.c/serial_while_loop.c1 /home/exouser/Testsuite/Tests/serial_while_loop.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/serial_while_loop.c\", line 50: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n\"/home/exouser/Testsuite/Tests/serial_while_loop.c\", line 51: warning: variable \"failed\" was declared but never referenced\n      int failed;\n          ^\n\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.16678408300504088
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.005303932353854179,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "set_default_async.F90": [
            {
                "compilation": {
                    "command": "nvfortran -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/set_default_async.F90/set_default_async.F900 /home/exouser/Testsuite/Tests/set_default_async.F90",
                    "config": 1,
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.5307545680552721
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.13108260789886117,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "set_default_async.c": [
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/set_default_async.c/set_default_async.c0 /home/exouser/Testsuite/Tests/set_default_async.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/set_default_async.c\", line 60: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.21572221210226417
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.009713886771351099,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "set_device_num.F90": [
            {
                "compilation": {
                    "command": "nvfortran -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/set_device_num.F90/set_device_num.F900 /home/exouser/Testsuite/Tests/set_device_num.F90",
                    "config": 1,
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.48820469761267304
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.12216913001611829,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "set_device_num.c": [
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/set_device_num.c/set_device_num.c0 /home/exouser/Testsuite/Tests/set_device_num.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/set_device_num.c\", line 51: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.16558947041630745
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.01760351797565818,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "set_device_type.F90": [
            {
                "compilation": {
                    "command": "nvfortran -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/set_device_type.F90/set_device_type.F900 /home/exouser/Testsuite/Tests/set_device_type.F90",
                    "config": 1,
                    "errors": "NVFORTRAN-S-1072-Specified device type is not a valid device type. Currently accepted device types are 'nvidia, host, multicore, and default' - device_type (/home/exouser/Testsuite/Tests/set_device_type.F90: 11)\n  0 inform,   0 warnings,   1 severes, 0 fatal for test1\n",
                    "export": false,
                    "output": "",
                    "result": 2,
                    "runtime": 0.14604563266038895
                },
                "post-compile commands": [],
                "pre-compile commands": [],
                "runtime": {
                    "export": false,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvfortran -fast -acc -ta=multicore -DT1 -o /home/exouser/Testsuite/build/set_device_type.F90/set_device_type.F901 /home/exouser/Testsuite/Tests/set_device_type.F90",
                    "config": 1,
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.43152471724897623
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.049252946861088276,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "set_device_type.c": [
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/set_device_type.c/set_device_type.c0 /home/exouser/Testsuite/Tests/set_device_type.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/set_device_type.c\", line 9: error: Specified device type is not a valid device type. Currently accepted device types are 'nvidia, host, multicore, and default'\n      #pragma acc set device_type(device_type)\n                                  ^\n\n\"/home/exouser/Testsuite/Tests/set_device_type.c\", line 20: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n1 error detected in the compilation of \"/home/exouser/Testsuite/Tests/set_device_type.c\".\n",
                    "export": false,
                    "output": "",
                    "result": 2,
                    "runtime": 0.06553325708955526
                },
                "post-compile commands": [],
                "pre-compile commands": [],
                "runtime": {
                    "export": false,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -DT1 -o /home/exouser/Testsuite/build/set_device_type.c/set_device_type.c1 /home/exouser/Testsuite/Tests/set_device_type.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/set_device_type.c\", line 20: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n\"/home/exouser/Testsuite/Tests/set_device_type.c\", line 21: warning: variable \"failed\" was declared but never referenced\n      int failed;\n          ^\n\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.16595086315646768
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.004945140797644854,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "shutdown.F90": [
            {
                "compilation": {
                    "command": "nvfortran -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/shutdown.F90/shutdown.F900 /home/exouser/Testsuite/Tests/shutdown.F90",
                    "config": 1,
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.4799606278538704
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.04679424175992608,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "shutdown.c": [
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/shutdown.c/shutdown.c0 /home/exouser/Testsuite/Tests/shutdown.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/shutdown.c\", line 16: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.16597787430509925
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.005442684981971979,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "shutdown_device_num.F90": [
            {
                "compilation": {
                    "command": "nvfortran -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/shutdown_device_num.F90/shutdown_device_num.F900 /home/exouser/Testsuite/Tests/shutdown_device_num.F90",
                    "config": 1,
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.4801690177991986
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.047264383640140295,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "shutdown_device_num.c": [
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/shutdown_device_num.c/shutdown_device_num.c0 /home/exouser/Testsuite/Tests/shutdown_device_num.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/shutdown_device_num.c\", line 18: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.16564780613407493
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.005316378083080053,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "shutdown_device_type.F90": [
            {
                "compilation": {
                    "command": "nvfortran -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/shutdown_device_type.F90/shutdown_device_type.F900 /home/exouser/Testsuite/Tests/shutdown_device_type.F90",
                    "config": 1,
                    "errors": "NVFORTRAN-S-1072-Specified device type is not a valid device type. Currently accepted device types are 'nvidia, host, multicore, and default' - device_type (/home/exouser/Testsuite/Tests/shutdown_device_type.F90: 11)\n  0 inform,   0 warnings,   1 severes, 0 fatal for test1\n",
                    "export": false,
                    "output": "",
                    "result": 2,
                    "runtime": 0.1840409580618143
                },
                "post-compile commands": [],
                "pre-compile commands": [],
                "runtime": {
                    "export": false,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvfortran -fast -acc -ta=multicore -DT1 -o /home/exouser/Testsuite/build/shutdown_device_type.F90/shutdown_device_type.F901 /home/exouser/Testsuite/Tests/shutdown_device_type.F90",
                    "config": 1,
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.3846114808693528
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.08205486601218581,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "shutdown_device_type.c": [
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/shutdown_device_type.c/shutdown_device_type.c0 /home/exouser/Testsuite/Tests/shutdown_device_type.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/shutdown_device_type.c\", line 10: error: Specified device type is not a valid device type. Currently accepted device types are 'nvidia, host, multicore, and default'\n      #pragma acc shutdown device_type(device_type)\n                                       ^\n\n\"/home/exouser/Testsuite/Tests/shutdown_device_type.c\", line 7: warning: variable \"device_type\" was set but never used\n      int device_type; \n          ^\n\n\"/home/exouser/Testsuite/Tests/shutdown_device_type.c\", line 18: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n1 error detected in the compilation of \"/home/exouser/Testsuite/Tests/shutdown_device_type.c\".\n",
                    "export": false,
                    "output": "",
                    "result": 2,
                    "runtime": 0.06599089410156012
                },
                "post-compile commands": [],
                "pre-compile commands": [],
                "runtime": {
                    "export": false,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -DT1 -o /home/exouser/Testsuite/build/shutdown_device_type.c/shutdown_device_type.c1 /home/exouser/Testsuite/Tests/shutdown_device_type.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/shutdown_device_type.c\", line 18: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n\"/home/exouser/Testsuite/Tests/shutdown_device_type.c\", line 19: warning: variable \"failed\" was declared but never referenced\n      int failed;\n          ^\n\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.1667998586781323
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.005096790846437216,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "shutdown_device_type_num.F90": [
            {
                "compilation": {
                    "command": "nvfortran -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/shutdown_device_type_num.F90/shutdown_device_type_num.F900 /home/exouser/Testsuite/Tests/shutdown_device_type_num.F90",
                    "config": 1,
                    "errors": "NVFORTRAN-S-1072-Specified device type is not a valid device type. Currently accepted device types are 'nvidia, host, multicore, and default' - device_num (/home/exouser/Testsuite/Tests/shutdown_device_type_num.F90: 13)\n  0 inform,   0 warnings,   1 severes, 0 fatal for test1\n",
                    "export": false,
                    "output": "",
                    "result": 2,
                    "runtime": 0.13060727156698704
                },
                "post-compile commands": [],
                "pre-compile commands": [],
                "runtime": {
                    "export": false,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvfortran -fast -acc -ta=multicore -DT1 -o /home/exouser/Testsuite/build/shutdown_device_type_num.F90/shutdown_device_type_num.F901 /home/exouser/Testsuite/Tests/shutdown_device_type_num.F90",
                    "config": 1,
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.42784334998577833
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.029394926968961954,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "shutdown_device_type_num.c": [
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/shutdown_device_type_num.c/shutdown_device_type_num.c0 /home/exouser/Testsuite/Tests/shutdown_device_type_num.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/shutdown_device_type_num.c\", line 8: error: expected a \";\"\n      int device_num\n      ^\n\n\"/home/exouser/Testsuite/Tests/shutdown_device_type_num.c\", line 11: error: identifier \"device_num\" is undefined\n      device_num = acc_get_device_num(device_type);\n      ^\n\n\"/home/exouser/Testsuite/Tests/shutdown_device_type_num.c\", line 11: warning: enumerated type mixed with another type\n      device_num = acc_get_device_num(device_type);\n                                      ^\n\n\"/home/exouser/Testsuite/Tests/shutdown_device_type_num.c\", line 11: warning: variable \"device_type\" is used before its value is set\n      device_num = acc_get_device_num(device_type);\n                                      ^\n\n\"/home/exouser/Testsuite/Tests/shutdown_device_type_num.c\", line 12: error: Specified device type is not a valid device type. Currently accepted device types are 'nvidia, host, multicore, and default'\n      #pragma acc shutdown device_type(device_type) device_num(device_num)\n                                       ^\n\n\"/home/exouser/Testsuite/Tests/shutdown_device_type_num.c\", line 20: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n3 errors detected in the compilation of \"/home/exouser/Testsuite/Tests/shutdown_device_type_num.c\".\n",
                    "export": false,
                    "output": "",
                    "result": 2,
                    "runtime": 0.06543579883873463
                },
                "post-compile commands": [],
                "pre-compile commands": [],
                "runtime": {
                    "export": false,
                    "system": 1
                },
                "testsuite_id": 1
            },
            {
                "compilation": {
                    "command": "nvc -fast -acc -ta=multicore -DT1 -o /home/exouser/Testsuite/build/shutdown_device_type_num.c/shutdown_device_type_num.c1 /home/exouser/Testsuite/Tests/shutdown_device_type_num.c",
                    "config": 1,
                    "errors": "\"/home/exouser/Testsuite/Tests/shutdown_device_type_num.c\", line 20: warning: variable \"testrun\" was declared but never referenced\n      int testrun;\n          ^\n\n\"/home/exouser/Testsuite/Tests/shutdown_device_type_num.c\", line 21: warning: variable \"failed\" was declared but never referenced\n      int failed;\n          ^\n\n",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.16574607184156775
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.004981601145118475,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ],
        "template.F90": [
            {
                "compilation": {
                    "command": "nvfortran -fast -acc -ta=multicore -o /home/exouser/Testsuite/build/template.F90/template.F900 /home/exouser/Testsuite/Tests/template.F90",
                    "config": 1,
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 0,
                    "runtime": 0.480466787237674
                },
                "post-compile commands": [],
                "post-run commands": [],
                "pre-compile commands": [],
                "pre-run commands": [],
                "runtime": {
                    "errors": "",
                    "export": true,
                    "output": "",
                    "result": 1,
                    "runtime": 0.10765232425183058,
                    "system": 1
                },
                "testsuite_id": 1
            }
        ]
    },
    "summary": {
        "1": {
            "1": {
                "1": {
                    "acc_async_test.F90": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        },
                        "2": {
                            "result": "Pass",
                            "run_index": 0
                        },
                        "3": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "acc_async_test.c": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        },
                        "2": {
                            "result": "Pass",
                            "run_index": 0
                        },
                        "3": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "acc_async_test_all.F90": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        },
                        "2": {
                            "result": "Pass",
                            "run_index": 0
                        },
                        "3": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "acc_async_test_all.c": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        },
                        "2": {
                            "result": "Pass",
                            "run_index": 0
                        },
                        "3": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "acc_copyin.F90": {
                        "1": {
                            "result": "Pass",
                            "run_index": 8
                        },
                        "2": {
                            "result": "Pass",
                            "run_index": 8
                        },
                        "3": {
                            "result": "Pass",
                            "run_index": 8
                        },
                        "4": {
                            "result": "Pass",
                            "run_index": 8
                        },
                        "5": {
                            "result": "Pass",
                            "run_index": 8
                        },
                        "6": {
                            "result": "Pass",
                            "run_index": 8
                        },
                        "7": {
                            "result": "Pass",
                            "run_index": 8
                        }
                    },
                    "acc_copyin.c": {
                        "1": {
                            "result": "Pass",
                            "run_index": 8
                        },
                        "2": {
                            "result": "Pass",
                            "run_index": 8
                        },
                        "3": {
                            "result": "Pass",
                            "run_index": 8
                        },
                        "4": {
                            "result": "Pass",
                            "run_index": 8
                        },
                        "5": {
                            "result": "Pass",
                            "run_index": 8
                        },
                        "6": {
                            "result": "Pass",
                            "run_index": 8
                        },
                        "7": {
                            "result": "Pass",
                            "run_index": 8
                        }
                    },
                    "acc_copyin_async.F90": {
                        "1": {
                            "result": "Pass",
                            "run_index": 6
                        },
                        "2": {
                            "result": "Pass",
                            "run_index": 6
                        },
                        "3": {
                            "result": "Pass",
                            "run_index": 6
                        },
                        "4": {
                            "result": "Pass",
                            "run_index": 6
                        },
                        "5": {
                            "result": "Runtime Failure",
                            "run_index": 6
                        }
                    },
                    "acc_copyin_async.c": {
                        "1": {
                            "result": "Pass",
                            "run_index": 6
                        },
                        "2": {
                            "result": "Pass",
                            "run_index": 6
                        },
                        "3": {
                            "result": "Pass",
                            "run_index": 6
                        },
                        "4": {
                            "result": "Pass",
                            "run_index": 6
                        },
                        "5": {
                            "result": "Pass",
                            "run_index": 6
                        }
                    },
                    "acc_copyin_async_with_len.F90": {
                        "1": {
                            "result": "Pass",
                            "run_index": 6
                        },
                        "2": {
                            "result": "Pass",
                            "run_index": 6
                        },
                        "3": {
                            "result": "Pass",
                            "run_index": 6
                        },
                        "4": {
                            "result": "Pass",
                            "run_index": 6
                        },
                        "5": {
                            "result": "Pass",
                            "run_index": 6
                        }
                    },
                    "acc_copyin_with_len.F90": {
                        "1": {
                            "result": "Pass",
                            "run_index": 8
                        },
                        "2": {
                            "result": "Pass",
                            "run_index": 8
                        },
                        "3": {
                            "result": "Pass",
                            "run_index": 8
                        },
                        "4": {
                            "result": "Pass",
                            "run_index": 8
                        },
                        "5": {
                            "result": "Pass",
                            "run_index": 8
                        },
                        "6": {
                            "result": "Runtime Failure",
                            "run_index": 8
                        },
                        "7": {
                            "result": "Pass",
                            "run_index": 8
                        }
                    },
                    "acc_copyout.F90": {
                        "1": {
                            "result": "Pass",
                            "run_index": 6
                        },
                        "2": {
                            "result": "Pass",
                            "run_index": 6
                        },
                        "3": {
                            "result": "Pass",
                            "run_index": 6
                        },
                        "4": {
                            "result": "Pass",
                            "run_index": 6
                        },
                        "5": {
                            "result": "Pass",
                            "run_index": 6
                        }
                    },
                    "acc_copyout.c": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        },
                        "2": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "acc_copyout_async.F90": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "acc_copyout_async.c": {
                        "1": {
                            "result": "Pass",
                            "run_index": 5
                        },
                        "2": {
                            "result": "Pass",
                            "run_index": 5
                        },
                        "3": {
                            "result": "Pass",
                            "run_index": 5
                        },
                        "4": {
                            "result": "Pass",
                            "run_index": 5
                        }
                    },
                    "acc_copyout_async_with_len.F90": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "acc_copyout_finalize.F90": {
                        "1": {
                            "result": "Compilation Failure",
                            "run_index": 0
                        }
                    },
                    "acc_copyout_finalize.c": {
                        "1": {
                            "result": "Unknown Section Result",
                            "run_index": -1
                        },
                        "2": {
                            "result": "Compilation Failure",
                            "run_index": 7
                        },
                        "3": {
                            "result": "Compilation Failure",
                            "run_index": 7
                        }
                    },
                    "acc_copyout_finalize_async.F90": {
                        "1": {
                            "result": "Compilation Failure",
                            "run_index": 0
                        }
                    },
                    "acc_copyout_finalize_async.c": {
                        "1": {
                            "result": "Compilation Failure",
                            "run_index": 1
                        },
                        "2": {
                            "result": "Compilation Failure",
                            "run_index": 2
                        },
                        "3": {
                            "result": "Pass",
                            "run_index": 5
                        },
                        "4": {
                            "result": "Compilation Failure",
                            "run_index": 4
                        }
                    },
                    "acc_copyout_finalize_async_with_len.F90": {
                        "1": {
                            "result": "Compilation Failure",
                            "run_index": 0
                        }
                    },
                    "acc_copyout_finalize_with_len.F90": {
                        "1": {
                            "result": "Compilation Failure",
                            "run_index": 0
                        }
                    },
                    "acc_copyout_with_len.F90": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        },
                        "2": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "acc_create.F90": {
                        "1": {
                            "result": "Pass",
                            "run_index": 5
                        },
                        "2": {
                            "result": "Pass",
                            "run_index": 5
                        },
                        "3": {
                            "result": "Pass",
                            "run_index": 5
                        },
                        "4": {
                            "result": "Pass",
                            "run_index": 5
                        }
                    },
                    "acc_create.c": {
                        "1": {
                            "result": "Pass",
                            "run_index": 6
                        },
                        "2": {
                            "result": "Pass",
                            "run_index": 6
                        },
                        "3": {
                            "result": "Pass",
                            "run_index": 6
                        },
                        "4": {
                            "result": "Pass",
                            "run_index": 6
                        },
                        "5": {
                            "result": "Pass",
                            "run_index": 6
                        }
                    },
                    "acc_create_async.F90": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "acc_create_async.c": {
                        "1": {
                            "result": "Pass",
                            "run_index": 6
                        },
                        "2": {
                            "result": "Pass",
                            "run_index": 6
                        },
                        "3": {
                            "result": "Pass",
                            "run_index": 6
                        },
                        "4": {
                            "result": "Pass",
                            "run_index": 6
                        },
                        "5": {
                            "result": "Pass",
                            "run_index": 6
                        }
                    },
                    "acc_create_async_with_len.F90": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "acc_create_with_len.F90": {
                        "1": {
                            "result": "Pass",
                            "run_index": 5
                        },
                        "2": {
                            "result": "Pass",
                            "run_index": 5
                        },
                        "3": {
                            "result": "Compilation Failure",
                            "run_index": 3
                        },
                        "4": {
                            "result": "Pass",
                            "run_index": 5
                        }
                    },
                    "acc_delete.F90": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        },
                        "2": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "acc_delete.c": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        },
                        "2": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "acc_delete_async.F90": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        },
                        "2": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "acc_delete_async.c": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        },
                        "2": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "acc_delete_async_with_len.F90": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        },
                        "2": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "acc_delete_finalize.F90": {
                        "1": {
                            "result": "Compilation Failure",
                            "run_index": 2
                        },
                        "2": {
                            "result": "Compilation Failure",
                            "run_index": 3
                        }
                    },
                    "acc_delete_finalize.c": {
                        "1": {
                            "result": "Compilation Failure",
                            "run_index": 2
                        },
                        "2": {
                            "result": "Compilation Failure",
                            "run_index": 3
                        }
                    },
                    "acc_delete_finalize_async.F90": {
                        "1": {
                            "result": "Compilation Failure",
                            "run_index": 2
                        },
                        "2": {
                            "result": "Compilation Failure",
                            "run_index": 3
                        }
                    },
                    "acc_delete_finalize_async.c": {
                        "1": {
                            "result": "Unknown Section Result",
                            "run_index": -1
                        },
                        "2": {
                            "result": "Pass",
                            "run_index": 1
                        }
                    },
                    "acc_delete_finalize_async_with_len.F90": {
                        "1": {
                            "result": "Compilation Failure",
                            "run_index": 2
                        },
                        "2": {
                            "result": "Compilation Failure",
                            "run_index": 3
                        }
                    },
                    "acc_delete_finalize_with_len.F90": {
                        "1": {
                            "result": "Compilation Failure",
                            "run_index": 2
                        },
                        "2": {
                            "result": "Compilation Failure",
                            "run_index": 3
                        }
                    },
                    "acc_delete_with_len.F90": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        },
                        "2": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "acc_deviceptr.c": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "acc_free.c": {
                        "1": {
                            "result": "Runtime Failure",
                            "run_index": 0
                        }
                    },
                    "acc_get_default_async.F90": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "acc_get_default_async.c": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "acc_get_device_num.F90": {
                        "1": {
                            "result": "Runtime Failure",
                            "run_index": 0
                        }
                    },
                    "acc_get_device_num.c": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "acc_get_num_devices.F90": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "acc_get_num_devices.c": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "acc_get_property.F90": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "acc_get_property.c": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "acc_get_property_string.F90": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "acc_hostptr.c": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "acc_init.F90": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "acc_init.c": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "acc_is_present.F90": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "acc_is_present.c": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "acc_is_present_with_len.F90": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "acc_malloc.c": {
                        "1": {
                            "result": "Runtime Failure",
                            "run_index": 0
                        }
                    },
                    "acc_map_data.c": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        },
                        "2": {
                            "result": "Pass",
                            "run_index": 0
                        },
                        "3": {
                            "result": "Runtime Failure",
                            "run_index": 0
                        }
                    },
                    "acc_memcpy_device.c": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "acc_memcpy_from_device.c": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "acc_memcpy_from_device_async.c": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "acc_memcpy_to_device.c": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "acc_memcpy_to_device_async.c": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "acc_on_device.F90": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "acc_on_device.c": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "acc_set_default_async.F90": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "acc_set_default_async.c": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "acc_set_device_num.F90": {
                        "1": {
                            "result": "Compilation Failure",
                            "run_index": 0
                        }
                    },
                    "acc_set_device_num.c": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "acc_set_device_type.F90": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "acc_set_device_type.c": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "acc_shutdown.F90": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "acc_shutdown.c": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "acc_unmap_data.c": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        },
                        "2": {
                            "result": "Pass",
                            "run_index": 0
                        },
                        "3": {
                            "result": "Runtime Failure",
                            "run_index": 0
                        }
                    },
                    "acc_update_device.F90": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        },
                        "2": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "acc_update_device.c": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        },
                        "2": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "acc_update_device_async.F90": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        },
                        "2": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "acc_update_device_async.c": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        },
                        "2": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "acc_update_device_async_with_len.F90": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        },
                        "2": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "acc_update_device_with_len.F90": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        },
                        "2": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "acc_update_self.F90": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        },
                        "2": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "acc_update_self.c": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        },
                        "2": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "acc_update_self_async.F90": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        },
                        "2": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "acc_update_self_async.c": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        },
                        "2": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "acc_update_self_async_with_len.F90": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        },
                        "2": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "acc_update_self_with_len.F90": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        },
                        "2": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "acc_wait.F90": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "acc_wait.c": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "acc_wait_all.F90": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "acc_wait_all.c": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "acc_wait_all_async.F90": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "acc_wait_all_async.c": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "acc_wait_async.F90": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "acc_wait_async.c": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "atomic_bitand_equals.c": {
                        "1": {
                            "result": "Runtime Failure",
                            "run_index": 0
                        }
                    },
                    "atomic_bitor_equals.c": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "atomic_bitxor_equals.c": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "atomic_capture_assign_expr_and_x.F90": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "atomic_capture_assign_expr_divided_x.F90": {
                        "1": {
                            "result": "Runtime Error",
                            "run_index": 0
                        }
                    },
                    "atomic_capture_assign_expr_eqv_x.F90": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "atomic_capture_assign_expr_minus_x.F90": {
                        "1": {
                            "result": "Runtime Error",
                            "run_index": 0
                        }
                    },
                    "atomic_capture_assign_expr_neqv_x.F90": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "atomic_capture_assign_expr_or_x.F90": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "atomic_capture_assign_expr_plus_x.F90": {
                        "1": {
                            "result": "Runtime Failure",
                            "run_index": 0
                        }
                    },
                    "atomic_capture_assign_expr_times_x.F90": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "atomic_capture_assign_iand_expr_x.F90": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "atomic_capture_assign_iand_x_expr.F90": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "atomic_capture_assign_ior_expr_x.F90": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "atomic_capture_assign_ior_x_expr.F90": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "atomic_capture_assign_ixor_expr_x.F90": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "atomic_capture_assign_ixor_x_expr.F90": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "atomic_capture_assign_max_expr_list_x.F90": {
                        "1": {
                            "result": "Runtime Failure",
                            "run_index": 0
                        }
                    },
                    "atomic_capture_assign_max_expr_x.F90": {
                        "1": {
                            "result": "Runtime Failure",
                            "run_index": 0
                        }
                    },
                    "atomic_capture_assign_max_x_expr.F90": {
                        "1": {
                            "result": "Runtime Failure",
                            "run_index": 0
                        }
                    },
                    "atomic_capture_assign_max_x_expr_list.F90": {
                        "1": {
                            "result": "Runtime Failure",
                            "run_index": 0
                        }
                    },
                    "atomic_capture_assign_min_expr_list_x.F90": {
                        "1": {
                            "result": "Runtime Failure",
                            "run_index": 0
                        }
                    },
                    "atomic_capture_assign_min_expr_x.F90": {
                        "1": {
                            "result": "Runtime Failure",
                            "run_index": 0
                        }
                    },
                    "atomic_capture_assign_min_x_expr.F90": {
                        "1": {
                            "result": "Runtime Failure",
                            "run_index": 0
                        }
                    },
                    "atomic_capture_assign_min_x_expr_list.F90": {
                        "1": {
                            "result": "Runtime Failure",
                            "run_index": 0
                        }
                    },
                    "atomic_capture_assign_x_and_expr.F90": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "atomic_capture_assign_x_divided_expr.F90": {
                        "1": {
                            "result": "Runtime Error",
                            "run_index": 0
                        }
                    },
                    "atomic_capture_assign_x_eqv_expr.F90": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "atomic_capture_assign_x_minus_expr.F90": {
                        "1": {
                            "result": "Runtime Error",
                            "run_index": 0
                        }
                    },
                    "atomic_capture_assign_x_neqv_expr.F90": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "atomic_capture_assign_x_or_expr.F90": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "atomic_capture_assign_x_plus_expr.F90": {
                        "1": {
                            "result": "Runtime Failure",
                            "run_index": 0
                        }
                    },
                    "atomic_capture_assign_x_times_expr.F90": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "atomic_capture_bitand_equals.c": {
                        "1": {
                            "result": "Compilation Failure",
                            "run_index": 0
                        }
                    },
                    "atomic_capture_bitor_equals.c": {
                        "1": {
                            "result": "Compilation Failure",
                            "run_index": 0
                        }
                    },
                    "atomic_capture_bitxor_equals.c": {
                        "1": {
                            "result": "Compilation Failure",
                            "run_index": 0
                        }
                    },
                    "atomic_capture_divided_equals.c": {
                        "1": {
                            "result": "Compilation Failure",
                            "run_index": 0
                        }
                    },
                    "atomic_capture_expr_and_x_assign.F90": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "atomic_capture_expr_bitand_x.c": {
                        "1": {
                            "result": "Compilation Failure",
                            "run_index": 0
                        }
                    },
                    "atomic_capture_expr_bitor_x.c": {
                        "1": {
                            "result": "Compilation Failure",
                            "run_index": 0
                        }
                    },
                    "atomic_capture_expr_bitxor_x.c": {
                        "1": {
                            "result": "Compilation Failure",
                            "run_index": 0
                        }
                    },
                    "atomic_capture_expr_divided_x.c": {
                        "1": {
                            "result": "Compilation Failure",
                            "run_index": 0
                        }
                    },
                    "atomic_capture_expr_divided_x_assign.F90": {
                        "1": {
                            "result": "Runtime Error",
                            "run_index": 0
                        }
                    },
                    "atomic_capture_expr_eqv_x_assign.F90": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "atomic_capture_expr_lshift_x.c": {
                        "1": {
                            "result": "Compilation Failure",
                            "run_index": 0
                        }
                    },
                    "atomic_capture_expr_minus_x.c": {
                        "1": {
                            "result": "Compilation Failure",
                            "run_index": 0
                        }
                    },
                    "atomic_capture_expr_minus_x_assign.F90": {
                        "1": {
                            "result": "Runtime Error",
                            "run_index": 0
                        }
                    },
                    "atomic_capture_expr_multiply_x.c": {
                        "1": {
                            "result": "Compilation Failure",
                            "run_index": 0
                        }
                    },
                    "atomic_capture_expr_neqv_x_assign.F90": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "atomic_capture_expr_or_x_assign.F90": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "atomic_capture_expr_plus_x.c": {
                        "1": {
                            "result": "Compilation Failure",
                            "run_index": 0
                        }
                    },
                    "atomic_capture_expr_plus_x_assign.F90": {
                        "1": {
                            "result": "Runtime Failure",
                            "run_index": 0
                        }
                    },
                    "atomic_capture_expr_rshift_x.c": {
                        "1": {
                            "result": "Compilation Failure",
                            "run_index": 0
                        }
                    },
                    "atomic_capture_expr_times_x_assign.F90": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "atomic_capture_iand_expr_x_assign.F90": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "atomic_capture_iand_x_expr_assign.F90": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "atomic_capture_ior_expr_x_assign.F90": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "atomic_capture_ior_x_expr_assign.F90": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "atomic_capture_ixor_expr_x_assign.F90": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "atomic_capture_ixor_x_expr_assign.F90": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "atomic_capture_lshift_equals.c": {
                        "1": {
                            "result": "Compilation Failure",
                            "run_index": 0
                        }
                    },
                    "atomic_capture_max_expr_list_x_assign.F90": {
                        "1": {
                            "result": "Runtime Failure",
                            "run_index": 0
                        }
                    },
                    "atomic_capture_max_expr_x_assign.F90": {
                        "1": {
                            "result": "Runtime Failure",
                            "run_index": 0
                        }
                    },
                    "atomic_capture_max_x_expr_assign.F90": {
                        "1": {
                            "result": "Runtime Failure",
                            "run_index": 0
                        }
                    },
                    "atomic_capture_max_x_expr_list_assign.F90": {
                        "1": {
                            "result": "Runtime Failure",
                            "run_index": 0
                        }
                    },
                    "atomic_capture_min_expr_list_x_assign.F90": {
                        "1": {
                            "result": "Runtime Failure",
                            "run_index": 0
                        }
                    },
                    "atomic_capture_min_expr_x_assign.F90": {
                        "1": {
                            "result": "Runtime Failure",
                            "run_index": 0
                        }
                    },
                    "atomic_capture_min_x_expr_assign.F90": {
                        "1": {
                            "result": "Runtime Failure",
                            "run_index": 0
                        }
                    },
                    "atomic_capture_min_x_expr_list_assign.F90": {
                        "1": {
                            "result": "Runtime Failure",
                            "run_index": 0
                        }
                    },
                    "atomic_capture_minus_equals.c": {
                        "1": {
                            "result": "Compilation Failure",
                            "run_index": 0
                        }
                    },
                    "atomic_capture_multiply_equals.c": {
                        "1": {
                            "result": "Compilation Failure",
                            "run_index": 0
                        }
                    },
                    "atomic_capture_plus_equals.c": {
                        "1": {
                            "result": "Compilation Failure",
                            "run_index": 0
                        }
                    },
                    "atomic_capture_postdecrement.c": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "atomic_capture_postincrement.c": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "atomic_capture_predecrement.c": {
                        "1": {
                            "result": "Compilation Failure",
                            "run_index": 0
                        }
                    },
                    "atomic_capture_preincrement.c": {
                        "1": {
                            "result": "Compilation Failure",
                            "run_index": 0
                        }
                    },
                    "atomic_capture_rshift_equals.c": {
                        "1": {
                            "result": "Compilation Failure",
                            "run_index": 0
                        }
                    },
                    "atomic_capture_x_and_expr_assign.F90": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "atomic_capture_x_divided_expr_assign.F90": {
                        "1": {
                            "result": "Runtime Error",
                            "run_index": 0
                        }
                    },
                    "atomic_capture_x_eqv_expr_assign.F90": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "atomic_capture_x_minus_expr_assign.F90": {
                        "1": {
                            "result": "Runtime Error",
                            "run_index": 0
                        }
                    },
                    "atomic_capture_x_neqv_expr_assign.F90": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "atomic_capture_x_or_expr_assign.F90": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "atomic_capture_x_plus_expr_assign.F90": {
                        "1": {
                            "result": "Runtime Failure",
                            "run_index": 0
                        }
                    },
                    "atomic_capture_x_times_expr_assign.F90": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "atomic_divided_equals.c": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "atomic_expr_and_x.F90": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "atomic_expr_and_x_end.F90": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "atomic_expr_bitand_x.c": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "atomic_expr_bitor_x.c": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "atomic_expr_bitxor_x.c": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "atomic_expr_divided_x.F90": {
                        "1": {
                            "result": "Runtime Error",
                            "run_index": 0
                        }
                    },
                    "atomic_expr_divided_x.c": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "atomic_expr_divided_x_end.F90": {
                        "1": {
                            "result": "Runtime Error",
                            "run_index": 0
                        }
                    },
                    "atomic_expr_eqv_x.F90": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "atomic_expr_eqv_x_end.F90": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "atomic_expr_lshift_x.c": {
                        "1": {
                            "result": "Compilation Failure",
                            "run_index": 0
                        }
                    },
                    "atomic_expr_minus_x.F90": {
                        "1": {
                            "result": "Runtime Error",
                            "run_index": 0
                        }
                    },
                    "atomic_expr_minus_x.c": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "atomic_expr_minus_x_end.F90": {
                        "1": {
                            "result": "Runtime Error",
                            "run_index": 0
                        }
                    },
                    "atomic_expr_multiply_x.c": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "atomic_expr_neqv_x.F90": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "atomic_expr_neqv_x_end.F90": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "atomic_expr_or_x.F90": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "atomic_expr_or_x_end.F90": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "atomic_expr_plus_x.F90": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "atomic_expr_plus_x.c": {
                        "1": {
                            "result": "Runtime Failure",
                            "run_index": 0
                        }
                    },
                    "atomic_expr_plus_x_end.F90": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "atomic_expr_rshift_x.c": {
                        "1": {
                            "result": "Compilation Failure",
                            "run_index": 0
                        }
                    },
                    "atomic_expr_times_x.F90": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "atomic_expr_times_x_end.F90": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "atomic_iand_expr_x.F90": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "atomic_iand_expr_x_end.F90": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "atomic_iand_x_expr.F90": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "atomic_iand_x_expr_end.F90": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "atomic_ior_expr_x.F90": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "atomic_ior_expr_x_end.F90": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "atomic_ior_x_expr.F90": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "atomic_ior_x_expr_end.F90": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "atomic_ixor_expr_x.F90": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "atomic_ixor_expr_x_end.F90": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "atomic_ixor_x_expr.F90": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "atomic_ixor_x_expr_end.F90": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "atomic_lshift_equals.c": {
                        "1": {
                            "result": "Compilation Failure",
                            "run_index": 0
                        }
                    },
                    "atomic_max_expr_list_x.F90": {
                        "1": {
                            "result": "Compilation Failure",
                            "run_index": 0
                        }
                    },
                    "atomic_max_expr_list_x_end.F90": {
                        "1": {
                            "result": "Compilation Failure",
                            "run_index": 0
                        }
                    },
                    "atomic_max_expr_x.F90": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "atomic_max_expr_x_end.F90": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "atomic_max_x_expr.F90": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "atomic_max_x_expr_end.F90": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "atomic_max_x_expr_list.F90": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "atomic_max_x_expr_list_end.F90": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "atomic_min_expr_list_x.F90": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "atomic_min_expr_list_x_end.F90": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "atomic_min_expr_x.F90": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "atomic_min_expr_x_end.F90": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "atomic_min_x_expr.F90": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "atomic_min_x_expr_end.F90": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "atomic_min_x_expr_list.F90": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "atomic_min_x_expr_list_end.F90": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "atomic_minus_equals.c": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "atomic_multiply_equals.c": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "atomic_plus_equals.c": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "atomic_postdecrement.c": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "atomic_postincrement.c": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "atomic_predecrement.c": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "atomic_preincrement.c": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "atomic_rshift_equals.c": {
                        "1": {
                            "result": "Compilation Failure",
                            "run_index": 0
                        }
                    },
                    "atomic_structured_assign_assign.c": {
                        "1": {
                            "result": "Compilation Failure",
                            "run_index": 0
                        }
                    },
                    "atomic_structured_assign_bitand_equals.c": {
                        "1": {
                            "result": "Compilation Failure",
                            "run_index": 0
                        }
                    },
                    "atomic_structured_assign_bitor_equals.c": {
                        "1": {
                            "result": "Compilation Failure",
                            "run_index": 0
                        }
                    },
                    "atomic_structured_assign_bitxor_equals.c": {
                        "1": {
                            "result": "Compilation Failure",
                            "run_index": 0
                        }
                    },
                    "atomic_structured_assign_divided_equals.c": {
                        "1": {
                            "result": "Compilation Failure",
                            "run_index": 0
                        }
                    },
                    "atomic_structured_assign_expr_bitand_x.c": {
                        "1": {
                            "result": "Compilation Failure",
                            "run_index": 0
                        }
                    },
                    "atomic_structured_assign_expr_bitor_x.c": {
                        "1": {
                            "result": "Compilation Failure",
                            "run_index": 0
                        }
                    },
                    "atomic_structured_assign_expr_bitxor_x.c": {
                        "1": {
                            "result": "Compilation Failure",
                            "run_index": 0
                        }
                    },
                    "atomic_structured_assign_expr_divided_x.c": {
                        "1": {
                            "result": "Compilation Failure",
                            "run_index": 0
                        }
                    },
                    "atomic_structured_assign_expr_multiply_x.c": {
                        "1": {
                            "result": "Compilation Failure",
                            "run_index": 0
                        }
                    },
                    "atomic_structured_assign_expr_plus_x.c": {
                        "1": {
                            "result": "Compilation Failure",
                            "run_index": 0
                        }
                    },
                    "atomic_structured_assign_lshift_equals.c": {
                        "1": {
                            "result": "Compilation Failure",
                            "run_index": 0
                        }
                    },
                    "atomic_structured_assign_minus_equals.c": {
                        "1": {
                            "result": "Compilation Failure",
                            "run_index": 0
                        }
                    },
                    "atomic_structured_assign_multiply_equals.c": {
                        "1": {
                            "result": "Compilation Failure",
                            "run_index": 0
                        }
                    },
                    "atomic_structured_assign_plus_equals.c": {
                        "1": {
                            "result": "Compilation Failure",
                            "run_index": 0
                        }
                    },
                    "atomic_structured_assign_postdecrement.c": {
                        "1": {
                            "result": "Compilation Failure",
                            "run_index": 0
                        }
                    },
                    "atomic_structured_assign_postincrement.c": {
                        "1": {
                            "result": "Compilation Failure",
                            "run_index": 0
                        }
                    },
                    "atomic_structured_assign_predecrement.c": {
                        "1": {
                            "result": "Compilation Failure",
                            "run_index": 0
                        }
                    },
                    "atomic_structured_assign_preincrement.c": {
                        "1": {
                            "result": "Compilation Failure",
                            "run_index": 0
                        }
                    },
                    "atomic_structured_assign_rshift_equals.c": {
                        "1": {
                            "result": "Compilation Failure",
                            "run_index": 0
                        }
                    },
                    "atomic_structured_assign_x_bitand_expr.c": {
                        "1": {
                            "result": "Compilation Failure",
                            "run_index": 0
                        }
                    },
                    "atomic_structured_assign_x_bitor_expr.c": {
                        "1": {
                            "result": "Compilation Failure",
                            "run_index": 0
                        }
                    },
                    "atomic_structured_assign_x_bitxor_expr.c": {
                        "1": {
                            "result": "Compilation Failure",
                            "run_index": 0
                        }
                    },
                    "atomic_structured_assign_x_divided_expr.c": {
                        "1": {
                            "result": "Compilation Failure",
                            "run_index": 0
                        }
                    },
                    "atomic_structured_assign_x_lshift_expr.c": {
                        "1": {
                            "result": "Compilation Failure",
                            "run_index": 0
                        }
                    },
                    "atomic_structured_assign_x_minus_expr.c": {
                        "1": {
                            "result": "Compilation Failure",
                            "run_index": 0
                        }
                    },
                    "atomic_structured_assign_x_multiply_expr.c": {
                        "1": {
                            "result": "Compilation Failure",
                            "run_index": 0
                        }
                    },
                    "atomic_structured_assign_x_plus_expr.c": {
                        "1": {
                            "result": "Compilation Failure",
                            "run_index": 0
                        }
                    },
                    "atomic_structured_assign_x_rshift_expr.c": {
                        "1": {
                            "result": "Compilation Failure",
                            "run_index": 0
                        }
                    },
                    "atomic_structured_bitand_equals_assign.c": {
                        "1": {
                            "result": "Compilation Failure",
                            "run_index": 0
                        }
                    },
                    "atomic_structured_bitor_equals_assign.c": {
                        "1": {
                            "result": "Compilation Failure",
                            "run_index": 0
                        }
                    },
                    "atomic_structured_bitxor_equals_assign.c": {
                        "1": {
                            "result": "Compilation Failure",
                            "run_index": 0
                        }
                    },
                    "atomic_structured_divided_equals_assign.c": {
                        "1": {
                            "result": "Compilation Failure",
                            "run_index": 0
                        }
                    },
                    "atomic_structured_expr_bitand_x_assign.c": {
                        "1": {
                            "result": "Compilation Failure",
                            "run_index": 0
                        }
                    },
                    "atomic_structured_expr_bitor_x_assign.c": {
                        "1": {
                            "result": "Compilation Failure",
                            "run_index": 0
                        }
                    },
                    "atomic_structured_expr_bitxor_x_assign.c": {
                        "1": {
                            "result": "Compilation Failure",
                            "run_index": 0
                        }
                    },
                    "atomic_structured_expr_multiply_x_assign.c": {
                        "1": {
                            "result": "Compilation Failure",
                            "run_index": 0
                        }
                    },
                    "atomic_structured_expr_plus_x_assign.c": {
                        "1": {
                            "result": "Compilation Failure",
                            "run_index": 0
                        }
                    },
                    "atomic_structured_lshift_equals_assign.c": {
                        "1": {
                            "result": "Compilation Failure",
                            "run_index": 0
                        }
                    },
                    "atomic_structured_minus_equals_assign.c": {
                        "1": {
                            "result": "Compilation Failure",
                            "run_index": 0
                        }
                    },
                    "atomic_structured_multiply_equals_assign.c": {
                        "1": {
                            "result": "Compilation Failure",
                            "run_index": 0
                        }
                    },
                    "atomic_structured_plus_equals_assign.c": {
                        "1": {
                            "result": "Compilation Failure",
                            "run_index": 0
                        }
                    },
                    "atomic_structured_postdecrement_assign.c": {
                        "1": {
                            "result": "Compilation Failure",
                            "run_index": 0
                        }
                    },
                    "atomic_structured_postincrement_assign.c": {
                        "1": {
                            "result": "Compilation Failure",
                            "run_index": 0
                        }
                    },
                    "atomic_structured_predecrement_assign.c": {
                        "1": {
                            "result": "Compilation Failure",
                            "run_index": 0
                        }
                    },
                    "atomic_structured_preincrement_assign.c": {
                        "1": {
                            "result": "Compilation Failure",
                            "run_index": 0
                        }
                    },
                    "atomic_structured_rshift_equals_assign.c": {
                        "1": {
                            "result": "Compilation Failure",
                            "run_index": 0
                        }
                    },
                    "atomic_structured_x_bitand_expr_assign.c": {
                        "1": {
                            "result": "Compilation Failure",
                            "run_index": 0
                        }
                    },
                    "atomic_structured_x_bitor_expr_assign.c": {
                        "1": {
                            "result": "Compilation Failure",
                            "run_index": 0
                        }
                    },
                    "atomic_structured_x_bitxor_expr_assign.c": {
                        "1": {
                            "result": "Compilation Failure",
                            "run_index": 0
                        }
                    },
                    "atomic_structured_x_divided_expr_assign.c": {
                        "1": {
                            "result": "Compilation Failure",
                            "run_index": 0
                        }
                    },
                    "atomic_structured_x_lshift_expr_assign.c": {
                        "1": {
                            "result": "Compilation Failure",
                            "run_index": 0
                        }
                    },
                    "atomic_structured_x_minus_expr_assign.c": {
                        "1": {
                            "result": "Compilation Failure",
                            "run_index": 0
                        }
                    },
                    "atomic_structured_x_multiply_expr_assign.c": {
                        "1": {
                            "result": "Compilation Failure",
                            "run_index": 0
                        }
                    },
                    "atomic_structured_x_plus_expr_assign.c": {
                        "1": {
                            "result": "Compilation Failure",
                            "run_index": 0
                        }
                    },
                    "atomic_structured_x_rshift_expr_assign.c": {
                        "1": {
                            "result": "Compilation Failure",
                            "run_index": 0
                        }
                    },
                    "atomic_update_bitand_equals.c": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "atomic_update_bitor_equals.c": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "atomic_update_bitxor_equals.c": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "atomic_update_divided_equals.c": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "atomic_update_expr_and_x.F90": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "atomic_update_expr_and_x_end.F90": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "atomic_update_expr_bitand_x.c": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "atomic_update_expr_bitor_x.c": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "atomic_update_expr_bitxor_x.c": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "atomic_update_expr_divided_x.F90": {
                        "1": {
                            "result": "Runtime Error",
                            "run_index": 0
                        }
                    },
                    "atomic_update_expr_divided_x.c": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "atomic_update_expr_divided_x_end.F90": {
                        "1": {
                            "result": "Runtime Error",
                            "run_index": 0
                        }
                    },
                    "atomic_update_expr_eqv_x.F90": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "atomic_update_expr_eqv_x_end.F90": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "atomic_update_expr_lshift_x.c": {
                        "1": {
                            "result": "Compilation Failure",
                            "run_index": 0
                        }
                    },
                    "atomic_update_expr_minus_x.F90": {
                        "1": {
                            "result": "Runtime Error",
                            "run_index": 0
                        }
                    },
                    "atomic_update_expr_minus_x.c": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "atomic_update_expr_minus_x_end.F90": {
                        "1": {
                            "result": "Runtime Error",
                            "run_index": 0
                        }
                    },
                    "atomic_update_expr_multiply_x.c": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "atomic_update_expr_neqv_x.F90": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "atomic_update_expr_neqv_x_end.F90": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "atomic_update_expr_or_x.F90": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "atomic_update_expr_or_x_end.F90": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "atomic_update_expr_plus_x.F90": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "atomic_update_expr_plus_x.c": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "atomic_update_expr_plus_x_end.F90": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "atomic_update_expr_rshift_x.c": {
                        "1": {
                            "result": "Compilation Failure",
                            "run_index": 0
                        }
                    },
                    "atomic_update_expr_times_x.F90": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "atomic_update_expr_times_x_end.F90": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "atomic_update_iand_expr_x.F90": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "atomic_update_iand_expr_x_end.F90": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "atomic_update_iand_x_expr.F90": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "atomic_update_iand_x_expr_end.F90": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "atomic_update_ior_expr_x.F90": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "atomic_update_ior_expr_x_end.F90": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "atomic_update_ior_x_expr.F90": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "atomic_update_ior_x_expr_end.F90": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "atomic_update_ixor_expr_x.F90": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "atomic_update_ixor_expr_x_end.F90": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "atomic_update_ixor_x_expr.F90": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "atomic_update_ixor_x_expr_end.F90": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "atomic_update_lshift_equals.c": {
                        "1": {
                            "result": "Compilation Failure",
                            "run_index": 0
                        }
                    },
                    "atomic_update_max_expr_list_x.F90": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "atomic_update_max_expr_list_x_end.F90": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "atomic_update_max_expr_x.F90": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "atomic_update_max_expr_x_end.F90": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "atomic_update_max_x_expr.F90": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "atomic_update_max_x_expr_end.F90": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "atomic_update_max_x_expr_list.F90": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "atomic_update_max_x_expr_list_end.F90": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "atomic_update_min_expr_list_x.F90": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "atomic_update_min_expr_list_x_end.F90": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "atomic_update_min_expr_x.F90": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "atomic_update_min_expr_x_end.F90": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "atomic_update_min_x_expr.F90": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "atomic_update_min_x_expr_end.F90": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "atomic_update_min_x_expr_list.F90": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "atomic_update_min_x_expr_list_end.F90": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "atomic_update_minus_equals.c": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "atomic_update_multiply_equals.c": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "atomic_update_plus_equals.c": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "atomic_update_postdecrement.c": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "atomic_update_postincrement.c": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "atomic_update_predecrement.c": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "atomic_update_preincrement.c": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "atomic_update_rshift_equals.c": {
                        "1": {
                            "result": "Compilation Failure",
                            "run_index": 0
                        }
                    },
                    "atomic_update_x_and_expr.F90": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "atomic_update_x_and_expr_end.F90": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "atomic_update_x_bitand_expr.c": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "atomic_update_x_bitor_expr.c": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "atomic_update_x_bitxor_expr.c": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "atomic_update_x_divided_expr.F90": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "atomic_update_x_divided_expr.c": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "atomic_update_x_divided_expr_end.F90": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "atomic_update_x_eqv_expr.F90": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "atomic_update_x_eqv_expr_end.F90": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "atomic_update_x_lshift_expr.c": {
                        "1": {
                            "result": "Compilation Failure",
                            "run_index": 0
                        }
                    },
                    "atomic_update_x_minus_expr.F90": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "atomic_update_x_minus_expr.c": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "atomic_update_x_minus_expr_end.F90": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "atomic_update_x_multiply_expr.c": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "atomic_update_x_neqv_expr.F90": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "atomic_update_x_neqv_expr_end.F90": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "atomic_update_x_or_expr.F90": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "atomic_update_x_or_expr_end.F90": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "atomic_update_x_plus_expr.F90": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "atomic_update_x_plus_expr.c": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "atomic_update_x_plus_expr_end.F90": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "atomic_update_x_rshift_expr.c": {
                        "1": {
                            "result": "Compilation Failure",
                            "run_index": 0
                        }
                    },
                    "atomic_update_x_times_expr.F90": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "atomic_update_x_times_expr_end.F90": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "atomic_x_and_expr.F90": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "atomic_x_and_expr_end.F90": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "atomic_x_bitand_expr.c": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "atomic_x_bitor_expr.c": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "atomic_x_bitxor_expr.c": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "atomic_x_divided_expr.F90": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "atomic_x_divided_expr.c": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "atomic_x_divided_expr_end.F90": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "atomic_x_eqv_expr.F90": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "atomic_x_eqv_expr_end.F90": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "atomic_x_lshift_expr.c": {
                        "1": {
                            "result": "Compilation Failure",
                            "run_index": 0
                        }
                    },
                    "atomic_x_minus_expr.F90": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "atomic_x_minus_expr.c": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "atomic_x_minus_expr_end.F90": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "atomic_x_multiply_expr.c": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "atomic_x_neqv_expr.F90": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "atomic_x_neqv_expr_end.F90": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "atomic_x_or_expr.F90": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "atomic_x_or_expr_end.F90": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "atomic_x_plus_expr.F90": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "atomic_x_plus_expr.c": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "atomic_x_plus_expr_end.F90": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "atomic_x_rshift_expr.c": {
                        "1": {
                            "result": "Compilation Failure",
                            "run_index": 0
                        }
                    },
                    "atomic_x_times_expr.F90": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "atomic_x_times_expr_end.F90": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "data_copy_no_lower_bound.F90": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "data_copy_no_lower_bound.c": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "data_copyin_no_lower_bound.F90": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "data_copyin_no_lower_bound.c": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "data_copyout_no_lower_bound.F90": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "data_copyout_no_lower_bound.c": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "data_copyout_reference_counts.F90": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        },
                        "2": {
                            "result": "Pass",
                            "run_index": 0
                        },
                        "3": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "data_copyout_reference_counts.c": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        },
                        "2": {
                            "result": "Pass",
                            "run_index": 0
                        },
                        "3": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "data_create.F90": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        },
                        "2": {
                            "result": "Pass",
                            "run_index": 0
                        },
                        "3": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "data_create.c": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        },
                        "2": {
                            "result": "Pass",
                            "run_index": 0
                        },
                        "3": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "data_create_no_lower_bound.F90": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "data_create_no_lower_bound.c": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "data_present_no_lower_bound.F90": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "data_present_no_lower_bound.c": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "data_with_changing_subscript.F90": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "data_with_changing_subscript.c": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "data_with_derived_type.F90": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "data_with_structs.c": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "declare_copyin.F90": {
                        "1": {
                            "result": "Compilation Failure",
                            "run_index": 1
                        },
                        "2": {
                            "result": "Compilation Failure",
                            "run_index": 2
                        },
                        "3": {
                            "result": "Compilation Failure",
                            "run_index": 3
                        },
                        "4": {
                            "result": "Compilation Failure",
                            "run_index": 4
                        }
                    },
                    "declare_copyin.c": {
                        "1": {
                            "result": "Compilation Failure",
                            "run_index": 1
                        },
                        "2": {
                            "result": "Compilation Failure",
                            "run_index": 2
                        },
                        "3": {
                            "result": "Compilation Failure",
                            "run_index": 3
                        },
                        "4": {
                            "result": "Compilation Failure",
                            "run_index": 4
                        },
                        "5": {
                            "result": "Compilation Failure",
                            "run_index": 5
                        }
                    },
                    "declare_create.F90": {
                        "1": {
                            "result": "Compilation Failure",
                            "run_index": 1
                        },
                        "2": {
                            "result": "Compilation Failure",
                            "run_index": 2
                        },
                        "3": {
                            "result": "Compilation Failure",
                            "run_index": 3
                        },
                        "4": {
                            "result": "Compilation Failure",
                            "run_index": 4
                        }
                    },
                    "declare_create.c": {
                        "1": {
                            "result": "Compilation Failure",
                            "run_index": 1
                        },
                        "2": {
                            "result": "Compilation Failure",
                            "run_index": 2
                        },
                        "3": {
                            "result": "Compilation Failure",
                            "run_index": 3
                        },
                        "4": {
                            "result": "Compilation Failure",
                            "run_index": 4
                        },
                        "5": {
                            "result": "Compilation Failure",
                            "run_index": 5
                        }
                    },
                    "declare_device_resident.c": {
                        "1": {
                            "result": "Unknown Section Result",
                            "run_index": -1
                        },
                        "2": {
                            "result": "Compilation Failure",
                            "run_index": 7
                        },
                        "3": {
                            "result": "Compilation Failure",
                            "run_index": 7
                        }
                    },
                    "declare_function_scope_copy.F90": {
                        "1": {
                            "result": "Pass",
                            "run_index": 5
                        },
                        "2": {
                            "result": "Pass",
                            "run_index": 5
                        },
                        "3": {
                            "result": "Pass",
                            "run_index": 5
                        },
                        "4": {
                            "result": "Pass",
                            "run_index": 5
                        }
                    },
                    "declare_function_scope_copy.c": {
                        "1": {
                            "result": "Pass",
                            "run_index": 5
                        },
                        "2": {
                            "result": "Runtime Error",
                            "run_index": 2
                        },
                        "3": {
                            "result": "Pass",
                            "run_index": 5
                        },
                        "4": {
                            "result": "Pass",
                            "run_index": 5
                        }
                    },
                    "declare_function_scope_copyin.F90": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        },
                        "2": {
                            "result": "Pass",
                            "run_index": 0
                        },
                        "3": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "declare_function_scope_copyin.c": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        },
                        "2": {
                            "result": "Pass",
                            "run_index": 0
                        },
                        "3": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "declare_function_scope_copyout.F90": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        },
                        "2": {
                            "result": "Pass",
                            "run_index": 0
                        },
                        "3": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "declare_function_scope_copyout.c": {
                        "1": {
                            "result": "Pass",
                            "run_index": 5
                        },
                        "2": {
                            "result": "Runtime Error",
                            "run_index": 2
                        },
                        "3": {
                            "result": "Pass",
                            "run_index": 5
                        },
                        "4": {
                            "result": "Pass",
                            "run_index": 5
                        }
                    },
                    "declare_function_scope_create.F90": {
                        "1": {
                            "result": "Unknown Section Result",
                            "run_index": -1
                        },
                        "2": {
                            "result": "Compilation Failure",
                            "run_index": 7
                        },
                        "3": {
                            "result": "Compilation Failure",
                            "run_index": 7
                        }
                    },
                    "declare_function_scope_create.c": {
                        "1": {
                            "result": "Pass",
                            "run_index": 2
                        },
                        "2": {
                            "result": "Unknown Section Result",
                            "run_index": -1
                        },
                        "3": {
                            "result": "Pass",
                            "run_index": 2
                        }
                    },
                    "declare_function_scope_deviceptr.c": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        },
                        "2": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "declare_function_scope_present.F90": {
                        "1": {
                            "result": "Compilation Failure",
                            "run_index": 2
                        },
                        "2": {
                            "result": "Compilation Failure",
                            "run_index": 3
                        }
                    },
                    "declare_function_scope_present.c": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        },
                        "2": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "enter_data_copyin_no_lower_bound.F90": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "enter_data_copyin_no_lower_bound.c": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "enter_data_create.F90": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        },
                        "2": {
                            "result": "Pass",
                            "run_index": 0
                        },
                        "3": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "enter_data_create.c": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        },
                        "2": {
                            "result": "Pass",
                            "run_index": 0
                        },
                        "3": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "enter_data_create_no_lower_bound.F90": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "enter_data_create_no_lower_bound.c": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "enter_data_if.F90": {
                        "1": {
                            "result": "Pass",
                            "run_index": 6
                        },
                        "2": {
                            "result": "Pass",
                            "run_index": 6
                        },
                        "3": {
                            "result": "Pass",
                            "run_index": 6
                        },
                        "4": {
                            "result": "Pass",
                            "run_index": 6
                        },
                        "5": {
                            "result": "Pass",
                            "run_index": 6
                        }
                    },
                    "enter_exit_data_if.c": {
                        "1": {
                            "result": "Pass",
                            "run_index": 6
                        },
                        "2": {
                            "result": "Pass",
                            "run_index": 6
                        },
                        "3": {
                            "result": "Pass",
                            "run_index": 6
                        },
                        "4": {
                            "result": "Pass",
                            "run_index": 6
                        },
                        "5": {
                            "result": "Pass",
                            "run_index": 6
                        }
                    },
                    "exit_data.F90": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        },
                        "2": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "exit_data.c": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        },
                        "2": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "exit_data_copyout_no_lower_bound.F90": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "exit_data_copyout_no_lower_bound.c": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "exit_data_copyout_reference_counts.F90": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        },
                        "2": {
                            "result": "Pass",
                            "run_index": 0
                        },
                        "3": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "exit_data_copyout_reference_counts.c": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        },
                        "2": {
                            "result": "Pass",
                            "run_index": 0
                        },
                        "3": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "exit_data_delete_no_lower_bound.F90": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        },
                        "2": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "exit_data_delete_no_lower_bound.c": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "exit_data_finalize.F90": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        },
                        "2": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "exit_data_finalize.c": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        },
                        "2": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "host_data.c": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "init.F90": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "init.c": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "init_device_num.F90": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "init_device_num.c": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "init_device_type.F90": {
                        "1": {
                            "result": "Compilation Failure",
                            "run_index": 0
                        }
                    },
                    "init_device_type.c": {
                        "1": {
                            "result": "Compilation Failure",
                            "run_index": 0
                        }
                    },
                    "init_device_type_num.F90": {
                        "1": {
                            "result": "Compilation Failure",
                            "run_index": 0
                        }
                    },
                    "init_device_type_num.c": {
                        "1": {
                            "result": "Compilation Failure",
                            "run_index": 0
                        }
                    },
                    "kernels_async.F90": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "kernels_async.c": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "kernels_copy.F90": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        },
                        "2": {
                            "result": "Pass",
                            "run_index": 0
                        },
                        "3": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "kernels_copy.c": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        },
                        "2": {
                            "result": "Pass",
                            "run_index": 0
                        },
                        "3": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "kernels_copyin.F90": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        },
                        "2": {
                            "result": "Pass",
                            "run_index": 0
                        },
                        "3": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "kernels_copyin.c": {
                        "1": {
                            "result": "Pass",
                            "run_index": 4
                        },
                        "2": {
                            "result": "Pass",
                            "run_index": 4
                        },
                        "3": {
                            "result": "Unknown Section Result",
                            "run_index": -1
                        }
                    },
                    "kernels_copyout.F90": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        },
                        "2": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "kernels_copyout.c": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        },
                        "2": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "kernels_create.F90": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        },
                        "2": {
                            "result": "Pass",
                            "run_index": 0
                        },
                        "3": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "kernels_create.c": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        },
                        "2": {
                            "result": "Pass",
                            "run_index": 0
                        },
                        "3": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "kernels_default_copy.F90": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        },
                        "2": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "kernels_default_copy.c": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        },
                        "2": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "kernels_default_present.F90": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "kernels_default_present.c": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "kernels_if.F90": {
                        "1": {
                            "result": "Pass",
                            "run_index": 5
                        },
                        "2": {
                            "result": "Pass",
                            "run_index": 5
                        },
                        "3": {
                            "result": "Pass",
                            "run_index": 5
                        },
                        "4": {
                            "result": "Pass",
                            "run_index": 5
                        }
                    },
                    "kernels_if.c": {
                        "1": {
                            "result": "Pass",
                            "run_index": 5
                        },
                        "2": {
                            "result": "Compilation Failure",
                            "run_index": 2
                        },
                        "3": {
                            "result": "Pass",
                            "run_index": 5
                        },
                        "4": {
                            "result": "Pass",
                            "run_index": 5
                        }
                    },
                    "kernels_loop.F90": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "kernels_loop.c": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "kernels_loop_independent.F90": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "kernels_loop_independent.c": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "kernels_loop_reduction_add_general.F90": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "kernels_loop_reduction_add_general.c": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "kernels_loop_reduction_add_loop.F90": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "kernels_loop_reduction_add_loop.c": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "kernels_loop_reduction_add_vector_loop.F90": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "kernels_loop_reduction_add_vector_loop.c": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "kernels_loop_reduction_and_general.F90": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "kernels_loop_reduction_and_general.c": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "kernels_loop_reduction_and_loop.F90": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "kernels_loop_reduction_and_loop.c": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "kernels_loop_reduction_and_vector_loop.F90": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "kernels_loop_reduction_and_vector_loop.c": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "kernels_loop_reduction_bitand_general.F90": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "kernels_loop_reduction_bitand_general.c": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "kernels_loop_reduction_bitand_loop.F90": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "kernels_loop_reduction_bitand_loop.c": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "kernels_loop_reduction_bitand_vector_loop.F90": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "kernels_loop_reduction_bitand_vector_loop.c": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "kernels_loop_reduction_bitor_general.F90": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "kernels_loop_reduction_bitor_general.c": {
                        "1": {
                            "result": "Runtime Failure",
                            "run_index": 0
                        }
                    },
                    "kernels_loop_reduction_bitor_loop.F90": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "kernels_loop_reduction_bitor_loop.c": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "kernels_loop_reduction_bitor_vector_loop.F90": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "kernels_loop_reduction_bitor_vector_loop.c": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "kernels_loop_reduction_bitxor_general.F90": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "kernels_loop_reduction_bitxor_general.c": {
                        "1": {
                            "result": "Runtime Failure",
                            "run_index": 0
                        }
                    },
                    "kernels_loop_reduction_bitxor_loop.F90": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "kernels_loop_reduction_bitxor_loop.c": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "kernels_loop_reduction_bitxor_vector_loop.F90": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "kernels_loop_reduction_bitxor_vector_loop.c": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "kernels_loop_reduction_max_general.F90": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "kernels_loop_reduction_max_general.c": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "kernels_loop_reduction_max_loop.F90": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "kernels_loop_reduction_max_loop.c": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "kernels_loop_reduction_max_vector_loop.F90": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "kernels_loop_reduction_max_vector_loop.c": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "kernels_loop_reduction_min_general.F90": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "kernels_loop_reduction_min_general.c": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "kernels_loop_reduction_min_loop.F90": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "kernels_loop_reduction_min_loop.c": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "kernels_loop_reduction_min_vector_loop.F90": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "kernels_loop_reduction_min_vector_loop.c": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "kernels_loop_reduction_multiply_general.F90": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "kernels_loop_reduction_multiply_general.c": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "kernels_loop_reduction_multiply_loop.F90": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "kernels_loop_reduction_multiply_loop.c": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "kernels_loop_reduction_multiply_vector_loop.F90": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "kernels_loop_reduction_multiply_vector_loop.c": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "kernels_loop_reduction_or_general.F90": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "kernels_loop_reduction_or_general.c": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "kernels_loop_reduction_or_loop.F90": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "kernels_loop_reduction_or_loop.c": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "kernels_loop_reduction_or_vector_loop.F90": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "kernels_loop_reduction_or_vector_loop.c": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "kernels_loop_seq.F90": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "kernels_loop_seq.c": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "kernels_loop_tile.F90": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "kernels_loop_tile.c": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        },
                        "2": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "kernels_loop_vector_blocking.F90": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "kernels_loop_vector_blocking.c": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "kernels_loop_worker_blocking.F90": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "kernels_loop_worker_blocking.c": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "kernels_num_gangs.F90": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "kernels_num_gangs.c": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "kernels_num_workers.F90": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "kernels_num_workers.c": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "kernels_present.F90": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "kernels_present.c": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "kernels_scalar_default_copy.F90": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "kernels_scalar_default_copy.c": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "kernels_vector_length.F90": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "kernels_vector_length.c": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "kernels_wait.F90": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "kernels_wait.c": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "loop_collapse.F90": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        },
                        "2": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "loop_collapse.c": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        },
                        "2": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "loop_no_collapse.F90": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        },
                        "2": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "loop_no_collapse_default.c": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "parallel.F90": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "parallel.c": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "parallel_async.F90": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "parallel_async.c": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "parallel_copy.F90": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "parallel_copy.c": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "parallel_copyin.F90": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "parallel_copyin.c": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        },
                        "2": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "parallel_copyout.F90": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        },
                        "2": {
                            "result": "Pass",
                            "run_index": 0
                        },
                        "3": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "parallel_copyout.c": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        },
                        "2": {
                            "result": "Pass",
                            "run_index": 0
                        },
                        "3": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "parallel_create.F90": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "parallel_create.c": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "parallel_default_copy.F90": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        },
                        "2": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "parallel_default_copy.c": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        },
                        "2": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "parallel_default_present.F90": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "parallel_default_present.c": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "parallel_deviceptr.c": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "parallel_firstprivate.F90": {
                        "1": {
                            "result": "Runtime Failure",
                            "run_index": 0
                        },
                        "2": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "parallel_firstprivate.c": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        },
                        "2": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "parallel_if.F90": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        },
                        "2": {
                            "result": "Pass",
                            "run_index": 0
                        },
                        "3": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "parallel_if.c": {
                        "1": {
                            "result": "Pass",
                            "run_index": 2
                        },
                        "2": {
                            "result": "Unknown Section Result",
                            "run_index": -1
                        },
                        "3": {
                            "result": "Pass",
                            "run_index": 2
                        }
                    },
                    "parallel_loop.F90": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        },
                        "2": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "parallel_loop.c": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        },
                        "2": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "parallel_loop_async.F90": {
                        "1": {
                            "result": "Compilation Failure",
                            "run_index": 0
                        }
                    },
                    "parallel_loop_async.c": {
                        "1": {
                            "result": "Compilation Failure",
                            "run_index": 0
                        }
                    },
                    "parallel_loop_auto.F90": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "parallel_loop_auto.c": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        },
                        "2": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "parallel_loop_gang.F90": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "parallel_loop_gang.c": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "parallel_loop_reduction_add_general.F90": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "parallel_loop_reduction_add_general.c": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        },
                        "2": {
                            "result": "Excluded From Run",
                            "run_index": -1
                        }
                    },
                    "parallel_loop_reduction_add_general_type_check_pt1.c": {
                        "1": {
                            "result": "Runtime Failure",
                            "run_index": 9
                        },
                        "2": {
                            "result": "Pass",
                            "run_index": 9
                        },
                        "3": {
                            "result": "Pass",
                            "run_index": 9
                        },
                        "4": {
                            "result": "Pass",
                            "run_index": 9
                        },
                        "5": {
                            "result": "Pass",
                            "run_index": 9
                        },
                        "6": {
                            "result": "Pass",
                            "run_index": 9
                        },
                        "7": {
                            "result": "Pass",
                            "run_index": 9
                        },
                        "8": {
                            "result": "Pass",
                            "run_index": 9
                        }
                    },
                    "parallel_loop_reduction_add_general_type_check_pt2.c": {
                        "1": {
                            "result": "Pass",
                            "run_index": 9
                        },
                        "2": {
                            "result": "Pass",
                            "run_index": 9
                        },
                        "3": {
                            "result": "Pass",
                            "run_index": 9
                        },
                        "4": {
                            "result": "Pass",
                            "run_index": 9
                        },
                        "5": {
                            "result": "Pass",
                            "run_index": 9
                        },
                        "6": {
                            "result": "Pass",
                            "run_index": 9
                        },
                        "7": {
                            "result": "Pass",
                            "run_index": 9
                        },
                        "8": {
                            "result": "Runtime Failure",
                            "run_index": 9
                        }
                    },
                    "parallel_loop_reduction_add_general_type_check_pt3.c": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        },
                        "2": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "parallel_loop_reduction_add_loop.F90": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "parallel_loop_reduction_add_loop.c": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        },
                        "2": {
                            "result": "Excluded From Run",
                            "run_index": -1
                        }
                    },
                    "parallel_loop_reduction_add_loop_type_check_pt1.c": {
                        "1": {
                            "result": "Runtime Failure",
                            "run_index": 0
                        },
                        "2": {
                            "result": "Runtime Failure",
                            "run_index": 0
                        }
                    },
                    "parallel_loop_reduction_add_vector_loop.F90": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "parallel_loop_reduction_add_vector_loop.c": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        },
                        "2": {
                            "result": "Excluded From Run",
                            "run_index": -1
                        }
                    },
                    "parallel_loop_reduction_and_general.F90": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "parallel_loop_reduction_and_general.c": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        },
                        "2": {
                            "result": "Excluded From Run",
                            "run_index": -1
                        }
                    },
                    "parallel_loop_reduction_and_loop.F90": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "parallel_loop_reduction_and_loop.c": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        },
                        "2": {
                            "result": "Excluded From Run",
                            "run_index": -1
                        }
                    },
                    "parallel_loop_reduction_and_vector_loop.F90": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "parallel_loop_reduction_and_vector_loop.c": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        },
                        "2": {
                            "result": "Excluded From Run",
                            "run_index": -1
                        }
                    },
                    "parallel_loop_reduction_bitand_general.F90": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "parallel_loop_reduction_bitand_general.c": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        },
                        "2": {
                            "result": "Excluded From Run",
                            "run_index": -1
                        }
                    },
                    "parallel_loop_reduction_bitand_loop.F90": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "parallel_loop_reduction_bitand_loop.c": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        },
                        "2": {
                            "result": "Excluded From Run",
                            "run_index": -1
                        }
                    },
                    "parallel_loop_reduction_bitand_vector_loop.F90": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "parallel_loop_reduction_bitand_vector_loop.c": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        },
                        "2": {
                            "result": "Excluded From Run",
                            "run_index": -1
                        }
                    },
                    "parallel_loop_reduction_bitor_general.F90": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "parallel_loop_reduction_bitor_general.c": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        },
                        "2": {
                            "result": "Excluded From Run",
                            "run_index": -1
                        }
                    },
                    "parallel_loop_reduction_bitor_loop.F90": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "parallel_loop_reduction_bitor_loop.c": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        },
                        "2": {
                            "result": "Excluded From Run",
                            "run_index": -1
                        }
                    },
                    "parallel_loop_reduction_bitor_vector_loop.F90": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "parallel_loop_reduction_bitor_vector_loop.c": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        },
                        "2": {
                            "result": "Excluded From Run",
                            "run_index": -1
                        }
                    },
                    "parallel_loop_reduction_bitxor_general.F90": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "parallel_loop_reduction_bitxor_general.c": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        },
                        "2": {
                            "result": "Excluded From Run",
                            "run_index": -1
                        }
                    },
                    "parallel_loop_reduction_bitxor_loop.F90": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "parallel_loop_reduction_bitxor_loop.c": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        },
                        "2": {
                            "result": "Excluded From Run",
                            "run_index": -1
                        }
                    },
                    "parallel_loop_reduction_bitxor_vector_loop.F90": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "parallel_loop_reduction_bitxor_vector_loop.c": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        },
                        "2": {
                            "result": "Excluded From Run",
                            "run_index": -1
                        }
                    },
                    "parallel_loop_reduction_max_general.F90": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "parallel_loop_reduction_max_general.c": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        },
                        "2": {
                            "result": "Excluded From Run",
                            "run_index": -1
                        }
                    },
                    "parallel_loop_reduction_max_loop.F90": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "parallel_loop_reduction_max_loop.c": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        },
                        "2": {
                            "result": "Excluded From Run",
                            "run_index": -1
                        }
                    },
                    "parallel_loop_reduction_max_vector_loop.F90": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "parallel_loop_reduction_max_vector_loop.c": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        },
                        "2": {
                            "result": "Excluded From Run",
                            "run_index": -1
                        }
                    },
                    "parallel_loop_reduction_min_general.F90": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "parallel_loop_reduction_min_general.c": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        },
                        "2": {
                            "result": "Excluded From Run",
                            "run_index": -1
                        }
                    },
                    "parallel_loop_reduction_min_loop.F90": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "parallel_loop_reduction_min_loop.c": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        },
                        "2": {
                            "result": "Excluded From Run",
                            "run_index": -1
                        }
                    },
                    "parallel_loop_reduction_min_vector_loop.F90": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "parallel_loop_reduction_min_vector_loop.c": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        },
                        "2": {
                            "result": "Excluded From Run",
                            "run_index": -1
                        }
                    },
                    "parallel_loop_reduction_multiply_general.F90": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "parallel_loop_reduction_multiply_general.c": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        },
                        "2": {
                            "result": "Excluded From Run",
                            "run_index": -1
                        }
                    },
                    "parallel_loop_reduction_multiply_loop.F90": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "parallel_loop_reduction_multiply_loop.c": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        },
                        "2": {
                            "result": "Excluded From Run",
                            "run_index": -1
                        }
                    },
                    "parallel_loop_reduction_multiply_vector_loop.F90": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "parallel_loop_reduction_multiply_vector_loop.c": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        },
                        "2": {
                            "result": "Excluded From Run",
                            "run_index": -1
                        },
                        "3": {
                            "result": "Excluded From Run",
                            "run_index": -1
                        }
                    },
                    "parallel_loop_reduction_or_general.F90": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "parallel_loop_reduction_or_general.c": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        },
                        "2": {
                            "result": "Excluded From Run",
                            "run_index": -1
                        }
                    },
                    "parallel_loop_reduction_or_loop.F90": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "parallel_loop_reduction_or_loop.c": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "parallel_loop_reduction_or_vector_loop.F90": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "parallel_loop_reduction_or_vector_loop.c": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "parallel_loop_seq.F90": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "parallel_loop_seq.c": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "parallel_loop_tile.F90": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "parallel_loop_tile.c": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        },
                        "2": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "parallel_loop_vector.F90": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "parallel_loop_vector.c": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "parallel_loop_vector_blocking.F90": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "parallel_loop_vector_blocking.c": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "parallel_loop_worker.F90": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "parallel_loop_worker.c": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "parallel_loop_worker_blocking.F90": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "parallel_loop_worker_blocking.c": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "parallel_present.F90": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "parallel_present.c": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "parallel_private.F90": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "parallel_private.c": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "parallel_reduction.F90": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "parallel_reduction.c": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "parallel_scalar_default_firstprivate.F90": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "parallel_scalar_default_firstprivate.c": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "parallel_switch.F90": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "parallel_switch.c": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "parallel_wait.F90": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "parallel_wait.c": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "parallel_while_loop.F90": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "parallel_while_loop.c": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "routine_bind.c": {
                        "1": {
                            "result": "Runtime Failure",
                            "run_index": 5
                        },
                        "2": {
                            "result": "Runtime Failure",
                            "run_index": 5
                        },
                        "3": {
                            "result": "Runtime Failure",
                            "run_index": 5
                        },
                        "4": {
                            "result": "Runtime Failure",
                            "run_index": 5
                        }
                    },
                    "routine_gang.c": {
                        "1": {
                            "result": "Compilation Failure",
                            "run_index": 1
                        },
                        "10": {
                            "result": "Pass",
                            "run_index": 11
                        },
                        "2": {
                            "result": "Pass",
                            "run_index": 11
                        },
                        "3": {
                            "result": "Pass",
                            "run_index": 11
                        },
                        "4": {
                            "result": "Pass",
                            "run_index": 11
                        },
                        "5": {
                            "result": "Pass",
                            "run_index": 11
                        },
                        "6": {
                            "result": "Pass",
                            "run_index": 11
                        },
                        "7": {
                            "result": "Pass",
                            "run_index": 11
                        },
                        "8": {
                            "result": "Pass",
                            "run_index": 11
                        },
                        "9": {
                            "result": "Pass",
                            "run_index": 11
                        }
                    },
                    "routine_nohost.c": {
                        "1": {
                            "result": "Compilation Failure",
                            "run_index": 0
                        }
                    },
                    "routine_seq.c": {
                        "1": {
                            "result": "Pass",
                            "run_index": 5
                        },
                        "2": {
                            "result": "Pass",
                            "run_index": 5
                        },
                        "3": {
                            "result": "Pass",
                            "run_index": 5
                        },
                        "4": {
                            "result": "Pass",
                            "run_index": 5
                        }
                    },
                    "routine_vector.c": {
                        "1": {
                            "result": "Pass",
                            "run_index": 7
                        },
                        "2": {
                            "result": "Pass",
                            "run_index": 7
                        },
                        "3": {
                            "result": "Pass",
                            "run_index": 7
                        },
                        "4": {
                            "result": "Pass",
                            "run_index": 7
                        },
                        "5": {
                            "result": "Pass",
                            "run_index": 7
                        },
                        "6": {
                            "result": "Pass",
                            "run_index": 7
                        }
                    },
                    "routine_worker.c": {
                        "1": {
                            "result": "Pass",
                            "run_index": 9
                        },
                        "2": {
                            "result": "Pass",
                            "run_index": 9
                        },
                        "3": {
                            "result": "Pass",
                            "run_index": 9
                        },
                        "4": {
                            "result": "Pass",
                            "run_index": 9
                        },
                        "5": {
                            "result": "Pass",
                            "run_index": 9
                        },
                        "6": {
                            "result": "Pass",
                            "run_index": 9
                        },
                        "7": {
                            "result": "Pass",
                            "run_index": 9
                        },
                        "8": {
                            "result": "Pass",
                            "run_index": 9
                        }
                    },
                    "serial.F90": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "serial.c": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "serial_async.F90": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "serial_async.c": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "serial_copy.F90": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "serial_copy.c": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "serial_copyin.F90": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        },
                        "2": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "serial_copyin.c": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        },
                        "2": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "serial_copyout.F90": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        },
                        "2": {
                            "result": "Pass",
                            "run_index": 0
                        },
                        "3": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "serial_copyout.c": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        },
                        "2": {
                            "result": "Pass",
                            "run_index": 0
                        },
                        "3": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "serial_create.F90": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "serial_create.c": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "serial_default_copy.F90": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        },
                        "2": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "serial_default_copy.c": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        },
                        "2": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "serial_default_present.F90": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "serial_default_present.c": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "serial_deviceptr.c": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "serial_firstprivate.F90": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        },
                        "2": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "serial_firstprivate.c": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        },
                        "2": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "serial_if.F90": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        },
                        "2": {
                            "result": "Pass",
                            "run_index": 0
                        },
                        "3": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "serial_if.c": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        },
                        "2": {
                            "result": "Pass",
                            "run_index": 0
                        },
                        "3": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "serial_loop.F90": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "serial_loop.c": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        },
                        "2": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "serial_loop_async.F90": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "serial_loop_async.c": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "serial_loop_auto.F90": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "serial_loop_auto.c": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        },
                        "2": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "serial_loop_gang.F90": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "serial_loop_gang.c": {
                        "1": {
                            "result": "Compilation Failure",
                            "run_index": 0
                        }
                    },
                    "serial_loop_reduction_add_general.F90": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "serial_loop_reduction_add_general.c": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "serial_loop_reduction_add_loop.F90": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "serial_loop_reduction_add_loop.c": {
                        "1": {
                            "result": "Compilation Failure",
                            "run_index": 0
                        }
                    },
                    "serial_loop_reduction_add_vector_loop.F90": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "serial_loop_reduction_add_vector_loop.c": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "serial_loop_reduction_and_general.F90": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "serial_loop_reduction_and_general.c": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "serial_loop_reduction_and_loop.F90": {
                        "1": {
                            "result": "Runtime Failure",
                            "run_index": 0
                        }
                    },
                    "serial_loop_reduction_and_loop.c": {
                        "1": {
                            "result": "Compilation Failure",
                            "run_index": 0
                        }
                    },
                    "serial_loop_reduction_and_vector_loop.F90": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "serial_loop_reduction_and_vector_loop.c": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "serial_loop_reduction_bitand_general.F90": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "serial_loop_reduction_bitand_general.c": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "serial_loop_reduction_bitand_loop.F90": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "serial_loop_reduction_bitand_loop.c": {
                        "1": {
                            "result": "Compilation Failure",
                            "run_index": 0
                        }
                    },
                    "serial_loop_reduction_bitand_vector_loop.F90": {
                        "1": {
                            "result": "Compilation Failure",
                            "run_index": 0
                        }
                    },
                    "serial_loop_reduction_bitand_vector_loop.c": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "serial_loop_reduction_bitor_general.F90": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "serial_loop_reduction_bitor_general.c": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "serial_loop_reduction_bitor_loop.F90": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "serial_loop_reduction_bitor_loop.c": {
                        "1": {
                            "result": "Compilation Failure",
                            "run_index": 0
                        }
                    },
                    "serial_loop_reduction_bitor_vector_loop.F90": {
                        "1": {
                            "result": "Compilation Failure",
                            "run_index": 0
                        }
                    },
                    "serial_loop_reduction_bitor_vector_loop.c": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "serial_loop_reduction_bitxor_general.F90": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "serial_loop_reduction_bitxor_general.c": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "serial_loop_reduction_bitxor_loop.F90": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "serial_loop_reduction_bitxor_loop.c": {
                        "1": {
                            "result": "Compilation Failure",
                            "run_index": 0
                        }
                    },
                    "serial_loop_reduction_bitxor_vector_loop.F90": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "serial_loop_reduction_bitxor_vector_loop.c": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "serial_loop_reduction_max_general.F90": {
                        "1": {
                            "result": "Compilation Failure",
                            "run_index": 0
                        }
                    },
                    "serial_loop_reduction_max_general.c": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "serial_loop_reduction_max_loop.F90": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "serial_loop_reduction_max_loop.c": {
                        "1": {
                            "result": "Compilation Failure",
                            "run_index": 0
                        }
                    },
                    "serial_loop_reduction_max_vector_loop.F90": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "serial_loop_reduction_max_vector_loop.c": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "serial_loop_reduction_min_general.F90": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "serial_loop_reduction_min_general.c": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "serial_loop_reduction_min_loop.F90": {
                        "1": {
                            "result": "Compilation Failure",
                            "run_index": 0
                        }
                    },
                    "serial_loop_reduction_min_loop.c": {
                        "1": {
                            "result": "Compilation Failure",
                            "run_index": 0
                        }
                    },
                    "serial_loop_reduction_min_vector_loop.F90": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "serial_loop_reduction_min_vector_loop.c": {
                        "1": {
                            "result": "Compilation Failure",
                            "run_index": 0
                        }
                    },
                    "serial_loop_reduction_multiply_general.F90": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "serial_loop_reduction_multiply_general.c": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "serial_loop_reduction_multiply_loop.F90": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "serial_loop_reduction_multiply_loop.c": {
                        "1": {
                            "result": "Compilation Failure",
                            "run_index": 0
                        }
                    },
                    "serial_loop_reduction_multiply_vector_loop.F90": {
                        "1": {
                            "result": "Compilation Failure",
                            "run_index": 0
                        }
                    },
                    "serial_loop_reduction_multiply_vector_loop.c": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "serial_loop_reduction_or_general.F90": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "serial_loop_reduction_or_general.c": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "serial_loop_reduction_or_loop.F90": {
                        "1": {
                            "result": "Compilation Failure",
                            "run_index": 0
                        }
                    },
                    "serial_loop_reduction_or_loop.c": {
                        "1": {
                            "result": "Compilation Failure",
                            "run_index": 0
                        }
                    },
                    "serial_loop_reduction_or_vector_loop.F90": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "serial_loop_reduction_or_vector_loop.c": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "serial_loop_seq.F90": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "serial_loop_seq.c": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "serial_loop_tile.F90": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "serial_loop_tile.c": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        },
                        "2": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "serial_loop_vector.F90": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "serial_loop_vector.c": {
                        "1": {
                            "result": "Compilation Failure",
                            "run_index": 0
                        }
                    },
                    "serial_loop_vector_blocking.F90": {
                        "1": {
                            "result": "Runtime Failure",
                            "run_index": 0
                        }
                    },
                    "serial_loop_vector_blocking.c": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "serial_loop_worker.F90": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "serial_loop_worker.c": {
                        "1": {
                            "result": "Compilation Failure",
                            "run_index": 0
                        }
                    },
                    "serial_loop_worker_blocking.F90": {
                        "1": {
                            "result": "Runtime Failure",
                            "run_index": 0
                        }
                    },
                    "serial_loop_worker_blocking.c": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "serial_present.F90": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "serial_present.c": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "serial_private.F90": {
                        "1": {
                            "result": "Runtime Failure",
                            "run_index": 0
                        }
                    },
                    "serial_private.c": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "serial_reduction.F90": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "serial_reduction.c": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "serial_scalar_default_firstprivate.F90": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "serial_scalar_default_firstprivate.c": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "serial_switch.F90": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "serial_switch.c": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "serial_wait.F90": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "serial_wait.c": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "serial_while_loop.F90": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "serial_while_loop.c": {
                        "1": {
                            "result": "Compilation Failure",
                            "run_index": 0
                        }
                    },
                    "set_default_async.F90": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "set_default_async.c": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "set_device_num.F90": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "set_device_num.c": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "set_device_type.F90": {
                        "1": {
                            "result": "Compilation Failure",
                            "run_index": 0
                        }
                    },
                    "set_device_type.c": {
                        "1": {
                            "result": "Compilation Failure",
                            "run_index": 0
                        }
                    },
                    "shutdown.F90": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "shutdown.c": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "shutdown_device_num.F90": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "shutdown_device_num.c": {
                        "1": {
                            "result": "Pass",
                            "run_index": 0
                        }
                    },
                    "shutdown_device_type.F90": {
                        "1": {
                            "result": "Compilation Failure",
                            "run_index": 0
                        }
                    },
                    "shutdown_device_type.c": {
                        "1": {
                            "result": "Compilation Failure",
                            "run_index": 0
                        }
                    },
                    "shutdown_device_type_num.F90": {
                        "1": {
                            "result": "Compilation Failure",
                            "run_index": 0
                        }
                    },
                    "shutdown_device_type_num.c": {
                        "1": {
                            "result": "Compilation Failure",
                            "run_index": 0
                        }
                    },
                    "template.F90": {
                        "1": {
                            "result": "Runtime Failure",
                            "run_index": 0
                        }
                    }
                }
            }
        }
    },
    "systems": [
        {
            "id": 1,
            "machine": "x86_64",
            "name": null,
            "node": "mini-wheats",
            "processor": "x86_64",
            "release": "4.15.0-144-generic",
            "version": "#148-Ubuntu SMP Sat May 8 02:33:43 UTC 2021"
        }
    ],
    "testsuites": [
        {
            "acc_async_test.F90": {
                "num tests": 3,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:runtime,async,construct-independent,V:2.0-2.7\n      LOGICAL FUNCTION test1()\n        USE OPENACC\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x, y !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT):: a, b, c, d, e !Data\n        INTEGER :: errors\n        errors = 0\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n        CALL RANDOM_NUMBER(a)\n        CALL RANDOM_NUMBER(b)\n        CALL RANDOM_NUMBER(d)\n        c = 0\n        e = 0\n        \n        !$acc enter data copyin(a(1:LOOPCOUNT), b(1:LOOPCOUNT)) create(c(1:LOOPCOUNT)) async(1)\n        !$acc enter data copyin(d(1:LOOPCOUNT)) create(e(1:LOOPCOUNT)) async(2)\n        !$acc parallel present(a(1:LOOPCOUNT), b(1:LOOPCOUNT), c(1:LOOPCOUNT)) async(1)\n          !$acc loop\n          DO x = 1, LOOPCOUNT\n            c(x) = a(x) + b(x)\n          END DO\n        !$acc end parallel\n        !$acc parallel present(c(1:LOOPCOUNT), d(1:LOOPCOUNT), e(1:LOOPCOUNT)) async(1) wait(2)\n          !$acc loop\n          DO x = 1, LOOPCOUNT\n            e(x) = c(x) + d(x)\n          END DO\n        !$acc end parallel\n        !$acc exit data copyout(e(1:LOOPCOUNT)) async(1)\n\n\n        DO WHILE (acc_async_test(1) .eqv. .FALSE.)\n          CONTINUE\n        END DO\n\n        DO x = 1, LOOPCOUNT\n          IF (abs(e(x) - (a(x) + b(x) + d(x))) .GT. PRECISION) THEN\n            errors = errors + 1\n          END IF\n        END DO\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n      LOGICAL :: test1\n#endif\n#ifndef T1\n      DO testrun = 1, NUM_TEST_CALLS\n        failed = failed .or. test1()\n      END DO\n      IF (failed) THEN\n        failcode = failcode + 2 ** 0\n        failed = .FALSE.\n      END IF\n#endif\n",
                        "tags": [
                            "runtime",
                            "async",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "2": {
                        "content": "#ifndef T2\n!T2:async,runtime,construct-independent,V:1.0-2.7\n      LOGICAL FUNCTION test2()\n        USE OPENACC\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x, y\n        REAL(8),DIMENSION(LOOPCOUNT):: a, b, c, d, e\n        INTEGER :: errors\n        errors = 0\n        \n        !Initialization\n        CALL RANDOM_SEED()\n        CALL RANDOM_NUMBER(a)\n        CALL RANDOM_NUMBER(b)\n        CALL RANDOM_NUMBER(d)\n        c = 0\n        e = 0\n\n        !$acc data copyin(a(1:LOOPCOUNT), b(1:LOOPCOUNT), d(1:LOOPCOUNT)) copyout(c(1:LOOPCOUNT), e(1:LOOPCOUNT))\n          !$acc parallel present(a(1:LOOPCOUNT), b(1:LOOPCOUNT), c(1:LOOPCOUNT)) async(1)\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              c(x) = a(x) + b(x)\n            END DO\n          !$acc end parallel\n          !$acc parallel present(c(1:LOOPCOUNT), d(1:LOOPCOUNT), e(1:LOOPCOUNT)) async(1)\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              e(x) = c(x) + d(x)\n            END DO\n          !$acc end parallel\n          DO WHILE (acc_async_test(1) .eqv. .FALSE.)\n            CONTINUE\n          END DO\n        !$acc end data\n\n        DO x = 1, LOOPCOUNT\n          IF (abs(e(x) - (a(x) + b(x) + d(x))) .GT. PRECISION) THEN\n            errors = errors + 1\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test2 = .FALSE.\n        ELSE\n          test2 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T2\n      LOGICAL :: test2\n#endif\n#ifndef T2\n      DO testrun = 1, NUM_TEST_CALLS\n        failed = failed .or. test2()\n      END DO\n      IF (failed) THEN\n        failcode = failcode + 2 ** 1\n        failed = .FALSE.\n      END IF\n#endif\n",
                        "tags": [
                            "async",
                            "runtime",
                            "construct-independent"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "3": {
                        "content": "#ifndef T3\n!T3:runtime,async,construct-independent,V:2.5-2.7\n      LOGICAL FUNCTION test3()\n        USE OPENACC\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x, y\n        REAL(8),DIMENSION(LOOPCOUNT):: a, b, c, d, e\n        INTEGER :: errors, async_val\n        INTEGER :: acc_get_default_async\n        async_val = acc_get_default_async()\n        errors = 0\n\n        !Initialization\n        CALL RANDOM_SEED()\n        CALL RANDOM_NUMBER(a)\n        CALL RANDOM_NUMBER(b)\n        CALL RANDOM_NUMBER(d)\n        c = 0\n        e = 0\n\n        !$acc data copyin(a(1:LOOPCOUNT), b(1:LOOPCOUNT), d(1:LOOPCOUNT)) copyout(c(1:LOOPCOUNT), e(1:LOOPCOUNT))\n          !$acc parallel present(a(1:LOOPCOUNT), b(1:LOOPCOUNT), c(1:LOOPCOUNT)) async\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              c(x) = a(x) + b(x)\n            END DO\n          !$acc end parallel\n          !$acc parallel present(c(1:LOOPCOUNT), d(1:LOOPCOUNT), e(1:LOOPCOUNT)) async\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              e(x) = c(x) + d(x)\n            END DO\n          !$acc end parallel\n          DO WHILE (acc_async_test(async_val) .eqv. .FALSE.)\n            CONTINUE\n          END DO\n        !$acc end data\n\n        DO x = 1, LOOPCOUNT\n          IF (abs(e(x) - (a(x) + b(x) + d(x))) .gt. PRECISION) THEN\n            errors = errors + 1\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test3 = .FALSE.\n        ELSE\n          test3 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T3\n      LOGICAL :: test3\n#endif\n#ifndef T3\n      DO testrun = 1, NUM_TEST_CALLS\n        failed = failed .or. test3()\n      END DO\n      IF (failed) THEN\n        failcode = failcode + 2 ** 2\n        failed = .FALSE.\n      END IF\n#endif\n",
                        "tags": [
                            "runtime",
                            "async",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "acc_async_test.c": {
                "num tests": 3,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:async,runtime,construct-independent,V:2.0-2.7\nint test1(){\n    int err = 0;\n    real_t *a = (real_t *)malloc(n * sizeof(real_t));\n    real_t *b = (real_t *)malloc(n * sizeof(real_t));\n    real_t *c = (real_t *)malloc(n * sizeof(real_t));\n    real_t *d = (real_t *)malloc(n * sizeof(real_t));\n    real_t *e = (real_t *)malloc(n * sizeof(real_t));\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n        c[x] = 0;\n        d[x] = rand() / (real_t)(RAND_MAX / 10);\n        e[x] = 0;\n    }\n\n    #pragma acc enter data copyin(a[0:n], b[0:n]) create(c[0:n]) async(1)\n    #pragma acc enter data copyin(d[0:n]) create(e[0:n]) async(2)\n    #pragma acc parallel present(a[0:n], b[0:n], c[0:n]) async(1)\n    {\n        #pragma acc loop\n        for (int x = 0; x < n; ++x){\n            c[x] = a[x] + b[x];\n        }\n    }\n    #pragma acc parallel present(c[0:n], d[0:n], e[0:n]) async(1) wait(2)\n    {\n        #pragma acc loop\n        for (int x = 0; x < n; ++x){\n            e[x] = c[x] + d[x];\n        }\n    }\n    #pragma acc exit data copyout(e[0:n]) async(1)\n\n    while (!acc_async_test(1));\n    for (int x = 0; x < n; ++x){\n        if (fabs(e[x] - (a[x] + b[x] + d[x])) > PRECISION){\n            err += 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "async",
                            "runtime",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "2": {
                        "content": "#ifndef T2\n//T2:async,runtime,construct-independent,V:1.0-2.7\nint test2(){\n    int err = 0;\n    real_t *a = (real_t *)malloc(n * sizeof(real_t));\n    real_t *b = (real_t *)malloc(n * sizeof(real_t));\n    real_t *c = (real_t *)malloc(n * sizeof(real_t));\n    real_t *d = (real_t *)malloc(n * sizeof(real_t));\n    real_t *e = (real_t *)malloc(n * sizeof(real_t));\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n        c[x] = 0;\n        d[x] = rand() / (real_t)(RAND_MAX / 10);\n        e[x] = 0;\n    }\n    #pragma acc data copyin(a[0:n], b[0:n], d[0:n]) create(c[0:n]) copyout(e[0:n])\n    {\n        #pragma acc parallel present(a[0:n], b[0:n], c[0:n]) async(1)\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x) {\n                c[x] = a[x] + b[x];\n            }\n        }\n        #pragma acc parallel present(c[0:n], d[0:n], e[0:n]) async(1)\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x) {\n                e[x] = c[x] + d[x];\n            }\n        }\n        while (!acc_async_test(1));\n    }\n\n    for (int x = 0; x < n; ++x) {\n        if (fabs(e[x] - (a[x] + b[x] + d[x])) > PRECISION) {\n            err += 1;\n        }\n    }\n    return err;\n}\n#endif\n#ifndef T2\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test2();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 1);\n    }\n#endif\n",
                        "tags": [
                            "async",
                            "runtime",
                            "construct-independent"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "3": {
                        "content": "#ifndef T3\n//T3:async,runtime,construct-independent,V:2.5-2.7\nint test3() {\n    int err = 0;\n    real_t* a = (real_t*)malloc(n * sizeof(real_t));\n    real_t* b = (real_t*)malloc(n * sizeof(real_t));\n    real_t* c = (real_t*)malloc(n * sizeof(real_t));\n    real_t* d = (real_t*)malloc(n * sizeof(real_t));\n    real_t* e = (real_t*)malloc(n * sizeof(real_t));\n    int async_val = acc_get_default_async();\n\n    for (int x = 0; x < n; ++x) {\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n        c[x] = 0;\n        d[x] = rand() / (real_t)(RAND_MAX / 10);\n        e[x] = 0;\n    }\n    #pragma acc data copyin(a[0:n], b[0:n], d[0:n]) create(c[0:n]) copyout(e[0:n])\n    {\n        #pragma acc parallel present(a[0:n], b[0:n], c[0:n]) async\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x) {\n                c[x] = a[x] + b[x];\n            }\n        }\n        #pragma acc parallel present(c[0:n], d[0:n], e[0:n]) async\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x) {\n                e[x] = c[x] + d[x];\n            }\n        }\n        while (!acc_async_test(async_val));\n    }\n\n    for (int x = 0; x < n; ++x) {\n        if (fabs(e[x] - (a[x] + b[x] + d[x])) > PRECISION) {\n            err += 1;\n        }\n    }\n    return err;\n}\n#endif\n#ifndef T3\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x) {\n        failed = failed + test3();\n    }\n    if (failed != 0) {\n        failcode = failcode + (1 << 2);\n    }\n#endif\n",
                        "tags": [
                            "async",
                            "runtime",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "acc_async_test_all.F90": {
                "num tests": 3,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:runtime,async,construct-independent,update,V:2.0-2.7\n      LOGICAL FUNCTION test1()\n        USE OPENACC\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x, y !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT, 10):: a, b, c, d, e !Data\n        INTEGER :: errors\n        errors = 0\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n        CALL RANDOM_NUMBER(a)\n        CALL RANDOM_NUMBER(b)\n        CALL RANDOM_NUMBER(d)\n        c = 0\n        e = 0\n\n        !$acc enter data create(a(1:LOOPCOUNT,1:10), b(1:LOOPCOUNT,1:10), c(1:LOOPCOUNT,1:10), d(1:LOOPCOUNT,1:10), e(1:LOOPCOUNT,1:10))\n        DO y = 1, 10\n          !$acc update device(a(1:LOOPCOUNT,y:y), b(1:LOOPCOUNT,y:y), d(1:LOOPCOUNT,y:y)) async(y)\n          !$acc parallel present(a(1:LOOPCOUNT,y:y), b(1:LOOPCOUNT,y:y), c(1:LOOPCOUNT,y:y)) async(y)\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              c(x, y) = a(x, y) + b(x, y)\n            END DO\n          !$acc end parallel\n          !$acc parallel present(c(1:LOOPCOUNT,y:y), d(1:LOOPCOUNT,y:y),e(1:LOOPCOUNT,y:y)) async(y)\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              e(x, y) = c(x, y) + d(x, y)\n            END DO\n          !$acc end parallel\n          !$acc update host(e(1:LOOPCOUNT,y:y)) async(y)\n        END DO\n\n        DO WHILE (acc_async_test_all() .eqv. .FALSE.)\n          CONTINUE\n        END DO\n\n        DO y = 1, 10\n          DO x = 1, LOOPCOUNT\n            IF (abs(e(x, y) - (a(x, y) + b(x, y) + d(x, y))) .GT. PRECISION) THEN\n              errors = errors + 1\n            END IF\n          END DO\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n      LOGICAL :: test1\n#endif\n#ifndef T1\n      DO testrun = 1, NUM_TEST_CALLS\n        failed = failed .or. test1()\n      END DO\n      IF (failed) THEN\n        failcode = failcode + 2 ** 0\n        failed = .FALSE.\n      END IF\n#endif\n",
                        "tags": [
                            "runtime",
                            "async",
                            "construct-independent",
                            "update"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "2": {
                        "content": "#ifndef T2\n!T2:async,runtime,construct-independent,V:1.0-2.7\n      LOGICAL FUNCTION test2()\n        USE OPENACC\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x, y !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT, 10):: a, b, c, d, e !Data\n        INTEGER :: errors\n        errors = 0\n\n        !Initialization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n        CALL RANDOM_NUMBER(a)\n        CALL RANDOM_NUMBER(b)\n        CALL RANDOM_NUMBER(d)\n        c = 0\n        e = 0\n\n        !$acc data copyin(a(1:LOOPCOUNT, 1:10), b(1:LOOPCOUNT,1:10), d(1:LOOPCOUNT, 1:10)) copyout(c(1:LOOPCOUNT, 1:10), e(1:LOOPCOUNT, 1:10))\n          DO x = 1, 10\n            !$acc parallel present(a(1:LOOPCOUNT, 1:10), b(1:LOOPCOUNT, 1:10), c(1:LOOPCOUNT, 1:10)) async(x)\n              !$acc loop\n              DO y = 1, LOOPCOUNT\n                c(y, x) = a(y, x) + b(y, x)\n              END DO\n            !$acc end parallel\n            !$acc parallel present(c(1:LOOPCOUNT, 1:10), d(1:LOOPCOUNT, 1:10), e(1:LOOPCOUNT, 1:10)) async(x)\n              !$acc loop\n              DO y = 1, LOOPCOUNT\n                e(y, x) = c(y, x) + d(y, x)\n              END DO\n            !$acc end parallel\n          END DO\n          DO WHILE (acc_async_test_all() .eqv. .FALSE.)\n            CONTINUE\n          END DO\n        !$acc end data\n\n        DO x = 1, 10\n          DO y = 1, LOOPCOUNT\n            IF (abs(e(y, x) - (a(y, x) + b(y, x) + d(y, x))) .gt. PRECISION) THEN\n              errors = errors + 1\n            END IF\n          END DO\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test2 = .FALSE.\n        ELSE\n          test2 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T2\n      LOGICAL :: test2\n#endif\n#ifndef T2\n      DO testrun = 1, NUM_TEST_CALLS\n        failed = failed .or. test2()\n      END DO\n      IF (failed) THEN\n        failcode = failcode + 2 ** 1\n        failed = .FALSE.\n      END IF\n#endif\n",
                        "tags": [
                            "async",
                            "runtime",
                            "construct-independent"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "3": {
                        "content": "#ifndef T3\n!T3:async,runtime,construct-independent,V:2.5-2.7\n      LOGICAL FUNCTION test3()\n        USE OPENACC\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x, y !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT, 10):: a, b, c, d, e !Data\n        INTEGER :: errors\n        errors = 0\n\n        !Initialization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n        CALL RANDOM_NUMBER(a)\n        CALL RANDOM_NUMBER(b)\n        CALL RANDOM_NUMBER(d)\n        c = 0\n        e = 0\n\n        !$acc data copyin(a(1:LOOPCOUNT, 1:10), b(1:LOOPCOUNT, 1:10), d(1:LOOPCOUNT, 1:10)) copyout(c(1:LOOPCOUNT, 1:10), e(1:LOOPCOUNT, 1:10))\n          DO x = 1, 10\n            CALL acc_set_default_async(x)\n            !$acc parallel present(a(1:LOOPCOUNT, 1:10), b(1:LOOPCOUNT, 1:10), c(1:LOOPCOUNT, 1:10)) async\n              !$acc loop\n              DO y = 1, LOOPCOUNT\n                c(y, x) = a(y, x) + b(y, x)\n              END DO\n            !$acc end parallel\n            !$acc parallel present(c(1:LOOPCOUNT, 1:10), d(1:LOOPCOUNT, 1:10), e(1:LOOPCOUNT, 1:10)) async\n              !$acc loop\n              DO y = 1, LOOPCOUNT\n                e(y, x) = c(y, x) + d(y, x)\n              END DO\n            !$acc end parallel\n          END DO\n          DO WHILE (acc_async_test_all() .eqv. .FALSE.)\n            CONTINUE\n          END DO\n        !$acc end data\n\n        DO x = 1, 10\n          DO y = 1, LOOPCOUNT\n            IF (abs(e(y, x) - (a(y, x) + b(y, x) + d(y, x))) .gt. PRECISION) THEN\n              errors = errors + 1\n            END IF\n          END DO\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test3 = .FALSE.\n        ELSE\n          test3 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T3\n      LOGICAL :: test3\n#endif\n#ifndef T3\n      DO testrun = 1, NUM_TEST_CALLS\n        failed = failed .or. test3()\n      END DO\n      IF (failed) THEN\n        failcode = failcode + 2 ** 2\n        failed = .FALSE.\n      END IF\n#endif\n",
                        "tags": [
                            "async",
                            "runtime",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "acc_async_test_all.c": {
                "num tests": 3,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:async,runtime,construct-independent,V:2.0-2.7\nint test1(){\n    int err = 0;\n    real_t **a = (real_t **)malloc(10 * sizeof(real_t*));\n    real_t **b = (real_t **)malloc(10 * sizeof(real_t*));\n    real_t **c = (real_t **)malloc(10 * sizeof(real_t*));\n    real_t **d = (real_t **)malloc(10 * sizeof(real_t*));\n    real_t **e = (real_t **)malloc(10 * sizeof(real_t*));\n\n    for (int x = 0; x < 10; ++x){\n        a[x] = (real_t *)malloc(n * sizeof(real_t));\n        b[x] = (real_t *)malloc(n * sizeof(real_t));\n        c[x] = (real_t *)malloc(n * sizeof(real_t));\n        d[x] = (real_t *)malloc(n * sizeof(real_t));\n        e[x] = (real_t *)malloc(n * sizeof(real_t));\n        for (int y = 0; y < n; ++y){\n            a[x][y] = rand() / (real_t)(RAND_MAX / 10);\n            b[x][y] = rand() / (real_t)(RAND_MAX / 10);\n            c[x][y] = 0;\n            d[x][y] = rand() / (real_t)(RAND_MAX / 10);\n            e[x][y] = 0;\n        }\n    }\n\n    #pragma acc enter data create(a[0:10][0:n], b[0:10][0:n], c[0:10][0:n], d[0:10][0:n], e[0:10][0:n])\n    for (int x = 0; x < 10; ++x){\n        #pragma acc update device(a[x:1][0:n], b[x:1][0:n], d[x:1][0:n]) async(x)\n        #pragma acc parallel present(a[x:1][0:n], b[x:1][0:n], c[x:1][0:n]) async(x)\n        {\n            #pragma acc loop\n            for (int y = 0; y < n; ++y){\n                c[x][y] = a[x][y] + b[x][y];\n            }\n        }\n        #pragma acc parallel present(c[x:1][0:n], d[x:1][0:n], e[x:1][0:n]) async(x)\n        {\n            #pragma acc loop\n            for (int y = 0; y < n; ++y){\n                e[x][y] = c[x][y] + d[x][y];\n            }\n        }\n        #pragma acc update host(e[x:1][0:n]) async(x)\n    }\n   \n    while(!acc_async_test_all());\n    for (int x = 0; x < 10; ++x){\n        for (int y = 0; y < n; ++y){\n            if (fabs(e[x][y] - (a[x][y] + b[x][y] + d[x][y])) > PRECISION){\n                err += 1;\n            }\n        }\n    }\n    #pragma acc exit data delete(a[0:10][0:n], b[0:10][0:n], c[0:10][0:n], d[0:10][0:n], e[0:10][0:n])\n    for (int x = 0; x < 10; ++x){\n        free(a[x]);\n        free(b[x]);\n        free(c[x]);\n        free(d[x]);\n        free(e[x]);\n    }\n    free(a);\n    free(b);\n    free(c);\n    free(d);\n    free(e);\n    \n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "async",
                            "runtime",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "2": {
                        "content": "#ifndef T2\n//T2:async,runtime,construct-independent,V:1.0-2.7\nint test2(){\n    int err = 0;\n    real_t *a = (real_t *)malloc(10 * n * sizeof(real_t));\n    real_t *b = (real_t *)malloc(10 * n * sizeof(real_t));\n    real_t *c = (real_t *)malloc(10 * n * sizeof(real_t));\n    real_t *d = (real_t *)malloc(10 * n * sizeof(real_t));\n    real_t *e = (real_t *)malloc(10 * n * sizeof(real_t));\n\n    for (int x = 0; x < 10*n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n        c[x] = 0;\n        d[x] = rand() / (real_t)(RAND_MAX / 10);\n        e[x] = 0;\n    }\n\n    #pragma acc data copyin(a[0:10*n], b[0:10*n], d[0:10*n]) copyout(c[0:10*n], e[0:10*n])\n    {\n        for (int x = 0; x < 10; ++x){\n            #pragma acc parallel present(a[0:10*n], b[0:10*n], c[0:10*n]) async(x)\n            {\n                #pragma acc loop\n                for (int y = 0; y < n; ++y){\n                    c[x * n + y] = a[x * n + y] + b[x * n + y];\n                }\n            }\n            #pragma acc parallel present(c[0:10*n], d[0:10*n], e[0:10*n]) async(x)\n            {\n                #pragma acc loop\n                for (int y = 0; y < n; ++y){\n                    e[x * n + y] = c[x * n + y] + d[x * n + y];\n                }\n            }\n        }\n        while(!acc_async_test_all());\n    }\n\n    for (int x = 0; x < 10*n; ++x){\n        if (fabs(e[x] - (a[x] + b[x] + d[x])) > PRECISION){\n            err += 1;\n        }\n    }\n    \n    free(a);\n    free(b);\n    free(c);\n    free(d);\n    free(e);\n    \n    return err;\n}\n#endif\n#ifndef T2\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test2();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 1);\n    }\n#endif\n",
                        "tags": [
                            "async",
                            "runtime",
                            "construct-independent"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "3": {
                        "content": "#ifndef T3\n//T3:async,runtime,construct-independent,V:2.5-2.7\nint test3(){\n    int err = 0;\n    real_t **a = (real_t **)malloc(10 * sizeof(real_t *));\n    real_t **b = (real_t **)malloc(10 * sizeof(real_t *));\n    real_t **c = (real_t **)malloc(10 * sizeof(real_t *));\n    real_t **d = (real_t **)malloc(10 * sizeof(real_t *));\n    real_t **e = (real_t **)malloc(10 * sizeof(real_t *));\n\n    for (int x = 0; x < 10; ++x){\n        a[x] = (real_t *)malloc(n * sizeof(real_t));\n        b[x] = (real_t *)malloc(n * sizeof(real_t));\n        c[x] = (real_t *)malloc(n * sizeof(real_t));\n        d[x] = (real_t *)malloc(n * sizeof(real_t));\n        e[x] = (real_t *)malloc(n * sizeof(real_t));\n        for (int y = 0; y < n; ++y){\n            a[x][y] = rand() / (real_t)(RAND_MAX / 10);\n            b[x][y] = rand() / (real_t)(RAND_MAX / 10);\n            c[x][y] = 0;\n            d[x][y] = rand() / (real_t)(RAND_MAX / 10);\n            e[x][y] = 0;\n        }\n    }\n\n    #pragma acc data copyin(a[0:10][0:n], b[0:10][0:n], d[0:10][0:n]) copyout(c[0:10][0:n], e[0:10][0:n])\n    {\n        for (int x = 0; x < 10; ++x){\n            acc_set_default_async(x);\n            #pragma acc parallel present(a[0:10][0:n], b[0:10][0:n], c[0:10][0:n]) async\n            {\n                #pragma acc loop\n                for (int y = 0; y < n; ++y){\n                    c[x][y] = a[x][y] + b[x][y];\n                }\n            }\n            #pragma acc parallel present(c[0:10][0:n], d[0:10][0:n], e[0:10][0:n]) async\n            {\n                #pragma acc loop\n                for (int y = 0; y < n; ++y){\n                    e[x][y] = c[x][y] + d[x][y];\n                }\n            }\n        }\n        while (!acc_async_test_all());\n    }\n\n    int count = 0;\n    int total = 0;\n    for (int x = 0; x < 10; ++x) {\n        for (int y = 0; y < n; ++y) {\n            if (fabs(e[x][y]) < PRECISION) {\n                count += 1;\n            }\n            total += 1;\n        }\n    }\n    printf(\"%d out of %d\\n\", count, total);\n\n    for (int x = 0; x < 10; ++x){\n        for (int y = 0; y < n; ++y){\n            if (fabs(e[x][y] - (a[x][y] + b[x][y] + d[x][y])) > PRECISION){\n                err += 1;\n            }\n        }\n    }\n    \n    for (int x = 0; x < 10; ++x){\n        free(a[x]);\n        free(b[x]);\n        free(c[x]);\n        free(d[x]);\n        free(e[x]);\n    }\n    free(a);\n    free(b);\n    free(c);\n    free(d);\n    free(e);\n    \n    return err;\n}\n#endif\n#ifndef T3\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test3();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 2);\n    }\n#endif\n",
                        "tags": [
                            "async",
                            "runtime",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "acc_copyin.F90": {
                "num tests": 7,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:runtime,data,executable-data,construct-independent,V:2.0-2.7\n      LOGICAL FUNCTION test1()\n        USE OPENACC\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT):: a, b, c !Data\n        INTEGER :: errors = 0\n\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n        CALL RANDOM_NUMBER(a)\n        CALL RANDOM_NUMBER(b)\n        c = 0\n\n        CALL acc_copyin(a(1:LOOPCOUNT))\n        CALL acc_copyin(b(1:LOOPCOUNT))\n\n        !$acc data copy(c(1:LOOPCOUNT))\n          !$acc parallel present(a(1:LOOPCOUNT), b(1:LOOPCOUNT))\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              c(x) = a(x) + b(x)\n            END DO\n          !$acc end parallel\n        !$acc end data\n\n        !$acc exit data copyout(a(1:LOOPCOUNT), b(1:LOOPCOUNT))\n\n        DO x = 1, LOOPCOUNT\n          IF (abs(c(x) - (a(x) + b(x))) .gt. PRECISION) THEN\n            errors = errors + 1\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END FUNCTION\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "runtime",
                            "data",
                            "executable-data",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "2": {
                        "content": "#ifndef T2\n!T2:runtime,data,executable-data,construct-independent,V:2.0-2.7\n      LOGICAL FUNCTION test2()\n        USE OPENACC\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT):: a, b, c !Data\n        INTEGER :: errors = 0\n\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n        CALL RANDOM_NUMBER(a)\n        CALL RANDOM_NUMBER(b)\n        c = 1\n\n        CALL acc_copyin(a(1:LOOPCOUNT))\n        CALL acc_copyin(b(1:LOOPCOUNT))\n\n        !$acc data copyout(c(1:LOOPCOUNT))\n          !$acc parallel present(a(1:LOOPCOUNT), b(1:LOOPCOUNT))\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              c(x) = a(x) + b(x)\n            END DO\n          !$acc end parallel\n        !$acc end data\n\n        CALL acc_copyout(a(1:LOOPCOUNT))\n        CALL acc_copyout(b(1:LOOPCOUNT))\n\n        DO x = 1, LOOPCOUNT\n          IF (abs(c(x) - (a(x) + b(x))) .gt. PRECISION) THEN\n            errors = errors + 1\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test2 = .FALSE.\n        ELSE\n          test2 = .TRUE.\n        END IF\n      END FUNCTION\n#endif\n#ifndef T2\n        LOGICAL :: test2\n#endif\n#ifndef T2\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test2()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 1\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "runtime",
                            "data",
                            "executable-data",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "3": {
                        "content": "#ifndef T3\n!T3:runtime,data,executable-data,devonly,construct-independent,V:2.5-2.7\n      LOGICAL FUNCTION test3()\n        USE OPENACC\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT):: a, b, c, a_copy, b_copy !Data\n        INTEGER :: errors = 0\n        LOGICAL,DIMENSION(1):: devtest\n\n        devtest(1) = .TRUE.\n        !$acc enter data copyin(devtest(1:1))\n        !$acc parallel present(devtest(1:1))\n          devtest(1) = .FALSE.\n        !$acc end parallel\n\n        IF (devtest(1) .eqv. .TRUE.) THEN\n          SEEDDIM(1) = 1\n#         ifdef SEED\n          SEEDDIM(1) = SEED\n#         endif\n          CALL RANDOM_SEED(PUT=SEEDDIM)\n          CALL RANDOM_NUMBER(a)\n          a_copy(:) = a(:)\n          CALL RANDOM_NUMBER(b)\n          b_copy(:) = b(:)\n          c = 0\n\n          CALL acc_copyin(a(1:LOOPCOUNT))\n          CALL acc_copyin(b(1:LOOPCOUNT))\n\n          a = 0\n          b = 0\n\n          !$acc data copyin(a(1:LOOPCOUNT), b(1:LOOPCOUNT)) copyout(c(1:LOOPCOUNT))\n            !$acc parallel\n              !$acc loop\n              DO x = 1, LOOPCOUNT\n                c(x) = a(x) + b(x)\n              END DO\n            !$acc end parallel\n          !$acc end data\n\n          !$acc exit data copyout(a(1:LOOPCOUNT), b(1:LOOPCOUNT))\n\n          DO x = 1, LOOPCOUNT\n            IF (abs(a(x) - a_copy(x)) .gt. PRECISION) THEN\n              errors = errors + 1\n            END IF\n            IF (abs(b(x) - b_copy(x)) .gt. PRECISION) THEN\n              errors = errors + 1\n            END IF\n            IF (abs(c(x) - (a(x) + b(x))) .gt. PRECISION) THEN\n              errors = errors + 1\n            END IF\n          END DO\n        END IF\n\n        IF (errors .eq. 0) THEN\n          test3 = .FALSE.\n        ELSE\n          test3 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T3\n        LOGICAL :: test3\n#endif\n#ifndef T3\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test3()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 2\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "runtime",
                            "data",
                            "executable-data",
                            "devonly",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "4": {
                        "content": "#ifndef T4\n!T4:runtime,executable-data,construct-independent,compatibility-features,V:2.0-2.7\n      LOGICAL FUNCTION test4()\n        USE OPENACC\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT):: a, b, c !Data\n        INTEGER :: errors = 0\n\n        !Initialization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n        CALL RANDOM_NUMBER(a)\n        CALL RANDOM_NUMBER(b)\n        c = 0\n\n        CALL acc_pcopyin(a(1:LOOPCOUNT))\n        CALL acc_pcopyin(b(1:LOOPCOUNT))\n\n        !$acc data copyout(c(1:LOOPCOUNT))\n          !$acc parallel present(a(1:LOOPCOUNT), b(1:LOOPCOUNT))\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              c(x) = a(x) + b(x)\n            END DO\n          !$acc end parallel\n        !$acc end data\n\n        !$acc exit data delete(a(1:LOOPCOUNT), b(1:LOOPCOUNT))\n\n        DO x = 1, LOOPCOUNT\n          IF (abs(c(x) - (a(x) + b(x))) .gt. PRECISION) THEN\n            errors = errors + 1\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test4 = .FALSE.\n        ELSE\n          test4 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T4\n        LOGICAL :: test4\n#endif\n#ifndef T4\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test4()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 3\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "runtime",
                            "executable-data",
                            "construct-independent",
                            "compatibility-features"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "5": {
                        "content": "#ifndef T5\n!T5:runtime,executable-data,construct-independent,compatibility-features,V:2.0-2.7\n      LOGICAL FUNCTION test5()\n        USE OPENACC\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT):: a, b, c !Data\n        INTEGER :: errors = 0\n\n        !Initialization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n        CALL RANDOM_NUMBER(a)\n        CALL RANDOM_NUMBER(b)\n        c = 0\n        \n        CALL acc_present_or_copyin(a(1:LOOPCOUNT))\n        CALL acc_present_or_copyin(b(1:LOOPCOUNT))\n\n        !$acc data copyout(c(1:LOOPCOUNT))\n          !$acc parallel present(a(1:LOOPCOUNT), b(1:LOOPCOUNT))\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              c(x) = a(x) + b(x)\n            END DO\n          !$acc end parallel\n        !$acc end data\n\n        !$acc exit data delete(a(1:LOOPCOUNT), b(1:LOOPCOUNT))\n\n        DO x = 1, LOOPCOUNT\n          IF (abs(c(x) - (a(x) + b(x))) .gt. PRECISION) THEN\n            errors = errors + 1\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test5 = .FALSE.\n        ELSE\n          test5 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T5\n        LOGICAL :: test5\n#endif\n#ifndef T5\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test5()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 4\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "runtime",
                            "executable-data",
                            "construct-independent",
                            "compatibility-features"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "6": {
                        "content": "#ifndef T6\n!T6:runtime,data,executable-data,construct-independent,reference-counting,V:2.5-2.7\n      LOGICAL FUNCTION test6()\n        USE OPENACC\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT):: a, b, c !Data\n        INTEGER :: errors = 0\n\n        !Initialization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n        CALL RANDOM_NUMBER(a)\n        CALL RANDOM_NUMBER(b)\n        c = 0\n\n        CALL acc_copyin(a(1:LOOPCOUNT))\n        CALL acc_copyin(a(1:LOOPCOUNT))\n        CALL acc_copyin(b(1:LOOPCOUNT))\n        CALL acc_copyin(b(1:LOOPCOUNT))\n\n        !$acc data copyout(c(1:LOOPCOUNT))\n          !$acc parallel present(a(1:LOOPCOUNT), b(1:LOOPCOUNT))\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              c(x) = a(x) + b(x)\n            END DO\n          !$acc end parallel\n        !$acc end data\n\n        !$acc exit data delete(a(1:LOOPCOUNT), b(1:LOOPCOUNT))\n        !$acc exit data delete(a(1:LOOPCOUNT), b(1:LOOPCOUNT))\n\n        DO x = 1, LOOPCOUNT\n          IF (abs(c(x) - (a(x) + b(x))) .gt. PRECISION) THEN\n            errors = errors + 1\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test6 = .FALSE.\n        ELSE\n          test6 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T6\n        LOGICAL :: test6\n#endif\n#ifndef T6\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test6()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 5\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "runtime",
                            "data",
                            "executable-data",
                            "construct-independent",
                            "reference-counting"
                        ],
                        "versions": [
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "7": {
                        "content": "#ifndef T7\n!T7:runtime,data,executable-data,construct-independent,reference-counting,devonly,V:2.5-2.7\n      LOGICAL FUNCTION test7()\n        USE OPENACC\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT):: a, b, c, a_copy, b_copy !Data\n        INTEGER :: errors = 0\n        LOGICAL,DIMENSION(1):: devtest\n\n        devtest(1) = .TRUE.\n        !$acc enter data copyin(devtest(1:1))\n        !$acc parallel present(devtest(1:1))\n          devtest(1) = .FALSE.\n        !$acc end parallel\n\n        IF (devtest(1) .eqv. .TRUE.) THEN\n          !Initialization\n          SEEDDIM(1) = 1\n#         ifdef SEED\n          SEEDDIM(1) = SEED\n#         endif\n          CALL RANDOM_SEED(PUT=SEEDDIM)\n          CALL RANDOM_NUMBER(a)\n          CALL RANDOM_NUMBER(b)\n          c = 0\n          a_copy = a\n          b_copy = b\n\n          CALL acc_copyin(a(1:LOOPCOUNT))\n          CALL acc_copyin(b(1:LOOPCOUNT))\n\n          a = 0\n          b = 0\n\n          CALL acc_copyin(a(1:LOOPCOUNT))\n          CALL acc_copyin(b(1:LOOPCOUNT))\n\n          !$acc data copyout(c(1:LOOPCOUNT))\n            !$acc parallel present(a(1:LOOPCOUNT), b(1:LOOPCOUNT))\n              !$acc loop\n              DO x = 1, LOOPCOUNT\n                c(x) = a(x) + b(x)\n              END DO\n            !$acc end parallel\n          !$acc end data\n\n          !$acc exit data delete(a(1:LOOPCOUNT), b(1:LOOPCOUNT))\n          !$acc exit data delete(a(1:LOOPCOUNT), b(1:LOOPCOUNT))\n\n          DO x = 1, LOOPCOUNT\n            IF (abs(c(x) - (a_copy(x) + b_copy(x))) .gt. PRECISION) THEN\n              errors = errors + 1\n            END IF\n          END DO\n        END IF\n\n        IF (errors .eq. 0) THEN\n          test7 = .FALSE.\n        ELSE\n          test7 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T7\n        LOGICAL :: test7\n#endif\n#ifndef T7\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test7()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 6\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "runtime",
                            "data",
                            "executable-data",
                            "construct-independent",
                            "reference-counting",
                            "devonly"
                        ],
                        "versions": [
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "acc_copyin.c": {
                "num tests": 7,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:runtime,data,executable-data,construct-independent,V:2.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n    real_t * c = (real_t *)malloc(n * sizeof(real_t));\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n        c[x] = 0.0;\n    }\n\n    acc_copyin(a, n * sizeof(real_t));\n    acc_copyin(b, n * sizeof(real_t));\n\n    #pragma acc data copy(c[0:n])\n    {\n        #pragma acc parallel present(a[0:n], b[0:n])\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                c[x] = a[x] + b[x];\n            }\n        }\n    }\n\n    acc_copyout(a, n * sizeof(real_t));\n    acc_copyout(b, n * sizeof(real_t));\n\n    for (int x = 0; x < n; ++x){\n        if (fabs(c[x] - (a[x] + b[x])) > PRECISION){\n            err += 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "runtime",
                            "data",
                            "executable-data",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "2": {
                        "content": "#ifndef T2\n//T2:runtime,data,executable-data,construct-independent,V:2.0-2.7\nint test2(){\n    int err = 0;\n    srand(time(NULL));\n    real_t * a = (real_t *)malloc(n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n    real_t * c = (real_t *)malloc(n * sizeof(real_t));\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n        c[x] = 0.0;\n    }\n\n    acc_copyin(a, n * sizeof(real_t));\n    acc_copyin(b, n * sizeof(real_t));\n\n    #pragma acc data copy(c[0:n])\n    {\n        #pragma acc parallel present(a[0:n], b[0:n])\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                c[x] = a[x] + b[x];\n            }\n        }\n    }\n\n    #pragma acc exit data copyout(a[0:n], b[0:n])\n\n    for (int x = 0; x < n; ++x){\n        if (fabs(c[x] - (a[x] + b[x])) > PRECISION){\n            err += 1;\n        }\n    }\n    return err;\n}\n#endif\n#ifndef T2\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test2();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 1);\n    }\n#endif\n",
                        "tags": [
                            "runtime",
                            "data",
                            "executable-data",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "3": {
                        "content": "#ifndef T3\n//T3:runtime,data,executable-data,devonly,construct-independent,reference-counting,V:2.5-2.7\nint test3(){\n    int err = 0;\n    srand(time(NULL));\n    real_t * a = (real_t *)malloc(n * sizeof(real_t));\n    real_t * a_copy = (real_t *)malloc(n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n    real_t * b_copy = (real_t *)malloc(n * sizeof(real_t));\n    real_t * c = (real_t *)malloc(n * sizeof(real_t));\n    int * dev_test = (int *)malloc(n * sizeof(int));\n\n    dev_test[0] = 1;\n    #pragma acc enter data copyin(dev_test[0:1])\n    #pragma acc parallel present(dev_test[0:1])\n    {\n        dev_test[0] = 0;\n    }\n\n    if (dev_test[0] == 1){\n        for (int x = 0; x < n; ++x){\n            a[x] = rand() / (real_t)(RAND_MAX / 10);\n            a_copy[x] = a[x];\n            b[x] = rand() / (real_t)(RAND_MAX / 10);\n            b_copy[x] = b[x];\n            c[x] = 0.0;\n        }\n\n        acc_copyin(a, n * sizeof(real_t));\n        acc_copyin(b, n * sizeof(real_t));\n\n        for (int x = 0; x < n; ++x){\n            a[x] = 0;\n            b[x] = 0;\n        }\n\n        #pragma acc data copyin(a[0:n], b[0:n]) copyout(c[0:n])\n        {\n            #pragma acc parallel\n            {\n                #pragma acc loop\n                for (int x = 0; x < n; ++x){\n                    c[x] = a[x] + b[x];\n                }\n            }\n        }\n\n        acc_copyout(a, n * sizeof(real_t));\n        acc_copyout(b, n * sizeof(real_t));\n\n        for (int x = 0; x < n; ++x){\n            if (fabs(a[x] - a_copy[x]) > PRECISION){\n                err += 1;\n            }\n            if (fabs(b[x] - b_copy[x]) > PRECISION){\n                err += 1;\n            }\n            if (fabs(c[x] - (a[x] + b[x])) > PRECISION){\n                err += 1;\n            }\n        }\n    }\n    return err;\n}\n#endif\n#ifndef T3\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test3();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 2);\n    }\n#endif\n",
                        "tags": [
                            "runtime",
                            "data",
                            "executable-data",
                            "devonly",
                            "construct-independent",
                            "reference-counting"
                        ],
                        "versions": [
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "4": {
                        "content": "#ifndef T4\n//T4:runtime,data,executable-data,construct-independent,compatibility-features,V:2.0-2.7\nint test4(){\n    int err = 0;\n    srand(time(NULL));\n    real_t * a = (real_t *)malloc(n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n    real_t * c = (real_t *)malloc(n * sizeof(real_t));\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n        c[x] = 0.0;\n    }\n\n    acc_pcopyin(a, n * sizeof(real_t));\n    acc_pcopyin(b, n * sizeof(real_t));\n\n    #pragma acc data copy(c[0:n])\n    {\n        #pragma acc parallel present(a[0:n], b[0:n])\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                c[x] = a[x] + b[x];\n            }\n        }\n    }\n\n    #pragma acc exit data delete(a[0:n], b[0:n])\n\n    for (int x = 0; x < n; ++x){\n        if (fabs(c[x] - (a[x] + b[x])) > PRECISION){\n            err += 1;\n        }\n    }\n    return err;\n}\n#endif\n#ifndef T4\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test4();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 3);\n    }\n#endif\n",
                        "tags": [
                            "runtime",
                            "data",
                            "executable-data",
                            "construct-independent",
                            "compatibility-features"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "5": {
                        "content": "#ifndef T5\n//T5:runtime,data,executable-data,construct-independent,compatibility-features,V:2.0-2.7\nint test5(){\n    int err = 0;\n    srand(time(NULL));\n    real_t * a = (real_t *)malloc(n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n    real_t * c = (real_t *)malloc(n * sizeof(real_t));\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n        c[x] = 0;\n    }\n\n    acc_present_or_copyin(a, n * sizeof(real_t));\n    acc_present_or_copyin(b, n * sizeof(real_t));\n\n    #pragma acc data copyout(c[0:n]) present(a[0:n], b[0:n])\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                c[x] = a[x] + b[x];\n            }\n        }\n    }\n\n    #pragma acc exit data delete(a[0:n], b[0:n])\n\n    for (int x = 0; x < n; ++x){\n        if (fabs(c[x] - (a[x] + b[x])) > PRECISION){\n            err += 1;\n        }\n    }\n    return err;\n}\n#endif\n#ifndef T5\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test5();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 4);\n    }\n#endif\n",
                        "tags": [
                            "runtime",
                            "data",
                            "executable-data",
                            "construct-independent",
                            "compatibility-features"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "6": {
                        "content": "#ifndef T6\n//T6:runtime,data,executable-data,construct-independent,reference-counting,V:2.5-2.7\nint test6() {\n    int err = 0;\n    srand(time(NULL));\n    real_t *a = (real_t *)malloc(n * sizeof(real_t));\n    real_t *b = (real_t *)malloc(n * sizeof(real_t));\n    real_t *c = (real_t *)malloc(n * sizeof(real_t));\n\n    for (int x = 0; x < n; ++x) {\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n        c[x] = 0;\n    }\n\n    acc_copyin(a, n * sizeof(real_t));\n    acc_copyin(a, n * sizeof(real_t));\n    acc_copyin(b, n * sizeof(real_t));\n    acc_copyin(b, n * sizeof(real_t));\n\n    #pragma acc data copyout(c[0:n])\n    {\n        #pragma acc parallel present(a[0:n], b[0:n])\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x) {\n                c[x] = a[x] + b[x];\n            }\n        }\n    }\n\n    #pragma acc exit data delete(a[0:n], b[0:n])\n    #pragma acc exit data delete(a[0:n], b[0:n])\n\n    for (int x = 0; x < n; ++x) {\n        if (fabs(c[x] - (a[x] + b[x])) > PRECISION) {\n            err += 1;\n        }\n    }\n    return err;\n}\n#endif\n#ifndef T6\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x) {\n        failed = failed + test6();\n    }\n    if (failed != 0) {\n        failcode = failcode + (1 << 5);\n    }\n#endif\n",
                        "tags": [
                            "runtime",
                            "data",
                            "executable-data",
                            "construct-independent",
                            "reference-counting"
                        ],
                        "versions": [
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "7": {
                        "content": "#ifndef T7\n//T7:runtime,data,executable-data,construct-independent,reference-counting,devonly,V:2.5-2.7\nint test7() {\n    int err = 0;\n    srand(time(NULL));\n    real_t *a = (real_t *)malloc(n * sizeof(real_t));\n    real_t *b = (real_t *)malloc(n * sizeof(real_t));\n    real_t *a_copy = (real_t *)malloc(n * sizeof(real_t));\n    real_t *b_copy = (real_t *)malloc(n * sizeof(real_t));\n    real_t *c = (real_t *)malloc(n * sizeof(real_t));\n    int * dev_test = (int *)malloc(n * sizeof(int));\n\n    dev_test[0] = 1;\n    #pragma acc enter data copyin(dev_test[0:1])\n    #pragma acc parallel present(dev_test[0:1])\n    {\n        dev_test[0] = 0;\n    }\n\n    if (dev_test[0] == 1){\n        for (int x = 0; x < n; ++x){\n            a[x] = rand() / (real_t)(RAND_MAX / 10);\n            b[x] = rand() / (real_t)(RAND_MAX / 10);\n            a_copy[x] = a[x];\n            b_copy[x] = b[x];\n            c[x] = 0;\n        }\n        \n        acc_copyin(a, n * sizeof(real_t));\n        acc_copyin(b, n * sizeof(real_t));\n\n        for (int x = 0; x < n; ++x){\n            a[x] = 0;\n            b[x] = 0;\n        }\n\n        acc_copyin(a, n * sizeof(real_t));\n        acc_copyin(b, n * sizeof(real_t));\n\n        #pragma acc data copyout(c[0:n])\n        {\n            #pragma acc parallel present(a[0:n], b[0:n])\n            {\n                #pragma acc loop\n                for (int x = 0; x < n; ++x){\n                    c[x] = a[x] + b[x];\n                }\n            }\n        }\n\n        #pragma acc exit data delete(a[0:n], b[0:n])\n        #pragma acc exit data delete(a[0:n], b[0:n])\n\n        for (int x = 0; x < n; ++x){\n            if (fabs(c[x] - (a_copy[x] + b_copy[x])) > PRECISION){\n                err += 1;\n            }\n        }\n    }\n    return err;\n}\n#endif\n#ifndef T7\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x) {\n        failed = failed + test7();\n    }\n    if (failed != 0) {\n        failcode = failcode + (1 << 6);\n    }\n#endif\n",
                        "tags": [
                            "runtime",
                            "data",
                            "executable-data",
                            "construct-independent",
                            "reference-counting",
                            "devonly"
                        ],
                        "versions": [
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "acc_copyin_async.F90": {
                "num tests": 5,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:runtime,data,executable-data,async,construct-independent,V:2.5-2.7\n      LOGICAL FUNCTION test1()\n        USE OPENACC\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT):: a, b, c, a_host, b_host !Data\n        REAL(8) :: RAND\n        INTEGER :: errors = 0\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n        CALL RANDOM_NUMBER(a)\n        CALL RANDOM_NUMBER(b)\n        c = 0\n        a_host = a\n        b_host = b\n\n        CALL acc_copyin_async(a(1:LOOPCOUNT), 1)\n        CALL acc_copyin_async(b(1:LOOPCOUNT), 2)\n\n        !$acc data copyout(c(1:LOOPCOUNT))\n          !$acc parallel async(1) present(a(1:LOOPCOUNT))\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              a(x) = a(x) * a(x)\n            END DO\n          !$acc end parallel\n          !$acc parallel async(2) present(b(1:LOOPCOUNT))\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              b(x) = b(x) * b(x)\n            END DO\n          !$acc end parallel\n          !$acc parallel async(2) wait(1) present(a(1:LOOPCOUNT), b(1:LOOPCOUNT))\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              c(x) = a(x) + b(x)\n            END DO\n          !$acc end parallel\n        !$acc end data\n        DO x = 1, LOOPCOUNT\n          IF (abs(c(x) - (a_host(x)*a_host(x) + b_host(x)*b_host(x))) .gt. PRECISION) THEN\n            errors = errors + 1\n          END IF\n        END DO\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n      LOGICAL :: test1\n#endif\n#ifndef T1\n      DO testrun = 1, NUM_TEST_CALLS\n        failed = failed .or. test1()\n      END DO\n      IF (failed) THEN\n        failcode = failcode + 2 ** 0\n        failed = .FALSE.\n      END IF\n#endif\n",
                        "tags": [
                            "runtime",
                            "data",
                            "executable-data",
                            "async",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "2": {
                        "content": "#ifndef T2\n!T2:runtime,data,executable-data,async,construct-independent,V:2.5-2.7\n      LOGICAL FUNCTION test2()\n        USE OPENACC\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT):: a, b, c, a_host, b_host !Data\n        REAL(8) :: RAND\n        INTEGER :: errors = 0\n\n        !Initialization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n        CALL RANDOM_NUMBER(a)\n        CALL RANDOM_NUMBER(b)\n        c = 0\n\n        CALL acc_copyin_async(a(1:LOOPCOUNT), 1)\n        CALL acc_copyin_async(b(1:LOOPCOUNT), 2)\n\n        !$acc data copyout(c(1:LOOPCOUNT))\n          DO WHILE (acc_async_test_all() .eqv. .FALSE.)\n            CONTINUE\n          END DO\n          !$acc parallel present(a(1:LOOPCOUNT), b(1:LOOPCOUNT))\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              c(x) = a(x) + b(x)\n            END DO\n          !$acc end parallel\n        !$acc end data\n\n        !$acc exit data delete(a(1:LOOPCOUNT), b(1:LOOPCOUNT))\n\n        DO x = 1, LOOPCOUNT\n          IF (abs(c(x) - (a(x) + b(x))) .gt. PRECISION) THEN\n            errors = errors + 1\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test2 = .FALSE.\n        ELSE\n          test2 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T2\n      LOGICAL :: test2\n#endif\n#ifndef T2\n      DO testrun = 1, NUM_TEST_CALLS\n        failed = failed .or. test2()\n      END DO\n      IF (failed) THEN\n        failcode = failcode + 2 ** 1\n        failed = .FALSE.\n      END IF\n#endif\n",
                        "tags": [
                            "runtime",
                            "data",
                            "executable-data",
                            "async",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "3": {
                        "content": "#ifndef T3\n!T3:runtime,data,executable-data,async,construct-independent,V:2.5-2.7\n      LOGICAL FUNCTION test3()\n        USE OPENACC\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT):: a, b, c !Data\n        REAL(8) :: RAND\n        INTEGER :: errors = 0\n\n        !Initialization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n        CALL RANDOM_NUMBER(a)\n        CALL RANDOM_NUMBER(b)\n        c = 0\n\n        CALL acc_copyin_async(a(1:LOOPCOUNT), 1)\n        CALL acc_copyin_async(b(1:LOOPCOUNT), 2)\n\n        !$acc data copyout(c(1:LOOPCOUNT))\n          !$acc wait\n          !$acc parallel present(a(1:LOOPCOUNT), b(1:LOOPCOUNT))\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              c(x) = a(x) + b(x)\n            END DO\n          !$acc end parallel\n        !$acc end data\n\n        !$acc exit data delete(a(1:LOOPCOUNT), b(1:LOOPCOUNT))\n\n        DO x = 1, LOOPCOUNT\n          IF (abs(c(x) - (a(x) + b(x))) .gt. PRECISION) THEN\n            errors = errors + 1\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test3 = .FALSE.\n        ELSE\n          test3 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T3\n      LOGICAL :: test3\n#endif\n#ifndef T3\n      DO testrun = 1, NUM_TEST_CALLS\n        failed = failed .or. test3()\n      END DO\n      IF (failed) THEN\n        failcode = failcode + 2 ** 2\n        failed = .FALSE.\n      END IF\n#endif\n",
                        "tags": [
                            "runtime",
                            "data",
                            "executable-data",
                            "async",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "4": {
                        "content": "#ifndef T4\n!T4:runtime,data,executable-data,async,construct-independent,reference-counting,V:2.5-2.7\n      LOGICAL FUNCTION test4()\n        USE OPENACC\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT):: a, b, c, d, e !Data\n        REAL(8) :: RAND\n        INTEGER :: errors = 0\n\n        !Initialization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n        CALL RANDOM_NUMBER(a)\n        CALL RANDOM_NUMBER(b)\n        c = 0\n        CALL RANDOM_NUMBER(d)\n        e = 0\n\n        !$acc enter data create(c(1:LOOPCOUNT))\n        !$acc data copyin(a(1:LOOPCOUNT), b(1:LOOPCOUNT), d(1:LOOPCOUNT)) copyout(e(1:LOOPCOUNT))\n          !$acc parallel present(c(1:LOOPCOUNT)) async(1)\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              c(x) = a(x) + b(x)\n            END DO\n          !$acc end parallel\n          CALL acc_copyin_async(c(1:LOOPCOUNT), 1)\n          !$acc exit data delete(c(1:LOOPCOUNT))\n          !$acc parallel present(c(1:LOOPCOUNT)) async(1)\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              e(x) = c(x) + d(x)\n            END DO\n          !$acc end parallel\n        !$acc end data\n        !$acc exit data copyout(c(1:LOOPCOUNT))\n\n        DO x = 1, LOOPCOUNT\n          IF (abs(c(x) - (a(x) + b(x))) .gt. PRECISION) THEN\n            errors = errors + 1\n          END IF\n          IF (abs(e(x) - (a(x) + b(x) + d(x))) .gt. PRECISION) THEN\n            errors = errors + 1\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test4 = .FALSE.\n        ELSE\n          test4 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T4\n      LOGICAL :: test4\n#endif\n#ifndef T4\n      DO testrun = 1, NUM_TEST_CALLS\n        failed = failed .or. test4()\n      END DO\n      IF (failed) THEN\n        failcode = failcode + 2 ** 3\n        failed = .FALSE.\n      END IF\n#endif\n",
                        "tags": [
                            "runtime",
                            "data",
                            "executable-data",
                            "async",
                            "construct-independent",
                            "reference-counting"
                        ],
                        "versions": [
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "5": {
                        "content": "#ifndef T5\n!T5:runtime,data,executable-data,async,construct-independent,reference-counting,V:2.5-2.7\n      LOGICAL FUNCTION test5()\n        USE OPENACC\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT):: a, b, c, a_copy, b_copy !Data\n        REAL(8) :: RAND\n        INTEGER :: errors = 0\n\n        !Initialization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n        CALL RANDOM_NUMBER(a)\n        a_copy = a\n        CALL RANDOM_NUMBER(b)\n        b_copy = b\n        c = 0\n\n        CALL acc_copyin_async(a(1:LOOPCOUNT), 1)\n        CALL acc_copyin_async(b(1:LOOPCOUNT), 2)\n\n        a = 0\n        b = 0\n\n        !$acc data copyin(a(1:LOOPCOUNT), b(1:LOOPCOUNT)) copyout(c(1:LOOPCOUNT))\n          !$acc wait\n          !$acc parallel\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              c(x) = a(x) + b(x)\n            END DO\n          !$acc end parallel\n        !$acc end data\n\n        !$acc exit data delete(a(1:LOOPCOUNT), b(1:LOOPCOUNT))\n\n        DO x = 1, LOOPCOUNT\n          IF (abs(c(x) - (a_copy(x) + b_copy(x))) .gt. PRECISION) THEN\n            errors = errors + 1\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test5 = .FALSE.\n        ELSE\n          test5 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T5\n      LOGICAL :: test5\n#endif\n#ifndef T5\n      DO testrun = 1, NUM_TEST_CALLS\n        failed = failed .or. test5()\n      END DO\n      IF (failed) THEN\n        failcode = failcode + 2 ** 4\n        failed = .FALSE.\n      END IF\n#endif\n",
                        "tags": [
                            "runtime",
                            "data",
                            "executable-data",
                            "async",
                            "construct-independent",
                            "reference-counting"
                        ],
                        "versions": [
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "acc_copyin_async.c": {
                "num tests": 5,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:async,data,executable-data,runtime,construct-independent,V:2.5-2.7\nint test1(){\n    int err = 0;\n    real_t *a = (real_t *)malloc(n * sizeof(real_t));\n    real_t *b = (real_t *)malloc(n * sizeof(real_t));\n    real_t *c = (real_t *)malloc(n * sizeof(real_t));\n    real_t *a_host = (real_t *)malloc(n * sizeof(real_t));\n    real_t *b_host = (real_t *)malloc(n * sizeof(real_t));\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n        c[x] = 0;\n        a_host[x] = a[x];\n        b_host[x] = b[x];\n    }\n\n    acc_copyin_async(a, n * sizeof(real_t), 1);\n    acc_copyin_async(b, n * sizeof(real_t), 2);\n    #pragma acc data copyout(c[0:n]) present(a[0:n], b[0:n])\n    {\n        #pragma acc parallel async(1)\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                a[x] = a[x] * a[x];\n            }\n        }\n        #pragma acc parallel async(2)\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                b[x] = b[x] * b[x];\n            }\n        }\n        #pragma acc parallel async(2) wait(1)\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                c[x] = a[x] + b[x];\n            }\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        if (fabs(c[x] - (a_host[x] * a_host[x] + b_host[x] * b_host[x])) > PRECISION * 4){\n            err += 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "async",
                            "data",
                            "executable-data",
                            "runtime",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "2": {
                        "content": "#ifndef T2\n//T2:runtime,data,executable-data,async,construct-independent,V:2.5-2.7\nint test2(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n    real_t * c = (real_t *)malloc(n * sizeof(real_t));\n    real_t * a_copy = (real_t *)malloc(n * sizeof(real_t));\n    real_t * b_copy = (real_t *)malloc(n * sizeof(real_t));\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n        c[x] = 1;\n    }\n\n    acc_copyin_async(a, n*sizeof(real_t), 1);\n    acc_copyin_async(b, n*sizeof(real_t), 2);\n\n    #pragma acc data copyout(c[0:n])\n    {\n        while (!acc_async_test_all());\n        #pragma acc parallel present(a[0:n], b[0:n])\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x) {\n                c[x] = a[x] + b[x];\n            }\n        }\n    }\n\n    #pragma acc exit data delete(a[0:n], b[0:n])\n\n    for (int x = 0; x < n; ++x) {\n        if (fabs(c[x] - (a[x] + b[x])) > PRECISION) {\n            err += 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T2\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test2();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 1);\n    }\n#endif\n",
                        "tags": [
                            "runtime",
                            "data",
                            "executable-data",
                            "async",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "3": {
                        "content": "#ifndef T3\n//T3:runtime,data,executable-data,async,construct-independent,V:2.5-2.7\nint test3(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n    real_t * c = (real_t *)malloc(n * sizeof(real_t));\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n        c[x] = 0;\n    }\n\n    acc_copyin_async(a, n * sizeof(real_t), 1);\n    acc_copyin_async(b, n * sizeof(real_t), 2);\n\n    #pragma acc data copyout(c[0:n])\n    {\n        #pragma acc wait\n        #pragma acc parallel present(a[0:n], b[0:n])\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x) {\n                c[x] = a[x] + b[x];\n            }\n        }\n    }\n\n    #pragma acc exit data delete(a[0:n], b[0:n])\n\n    for (int x = 0; x < n; ++x) {\n        if (fabs(c[x] - (a[x] + b[x])) > PRECISION) {\n            err = err + 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T3\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test3();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 2);\n    }\n#endif\n",
                        "tags": [
                            "runtime",
                            "data",
                            "executable-data",
                            "async",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "4": {
                        "content": "#ifndef T4\n//T4:runtime,data,executable-data,async,construct-independent,reference-counting,V:2.5-2.7\nint test4(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n    real_t * c = (real_t *)malloc(n * sizeof(real_t));\n    real_t * d = (real_t *)malloc(n * sizeof(real_t));\n    real_t * e = (real_t *)malloc(n * sizeof(real_t));\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n        c[x] = 0;\n        d[x] = rand() / (real_t)(RAND_MAX / 10);\n        e[x] = 0;\n    }\n\n    #pragma acc enter data create(c[0:n])\n    #pragma acc data copyin(a[0:n], b[0:n], d[0:n]) copyout(e[0:n])\n    {\n        #pragma acc parallel present(c[0:n]) async(1)\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x) {\n                c[x] = a[x] + b[x];\n            }\n        }\n        acc_copyin_async(c, n * sizeof(real_t), 1);\n        #pragma acc exit data delete(c[0:n]) async(1)\n        #pragma acc parallel present(c[0:n]) async(1)\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x) {\n                e[x] = c[x] + d[x];\n            }\n        }\n    }\n    #pragma acc wait\n    #pragma acc exit data copyout(c[0:n])\n\n    for (int x = 0; x < n; ++x) {\n        if (fabs(c[x] - (a[x] + b[x])) > PRECISION) {\n            err += 1;\n        }\n        if (fabs(e[x] - (a[x] + b[x] + d[x])) > PRECISION) {\n            err += 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T4\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test4();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 3);\n    }\n#endif\n",
                        "tags": [
                            "runtime",
                            "data",
                            "executable-data",
                            "async",
                            "construct-independent",
                            "reference-counting"
                        ],
                        "versions": [
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "5": {
                        "content": "#ifndef T5\n//T5:runtime,data,executable-data,async,construct-independent,reference-counting,V:2.5-2.7\nint test5(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n    real_t * c = (real_t *)malloc(n * sizeof(real_t));\n    real_t * a_copy = (real_t *)malloc(n * sizeof(real_t));\n    real_t * b_copy = (real_t *)malloc(n * sizeof(real_t));\n    int * devtest = (int *)malloc(sizeof(int));\n\n    devtest[0] = 0;\n    #pragma acc enter data copyin(devtest[0:1])\n    #pragma acc parallel present(devtest[0:1])\n    {\n        devtest[0] = 1;\n    }\n\n    if (devtest[0] == 0){\n        for (int x = 0; x < n; ++x){\n            a[x] = rand() / (real_t)(RAND_MAX / 10);\n            b[x] = rand() / (real_t)(RAND_MAX / 10);\n            c[x] = 0;\n            a_copy[x] = a[x];\n            b_copy[x] = b[x];\n        }\n\n        acc_copyin_async(a, n * sizeof(real_t), 1);\n        acc_copyin_async(b, n * sizeof(real_t), 2);\n\n        for (int x = 0; x < n; ++x) {\n            a[x] = 0;\n            b[x] = 0;\n        }\n\n        #pragma acc data copyin(a[0:n], b[0:n]) copyout(c[0:n])\n        {\n            #pragma acc wait\n            #pragma acc parallel\n            {\n                #pragma acc loop\n                for (int x = 0; x < n; ++x) {\n                    c[x] = a[x] + b[x];\n                }\n            }\n        }\n\n        #pragma acc exit data delete(a[0:n], b[0:n])\n\n        for (int x = 0; x < n; ++x) {\n            if (fabs(c[x] - (a_copy[x] + b_copy[x])) > PRECISION) {\n                err += 1;\n            }\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T5\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test5();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 4);\n    }\n#endif\n",
                        "tags": [
                            "runtime",
                            "data",
                            "executable-data",
                            "async",
                            "construct-independent",
                            "reference-counting"
                        ],
                        "versions": [
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "acc_copyin_async_with_len.F90": {
                "num tests": 5,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:runtime,data,executable-data,async,construct-independent,V:2.5-2.7\n      LOGICAL FUNCTION test1()\n        USE OPENACC\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT):: a, b, c, a_host, b_host !Data\n        INTEGER :: errors\n        errors = 0\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n        CALL RANDOM_NUMBER(a)\n        CALL RANDOM_NUMBER(b)\n        c = 0\n        a_host = a\n        b_host = b\n\n        CALL acc_copyin_async(a(1), LOOPCOUNT*8, 1)\n        CALL acc_copyin_async(b(1), LOOPCOUNT*8, 2)\n\n        !$acc data copyout(c(1:LOOPCOUNT)) present(a(1:LOOPCOUNT), b(1:LOOPCOUNT))\n          !$acc parallel async(1)\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              a(x) = a(x) * a(x)\n            END DO\n          !$acc end parallel\n          !$acc parallel async(2)\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              b(x) = b(x) * b(x)\n            END DO\n          !$acc end parallel\n          !$acc parallel wait(1, 2)\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              c(x) = a(x) + b(x)\n            END DO\n          !$acc end parallel\n        !$acc end data\n\n        DO x = 1, LOOPCOUNT\n          IF (abs(c(x) - (a_host(x)*a_host(x) + b_host(x)*b_host(x))) .gt. 4*PRECISION) THEN\n            errors = errors + 1\n          END IF\n        END DO\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "runtime",
                            "data",
                            "executable-data",
                            "async",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "2": {
                        "content": "#ifndef T2\n!T2:runtime,data,executable-data,async,construct-independent,V:2.5-2.7\n      LOGICAL FUNCTION test2()\n        USE OPENACC\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT):: a, b, c !Data\n        INTEGER :: errors\n        errors = 0\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n        CALL RANDOM_NUMBER(a)\n        CALL RANDOM_NUMBER(b)\n        c = 0\n\n        CALL acc_copyin_async(a(1), LOOPCOUNT*8, 1)\n        CALL acc_copyin_async(b(1), LOOPCOUNT*8, 2)\n\n        !$acc data copyout(c(1:LOOPCOUNT))\n          DO WHILE (acc_async_test_all() .eqv. .FALSE.)\n            CONTINUE\n          END DO\n          !$acc parallel present(a(1:LOOPCOUNT), b(1:LOOPCOUNT))\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              c(x) = a(x) + b(x)\n            END DO\n          !$acc end parallel\n        !$acc end data\n\n        !$acc exit data delete(a(1:LOOPCOUNT), b(1:LOOPCOUNT))\n\n        DO x = 1, LOOPCOUNT\n          IF (abs(c(x) - (a(x) + b(x))) .gt. PRECISION) THEN\n            errors = errors + 1\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test2 = .FALSE.\n        ELSE\n          test2 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T2\n        LOGICAL :: test2\n#endif\n#ifndef T2\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test2()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 1\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "runtime",
                            "data",
                            "executable-data",
                            "async",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "3": {
                        "content": "#ifndef T3\n!T3:runtime,data,executable-data,async,construct-independent,V:2.5-2.7\n      LOGICAL FUNCTION test3()\n        USE OPENACC\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT):: a, b, c !Data\n        INTEGER :: errors\n        errors = 0\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n        CALL RANDOM_NUMBER(a)\n        CALL RANDOM_NUMBER(b)\n        c = 0\n\n        CALL acc_copyin_async(a(1), LOOPCOUNT*8, 1)\n        CALL acc_copyin_async(b(1), LOOPCOUNT*8, 2)\n\n        !$acc data copyout(c(1:LOOPCOUNT))\n          !$acc wait\n          !$acc parallel present(a(1:LOOPCOUNT), b(1:LOOPCOUNT))\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              c(x) = a(x) + b(x)\n            END DO\n          !$acc end parallel\n        !$acc end data\n\n        !$acc exit data delete(a(1:LOOPCOUNT), b(1:LOOPCOUNT))\n\n        DO x = 1, LOOPCOUNT\n          IF (abs(c(x) - (a(x) + b(x))) .gt. PRECISION) THEn\n            errors = errors + 1\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test3 = .FALSE.\n        ELSE\n          test3 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T3\n        LOGICAL :: test3\n#endif\n#ifndef T3\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test3()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 2\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "runtime",
                            "data",
                            "executable-data",
                            "async",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "4": {
                        "content": "#ifndef T4\n!T4:runtime,data,executable-data,async,construct-independent,reference-counting,V:2.5-2.7\n      LOGICAL FUNCTION test4()\n        USE OPENACC\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT):: a, b, c, d, e !Data\n        REAL(8) :: RAND\n        INTEGER :: errors = 0\n\n        !Initialization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n        CALL RANDOM_NUMBER(a)\n        CALL RANDOM_NUMBER(b)\n        c = 0\n        CALL RANDOM_NUMBER(d)\n        e = 0\n\n        !$acc enter data create(c(1:LOOPCOUNT))\n        !$acc data copyin(a(1:LOOPCOUNT), b(1:LOOPCOUNT), d(1:LOOPCOUNT)) copyout(e(1:LOOPCOUNT))\n          !$acc parallel present(c(1:LOOPCOUNT)) async(1)\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              c(x) = a(x) + b(x)\n            END DO\n          !$acc end parallel\n          CALL acc_copyin_async(c(1), LOOPCOUNT*8, 1)\n          !$acc exit data delete(c(1:LOOPCOUNT))\n          !$acc parallel present(c(1:LOOPCOUNT)) async(1)\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              e(x) = c(x) + d(x)\n            END DO\n          !$acc end parallel\n        !$acc end data\n        !$acc exit data copyout(c(1:LOOPCOUNT))\n\n        DO x = 1, LOOPCOUNT\n          IF (abs(c(x) - (a(x) + b(x))) .gt. PRECISION) THEN\n            errors = errors + 1\n          END IF\n          IF (abs(e(x) - (a(x) + b(x) + d(x))) .gt. PRECISION) THEN\n            errors = errors + 1\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test4 = .FALSE.\n        ELSE\n          test4 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T4\n        LOGICAL :: test4\n#endif\n#ifndef T4\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test4()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 3\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "runtime",
                            "data",
                            "executable-data",
                            "async",
                            "construct-independent",
                            "reference-counting"
                        ],
                        "versions": [
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "5": {
                        "content": "#ifndef T5\n!T5:runtime,data,executable-data,async,construct-independent,reference-counting,V:2.5-2.7\n      LOGICAL FUNCTION test5()\n        USE OPENACC\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT):: a, b, c !Data\n        REAL(8) :: RAND\n        INTEGER :: errors = 0\n\n        !Initialization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n        CALL RANDOM_NUMBER(a)\n        CALL RANDOM_NUMBER(b)\n        c = 0\n\n        CALL acc_copyin_async(a(1), LOOPCOUNT*8, 1)\n        CALL acc_copyin_async(b(1), LOOPCOUNT*8, 2)\n\n        !$acc data create(a(1:LOOPCOUNT), b(1:LOOPCOUNT)) copyout(c(1:LOOPCOUNT))\n          !$acc wait\n          !$acc parallel\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              c(x) = a(x) + b(x)\n            END DO\n          !$acc end parallel\n        !$acc end data\n\n        !$acc exit data delete(a(1:LOOPCOUNT), b(1:LOOPCOUNT))\n\n        DO x = 1, LOOPCOUNT\n          IF (abs(c(x) - (a(x) + b(x))) .gt. PRECISION) THEN\n            errors = errors + 1\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test5 = .FALSE.\n        ELSE\n          test5 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T5\n        LOGICAL :: test5\n#endif\n#ifndef T5\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test5()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 4\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "runtime",
                            "data",
                            "executable-data",
                            "async",
                            "construct-independent",
                            "reference-counting"
                        ],
                        "versions": [
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "acc_copyin_with_len.F90": {
                "num tests": 7,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:runtime,data,executable-data,construct-independent,V:2.0-2.7\n      LOGICAL FUNCTION test1()\n        USE OPENACC\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT):: a, b, c !Data\n        REAL(8) :: RAND\n        INTEGER :: errors = 0\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n        CALL RANDOM_NUMBER(a)\n        CALL RANDOM_NUMBER(b)\n        c = 0\n        CALL acc_copyin(a(1), LOOPCOUNT*8)\n        CALL acc_copyin(b(1), LOOPCOUNT*8)\n        !$acc data copy(c(1:LOOPCOUNT))\n          !$acc parallel present(a(1:LOOPCOUNT), b(1:LOOPCOUNT))\n            !$acc Loop\n            DO x = 1, LOOPCOUNT\n              c(x) = a(x) + b(x)\n            END DO\n          !$acc end parallel\n        !$acc end data\n\n        CALL acc_copyout(a(1:LOOPCOUNT))\n        CALL acc_copyout(b(1:LOOPCOUNT))\n\n        DO x = 1, LOOPCOUNT\n          IF (abs(c(x) - (a(x) + b(x))) .gt. PRECISION) THEN\n            errors = errors + 1\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END FUNCTION\n#endif\n#ifndef T1\n      LOGICAL :: test1\n#endif\n#ifndef T1\n      DO testrun = 1, NUM_TEST_CALLS\n        failed = failed .or. test1()\n      END DO\n      IF (failed) THEN\n        failcode = failcode + 2 ** 0\n        failed = .FALSE.\n      END IF\n#endif\n",
                        "tags": [
                            "runtime",
                            "data",
                            "executable-data",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "2": {
                        "content": "#ifndef T2\n!T2:runtime,data,executable-data,construct-independent,V:2.0-2.7\n      LOGICAL FUNCTION test2()\n        USE OPENACC\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT):: a, b, c !Data\n        REAL(8) :: RAND\n        INTEGER :: errors = 0\n\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n        CALL RANDOM_NUMBER(a)\n        CALL RANDOM_NUMBER(b)\n        c = 0\n\n        CALL acc_copyin(a(1), LOOPCOUNT*8)\n        CALL acc_copyin(b(1), LOOPCOUNT*8)\n        !$acc data copy(c(1:LOOPCOUNT))\n          !$acc parallel present(a(1:LOOPCOUNT), b(1:LOOPCOUNT))\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              c(x) = a(x) + b(x)\n            END DO\n          !$acc end parallel\n        !$acc end data\n\n        !$acc exit data copyout(a(1:LOOPCOUNT), b(1:LOOPCOUNT))\n\n        DO x = 1, LOOPCOUNT\n          IF (abs(c(x) - (a(x) + b(x))) .gt. PRECISION) THEN\n            errors = errors + 1\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test2 = .FALSE.\n        ELSE\n          test2 = .TRUE.\n        END IF\n      END FUNCTION\n#endif\n#ifndef T2\n      LOGICAL :: test2\n#endif\n#ifndef T2\n      DO testrun = 1, NUM_TEST_CALLS\n        failed = failed .or. test2()\n      END DO\n      IF (failed) THEN\n        failcode = failcode + 2 ** 1\n        failed = .FALSE.\n      END IF\n#endif\n",
                        "tags": [
                            "runtime",
                            "data",
                            "executable-data",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "3": {
                        "content": "#ifndef T3\n!T3:runtime,data,executable-data,devonly,construct-independent,V:2.5-2.7\n      LOGICAL FUNCTION test3()\n        USE OPENACC\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT):: a, b, c, a_copy, b_copy !Data\n        REAL(8) :: RAND\n        INTEGER :: errors = 0\n        INTEGER,DIMENSION(1) :: devtest\n\n        devtest(1) = 1\n        !$acc enter data copyin(devtest(1:1))\n        !$acc parallel present(devtest(1:1))\n          devtest(1) = 0\n        !$acc end parallel\n\n        IF (devtest(1) .eq. 1) THEN\n          SEEDDIM(1) = 1\n#         ifdef SEED\n          SEEDDIM(1) = SEED\n#         endif\n          CALL RANDOM_SEED(PUT=SEEDDIM)\n          CALL RANDOM_NUMBER(a)\n          CALL RANDOM_NUMBER(b)\n          a_copy = a\n          b_copy = b\n          c = 0\n\n          CALL acc_copyin(a(1), LOOPCOUNT*8)\n          CALL acc_copyin(b(1), LOOPCOUNT*8)\n\n          a = 0\n          b = 0\n\n          !$acc data copyin(a(1:LOOPCOUNT), b(1:LOOPCOUNT)) copy(c(1:LOOPCOUNT))\n            !$acc parallel\n              !$acc loop\n              DO x = 1, LOOPCOUNT\n                c(x) = a(x) + b(x)\n              END DO\n            !$acc end parallel\n          !$acc end data\n\n          CALL acc_copyout(a(1:LOOPCOUNT))\n          CALL acc_copyout(b(1:LOOPCOUNT))\n\n          DO x = 1, LOOPCOUNT\n            IF (abs(a(x) - a_copy(x)) .gt. PRECISION) THEN\n              errors = errors + 1\n            END IF\n            IF (abs(b(x) - b_copy(x)) .gt. PRECISION) THEN\n              errors = errors + 1\n            END IF\n            IF (abs(c(x) - (a(x) + b(x))) .gt. PRECISION) THEN\n              errors = errors + 1\n            END IF\n          END DO\n        END IF\n\n        IF (errors .eq. 0) THEN\n          test3 = .FALSE.\n        ELSE\n          test3 = .TRUE.\n        END IF\n      END FUNCTION\n#endif\n#ifndef T3\n      LOGICAL :: test3\n#endif\n#ifndef T3\n      DO testrun = 1, NUM_TEST_CALLS\n        failed = failed .or. test3()\n      END DO\n      IF (failed) THEN\n        failcode = failcode + 2 ** 2\n        failed = .FALSE.\n      END IF\n#endif\n",
                        "tags": [
                            "runtime",
                            "data",
                            "executable-data",
                            "devonly",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "4": {
                        "content": "#ifndef T4\n!T4:runtime,compatibility-features,construct-independent,V:2.0-2.7\n      LOGICAL FUNCTION test4()\n        USE OPENACC\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT):: a, b, c !Data\n        REAL(8) :: RAND\n        INTEGER :: errors = 0\n\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n        CALL RANDOM_NUMBER(a)\n        CALL RANDOM_NUMBER(b)\n        c = 0\n\n        CALL acc_pcopyin(a(1), LOOPCOUNT*8)\n        CALL acc_pcopyin(b(1), LOOPCOUNT*8)\n\n        !$acc data copyout(c(1:LOOPCOUNT)) present(a(1:LOOPCOUNT), b(1:LOOPCOUNT))\n          !$acc parallel\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              c(x) = a(x) + b(x)\n            END DO\n          !$acc end parallel\n        !$acc end data\n\n        !$acc exit data delete(a(1:LOOPCOUNT), b(1:LOOPCOUNT))\n\n        DO x = 1, LOOPCOUNT\n          IF (abs(c(x) - (a(x) + b(x))) .gt. PRECISION) THEN\n            errors = errors + 1\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test4 = .FALSE.\n        ELSE\n          test4 = .TRUE.\n        END IF\n      END FUNCTION\n#endif\n#ifndef T4\n      LOGICAL :: test4\n#endif\n#ifndef T4\n      DO testrun = 1, NUM_TEST_CALLS\n        failed = failed .or. test4()\n      END DO\n      IF (failed) THEN\n        failcode = failcode + 2 ** 3\n        failed = .FALSE.\n      END IF\n#endif\n",
                        "tags": [
                            "runtime",
                            "compatibility-features",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "5": {
                        "content": "#ifndef T5\n!T5:runtime,compatibility-features,construct-independent,V:2.0-2.7\n      LOGICAL FUNCTION test5()\n        USE OPENACC\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT):: a, b, c !Data\n        REAL(8) :: RAND\n        INTEGER :: errors = 0\n\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n        CALL RANDOM_NUMBER(a)\n        CALL RANDOM_NUMBER(b)\n        c = 0\n\n        CALL acc_present_or_copyin(a(1), LOOPCOUNT*8)\n        CALL acc_present_or_copyin(b(1), LOOPCOUNT*8)\n\n        !$acc data copyout(c(1:LOOPCOUNT)) present(a(1:LOOPCOUNT), b(1:LOOPCOUNT))\n          !$acc parallel\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              c(x) = a(x) + b(x)\n            END DO\n          !$acc end parallel\n        !$acc end data\n\n        !$acc exit data delete(a(1:LOOPCOUNT), b(1:LOOPCOUNT))\n\n        DO x = 1, LOOPCOUNT\n          IF (abs(c(x) - (a(x) + b(x))) .gt. PRECISION) THEN\n            errors = errors + 1\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test5 = .FALSE.\n        ELSE\n          test5 = .TRUE.\n        END IF\n      END FUNCTION\n#endif\n#ifndef T5\n      LOGICAL :: test5\n#endif\n#ifndef T5\n      DO testrun = 1, NUM_TEST_CALLS\n        failed = failed .or. test5()\n      END DO\n      IF (failed) THEN\n        failcode = failcode + 2 ** 4\n        failed = .FALSE.\n      END IF\n#endif\n",
                        "tags": [
                            "runtime",
                            "compatibility-features",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "6": {
                        "content": "#ifndef T6\n!T6:runtime,data,executable-data,construct-independent,reference-counting,V:2.5-2.7\n      LOGICAL FUNCTION test6()\n        USE OPENACC\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT):: a, b, c !Data\n        REAL(8) :: RAND\n        INTEGER :: errors = 0\n\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n        CALL RANDOM_NUMBER(a)\n        CALL RANDOM_NUMBER(b)\n        c = 0\n\n        CALL acc_copyin(a(1), LOOPCOUNT*8)\n        CALL acc_copyin(a(1), LOOPCOUNT*8)\n        CALL acc_copyin(b(1), LOOPCOUNT*8)\n        CALL acc_copyin(b(1), LOOPCOUNT*8)\n\n        !$acc data copyout(c(1:LOOPCOUNT))\n          !$acc parallel present(a(1:LOOPCOUNT), b(1:LOOPCOUNT))\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              c(x) = a(x) + b(x)\n            END DO\n          !$acc end parallel\n        !$acc end data\n\n        !$acc exit data delete(a(1:LOOPCOUNT), b(1:LOOPCOUNT))\n        !$acc exit data delete(a(1:LOOPCOUNT), b(1:LOOPCOUNT))\n\n        DO x = 1, LOOPCOUNT\n          IF (abs(c(x) + (a(x) + b(x))) .gt. PRECISION) THEN\n            errors = errors + 1\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test6 = .FALSE.\n        ELSE\n          test6 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T6\n      LOGICAL :: test6\n#endif\n#ifndef T6\n      DO testrun = 1, NUM_TEST_CALLS\n        failed = failed .or. test6()\n      END DO\n      IF (failed) THEN\n        failcode = failcode + 2 ** 5\n        failed = .FALSE.\n      END IF\n#endif\n",
                        "tags": [
                            "runtime",
                            "data",
                            "executable-data",
                            "construct-independent",
                            "reference-counting"
                        ],
                        "versions": [
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "7": {
                        "content": "#ifndef T7\n!T7:runtime,data,executable-data,construct-independent,reference-counting,devonly,V:2.5-2.7\n      LOGICAL FUNCTION test7()\n        USE OPENACC\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT):: a, b, c, a_copy, b_copy !Data\n        REAL(8) :: RAND\n        INTEGER :: errors = 0\n        LOGICAL,DIMENSION(1):: devtest\n\n        devtest(1) = .TRUE.\n        !$acc enter data copyin(devtest(1:1))\n        !$acc parallel present(devtest(1:1))\n          devtest(1) = .FALSE.\n        !$acc end parallel\n\n        IF (devtest(1) .eqv. .TRUE.) THEN\n          SEEDDIM(1) = 1\n#         ifdef SEED\n          SEEDDIM(1) = SEED\n#         endif\n          CALL RANDOM_SEED(PUT=SEEDDIM)\n          CALL RANDOM_NUMBER(a)\n          CALL RANDOM_NUMBER(b)\n          c = 0\n          a_copy = a\n          b_copy = b\n\n          CALL acc_copyin(a(1), LOOPCOUNT*8)\n          CALL acc_copyin(b(1), LOOPCOUNT*8)\n\n          a = 0\n          b = 0\n\n          CALL acc_copyin(a(1), LOOPCOUNT*8)\n          CALL acc_copyin(b(1), LOOPCOUNT*8)\n\n          !$acc data copyout(c(1:LOOPCOUNT))\n            !$acc parallel present(a(1:LOOPCOUNT), b(1:LOOPCOUNT))\n              !$acc loop\n              DO x = 1, LOOPCOUNT\n                c(x) = a(x) + b(x)\n              END DO\n            !$acc end parallel\n          !$acc end data\n\n          !$acc exit data delete(a(1:LOOPCOUNT), b(1:LOOPCOUNT))\n          !$acc exit data delete(a(1:LOOPCOUNT), b(1:LOOPCOUNT))\n\n          DO x = 1, LOOPCOUNT\n            IF (abs(c(x) - (a(x) + b(x))) .gt. PRECISION) THEN\n              errors = errors + 1\n            END IF\n          END DO\n        END IF\n        IF (errors .eq. 0) THEN\n          test7 = .FALSE.\n        ELSE\n          test7 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T7\n      LOGICAL :: test7\n#endif\n#ifndef T7\n      DO testrun = 1, NUM_TEST_CALLS\n        failed = failed .or. test7()\n      END DO\n      IF (failed) THEN\n        failcode = failcode + 2 ** 6\n        failed = .FALSE.\n      END IF\n#endif\n",
                        "tags": [
                            "runtime",
                            "data",
                            "executable-data",
                            "construct-independent",
                            "reference-counting",
                            "devonly"
                        ],
                        "versions": [
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "acc_copyout.F90": {
                "num tests": 5,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:runtime,data,executable-data,construct-independent,V:2.0-2.7\n      LOGICAL FUNCTION test1()\n        USE OPENACC\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT):: a, b, c !Data\n        INTEGER :: errors = 0\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n        CALL RANDOM_NUMBER(a)\n        CALL RANDOM_NUMBER(b)\n        c = 0\n\n        CALL acc_create(c(1:LOOPCOUNT))\n\n        !$acc data copyin(a(1:LOOPCOUNT), b(1:LOOPCOUNT)) present(c(1:LOOPCOUNT))\n          !$acc parallel\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              c(x) = a(x) + b(x)\n            END DO\n          !$acc end parallel\n        !$acc end data\n\n        CALL acc_copyout(c(1:LOOPCOUNT))\n\n        DO x = 1, LOOPCOUNT\n          IF (abs(c(x) - (a(x) + b(x))) .gt. PRECISION) THEN\n            errors = errors + 1\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END FUNCTION\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "runtime",
                            "data",
                            "executable-data",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "2": {
                        "content": "#ifndef T2\n!T2:runtime,data,executable-data,construct-independent,V:2.0-2.7\n      LOGICAL FUNCTION test2()\n        USE OPENACC\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x\n        REAL(8),DIMENSION(LOOPCOUNT):: a, b, c\n        INTEGER :: errors = 0\n\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n        CALL RANDOM_NUMBER(a)\n        CALL RANDOM_NUMBER(b)\n        c = 0\n\n        !$acc enter data create(c(1:LOOPCOUNT))\n\n        !$acc data copyin(a(1:LOOPCOUNT), b(1:LOOPCOUNT)) present(c(1:LOOPCOUNT))\n          !$acc parallel\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              c(x) = a(x) + b(x)\n            END DO\n          !$acc end parallel\n        !$acc end data\n\n        CALL acc_copyout(c(1:LOOPCOUNT))\n\n        DO x = 1, LOOPCOUNT\n          IF (abs(c(x) - (a(x) + b(x))) .gt. PRECISION) THEN\n            errors = errors + 1\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test2 = .FALSE.\n        ELSE\n          test2 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T2\n        LOGICAL :: test2\n#endif\n#ifndef T2\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test2()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 1\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "runtime",
                            "data",
                            "executable-data",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "3": {
                        "content": "#ifndef T3\n!T3:runtime,data,executable-data,construct-independent,devonly,reference-counting,V:2.5-2.7\n      LOGICAL FUNCTION test3()\n        USE OPENACC\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x\n        REAL(8),DIMENSION(LOOPCOUNT):: a, b, c\n        INTEGER :: errors = 0\n        LOGICAL,DIMENSION(1):: devtest\n\n        devtest(1) = .TRUE.\n        !$acc enter data copyin(devtest(1:1))\n        !$acc parallel present(devtest(1:1))\n          devtest(1) = .FALSE.\n        !$acc end parallel\n\n        IF (devtest(1) .eqv. .TRUE.) THEN\n          SEEDDIM(1) = 1\n#         ifdef SEED\n          SEEDDIM(1) = SEED\n#         endif\n          CALL RANDOM_SEED(PUT=SEEDDIM)\n          CALL RANDOM_NUMBER(a)\n          CALL RANDOM_NUMBER(b)\n          c = 0\n\n          !$acc enter data copyin(c(1:LOOPCOUNT))\n          !$acc data copyin(a(1:LOOPCOUNT), b(1:LOOPCOUNT), c(1:LOOPCOUNT))\n            !$acc parallel\n              !$acc loop\n              DO x = 1, LOOPCOUNT\n                c(x) = a(x) + b(x)\n              END DO\n            !$acc end parallel\n            CALL acc_copyout(c(1:LOOPCOUNT))\n          !$acc end data\n\n          DO x = 1, LOOPCOUNT\n            IF (abs(c(x)) .gt. PRECISION) THEN\n              errors = errors + 1\n            END IF\n          END DO\n        END IF\n\n        IF (errors .eq. 0) THEN\n          test3 = .FALSE.\n        ELSE\n          test3 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T3\n        LOGICAL :: test3\n#endif\n#ifndef T3\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test3()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 2\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "runtime",
                            "data",
                            "executable-data",
                            "construct-independent",
                            "devonly",
                            "reference-counting"
                        ],
                        "versions": [
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "4": {
                        "content": "#ifndef T4\n!T4:runtime,data,executable-data,construct-independent,reference-counting,V:2.5-2.7\n      LOGICAL FUNCTION test4()\n        USE OPENACC\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x\n        REAL(8),DIMENSION(LOOPCOUNT):: a, b, c\n        INTEGER :: errors = 0\n\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n        CALL RANDOM_NUMBER(a)\n        CALL RANDOM_NUMBER(b)\n        c = 0\n\n        !$acc enter data create(c(1:LOOPCOUNT))\n        !$acc enter data create(c(1:LOOPCOUNT))\n        !$acc data copyin(a(1:LOOPCOUNT), b(1:LOOPCOUNT)) present(c(1:LOOPCOUNT))\n          !$acc parallel\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              c(x) = a(x) + b(x)\n            END DO\n          !$acc end parallel\n        !$acc end data\n        !$acc exit data delete(c(1:LOOPCOUNT))\n        CALL acc_copyout(c(1:LOOPCOUNT))\n\n        DO x = 1, LOOPCOUNT\n          IF (abs(c(x) - (a(x) + b(x))) .gt. PRECISION) THEN\n            errors = errors + 1\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test4 = .FALSE.\n        ELSE\n          test4 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T4\n        LOGICAL :: test4\n#endif\n#ifndef T4\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test4()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 3\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "runtime",
                            "data",
                            "executable-data",
                            "construct-independent",
                            "reference-counting"
                        ],
                        "versions": [
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "5": {
                        "content": "#ifndef T5\n!T5:runtime,data,executable-data,construct-independent,reference-counting,devonly,V:2.5-2.7\n      LOGICAL FUNCTION test5()\n        USE OPENACC\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x\n        REAL(8),DIMENSION(LOOPCOUNT):: a, b, c\n        INTEGER :: errors = 0\n        LOGICAL,DIMENSION(1):: devtest\n        devtest(1) = .TRUE.\n\n        !$acc enter data copyin(devtest(1:1))\n        !$acc parallel present(devtest(1:1))\n          devtest(1) = .FALSE.\n        !$acc end parallel\n\n        IF (devtest(1) .eqv. .TRUE.) THEN\n          SEEDDIM(1) = 1\n#         ifdef SEED\n          SEEDDIM(1) = SEED\n#         endif\n          CALL RANDOM_SEED(PUT=SEEDDIM)\n          CALL RANDOM_NUMBER(a)\n          CALL RANDOM_NUMBER(b)\n          c = 0\n\n          !$acc enter data create(c(1:LOOPCOUNT))\n          !$acc enter data create(c(1:LOOPCOUNT))\n          !$acc data copyin(a(1:LOOPCOUNT), b(1:LOOPCOUNT)) present(c(1:LOOPCOUNT))\n            !$acc parallel\n              !$acc loop\n              DO x = 1, LOOPCOUNT\n                c(x) = a(x) + b(x)\n              END DO\n            !$acc end parallel\n          !$acc end data\n          CALL acc_copyout(c(1:LOOPCOUNT))\n          !$acc exit data delete(c(1:LOOPCOUNT))\n\n          DO x = 1, LOOPCOUNT\n            IF (abs(c(x)) .gt. PRECISION) THEN\n              errors = errors + 1\n            END IF\n          END DO\n        END IF\n\n        IF (errors .eq. 0) THEN\n          test5 = .FALSE.\n        ELSE\n          test5 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T5\n        LOGICAL :: test5\n#endif\n#ifndef T5\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test5()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 4\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "runtime",
                            "data",
                            "executable-data",
                            "construct-independent",
                            "reference-counting",
                            "devonly"
                        ],
                        "versions": [
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "acc_copyout.c": {
                "num tests": 2,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:runtime,data,executable-data,construct-independent,V:2.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n    real_t * c = (real_t *)malloc(n * sizeof(real_t));\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n        c[x] = 0;\n    }\n\n    acc_create(c, n * sizeof(real_t));\n\n    #pragma acc data copyin(a[0:n], b[0:n]) present(c[0:n])\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                c[x] = a[x] + b[x];\n            }\n        }\n    }\n\n    acc_copyout(c, n * sizeof(real_t));\n\n    for (int x = 0; x < n; ++x){\n        if (fabs(c[x] - (a[x] + b[x])) > PRECISION){\n            err += 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "runtime",
                            "data",
                            "executable-data",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "2": {
                        "content": "#ifndef T2\n//T2:runtime,data,executable-data,construct-independent,V:2.0-2.7\nint test2(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n    real_t * c = (real_t *)malloc(n * sizeof(real_t));\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n        c[x] = 0;\n    }\n\n    #pragma acc enter data create(c[0:n])\n\n    #pragma acc data copyin(a[0:n], b[0:n]) present(c[0:n])\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                c[x] = a[x] + b[x];\n            }\n        }\n    }\n\n    acc_copyout(c, n * sizeof(real_t));\n\n    for (int x = 0; x < n; ++x){\n        if (fabs(c[x] - (a[x] + b[x])) > PRECISION){\n            err += 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T2\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test2();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 1);\n    }\n#endif\n",
                        "tags": [
                            "runtime",
                            "data",
                            "executable-data",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "acc_copyout_async.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:runtime,data,executable-data,async,construct-independent,V:2.5-2.7\n      LOGICAL FUNCTION test1()\n        USE OPENACC\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.fh\"\n        INTEGER :: x !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT):: a, b, c, d, e, f !Data\n        REAL(8) :: RAND\n        INTEGER :: errors = 0\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n        CALL RANDOM_NUMBER(a)\n        CALL RANDOM_NUMBER(b)\n        c = 0\n        CALL RANDOM_NUMBER(d)\n        CALL RANDOM_NUMBER(e)\n        f = 0\n\n        !$acc enter data create(c(1:LOOPCOUNT), f(1:LOOPCOUNT))\n\n        !$acc data copyin(a(1:LOOPCOUNT), b(1:LOOPCOUNT), d(1:LOOPCOUNT), e(1:LOOPCOUNT)) present(c(1:LOOPCOUNT), f(1:LOOPCOUNT))\n          !$acc parallel async(1)\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              c(x) = a(x) + b(x)\n            END DO\n          !$acc end parallel\n          !$acc parallel async(2)\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              f(x) = d(x) + e(x)\n            END DO\n          !$acc end parallel\n          CALL acc_copyout_async(c(1:LOOPCOUNT), 1)\n          CALL acc_copyout_async(f(1:LOOPCOUNT), 2)\n        !$acc end data\n        !$acc wait\n        DO x = 1, LOOPCOUNT\n          IF (abs(c(x) - (a(x) + b(x))) .gt. PRECISION) THEN\n            errors = errors + 1\n          END IF\n          IF (abs(f(x) - (d(x) + e(x))) .gt. PRECISION) THEN\n            errors = errors + 1\n          END IF\n        END DO\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n      LOGICAL :: test1\n#endif\n#ifndef T1\n      DO testrun = 1, NUM_TEST_CALLS\n        failed = failed .or. test1()\n      END DO\n      IF (failed) THEN\n        failcode = failcode + 2 ** 0\n        failed = .FALSE.\n      END IF\n#endif\n",
                        "tags": [
                            "runtime",
                            "data",
                            "executable-data",
                            "async",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "acc_copyout_async.c": {
                "num tests": 4,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:runtime,data,executable-data,async,construct-independent,V:2.5-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t *a = (real_t *)malloc(n * sizeof(real_t));\n    real_t *b = (real_t *)malloc(n * sizeof(real_t));\n    real_t *c = (real_t *)malloc(n * sizeof(real_t));\n    real_t *d = (real_t *)malloc(n * sizeof(real_t));\n    real_t *e = (real_t *)malloc(n * sizeof(real_t));\n    real_t *f = (real_t *)malloc(n * sizeof(real_t));\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n        c[x] = 0;\n        d[x] = rand() / (real_t)(RAND_MAX / 10);\n        e[x] = rand() / (real_t)(RAND_MAX / 10);\n        f[x] = 0;\n    }\n\n    #pragma acc enter data create(c[0:n], f[0:n])\n\n    #pragma acc data copyin(a[0:n], b[0:n], d[0:n], e[0:n])\n    {\n        #pragma acc parallel async(1) present(c[0:n])\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                c[x] = a[x] + b[x];\n            }\n        }\n        #pragma acc parallel async(2) present(f[0:n])\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                f[x] = d[x] + e[x];\n            }\n        }\n        acc_copyout_async(c, n * sizeof(real_t), 1);\n        acc_copyout_async(f, n * sizeof(real_t), 2);\n        #pragma acc wait\n    }\n\n    for (int x = 0; x < n; ++x){\n        if (fabs(c[x] - (a[x] + b[x])) > PRECISION){\n            err += 1;\n        }\n        if (fabs(f[x] - (d[x] + e[x])) > PRECISION){\n            err += 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "runtime",
                            "data",
                            "executable-data",
                            "async",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "2": {
                        "content": "#ifndef T2\n//T2:runtime,async,data,executable-data,internal-control-values,construct-independent,V:2.5-2.7\nint test2(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n    real_t * c = (real_t *)malloc(n * sizeof(real_t));\n    int def_async_var = acc_get_default_async();\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n        c[x] = 0;\n    }\n\n    #pragma acc enter data create(c[0:n])\n\n    #pragma acc data copyin(a[0:n], b[0:n])\n    {\n        #pragma acc parallel present(c[0:n]) async\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x) {\n                c[x] = a[x] + b[x];\n            }\n        }\n        acc_copyout_async(c, n * sizeof(real_t), def_async_var);\n        #pragma acc wait\n    }\n\n    for (int x = 0; x < n; ++x) {\n        if (fabs(c[x] - (a[x] + b[x])) > PRECISION) {\n            err += 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T2\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test2();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 1);\n    }\n#endif\n",
                        "tags": [
                            "runtime",
                            "async",
                            "data",
                            "executable-data",
                            "internal-control-values",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "3": {
                        "content": "#ifndef T3\n//T3:runtime,async,data,executable-data,internal-control-values,construct-independent,V:2.5-2.7\nint test3(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n    real_t * c = (real_t *)malloc(n * sizeof(real_t));\n    int def_async_var = acc_get_default_async();\n\n    acc_set_default_async(def_async_var + 1);\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n        c[x] = 0;\n    }\n    \n    #pragma acc enter data create(c[0:n])\n    #pragma acc data copyin(a[0:n], b[0:n])\n    {\n        #pragma acc parallel present(c[0:n]) async\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x) {\n                c[x] = a[x] + b[x];\n            }\n        }\n        acc_copyout_async(c, n * sizeof(real_t), def_async_var + 1);\n        #pragma acc wait\n    }\n\n    for (int x = 0; x < n; ++x) {\n        if (fabs(c[x] - (a[x] + b[x])) > PRECISION) {\n            err += 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T3\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test3();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 2);\n    }\n#endif\n",
                        "tags": [
                            "runtime",
                            "async",
                            "data",
                            "executable-data",
                            "internal-control-values",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "4": {
                        "content": "#ifndef T4\n//T4:runtime,async,data,executable-data,construct-independent,V:2.5-2.7\nint test4(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n    real_t * c = (real_t *)malloc(n * sizeof(real_t));\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n        c[x] = 0;\n    }\n\n    #pragma acc enter data create(c[0:n])\n    #pragma acc data copyin(a[0:n], b[0:n])\n    {\n        #pragma acc parallel present(c[0:n]) async(1)\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x) {\n                c[x] = a[x] + b[x];\n            }\n        }\n        #pragma acc enter data copyin(c[0:n])\n        acc_copyout_async(c, n * sizeof(real_t), 1);\n        #pragma acc parallel present(c[0:n]) async(1)\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x) {\n                c[x] += a[x] + b[x];\n            }\n        }\n        acc_copyout_async(c, n * sizeof(real_t), 1);\n    }\n    \n    for (int x = 0; x < n; ++x) {\n        if (fabs(c[x] - (2 * (a[x] + b[x]))) > PRECISION) {\n            err += 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T4\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test4();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 3);\n    }\n#endif\n",
                        "tags": [
                            "runtime",
                            "async",
                            "data",
                            "executable-data",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "acc_copyout_async_with_len.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:runtime,data,executable-data,async,construct-independent,V:2.5-2.7\n      LOGICAL FUNCTION test1()\n        USE OPENACC\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.fh\"\n        INTEGER :: x !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT):: a, b, c, d, e, f !Data\n        REAL(8) :: RAND\n        INTEGER :: errors = 0\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n        CALL RANDOM_NUMBER(a)\n        CALL RANDOM_NUMBER(b)\n        c = 0\n        CALL RANDOM_NUMBER(d)\n        CALL RANDOM_NUMBER(e)\n        f = 0\n\n        !$acc enter data create(c(1:LOOPCOUNT), f(1:LOOPCOUNT))\n\n        !$acc data copyin(a(1:LOOPCOUNT), b(1:LOOPCOUNT), d(1:LOOPCOUNT), e(1:LOOPCOUNT)) present(c(1:LOOPCOUNT), f(1:LOOPCOUNT))\n          !$acc parallel async(1)\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              c(x) = a(x) + b(x)\n            END DO\n          !$acc end parallel\n          !$acc parallel async(2)\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              f(x) = d(x) + e(x)\n            END DO\n          !$acc end parallel\n          CALL acc_copyout_async(c(1), LOOPCOUNT*8, 1)\n          CALL acc_copyout_async(f(1), LOOPCOUNT*8, 2)\n        !$acc end data\n\n        DO x = 1, LOOPCOUNT\n          IF (abs(c(x) - (a(x) + b(x))) .gt. PRECISION) THEN\n            errors = errors + 1\n          END IF\n          IF (abs(f(x) - (d(x) + e(x))) .gt. PRECISION) THEN\n            errors = errors + 1\n          END IF\n        END DO\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "runtime",
                            "data",
                            "executable-data",
                            "async",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "acc_copyout_finalize.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:runtime,data,executable-data,construct-independent,V:2.5-2.7\n      LOGICAL FUNCTION test1()\n        USE OPENACC\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.fh\"\n        INTEGER :: x !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT):: a, b, c !Data\n        INTEGER :: errors = 0\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n        CALL RANDOM_NUMBER(a)\n        CALL RANDOM_NUMBER(b)\n        c = 0\n\n        !$acc enter data create(c(1:LOOPCOUNT))\n        !$acc enter data create(c(1:LOOPCOUNT))\n\n        !$acc data copyin(a(1:LOOPCOUNT), b(1:LOOPCOUNT)) present(c(1:LOOPCOUNT))\n          !$acc parallel\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              c(x) = a(x) + b(x)\n            END DO\n          !$acc end parallel\n        !$acc end data\n\n        CALL acc_copyout_finalize(c(1:LOOPCOUNT))\n\n        DO x = 1, LOOPCOUNT\n          IF (abs(c(x) - (a(x) + b(x))) .gt. PRECISION) THEN\n            errors = errors + 1\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "runtime",
                            "data",
                            "executable-data",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "acc_copyout_finalize.c": {
                "num tests": 3,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:runtime,data,executable-data,construct-independent,reference-counting,V:2.5-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t *a = (real_t *)malloc(n * sizeof(real_t));\n    real_t *b = (real_t *)malloc(n * sizeof(real_t));\n    real_t *c = (real_t *)malloc(n * sizeof(real_t));\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n        c[x] = 0;\n    }\n\n    #pragma acc enter data create(c[0:n])\n    #pragma acc enter data create(c[0:n])\n\n    #pragma acc data copyin(a[0:n], b[0:n]) present(c[0:n])\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                c[x] = a[x] + b[x];\n            }\n        }\n    }\n    acc_copyout_finalize(c, n * sizeof(real_t));\n\n    for (int x = 0; x < n; ++x){\n        if (fabs(c[x] - (a[x] + b[x])) > PRECISION){\n            err += 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "runtime",
                            "data",
                            "executable-data",
                            "construct-independent",
                            "reference-counting"
                        ],
                        "versions": [
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "2": {
                        "content": "#ifndef T2\n//T2:runtime,data,executable-data,construct-independent,reference-counting,V:2.5-2.7\nint test2(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n    real_t * c = (real_t *)malloc(n * sizeof(real_t));\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n        c[x] = 0;\n    }\n\n    #pragma acc enter data copyin(c[0:n])\n    #pragma acc data copyin(a[0:n], b[0:n])\n    {\n        #pragma acc parallel present(a[0:n], b[0:n])\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x) {\n                c[x] = a[x] + b[x];\n            }\n        }\n    }\n    acc_copyout_finalize(c, n * sizeof(real_t));\n\n    for (int x = 0; x < n; ++x) {\n        if (fabs(c[x] - (a[x] + b[x])) > PRECISION) {\n            err += 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T2\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test2();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 1);\n    }\n#endif\n",
                        "tags": [
                            "runtime",
                            "data",
                            "executable-data",
                            "construct-independent",
                            "reference-counting"
                        ],
                        "versions": [
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "3": {
                        "content": "#ifndef T3\n//T3:runtime,data,executable-data,construct-independent,reference-counting,V:2.5-2.7\nint test3(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n    real_t * c = (real_t *)malloc(n * sizeof(real_t));\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n        c[x] = 0;\n    }\n\n    #pragma acc enter data copyin(c[0:n])\n    #pragma acc enter data copyin(c[0:n])\n    #pragma acc data copyin(a[0:n], b[0:n])\n    {\n        #pragma acc parallel present(c[0:n])\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x) {\n                c[x] = a[x] + b[x];\n            }\n        }\n        acc_copyout_finalize(c, n * sizeof(real_t));\n        #pragma acc enter data copyin(c[0:n])\n        #pragma acc parallel present(c[0:n])\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x) {\n                c[x] += a[x] + b[x];\n            }\n        }\n    }\n    #pragma acc exit data copyout(c[0:n])\n\n    for (int x = 0; x < n; ++x) {\n        if (fabs(c[x] - (2 * (a[x] + b[x]))) > PRECISION) {\n            err += 1;\n        }\n    }\n    \n\n    return err;\n}\n#endif\n#ifndef T3\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test3();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 2);\n    }\n#endif\n",
                        "tags": [
                            "runtime",
                            "data",
                            "executable-data",
                            "construct-independent",
                            "reference-counting"
                        ],
                        "versions": [
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "acc_copyout_finalize_async.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:runtime,data,executable-data,async,construct-independent,V:2.5-2.7\n      LOGICAL FUNCTION test1()\n        USE OPENACC\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.fh\"\n        INTEGER :: x !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT):: a, b, c, d, e, f !Data\n        REAL(8) :: RAND\n        INTEGER :: errors = 0\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n        CALL RANDOM_NUMBER(a)\n        CALL RANDOM_NUMBER(b)\n        c = 0\n        CALL RANDOM_NUMBER(d)\n        CALL RANDOM_NUMBER(e)\n        f = 0\n\n        !$acc enter data create(c(1:LOOPCOUNT), f(1:LOOPCOUNT))\n        !$acc enter data create(c(1:LOOPCOUNT), f(1:LOOPCOUNT))\n\n        !$acc data copyin(a(1:LOOPCOUNT), b(1:LOOPCOUNT), d(1:LOOPCOUNT), e(1:LOOPCOUNT)) present(c(1:LOOPCOUNT), f(1:LOOPCOUNT))\n          !$acc parallel async(1)\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              c(x) = a(x) + b(x)\n            END DO\n          !$acc end parallel\n          !$acc parallel async(2)\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              f(x) = d(x) + e(x)\n            END DO\n          !$acc end parallel\n          CALL acc_copyout_finalize_async(c(1:LOOPCOUNT), 1)\n          CALL acc_copyout_finalize_async(f(1:LOOPCOUNT), 2)\n          !$acc wait\n        !$acc end data\n\n        DO x = 1, LOOPCOUNT\n          IF (abs(c(x) - (a(x) + b(x))) .gt. PRECISION) THEN\n            errors = errors + 1\n          END IF\n          IF (abs(f(x) - (d(x) + e(x))) .gt. PRECISION) THEN\n            errors = errors + 1\n          END IF\n        END DO\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n      LOGICAL :: test1\n#endif\n#ifndef T1\n      DO testrun = 1, NUM_TEST_CALLS\n        failed = failed .or. test1()\n      END DO\n      IF (failed) THEN\n        failcode = failcode + 2 ** 0\n        failed = .FALSE.\n      END IF\n#endif\n",
                        "tags": [
                            "runtime",
                            "data",
                            "executable-data",
                            "async",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "acc_copyout_finalize_async.c": {
                "num tests": 4,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:runtime,data,executable-data,async,construct-independent,reference-counting,V:2.5-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t *a = (real_t *)malloc(n * sizeof(real_t));\n    real_t *b = (real_t *)malloc(n * sizeof(real_t));\n    real_t *c = (real_t *)malloc(n * sizeof(real_t));\n    real_t *d = (real_t *)malloc(n * sizeof(real_t));\n    real_t *e = (real_t *)malloc(n * sizeof(real_t));\n    real_t *f = (real_t *)malloc(n * sizeof(real_t));\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n        c[x] = 0;\n        d[x] = rand() / (real_t)(RAND_MAX / 10);\n        e[x] = rand() / (real_t)(RAND_MAX / 10);\n        f[x] = 0;\n    }\n\n    #pragma acc enter data create(c[0:n], f[0:n])\n    #pragma acc enter data create(c[0:n], f[0:n])\n\n    #pragma acc data copyin(a[0:n], b[0:n], d[0:n], e[0:n]) present(c[0:n], f[0:n])\n    {\n        #pragma acc parallel async(1)\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                c[x] = a[x] + b[x];\n            }\n        }\n        #pragma acc parallel async(2)\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                f[x] = d[x] + e[x];\n            }\n        }\n        acc_copyout_finalize_async(c, n * sizeof(real_t), 1);\n        acc_copyout_finalize_async(f, n * sizeof(real_t), 2);\n        #pragma acc wait\n    }\n\n    for (int x = 0; x < n; ++x){\n        if (fabs(c[x] - (a[x] + b[x])) > PRECISION){\n            err += 1;\n        }\n        if (fabs(f[x] - (d[x] + e[x])) > PRECISION){\n            err += 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "runtime",
                            "data",
                            "executable-data",
                            "async",
                            "construct-independent",
                            "reference-counting"
                        ],
                        "versions": [
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "2": {
                        "content": "#ifndef T2\n//T2:runtime,data,executable-data,async,construct-independent,internal-control-values,V:2.5-2.7\nint test2(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n    real_t * c = (real_t *)malloc(n * sizeof(real_t));\n    int def_async_var = acc_get_default_async();\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n        c[x] = 0;\n    }\n\n    #pragma acc enter data create(c[0:n])\n    #pragma acc enter data create(c[0:n])\n    \n    #pragma acc data copyin(a[0:n], b[0:n])\n    {\n        #pragma acc parallel present(c[0:n])\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x) {\n                c[x] = a[x] + b[x];\n            }\n        }\n        acc_copyout_finalize_async(c, n * sizeof(real_t), def_async_var);\n        #pragma acc wait\n    }\n\n    for (int x = 0; x < n; ++x) {\n        if (fabs(c[x] - (a[x] + b[x])) > PRECISION) {\n            err += 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T2\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test2();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 1);\n    }\n#endif\n",
                        "tags": [
                            "runtime",
                            "data",
                            "executable-data",
                            "async",
                            "construct-independent",
                            "internal-control-values"
                        ],
                        "versions": [
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "3": {
                        "content": "#ifndef T3\n//T3:runtime,data,executable-data,async,construct-independent,internal-control-values,set,V:2.5-2.7\nint test3(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n    real_t * c = (real_t *)malloc(n * sizeof(real_t));\n    int def_async_var = acc_get_default_async();\n\n    acc_set_default_async(def_async_var + 1);\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n        c[x] = 0;\n    }\n\n    #pragma acc enter data create(c[0:n])\n    #pragma acc enter data create(c[0:n])\n    #pragma acc data copyin(a[0:n], b[0:n])\n    {\n        #pragma acc parallel present(c[0:n]) async\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x) {\n                c[x] = a[x] + b[x];\n            }\n        }\n        acc_copyout_async(c, n * sizeof(real_t), def_async_var + 1);\n        #pragma acc wait\n    }\n\n    for (int x = 0; x < n; ++x) {\n        if (fabs(c[x] - (a[x] + b[x])) > PRECISION) {\n            err += 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T3\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test3();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 2);\n    }\n#endif\n",
                        "tags": [
                            "runtime",
                            "data",
                            "executable-data",
                            "async",
                            "construct-independent",
                            "internal-control-values",
                            "set"
                        ],
                        "versions": [
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "4": {
                        "content": "#ifndef T4\n//T4:runtime,data,executable-data,async,construct-independent,V:2.5-2.7\nint test4(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n    real_t * c = (real_t *)malloc(n * sizeof(real_t));\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n        c[x] = 0;\n    }\n\n    #pragma acc enter data create(c[0:n])\n    #pragma acc enter data create(c[0:n])\n    #pragma acc data copyin(a[0:n], b[0:n])\n    {\n        #pragma acc parallel present(c[0:n]) async(1)\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x) {\n                c[x] = a[x] + b[x];\n            }\n        }\n        acc_copyout_finalize_async(c, n * sizeof(real_t), 1);\n        #pragma acc enter data copyin(c[0:n]) async(1)\n        #pragma acc parallel present(c[0:n]) async(1)\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x) {\n                c[x] += a[x] + b[x];\n            }\n        }\n    }\n\n    for (int x = 0; x < n; ++x) {\n        if (fabs(c[x] - (2 * (a[x] + b[x]))) > PRECISION) {\n            err += 1;\n        }\n    }\n    \n\n    return err;\n}\n#endif\n#ifndef T4\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test4();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 3);\n    }\n#endif\n",
                        "tags": [
                            "runtime",
                            "data",
                            "executable-data",
                            "async",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "acc_copyout_finalize_async_with_len.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:runtime,data,executable-data,async,construct-independent,V:2.5-2.7\n      LOGICAL FUNCTION test1()\n        USE OPENACC\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.fh\"\n        INTEGER :: x !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT):: a, b, c, d, e, f !Data\n        REAL(8) :: RAND\n        INTEGER :: errors = 0\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n        CALL RANDOM_NUMBER(a)\n        CALL RANDOM_NUMBER(b)\n        c = 0\n        CALL RANDOM_NUMBER(d)\n        CALL RANDOM_NUMBER(e)\n        f = 0\n\n        !$acc enter data create(c(1:LOOPCOUNT), f(1:LOOPCOUNT))\n        !$acc enter data create(c(1:LOOPCOUNT), f(1:LOOPCOUNT))\n\n        !$acc data copyin(a(1:LOOPCOUNT), b(1:LOOPCOUNT), d(1:LOOPCOUNT), e(1:LOOPCOUNT)) present(c(1:LOOPCOUNT), f(1:LOOPCOUNT))\n          !$acc parallel async(1)\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              c(x) = a(x) + b(x)\n            END DO\n          !$acc end parallel\n          !$acc parallel async(2)\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              f(x) = d(x) + e(x)\n            END DO\n          !$acc end parallel\n          CALL acc_copyout_finalize_async(c(1), LOOPCOUNT*8, 1)\n          CALL acc_copyout_finalize_async(f(1), LOOPCOUNT*8, 2)\n          !$acc wait\n        !$acc end data\n\n        DO x = 1, LOOPCOUNT\n          IF (abs(c(x) - (a(x) + b(x))) .gt. PRECISION) THEN\n            errors = errors + 1\n          END IF\n          IF (abs(f(x) - (d(x) + e(x))) .gt. PRECISION) THEN\n            errors = errors + 1\n          END IF\n        END DO\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n      LOGICAL :: test1\n#endif\n#ifndef T1\n      DO testrun = 1, NUM_TEST_CALLS\n        failed = failed .or. test1()\n      END DO\n      IF (failed) THEN\n        failcode = failcode + 2 ** 0\n        failed = .FALSE.\n      END IF\n#endif\n",
                        "tags": [
                            "runtime",
                            "data",
                            "executable-data",
                            "async",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "acc_copyout_finalize_with_len.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:runtime,data,executable-data,construct-independent,V:2.5-2.7\n      LOGICAL FUNCTION test1()\n        USE OPENACC\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.fh\"\n        INTEGER :: x !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT):: a, b, c !Data\n        REAL(8) :: RAND\n        INTEGER :: errors = 0\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n        CALL RANDOM_NUMBER(a)\n        CALL RANDOM_NUMBER(b)\n        c = 0\n\n        !$acc enter data create(c(1:LOOPCOUNT))\n        !$acc enter data create(c(1:LOOPCOUNT))\n\n        !$acc data copyin(a(1:LOOPCOUNT), b(1:LOOPCOUNT)) present(c(1:LOOPCOUNT))\n          !$acc parallel\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              c(x) = a(x) + b(x)\n            END DO\n          !$acc end parallel\n        !$acc end data\n\n        CALL acc_copyout_finalize(c(1), LOOPCOUNT*8)\n\n        DO x = 1, LOOPCOUNT\n          IF (abs(c(x) - (a(x) + b(x))) .gt. PRECISION) THEN\n            errors = errors + 1\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "runtime",
                            "data",
                            "executable-data",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "acc_copyout_with_len.F90": {
                "num tests": 2,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:runtime,data,executable-data,construct-independent,V:2.0-2.7\n      LOGICAL FUNCTION test1()\n        USE OPENACC\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT):: a, b, c !Data\n        INTEGER :: errors = 0\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n        CALL RANDOM_NUMBER(a)\n        CALL RANDOM_NUMBER(b)\n        c = 0\n\n        CALL acc_create(c(1:LOOPCOUNT))\n\n        !$acc data copyin(a(1:LOOPCOUNT), b(1:LOOPCOUNT)) present(c(1:LOOPCOUNT))\n          !$acc parallel\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              c(x) = a(x) + b(x)\n            END DO\n          !$acc end parallel\n        !$acc end data\n\n        CALL acc_copyout(c(1), LOOPCOUNT*8)\n\n        DO x = 1, LOOPCOUNT\n          IF (abs(c(x) - (a(x) + b(x))) .gt. PRECISION) THEN\n            errors = errors + 1\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "runtime",
                            "data",
                            "executable-data",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "2": {
                        "content": "#ifndef T2\n!T2:runtime,data,executable-data,construct-independent,V:2.0-2.7\n      LOGICAL FUNCTION test2()\n        USE OPENACC\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x\n        REAL(8),DIMENSION(LOOPCOUNT):: a, b, c\n        INTEGER :: errors = 0\n\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n        CALL RANDOM_NUMBER(a)\n        CALL RANDOM_NUMBER(b)\n        c = 0\n\n        !$acc enter data create(c(1:LOOPCOUNT))\n\n        !$acc data copyin(a(1:LOOPCOUNT), b(1:LOOPCOUNT)) present(c(1:LOOPCOUNT))\n          !$acc parallel\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              c(x) = a(x) + b(x)\n            END DO\n          !$acc end parallel\n        !$acc end data\n\n        CALL acc_copyout(c(1), LOOPCOUNT*8)\n\n        DO x = 1, LOOPCOUNT\n          IF (abs(c(x) - (a(x) + b(x))) .gt. PRECISION) THEN\n            errors = errors + 1\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test2 = .FALSE.\n        ELSE\n          test2 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T2\n        LOGICAL :: test2\n#endif\n#ifndef T2\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test2()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2**1\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "runtime",
                            "data",
                            "executable-data",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "acc_create.F90": {
                "num tests": 4,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:runtime,data,executable-data,construct-independent,V:2.0-2.7\n      LOGICAL FUNCTION test1()\n        USE OPENACC\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT):: a, b, c !Data\n        INTEGER :: errors\n        errors = 0\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n        CALL RANDOM_NUMBER(a)\n        CALL RANDOM_NUMBER(b)\n        c = 0\n\n        CALL acc_create(c(1:LOOPCOUNT))\n\n        !$acc data copyin(a(1:LOOPCOUNT), b(1:LOOPCOUNT))\n          !$acc parallel present(c(1:LOOPCOUNT))\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              c(x) = a(x) + b(x)\n            END DO\n          !$acc end parallel\n        !$acc end data\n\n        CALL acc_copyout(c(1:LOOPCOUNT))\n\n        DO x = 1, LOOPCOUNT\n          IF (abs(c(x) - (a(x) + b(x))) .gt. PRECISION) THEN\n            errors = errors + 1\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "runtime",
                            "data",
                            "executable-data",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "2": {
                        "content": "#ifndef T2\n!T2:runtime,data,executable-data,construct-independent,V:2.0-2.7\n      LOGICAL FUNCTION test2()\n        USE OPENACC\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x\n        REAL(8),DIMENSION(LOOPCOUNT):: a, b, c\n        INTEGER:: errors\n        errors = 0\n\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n        CALL RANDOM_NUMBER(a)\n        CALL RANDOM_NUMBER(b)\n        c= 0\n\n        CALL acc_create(c(1:LOOPCOUNT))\n\n        !$acc data copyin(a(1:LOOPCOUNT), b(1:LOOPCOUNT))\n          !$acc parallel present(c(1:LOOPCOUNT))\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              c(x) = a(x) + b(x)\n            END DO\n          !$acc end parallel\n        !$acc end data\n\n        !$acc exit data copyout(c(1:LOOPCOUNT))\n\n        DO x = 1, LOOPCOUNT\n          IF (abs(c(x) - (a(x) + b(x))) .gt. PRECISION) THEN\n            errors = errors + 1\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test2 = .FALSE.\n        ELSE\n          test2 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T2\n        LOGICAL :: test2\n#endif\n#ifndef T2\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test2()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 1\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "runtime",
                            "data",
                            "executable-data",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "3": {
                        "content": "#ifndef T3\n!T3:runtime,compatibility-features,construct-independent,V:2.0-2.7\n      LOGICAL FUNCTION test3()\n        USE OPENACC\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER:: x\n        REAL(8),DIMENSION(LOOPCOUNT):: a, b, c\n        INTEGER:: errors\n        errors = 0\n\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n        CALL RANDOM_NUMBER(a)\n        CALL RANDOM_NUMBER(b)\n        c = 0\n\n        CALL acc_pcreate(c(1:LOOPCOUNT))\n\n        !$acc data copyin(a(1:LOOPCOUNT), b(1:LOOPCOUNT)) present(c(1:LOOPCOUNT))\n          !$acc parallel\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              c(x) = a(x) + b(x)\n            END DO\n          !$acc end parallel\n        !$acc end data\n\n        !$acc exit data copyout(c(1:LOOPCOUNT))\n\n        DO x = 1, LOOPCOUNT\n          IF (abs(c(x) - (a(x) + b(x))) .gt. PRECISION) THEN\n            errors = errors + 1\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test3 = .FALSE.\n        ELSE\n          test3 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T3\n        LOGICAL :: test3\n#endif\n#ifndef T3\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test3()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 2\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "runtime",
                            "compatibility-features",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "4": {
                        "content": "#ifndef T4\n!T4:runtime,compatibility-features,construct-independent,V:2.0-2.7\n      LOGICAL FUNCTION test4()\n        USE OPENACC\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER:: x\n        REAL(8),DIMENSION(LOOPCOUNT):: a, b, c\n        INTEGER:: errors\n        errors = 0\n\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n        CALL RANDOM_NUMBER(a)\n        CALL RANDOM_NUMBER(b)\n        c = 0\n\n        CALL acc_present_or_create(c(1:LOOPCOUNT))\n\n        !$acc data copyin(a(1:LOOPCOUNT), b(1:LOOPCOUNT)) present(c(1:LOOPCOUNT))\n          !$acc parallel\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              c(x) = a(x) + b(x)\n            END DO\n          !$acc end parallel\n        !$acc end data\n\n        !$acc exit data copyout(c(1:LOOPCOUNT))\n\n        DO x = 1, LOOPCOUNT\n          IF (abs(c(x) - (a(x) + b(x))) .gt. PRECISION) THEN\n            errors = errors + 1\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test4 = .FALSE.\n        ELSE\n          test4 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T4\n        LOGICAL :: test4\n#endif\n#ifndef T4\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test4()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 3\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "runtime",
                            "compatibility-features",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "acc_create.c": {
                "num tests": 5,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:runtime,data,executable-data,construct-independent,V:2.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n    real_t * c = (real_t *)malloc(n * sizeof(real_t));\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n        c[x] = 0.0;\n    }\n\n    acc_create(c, n * sizeof(real_t));\n\n    #pragma acc data copyin(a[0:n], b[0:n])\n    {\n        #pragma acc parallel present(c[0:n])\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                c[x] = a[x] + b[x];\n            }\n        }\n    }\n\n    acc_copyout(c, n * sizeof(real_t));\n\n    for (int x = 0; x < n; ++x){\n        if (fabs(c[x] - (a[x] + b[x])) > PRECISION){\n            err += 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "runtime",
                            "data",
                            "executable-data",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "2": {
                        "content": "#ifndef T2\n//T2:runtime,data,executable-data,construct-independent,V:2.0-2.7\nint test2(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n    real_t * c = (real_t *)malloc(n * sizeof(real_t));\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n        c[x] = 0.0;\n    }\n\n    acc_create(c, n * sizeof(real_t));\n\n    #pragma acc data copyin(a[0:n], b[0:n])\n    {\n        #pragma acc parallel present(c[0:n])\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                c[x] = a[x] + b[x];\n            }\n        }\n    }\n\n    #pragma acc exit data copyout(c[0:n])\n\n    for (int x = 0; x < n; ++x){\n        if (fabs(c[x] - (a[x] + b[x])) > PRECISION){\n            err += 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T2\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test2();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 1);\n    }\n#endif\n",
                        "tags": [
                            "runtime",
                            "data",
                            "executable-data",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "3": {
                        "content": "#ifndef T3\n//T3:runtime,data,executable-data,compatibility-features,construct-independent,V:2.0-2.7\nint test3(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n    real_t * c = (real_t *)malloc(n * sizeof(real_t));\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n        c[x] = 0;\n    }\n\n    acc_pcreate(c, n * sizeof(real_t));\n\n    #pragma acc data copyin(a[0:n], b[0:n]) present(c[0:n])\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                c[x] = a[x] + b[x];\n            }\n        }\n    }\n\n    #pragma acc exit data copyout(c[0:n])\n\n    for (int x = 0; x < n; ++x){\n        if (fabs(c[x] - (a[x] + b[x])) > PRECISION){\n            err += 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T3\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test3();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 2);\n    }\n#endif\n",
                        "tags": [
                            "runtime",
                            "data",
                            "executable-data",
                            "compatibility-features",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "4": {
                        "content": "#ifndef T4\n//T4:runtime,data,executable-data,compatibility-features,construct-independent,V:2.0-2.7\nint test4(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n    real_t * c = (real_t *)malloc(n * sizeof(real_t));\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n        c[x] = 0;\n    }\n\n    acc_present_or_create(c, n * sizeof(real_t));\n\n    #pragma acc data copyin(a[0:n], b[0:n]) present(c[0:n])\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                c[x] = a[x] + b[x];\n            }\n        }\n    }\n\n    #pragma acc exit data copyout(c[0:n])\n\n    for (int x = 0; x < n; ++x){\n        if (fabs(c[x] - (a[x] + b[x])) > PRECISION){\n            err += 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T4\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test4();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 3);\n    }\n#endif\n",
                        "tags": [
                            "runtime",
                            "data",
                            "executable-data",
                            "compatibility-features",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "5": {
                        "content": "#ifndef T5\n//T5:runtime,data,executable-data,devonly,construct-independent,reference-counting,V:2.5-2.7\nint test5(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n    real_t * c = (real_t *)malloc(n * sizeof(real_t));\n    int * dev_test = (int *)malloc(sizeof(int));\n\n    dev_test[0] = 1;\n    #pragma acc enter data copyin(dev_test[0:1])\n    #pragma acc parallel present(dev_test[0:1])\n    {\n        dev_test[0] = 0;\n    }\n    if (dev_test[0] == 1){\n        for (int x = 0; x < n; ++x){\n            a[x] = rand() / (real_t)(RAND_MAX / 10);\n            b[x] = rand() / (real_t)(RAND_MAX / 10);\n            c[x] = 1;\n        }\n\n        #pragma acc enter data copyin(c[0:n])\n        for (int x = 0; x < n; ++x){\n            c[x] = 0;\n        }\n        acc_create(c, n * sizeof(real_t));\n        #pragma acc data copyin(a[0:n], b[0:n])\n        {\n            #pragma acc parallel present(c[0:n])\n            {\n                #pragma acc loop\n                for (int x = 0; x < n; ++x) {\n                    c[x] += a[x] + b[x];\n                }\n            }\n        }\n\n        #pragma acc exit data delete(c[0:n])\n        #pragma acc exit data copyout(c[0:n])\n    \n        for (int x = 0; x < n; ++x) {\n            if (fabs(c[x] - (1 + a[x] + b[x])) > PRECISION) {\n                err += 1;\n            }\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T5\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test5();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 4);\n    }\n#endif\n",
                        "tags": [
                            "runtime",
                            "data",
                            "executable-data",
                            "devonly",
                            "construct-independent",
                            "reference-counting"
                        ],
                        "versions": [
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "acc_create_async.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:runtime,data,executable-data,async,construct-independent,V:2.5-2.7\n      LOGICAL FUNCTION test1()\n        USE OPENACC\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT):: a, b, c, d, e, f !Data\n        REAL(8) :: RAND\n        INTEGER :: errors = 0\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n        CALL RANDOM_NUMBER(a)\n        CALL RANDOM_NUMBER(b)\n        c = 0\n        CALL RANDOM_NUMBER(d)\n        CALL RANDOM_NUMBER(e)\n        f = 0\n\n        !$acc data copyin(a(1:LOOPCOUNT), b(1:LOOPCOUNT), d(1:LOOPCOUNT), e(1:LOOPCOUNT))\n          CALL acc_create_async(c(1:LOOPCOUNT), 1)\n          CALL acc_create_async(f(1:LOOPCOUNT), 2)\n          !$acc data present(c(1:LOOPCOUNT), f(1:LOOPCOUNT))\n            !$acc parallel async(1)\n              !$acc loop\n              DO x = 1, LOOPCOUNT\n                c(x) = a(x) + b(x)\n              END DO\n            !$acc end parallel\n            !$acc parallel async(2)\n              !$acc loop\n              DO x = 1, LOOPCOUNT\n                f(x) = d(x) + e(x)\n              END DO\n            !$acc end parallel\n            !$acc wait\n          !$acc end data\n        !$acc end data\n\n        !$acc exit data copyout(c(1:LOOPCOUNT), f(1:LOOPCOUNT))\n\n        DO x = 1, LOOPCOUNT\n          IF (abs(c(x) - (a(x) + b(x))) .gt. PRECISION) THEN\n            errors = errors + 1\n          END IF\n          IF (abs(f(x) - (d(x) + e(x))) .gt. PRECISION) THEN\n            errors = errors + 1\n          END IF\n        END DO\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "runtime",
                            "data",
                            "executable-data",
                            "async",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "acc_create_async.c": {
                "num tests": 5,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:runtime,async,data,executable-data,construct-independent,V:2.5-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t *a = (real_t *)malloc(n * sizeof(real_t));\n    real_t *b = (real_t *)malloc(n * sizeof(real_t));\n    real_t *c = (real_t *)malloc(n * sizeof(real_t));\n    real_t *d = (real_t *)malloc(n * sizeof(real_t));\n    real_t *e = (real_t *)malloc(n * sizeof(real_t));\n    real_t *f = (real_t *)malloc(n * sizeof(real_t));\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n        c[x] = 0;\n        d[x] = rand() / (real_t)(RAND_MAX / 10);\n        e[x] = rand() / (real_t)(RAND_MAX / 10);\n        f[x] = 0;\n    }\n\n    #pragma acc data copyin(a[0:n], b[0:n], d[0:n], e[0:n])\n    {\n        acc_create_async(c, n * sizeof(real_t), 1);\n        acc_create_async(f, n * sizeof(real_t), 2);\n        #pragma acc data present(c[0:n], f[0:n])\n        {\n            #pragma acc parallel async(1)\n            {\n                #pragma acc loop\n                for (int x = 0; x < n; ++x){\n                    c[x] = a[x] + b[x];\n                }\n            }\n            #pragma acc parallel async(2)\n            {\n                #pragma acc loop\n                for (int x = 0; x < n; ++x){\n                    f[x] = d[x] + e[x];\n                }\n            }\n            #pragma acc wait\n        }\n    }\n\n    #pragma acc exit data copyout(c[0:n], f[0:n])\n\n    for (int x = 0; x < n; ++x){\n        if (fabs(c[x] - (a[x] + b[x])) > PRECISION){\n            err += 1;\n        }\n        if (fabs(f[x] - (d[x] + e[x])) > PRECISION){\n            err += 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "runtime",
                            "async",
                            "data",
                            "executable-data",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "2": {
                        "content": "#ifndef T2\n//T2:runtime,data,executable-data,async,construct-independent,V:2.5-2.7\nint test2(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n    real_t * c = (real_t *)malloc(n * sizeof(real_t));\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n        c[x] = 0;\n    }\n\n    acc_create_async(c, n * sizeof(real_t), 1);\n\n    #pragma acc data copyin(a[0:n], b[0:n])\n    {\n        while (!acc_async_test_all());\n        #pragma acc parallel present(c[0:n])\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x) {\n                c[x] = a[x] + b[x];\n            }\n        }\n    }\n\n    #pragma acc exit data copyout(c[0:n])\n\n    for (int x = 0; x < n; ++x) {\n        if (fabs(c[x] - (a[x] + b[x])) > PRECISION){\n            err += 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T2\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test2();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 1);\n    }\n#endif\n",
                        "tags": [
                            "runtime",
                            "data",
                            "executable-data",
                            "async",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "3": {
                        "content": "#ifndef T3\n//T3:runtime,data,executable-data,async,construct-independent,V:2.5-2.7\nint test3(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n    real_t * c = (real_t *)malloc(n * sizeof(real_t));\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n        c[x] = 0;\n    }\n\n    acc_create_async(c, n * sizeof(real_t), 1);\n\n    #pragma acc data copyin(a[0:n], b[0:n])\n    {\n        #pragma acc wait\n        #pragma acc parallel present(c[0:n])\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x) {\n                c[x] = a[x] + b[x];\n            }\n        }\n    }\n\n    #pragma acc exit data copyout(c[0:n])\n\n    for (int x = 0; x < n; ++x) {\n        if (fabs(c[x] - (a[x] + b[x])) > PRECISION) {\n            err += 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T3\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test3();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 2);\n    }\n#endif\n",
                        "tags": [
                            "runtime",
                            "data",
                            "executable-data",
                            "async",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "4": {
                        "content": "#ifndef T4\n//T4:runtime,data,executable-data,async,construct-independent,reference-counting,V:2.5-2.7\nint test4(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n    real_t * c = (real_t *)malloc(n * sizeof(real_t));\n    real_t * d = (real_t *)malloc(n * sizeof(real_t));\n    real_t * e = (real_t *)malloc(n * sizeof(real_t));\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n        c[x] = 0;\n        d[x] = rand() / (real_t)(RAND_MAX / 10);\n        e[x] = 0;\n    }\n\n    #pragma acc enter data create(c[0:n])\n    #pragma acc data copyin(a[0:n], b[0:n], d[0:n]) copyout(e[0:n])\n    {\n        #pragma acc parallel present(c[0:n]) async(1)\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x) {\n                c[x] = a[x] + b[x];\n            }\n        }\n        acc_create_async(c, n * sizeof(real_t), 1);\n        #pragma acc exit data delete(c[0:n]) async(1)\n        #pragma acc parallel present(c[0:n]) async(1)\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x) {\n                e[x] = c[x] + d[x];\n            }\n        }\n    }\n    #pragma acc wait\n    #pragma acc exit data copyout(c[0:n])\n\n    for (int x = 0; x < n; ++x) {\n        if (fabs(e[x] - (a[x] + b[x] + d[x])) > PRECISION) {\n            err += 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T4\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test4();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 3);\n    }\n#endif\n",
                        "tags": [
                            "runtime",
                            "data",
                            "executable-data",
                            "async",
                            "construct-independent",
                            "reference-counting"
                        ],
                        "versions": [
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "5": {
                        "content": "#ifndef T5\n//T5:runtime,data,executable-data,devonly,async,construct-independent,reference-counting,V:2.5-2.7\nint test5(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n    real_t * c = (real_t *)malloc(n * sizeof(real_t));\n    int * devtest = (int *)malloc(sizeof(int));\n    \n    devtest[0] = 0;\n    #pragma acc enter data copyin(devtest[0:1])\n    #pragma acc parallel present(devtest[0:1])\n    {\n        devtest[0] = 1;\n    }\n\n    if (devtest[0] == 0){\n        for (int x = 0; x < n; ++x){\n            a[x] = rand() / (real_t)(RAND_MAX / 10);\n            b[x] = rand() / (real_t)(RAND_MAX / 10);\n            c[x] = 0;\n        }\n\n        #pragma acc enter data create(c[0:n])\n        #pragma acc data copyin(a[0:n], b[0:n])\n        {\n            #pragma acc parallel present(c[0:n]) async(1)\n            {\n                #pragma acc loop\n                for (int x = 0; x < n; ++x) {\n                    c[x] = a[x] + b[x];\n                }\n            }\n            acc_create_async(c, n * sizeof(real_t), 1);\n            #pragma acc parallel present(c[0:n]) async(1)\n            {\n                #pragma acc loop\n                for (int x = 0; x < n; ++x) {\n                    c[x] += a[x] + b[x];\n                }\n            }\n            #pragma acc exit data copyout(c[0:n]) async(1)\n            #pragma acc wait\n        }\n\n        for (int x = 0; x < n; ++x) {\n            if (fabs(c[x] - (2 * (a[x] + b[x]))) > PRECISION) {\n                err += 1;\n            }\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T5\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test5();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 4);\n    }\n#endif\n",
                        "tags": [
                            "runtime",
                            "data",
                            "executable-data",
                            "devonly",
                            "async",
                            "construct-independent",
                            "reference-counting"
                        ],
                        "versions": [
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "acc_create_async_with_len.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:runtime,data,executable-data,async,construct-independent,V:2.5-2.7\n      LOGICAL FUNCTION test1()\n        USE OPENACC\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.fh\"\n        INTEGER :: x !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT):: a, b, c, d, e, f !Data\n        REAL(8) :: RAND\n        INTEGER :: errors = 0\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n        CALL RANDOM_NUMBER(a)\n        CALL RANDOM_NUMBER(b)\n        c = 0\n        CALL RANDOM_NUMBER(d)\n        CALL RANDOM_NUMBER(e)\n        f = 0\n\n        !$acc data copyin(a(1:LOOPCOUNT), b(1:LOOPCOUNT), d(1:LOOPCOUNT), e(1:LOOPCOUNT))\n          CALL acc_create_async(c(1), LOOPCOUNT*8, 1)\n          CALL acc_create_async(f(1), LOOPCOUNT*8, 2)\n          !$acc data present(c(1:LOOPCOUNT), f(1:LOOPCOUNT))\n            !$acc parallel async(1)\n              !$acc loop\n              DO x = 1, LOOPCOUNT\n                c(x) = a(x) + b(x)\n              END DO\n            !$acc end parallel\n            !$acc parallel async(2)\n              !$acc loop\n              DO x = 1, LOOPCOUNT\n                f(x) = d(x) + e(x)\n              END DO\n            !$acc end parallel\n            !$acc wait\n          !$acc end data\n        !$acc end data\n\n        !$acc exit data copyout(c(1:LOOPCOUNT), f(1:LOOPCOUNT))\n\n        DO x = 1, LOOPCOUNT\n          IF (abs(c(x) - (a(x) + b(x))) .gt. PRECISION) THEN\n            errors = errors + 1\n          END IF\n          IF (abs(f(x) - (d(x) + e(x))) .gt. PRECISION) THEN\n            errors = errors + 1\n          END IF\n        END DO\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "runtime",
                            "data",
                            "executable-data",
                            "async",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "acc_create_with_len.F90": {
                "num tests": 4,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:runtime,data,executable-data,construct-independent,V:2.0-2.7\n      LOGICAL FUNCTION test1()\n        USE OPENACC\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT):: a, b, c !Data\n        INTEGER :: errors\n        errors = 0\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n        CALL RANDOM_NUMBER(a)\n        CALL RANDOM_NUMBER(b)\n        c = 0\n\n        CALL acc_create(c(1), LOOPCOUNT*8)\n\n        !$acc data copyin(a(1:LOOPCOUNT), b(1:LOOPCOUNT))\n          !$acc parallel present(c(1:LOOPCOUNT))\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              c(x) = a(x) + b(x)\n            END DO\n          !$acc end parallel\n        !$acc end data\n\n        CALL acc_copyout(c(1:LOOPCOUNT))\n\n        DO x = 1, LOOPCOUNT\n          IF (abs(c(x) - (a(x) + b(x))) .gt. PRECISION) THEN\n            errors = errors + 1\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "runtime",
                            "data",
                            "executable-data",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "2": {
                        "content": "#ifndef T2\n!T2:runtime,data,executable-data,construct-independent,V:2.0-2.7\n      LOGICAL FUNCTION test2()\n        USE OPENACC\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER:: x\n        REAL(8),DIMENSION(LOOPCOUNT):: a, b, c\n        INTEGER :: errors\n        errors = 0\n\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n        CALL RANDOM_NUMBER(a)\n        CALL RANDOM_NUMBER(b)\n        c= 0\n\n        CALL acc_create(c(1), LOOPCOUNT*8)\n\n        !$acc data copyin(a(1:LOOPCOUNT), b(1:LOOPCOUNT))\n          !$acc parallel present(c(1:LOOPCOUNT))\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              c(x) = a(x) + b(x)\n            END DO\n          !$acc end parallel\n        !$acc end data\n\n        !$acc exit data copyout(c(1:LOOPCOUNT))\n\n        DO x = 1, LOOPCOUNT\n          IF (abs(c(x) - (a(x) + b(x))) .gt. PRECISION) THEN\n            errors = errors + 1\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test2 = .FALSE.\n        ELSE\n          test2 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T2\n        LOGICAL :: test2\n#endif\n#ifndef T2\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test2()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 1\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "runtime",
                            "data",
                            "executable-data",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "3": {
                        "content": "#ifndef T3\n!T3:runtime,compatibility-features,construct-independent,V:2.0-2.7\n      LOGICAL FUNCTION test3()\n        USE OPENACC\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER:: x\n        REAL(8),DIMENSION(LOOPCOUNT):: a, b, c\n        INTEGER:: errors\n        errors = 0\n\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n        CALL RANDOM_NUMBER(a)\n        CALL RANDOM_NUMBER(b)\n        c = 0\n\n        CALL acc_pcreate(c(1), LOOPCOUNT*8)\n\n        !$acc data copyin(a(1:LOOPCOUNT), b(1:LOOPCOUNT)) present(c(1:LOOPCOUNT))\n          !$acc parallel\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              c(x) = a(x) + b(x)\n            END DO\n          !$acc end parallel\n        !$acc end data\n\n        !$acc exit data copyout(c(1:LOOPCOUNT))\n\n        DO x = 1, LOOPCOUNT\n          IF (abs(c(x) - (a(x) + b(x))) .gt. PRECISION) THEN\n            errors = errors + 1\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test3 = .FALSE.\n        ELSE\n          test4 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T3\n        LOGICAL :: test3\n#endif\n#ifndef T3\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test3()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 2\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "runtime",
                            "compatibility-features",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "4": {
                        "content": "#ifndef T4\n!T4:runtime,compatibility-features,construct-independent,V:2.0-2.7\n      LOGICAL FUNCTION test4()\n        USE OPENACC\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER:: x\n        REAL(8),DIMENSION(LOOPCOUNT):: a, b, c\n        INTEGER:: errors\n        errors = 0\n\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n        CALL RANDOM_NUMBER(a)\n        CALL RANDOM_NUMBER(b)\n        c = 0\n\n        CALL acc_present_or_create(c(1), LOOPCOUNT*8)\n\n        !$acc data copyin(a(1:LOOPCOUNT), b(1:LOOPCOUNT)) present(c(1:LOOPCOUNT))\n          !$acc parallel\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              c(x) = a(x) + b(x)\n            END DO\n          !$acc end parallel\n        !$acc end data\n\n        DO x = 1, LOOPCOUNT\n          IF (abs(c(x) - (a(x) + b(x))) .gt. PRECISION) THEN\n            errors = errors + 1\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test4 = .FALSE.\n        ELSE\n          test4 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T4\n        LOGICAL :: test4\n#endif\n#ifndef T4\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test4()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 3\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "runtime",
                            "compatibility-features",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "acc_delete.F90": {
                "num tests": 2,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:runtime,data,executable-data,construct-independent,V:2.0-2.7\n      LOGICAL FUNCTION test1()\n        USE OPENACC\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT):: a, b, c !Data\n        INTEGER :: errors\n        errors = 0\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n        CALL RANDOM_NUMBER(a)\n        CALL RANDOM_NUMBER(b)\n        c = 0\n\n        !$acc enter data copyin(a(1:LOOPCOUNT), b(1:LOOPCOUNT))\n\n        !$acc data copyout(c(1:LOOPCOUNT))\n          !$acc parallel present(a(1:LOOPCOUNT), b(1:LOOPCOUNT))\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              c(x) = a(x) + b(x)\n            END DO\n          !$acc end parallel\n        !$acc end data\n\n        CALL acc_delete(a(1:LOOPCOUNT))\n        CALL acc_delete(b(1:LOOPCOUNT))\n\n        DO x = 1, LOOPCOUNT\n          IF (abs(c(x) - (a(x) + b(x))) .gt. PRECISION) THEN\n            errors = errors + 1\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "runtime",
                            "data",
                            "executable-data",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "2": {
                        "content": "#ifndef T2\n!T2:runtime,data,executable-data,construct-independent,V:2.0-2.7\n      LOGICAL FUNCTION test2()\n        USE OPENACC\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER:: x\n        REAL(8),DIMENSION(LOOPCOUNT):: a, b, c\n        INTEGER:: errors\n        errors = 0\n\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n        CALL RANDOM_NUMBER(a)\n        CALL RANDOM_NUMBER(b)\n        c = 0\n\n        CALL acc_copyin(a(1:LOOPCOUNT))\n        CALL acc_copyin(b(1:LOOPCOUNT))\n\n        !$acc data copyout(c(1:LOOPCOUNT))\n          !$acc parallel present(a(1:LOOPCOUNT), b(1:LOOPCOUNT))\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              c(x) = a(x) + b(x)\n            END DO\n          !$acc end parallel\n        !$acc end data\n\n        CALL acc_delete(a(1:LOOPCOUNT))\n        CALL acc_delete(b(1:LOOPCOUNT))\n\n        DO x = 1, LOOPCOUNT\n          IF (abs(c(x) - (a(x) + b(x))) .gt. PRECISION) THEN\n            errors = errors + 1\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test2 = .FALSE.\n        ELSE\n          test2 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T2\n        LOGICAL :: test2\n#endif\n#ifndef T2\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test2()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2**1\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "runtime",
                            "data",
                            "executable-data",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "acc_delete.c": {
                "num tests": 2,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:runtime,data,executable-data,construct-independent,V:2.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n    real_t * c = (real_t *)malloc(n * sizeof(real_t));\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n        c[x] = 0.0;\n    }\n\n    #pragma acc enter data copyin(a[0:n], b[0:n])\n\n    #pragma acc data copyout(c[0:n])\n    {\n        #pragma acc parallel present(a[0:n], b[0:n])\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                c[x] = a[x] + b[x];\n            }\n        }\n    }\n\n    acc_delete(a, n * sizeof(real_t));\n    acc_delete(b, n * sizeof(real_t));\n\n    for (int x = 0; x < n; ++x){\n        if (fabs(c[x] - (a[x] + b[x])) > PRECISION){\n            err += 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "runtime",
                            "data",
                            "executable-data",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "2": {
                        "content": "#ifndef T2\n//T2:runtime,data,executable-data,construct-independent,V:2.0-2.7\nint test2(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n    real_t * c = (real_t *)malloc(n * sizeof(real_t));\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n        c[x] = 0.0;\n    }\n\n    acc_copyin(a, n * sizeof(real_t));\n    acc_copyin(b, n * sizeof(real_t));\n\n    #pragma acc data copyout(c[0:n])\n    {\n        #pragma acc parallel present(a[0:n], b[0:n])\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                c[x] = a[x] + b[x];\n            }\n        }\n    }\n\n    acc_delete(a, n * sizeof(real_t));\n    acc_delete(b, n * sizeof(real_t));\n\n    for (int x = 0; x < n; ++x){\n        if (fabs(c[x] - (a[x] + b[x])) > PRECISION){\n            err += 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T2\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test2();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 1);\n    }\n#endif\n",
                        "tags": [
                            "runtime",
                            "data",
                            "executable-data",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "acc_delete_async.F90": {
                "num tests": 2,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:runtime,data,executable-data,async,construct-independent,V:2.5-2.7\n      LOGICAL FUNCTION test1()\n        USE OPENACC\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT):: a, b, c, d, e, f !Data\n        INTEGER :: errors = 0\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n        CALL RANDOM_NUMBER(a)\n        CALL RANDOM_NUMBER(b)\n        c = 0\n        CALL RANDOM_NUMBER(d)\n        CALL RANDOM_NUMBER(e)\n        f = 0\n\n        !$acc enter data copyin(a(1:LOOPCOUNT), b(1:LOOPCOUNT), d(1:LOOPCOUNT), e(1:LOOPCOUNT))\n\n        !$acc data present(a(1:LOOPCOUNT), b(1:LOOPCOUNT), d(1:LOOPCOUNT), e(1:LOOPCOUNT)) copyout(c(1:LOOPCOUNT), f(1:LOOPCOUNT))\n          !$acc parallel async(1)\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              c(x) = a(x) + b(x)\n            END DO\n          !$acc end parallel\n          !$acc parallel async(2)\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              f(x) = d(x) + e(x)\n            END DO\n          !$acc end parallel\n          CALL acc_delete_async(a(1:LOOPCOUNT), 1)\n          CALL acc_delete_async(b(1:LOOPCOUNT), 1)\n          CALL acc_delete_async(d(1:LOOPCOUNT), 2)\n          CALL acc_delete_async(e(1:LOOPCOUNT), 2)\n          !$acc wait\n        !$acc end data\n\n        DO x = 1, LOOPCOUNT\n          IF (abs(c(x) - (a(x) + b(x))) .gt. PRECISION) THEN\n            errors = errors + 1\n          END IF\n          IF (abs(f(x) - (d(x) + e(x))) .gt. PRECISION) THEN\n            errors = errors + 1\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "runtime",
                            "data",
                            "executable-data",
                            "async",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "2": {
                        "content": "#ifndef T2\n!T2:runtime,data,executable-data,devonly,async,construct-independent,V:2.5-2.7\n      LOGICAL FUNCTION test2()\n        USE OPENACC\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT):: a, b, c!Data\n        INTEGER,DIMENSION(1) :: devtest\n        INTEGER :: errors = 0\n\n        devtest(1) = 1\n        !$acc enter data copyin(devtest(1:1))\n        !$acc parallel present(devtest(1:1))\n          devtest(1) = 0\n        !$acc end parallel\n\n        IF (devtest(1) == 1) THEN\n          CALL RANDOM_NUMBER(a)\n          CALL RANDOM_NUMBER(b)\n          c = 0\n\n          !$acc enter data copyin(a(1:LOOPCOUNT), b(1:LOOPCOUNT), c(1:LOOPCOUNT))\n          !$acc data present(a(1:LOOPCOUNT), b(1:LOOPCOUNT), c(1:LOOPCOUNT))\n            !$acc parallel async(1)\n              !$acc loop\n              DO x = 1, LOOPCOUNT\n                c(x) = a(x) + b(x)\n              END DO\n            !$acc end parallel\n          !$acc end data\n          CALL acc_delete_async(c(1:LOOPCOUNT), 1)\n          !$acc enter data copyin(c(1:LOOPCOUNT)) async(1)\n          !$acc data present(a(1:LOOPCOUNT), b(1:LOOPCOUNT), c(1:LOOPCOUNT))\n            !$acc parallel async(1)\n              !$acc loop\n              DO x = 1, LOOPCOUNT\n                c(x) = c(x) + a(x) + b(x)\n              END DO\n            !$acc end parallel\n          !$acc end data\n          !$acc exit data delete(a(1:LOOPCOUNT), b(1:LOOPCOUNT)) copyout(c(1:LOOPCOUNT))\n\n          DO x = 1, LOOPCOUNT\n            IF (abs(c(x) - (a(x) + b(x))) .gt. PRECISION) THEN\n              errors = errors + 1\n            END IF\n          END DO\n        END IF\n\n        IF (errors .eq. 0) THEN\n          test2 = .FALSE.\n        ELSE\n          test2 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T2\n        LOGICAL :: test2\n#endif\n#ifndef T2\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test2()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2**1\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "runtime",
                            "data",
                            "executable-data",
                            "devonly",
                            "async",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "acc_delete_async.c": {
                "num tests": 2,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:runtime,data,executable-data,construct-independent,async,V:2.5-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t *a = (real_t *)malloc(n * sizeof(real_t));\n    real_t *b = (real_t *)malloc(n * sizeof(real_t));\n    real_t *c = (real_t *)malloc(n * sizeof(real_t));\n    real_t *d = (real_t *)malloc(n * sizeof(real_t));\n    real_t *e = (real_t *)malloc(n * sizeof(real_t));\n    real_t *f = (real_t *)malloc(n * sizeof(real_t));\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n        c[x] = 0;\n        d[x] = rand() / (real_t)(RAND_MAX / 10);\n        e[x] = rand() / (real_t)(RAND_MAX / 10);\n        f[x] = 0;\n    }\n\n    #pragma acc enter data copyin(a[0:n], b[0:n], d[0:n], e[0:n])\n\n    #pragma acc data present(a[0:n], b[0:n], d[0:n], e[0:n]) copyout(c[0:n], f[0:n])\n    {\n        #pragma acc parallel async(1)\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                c[x] = a[x] + b[x];\n            }\n        }\n        #pragma acc parallel async(2)\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                f[x] = d[x] + e[x];\n            }\n        }\n        acc_delete_async(a, n * sizeof(real_t), 1);\n        acc_delete_async(b, n * sizeof(real_t), 1);\n        acc_delete_async(d, n * sizeof(real_t), 2);\n        acc_delete_async(e, n * sizeof(real_t), 2);\n        #pragma acc wait\n    }\n\n    for (int x = 0; x < n; ++x){\n        if (fabs(c[x] - (a[x] + b[x])) > PRECISION){\n            err += 1;\n        }\n        if (fabs(f[x] - (d[x] + e[x])) > PRECISION){\n            err += 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "runtime",
                            "data",
                            "executable-data",
                            "construct-independent",
                            "async"
                        ],
                        "versions": [
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "2": {
                        "content": "#ifndef T2\n//T2:runtime,data,executable-data,devonly,async,construct-independent,V:2.5-2.7\nint test2(){\n    int err = 0;\n    srand(SEED);\n    real_t *a = (real_t *)malloc(n * sizeof(real_t));\n    real_t *b = (real_t *)malloc(n * sizeof(real_t));\n    real_t *c = (real_t *)malloc(n * sizeof(real_t));\n    real_t *d = (real_t *)malloc(n * sizeof(real_t));\n    real_t *e = (real_t *)malloc(n * sizeof(real_t));\n    real_t *f = (real_t *)malloc(n * sizeof(real_t));\n    int* devtest = (int *)malloc(sizeof(int));\n\n    devtest[0] = 1;\n    #pragma acc enter data copyin(devtest[0:1])\n    #pragma acc parallel present(devtest[0:1])\n    {\n        devtest[0] = 0;\n    }\n\n    if (devtest[0] == 1){\n        for (int x = 0; x < n; ++x){\n            a[x] = rand() / (real_t)(RAND_MAX / 10);\n            b[x] = rand() / (real_t)(RAND_MAX / 10);\n            c[x] = 0;\n        }\n\n        #pragma acc enter data copyin(a[0:n], b[0:n], c[0:n])\n        #pragma acc data present(a[0:n], b[0:n], c[0:n])\n        {\n            #pragma acc parallel async(1)\n            {\n                #pragma acc loop\n                for (int x = 0; x < n; ++x){\n                    c[x] = a[x] * b[x];\n                }\n            }\n        }\n        acc_delete_async(c, n * sizeof(real_t), 1);\n        #pragma acc enter data copyin(c[0:n]) async(1)\n        #pragma acc data present(a[0:n], b[0:n], c[0:n])\n        {\n            #pragma acc parallel async(1)\n            {\n                #pragma acc loop\n                for (int x = 0; x < n; ++x){\n                    c[x] += a[x] + b[x];\n                }\n            }\n        }\n        #pragma acc exit data delete(a[0:n], b[0:n]) copyout(c[0:n])\n\n        for (int x = 0; x < n; ++x){\n            if (fabs(c[x] - (a[x] + b[x])) > PRECISION){\n                err += 1;\n            }\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T2\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test2();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 1);\n    }\n#endif\n",
                        "tags": [
                            "runtime",
                            "data",
                            "executable-data",
                            "devonly",
                            "async",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "acc_delete_async_with_len.F90": {
                "num tests": 2,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:runtime,data,executable-data,async,construct-independent,V:2.5-2.7\n      LOGICAL FUNCTION test1()\n        USE OPENACC\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT):: a, b, c, d, e, f !Data\n        INTEGER :: errors = 0\n\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n        CALL RANDOM_NUMBER(a)\n        CALL RANDOM_NUMBER(b)\n        c = 0\n        CALL RANDOM_NUMBER(d)\n        CALL RANDOM_NUMBER(e)\n        f = 0\n\n        !$acc enter data copyin(a(1:LOOPCOUNT), b(1:LOOPCOUNT), d(1:LOOPCOUNT), e(1:LOOPCOUNT))\n\n        !$acc data present(a(1:LOOPCOUNT), b(1:LOOPCOUNT), d(1:LOOPCOUNT), e(1:LOOPCOUNT)) copyout(c(1:LOOPCOUNT), f(1:LOOPCOUNT))\n          !$acc parallel async(1)\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              c(x) = a(x) + b(x)\n            END DO\n          !$acc end parallel\n          !$acc parallel async(2)\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              f(x) = d(x) + e(x)\n            END DO\n          !$acc end parallel\n          CALL acc_delete_async(a(1), LOOPCOUNT*8, 1)\n          CALL acc_delete_async(b(1), LOOPCOUNT*8, 1)\n          CALL acc_delete_async(d(1), LOOPCOUNT*8, 2)\n          CALL acc_delete_async(e(1), LOOPCOUNT*8, 2)\n          !$acc wait\n        !$acc end data\n\n        DO x = 1, LOOPCOUNT\n          IF (abs(c(x) - (a(x) + b(x))) .gt. PRECISION) THEN\n            errors = errors + 1\n          END IF\n          IF (abs(f(x) - (d(x) + e(x))) .gt. PRECISION) THEN\n            errors = errors + 1\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "runtime",
                            "data",
                            "executable-data",
                            "async",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "2": {
                        "content": "#ifndef T2\n!T2:runtime,data,executable-data,devonly,async,construct-independent,V:2.5-2.7\n      LOGICAL FUNCTION test2()\n        USE OPENACC\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT):: a, b, c !Data\n        INTEGER,DIMENSION(1):: devtest\n        INTEGER :: errors = 0\n\n        devtest(1) = 1\n        !$acc enter data copyin(devtest(1:1))\n        !$acc parallel present(devtest(1:1))\n          devtest(1) = 0\n        !$acc end parallel\n        IF (devtest(1) == 1) THEN\n          CALL RANDOM_NUMBER(a)\n          CALL RANDOM_NUMBER(b)\n          c = 0\n\n          !$acc enter data copyin(a(1:LOOPCOUNT), b(1:LOOPCOUNT), c(1:LOOPCOUNT))\n          !$acc data present(a(1:LOOPCOUNT), b(1:LOOPCOUNT), c(1:LOOPCOUNT))\n            !$acc parallel async(1)\n              !$acc loop\n              DO x = 1, LOOPCOUNT\n                c(x) = a(x) + b(x)\n              END DO\n            !$acc end parallel\n          !$acc end data\n          CALL acc_delete_async(c(1), LOOPCOUNT*8, 1)\n          !$acc enter data copyin(c(1:LOOPCOUNT)) async(1)\n          !$acc data present(a(1:LOOPCOUNT), b(1:LOOPCOUNT), c(1:LOOPCOUNT))\n            !$acc parallel async(1)\n              !$acc loop\n              DO x = 1, LOOPCOUNT\n                c(x) = c(x) + a(x) + b(x)\n              END DO\n            !$acc end parallel\n          !$acc end data\n          !$acc exit data delete(a(1:LOOPCOUNT), b(1:LOOPCOUNT)) copyout(c(1:LOOPCOUNT))\n\n          DO x = 1, LOOPCOUNT\n            IF (abs(c(x) - (a(x) + b(x))) .gt. PRECISION) THEN\n              errors = errors + 1\n            END IF\n          END DO\n        END IF\n\n        IF (errors .eq. 0) THEN\n          test2 = .FALSE.\n        ELSE\n          test2 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T2\n        LOGICAL :: test2\n#endif\n#ifndef T2\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test2()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2**1\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "runtime",
                            "data",
                            "executable-data",
                            "devonly",
                            "async",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "acc_delete_finalize.F90": {
                "num tests": 2,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:runtime,data,executable-data,construct-independent,V:2.5-2.7\n      LOGICAL FUNCTION test1()\n        USE OPENACC\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT):: a, b, c !Data\n        INTEGER :: errors = 0\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n        CALL RANDOM_NUMBER(a)\n        CALL RANDOM_NUMBER(b)\n        c = 0\n\n        !$acc enter data copyin(a(1:LOOPCOUNT), b(1:LOOPCOUNT))\n        !$acc enter data copyin(a(1:LOOPCOUNT), b(1:LOOPCOUNT))\n\n        !$acc data copyout(c(1:LOOPCOUNT))\n          !$acc parallel present(a(1:LOOPCOUNT), b(1:LOOPCOUNT))\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              c(x) = a(x) + b(x)\n            END DO\n          !$acc end parallel\n        !$acc end data\n\n        CALL acc_delete_finalize(a(1:LOOPCOUNT))\n        CALL acc_delete_finalize(b(1:LOOPCOUNT))\n\n        DO x = 1, LOOPCOUNT\n          IF (abs(c(x) - (a(x) + b(x))) .gt. PRECISION) THEN\n            errors = errors + 1\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "runtime",
                            "data",
                            "executable-data",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "2": {
                        "content": "#ifndef T2\n!T2:runtime,data,executable-data,construct-independent,V:2.5-2.7\n      LOGICAL FUNCTION test2()\n        USE OPENACC\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT):: a, b, c !Data\n        INTEGER :: errors = 0\n\n        CALL RANDOM_NUMBER(a)\n        CALL RANDOM_NUMBER(b)\n        c = 0\n\n        CALL acc_copyin(a(1:LOOPCOUNT))\n        CALL acc_copyin(a(1:LOOPCOUNT))\n        CALL acc_copyin(b(1:LOOPCOUNT))\n        CALL acc_copyin(b(1:LOOPCOUNT))\n\n        !$acc data copyout(c(1:LOOPCOUNT))\n          !$acc parallel present(a(1:LOOPCOUNT), b(1:LOOPCOUNT))\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              c(x) = a(x) + b(x)\n            END DO\n          !$acc end parallel\n        !$acc end data\n\n        CALL acc_delete_finalize(a(1:LOOPCOUNT))\n        CALL acc_delete_finalize(b(1:LOOPCOUNT))\n\n        DO x = 1, LOOPCOUNT\n          IF (abs(c(x) - (a(x) + b(x))) .gt. PRECISION) THEN\n            errors = errors + 1\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test2 = .FALSE.\n        ELSE\n          test2 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T2\n        LOGICAL :: test2\n#endif\n#ifndef T2\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test2()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2**1\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "runtime",
                            "data",
                            "executable-data",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "acc_delete_finalize.c": {
                "num tests": 2,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:runtime,data,executable-data,reference-counting,construct-independent,syntactic,V:2.5-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n    real_t * c = (real_t *)malloc(n * sizeof(real_t));\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n        c[x] = 0.0;\n    }\n\n    #pragma acc enter data copyin(a[0:n], b[0:n])\n    #pragma acc enter data copyin(a[0:n], b[0:n])\n\n    #pragma acc data copyout(c[0:n])\n    {\n        #pragma acc parallel present(a[0:n], b[0:n])\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                c[x] = a[x] + b[x];\n            }\n        }\n    }\n\n    acc_delete_finalize(a, n * sizeof(real_t));\n    acc_delete_finalize(b, n * sizeof(real_t));\n\n    for (int x = 0; x < n; ++x){\n        if (fabs(c[x] - (a[x] + b[x])) > PRECISION){\n            err += 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "runtime",
                            "data",
                            "executable-data",
                            "reference-counting",
                            "construct-independent",
                            "syntactic"
                        ],
                        "versions": [
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "2": {
                        "content": "#ifndef T2\n//T2:runtime,data,executable-data,reference-counting,syntactic,construct-independent,V:2.5-2.7\nint test2(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n    real_t * c = (real_t *)malloc(n * sizeof(real_t));\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n        c[x] = 0.0;\n    }\n\n    acc_copyin(a, n * sizeof(real_t));\n    acc_copyin(a, n * sizeof(real_t));\n    acc_copyin(b, n * sizeof(real_t));\n    acc_copyin(b, n * sizeof(real_t));\n\n    #pragma acc data copyout(c[0:n])\n    {\n        #pragma acc parallel present(a[0:n], b[0:n])\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                c[x] = a[x] + b[x];\n            }\n        }\n    }\n\n    acc_delete_finalize(a, n * sizeof(real_t));\n    acc_delete_finalize(b, n * sizeof(real_t));\n\n    for (int x = 0; x < n; ++x){\n        if (fabs(c[x] - (a[x] + b[x])) > PRECISION){\n            err += 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T2\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test2();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 1);\n    }\n#endif\n",
                        "tags": [
                            "runtime",
                            "data",
                            "executable-data",
                            "reference-counting",
                            "syntactic",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "acc_delete_finalize_async.F90": {
                "num tests": 2,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:runtime,data,executable-data,async,construct-independent,V:2.5-2.7\n      LOGICAL FUNCTION test1()\n        USE OPENACC\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT):: a, b, c, d, e, f !Data\n        INTEGER :: errors\n        errors = 0\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n        CALL RANDOM_NUMBER(a)\n        CALL RANDOM_NUMBER(b)\n        c = 0\n        CALL RANDOM_NUMBER(d)\n        CALL RANDOM_NUMBER(e)\n        f = 0\n\n        !$acc enter data copyin(a(1:LOOPCOUNT), b(1:LOOPCOUNT), d(1:LOOPCOUNT), e(1:LOOPCOUNT))\n        !$acc enter data copyin(a(1:LOOPCOUNT), b(1:LOOPCOUNT), d(1:LOOPCOUNT), e(1:LOOPCOUNT))\n\n        !$acc data present(a(1:LOOPCOUNT), b(1:LOOPCOUNT), d(1:LOOPCOUNT), e(1:LOOPCOUNT)) copyout(c(1:LOOPCOUNT), f(1:LOOPCOUNT))\n          !$acc parallel async(1)\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              c(x) = a(x) + b(x)\n            END DO\n          !$acc end parallel\n          !$acc parallel async(2)\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              f(x) = d(x) + e(x)\n            END DO\n          !$acc end parallel\n          CALL acc_delete_finalize_async(a(1:LOOPCOUNT), 1)\n          CALL acc_delete_finalize_async(b(1:LOOPCOUNT), 1)\n          CALL acc_delete_finalize_async(d(1:LOOPCOUNT), 2)\n          CALL acc_delete_finalize_async(e(1:LOOPCOUNT), 2)\n          !$acc wait\n        !$acc end data\n\n        DO x = 1, LOOPCOUNT\n          IF (abs(c(x) - (a(x) + b(x))) .gt. PRECISION) THEN\n            errors = errors + 1\n          END IF\n          IF (abs(f(x) - (d(x) + e(x))) .gt. PRECISION) THEN\n            errors = errors + 1\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "runtime",
                            "data",
                            "executable-data",
                            "async",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "2": {
                        "content": "#ifndef T2\n!T2:runtime,data,executable-data,async,construct-independent,V:2.5-2.7\n      LOGICAL FUNCTION test2()\n        USE OPENACC\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT):: a, b, c !Data\n        INTEGER :: errors\n        errors = 0\n\n        CALL RANDOM_NUMBER(a)\n        CALL RANDOM_NUMBER(b)\n        c = 0\n\n        !$acc enter data copyin(a(1:LOOPCOUNT), b(1:LOOPCOUNT), c(1:LOOPCOUNT))\n        !$acc enter data copyin(c(1:LOOPCOUNT))\n        !$acc data present(a(1:LOOPCOUNT), b(1:LOOPCOUNT), c(1:LOOPCOUNT))\n          !$acc parallel async(1)\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              c(x) = a(x) + b(x)\n            END DO\n          !$acc end parallel\n        !$acc end data\n\n        CALL acc_delete_finalize_async(c(1:LOOPCOUNT), 1)\n\n        !$acc enter data copyin(c(1:LOOPCOUNT)) async(1)\n        !$acc data present(a(1:LOOPCOUNT), b(1:LOOPCOUNT), c(1:LOOPCOUNT))\n          !$acc parallel async(1)\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              c(x) = c(x) + a(x) + b(x)\n            END DO\n          !$acc end parallel\n        !$acc end data\n\n        !$acc exit data delete(a(1:LOOPCOUNT), b(1:LOOPCOUNT)) copyout(c(1:LOOPCOUNT))\n\n        DO x = 1, LOOPCOUNT\n          IF (abs(c(x) - (a(x) + b(x))) .gt. PRECISION) THEN\n            errors = errors + 1\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test2 = .FALSE.\n        ELSE\n          test2 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T2\n        LOGICAL :: test2\n#endif\n#ifndef T2\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test2()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2**1\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "runtime",
                            "data",
                            "executable-data",
                            "async",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "acc_delete_finalize_async.c": {
                "num tests": 2,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:runtime,data,executable-data,reference-counting,syntactic,construct-independent,async,V:2.5-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t *a = (real_t *)malloc(n * sizeof(real_t));\n    real_t *b = (real_t *)malloc(n * sizeof(real_t));\n    real_t *c = (real_t *)malloc(n * sizeof(real_t));\n    real_t *d = (real_t *)malloc(n * sizeof(real_t));\n    real_t *e = (real_t *)malloc(n * sizeof(real_t));\n    real_t *f = (real_t *)malloc(n * sizeof(real_t));\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n        c[x] = 0;\n        d[x] = rand() / (real_t)(RAND_MAX / 10);\n        e[x] = rand() / (real_t)(RAND_MAX / 10);\n        f[x] = 0;\n    }\n\n    #pragma acc enter data copyin(a[0:n], b[0:n], d[0:n], e[0:n])\n    #pragma acc enter data copyin(a[0:n], b[0:n], d[0:n], e[0:n])\n\n    #pragma acc data present(a[0:n], b[0:n], d[0:n], e[0:n]) copyout(c[0:n], f[0:n])\n    {\n        #pragma acc parallel async(1)\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                c[x] = a[x] + b[x];\n            }\n        }\n        #pragma acc parallel async(2)\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                f[x] = d[x] + e[x];\n            }\n        }\n        acc_delete_finalize_async(a, n * sizeof(real_t), 1);\n        acc_delete_finalize_async(b, n * sizeof(real_t), 1);\n        acc_delete_finalize_async(d, n * sizeof(real_t), 2);\n        acc_delete_finalize_async(e, n * sizeof(real_t), 2);\n        #pragma acc wait\n    }\n\n    for (int x = 0; x < n; ++x){\n        if (fabs(c[x] - (a[x] + b[x])) > PRECISION){\n            err += 1;\n        }\n        if (fabs(f[x] - (d[x] + e[x])) > PRECISION){\n            err += 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "runtime",
                            "data",
                            "executable-data",
                            "reference-counting",
                            "syntactic",
                            "construct-independent",
                            "async"
                        ],
                        "versions": [
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "2": {
                        "content": "#ifndef T2\n//T2:runtime,data,executable-data,reference-counting,devonly,async,construct-independent,V:2.5-2.7\nint test2(){\n    int err = 0;\n    srand(SEED);\n    real_t *a = (real_t *)malloc(n * sizeof(real_t));\n    real_t *b = (real_t *)malloc(n * sizeof(real_t));\n    real_t *c = (real_t *)malloc(n * sizeof(real_t));\n    real_t *d = (real_t *)malloc(n * sizeof(real_t));\n    real_t *e = (real_t *)malloc(n * sizeof(real_t));\n    real_t *f = (real_t *)malloc(n * sizeof(real_t));\n    int* devtest = (int *)malloc(sizeof(int));\n\n    devtest[0] = 1;\n    #pragma acc enter data copyin(devtest[0:1])\n    #pragma acc parallel present(devtest[0:1])\n    {\n        devtest[0] = 0;\n    }\n\n    if (devtest[0] == 1){\n        for (int x = 0; x < n; ++x){\n            a[x] = rand() / (real_t)(RAND_MAX / 10);\n            b[x] = rand() / (real_t)(RAND_MAX / 10);\n            c[x] = 0;\n        }\n\n        #pragma acc enter data copyin(a[0:n], b[0:n], c[0:n])\n        #pragma acc enter data copyin(c[0:n])\n        #pragma acc data present(a[0:n], b[0:n], c[0:n])\n        {\n            #pragma acc parallel async(1)\n            {\n                #pragma acc loop\n                for (int x = 0; x < n; ++x){\n                    c[x] = a[x] * b[x];\n                }\n            }\n        }\n        acc_delete_finalize_async(c, n * sizeof(real_t), 1);\n        #pragma acc enter data copyin(c[0:n]) async(1)\n        #pragma acc data present(a[0:n], b[0:n], c[0:n])\n        {\n            #pragma acc parallel async(1)\n            {\n                #pragma acc loop\n                for (int x = 0; x < n; ++x){\n                    c[x] += a[x] + b[x];\n                }\n            }\n        }\n        #pragma acc exit data delete(a[0:n], b[0:n]) copyout(c[0:n])\n\n        for (int x = 0; x < n; ++x){\n            if (fabs(c[x] - (a[x] + b[x])) > PRECISION){\n                err += 1;\n            }\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T2\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test2();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 1);\n    }\n#endif\n",
                        "tags": [
                            "runtime",
                            "data",
                            "executable-data",
                            "reference-counting",
                            "devonly",
                            "async",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "acc_delete_finalize_async_with_len.F90": {
                "num tests": 2,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:runtime,data,executable-data,async,construct-independent,V:2.5-2.7\n      LOGICAL FUNCTION test1()\n        USE OPENACC\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT):: a, b, c, d, e, f !Data\n        INTEGER :: errors = 0\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n        CALL RANDOM_NUMBER(a)\n        CALL RANDOM_NUMBER(b)\n        c = 0\n        CALL RANDOM_NUMBER(d)\n        CALL RANDOM_NUMBER(e)\n        f = 0\n\n        !$acc enter data copyin(a(1:LOOPCOUNT), b(1:LOOPCOUNT), d(1:LOOPCOUNT), e(1:LOOPCOUNT))\n        !$acc enter data copyin(a(1:LOOPCOUNT), b(1:LOOPCOUNT), d(1:LOOPCOUNT), e(1:LOOPCOUNT))\n\n        !$acc data present(a(1:LOOPCOUNT), b(1:LOOPCOUNT), d(1:LOOPCOUNT), e(1:LOOPCOUNT)) copyout(c(1:LOOPCOUNT), f(1:LOOPCOUNT))\n          !$acc parallel async(1)\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              c(x) = a(x) + b(x)\n            END DO\n          !$acc end parallel\n          !$acc parallel async(2)\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              f(x) = d(x) + e(x)\n            END DO\n          !$acc end parallel\n          CALL acc_delete_finalize_async(a(1), LOOPCOUNT*8, 1)\n          CALL acc_delete_finalize_async(b(1), LOOPCOUNT*8, 1)\n          CALL acc_delete_finalize_async(d(1), LOOPCOUNT*8, 2)\n          CALL acc_delete_finalize_async(e(1), LOOPCOUNT*8, 2)\n          !$acc wait\n        !$acc end data\n\n        DO x = 1, LOOPCOUNT\n          IF (abs(c(x) - (a(x) + b(x))) .gt. PRECISION) THEN\n            errors = errors + 1\n          END IF\n          IF (abs(f(x) - (d(x) + e(x))) .gt. PRECISION) THEN\n            errors = errors + 1\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "runtime",
                            "data",
                            "executable-data",
                            "async",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "2": {
                        "content": "#ifndef T2\n!T2:runtime,data,executable-data,async,construct-independent,V:2.5-2.7\n      LOGICAL FUNCTION test2()\n        USE OPENACC\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT):: a, b, c !Data\n        INTEGER :: errors = 0\n\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n        CALL RANDOM_NUMBER(a)\n        CALL RANDOM_NUMBER(b)\n        c = 0\n\n        !$acc enter data copyin(a(1:LOOPCOUNT), b(1:LOOPCOUNT), c(1:LOOPCOUNT))\n        !$acc enter data copyin(c(1:LOOPCOUNT))\n        !$acc data present(a(1:LOOPCOUNT), b(1:LOOPCOUNT), c(1:LOOPCOUNT))\n          !$acc parallel async(1)\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              c(x) = a(x) + b(x)\n            END DO\n          !$acc end parallel\n        !$acc end data\n\n        CALL acc_delete_finalize_async(c(1), LOOPCOUNT*8, 1)\n\n        !$acc enter data copyin(c(1:LOOPCOUNT)) async(1)\n        !$acc data present(a(1:LOOPCOUNT), b(1:LOOPCOUNT), c(1:LOOPCOUNT))\n          !$acc parallel async(1)\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              c(x) = c(x) + a(x) + b(x)\n            END DO\n          !$acc end parallel\n        !$acc end data\n\n        !$acc exit data delete(a(1:LOOPCOUNT), b(1:LOOPCOUNT)) copyout(c(1:LOOPCOUNT))\n\n        DO x = 1, LOOPCOUNT\n          IF (abs(c(x) - (a(x) + b(x))) .gt. PRECISION) THEN\n            errors = errors + 1\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test2 = .FALSE.\n        ELSE\n          test2 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T2\n        LOGICAL :: test2\n#endif\n#ifndef T2\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test2()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2**1\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "runtime",
                            "data",
                            "executable-data",
                            "async",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "acc_delete_finalize_with_len.F90": {
                "num tests": 2,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:runtime,data,executable-data,construct-independent,V:2.5-2.7\n      LOGICAL FUNCTION test1()\n        USE OPENACC\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT):: a, b, c !Data\n        INTEGER :: errors\n        errors = 0\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n        CALL RANDOM_NUMBER(a)\n        CALL RANDOM_NUMBER(b)\n        c = 0\n\n        !$acc enter data copyin(a(1:LOOPCOUNT), b(1:LOOPCOUNT))\n        !$acc enter data copyin(a(1:LOOPCOUNT), b(1:LOOPCOUNT))\n\n        !$acc data copyout(c(1:LOOPCOUNT))\n          !$acc parallel present(a(1:LOOPCOUNT), b(1:LOOPCOUNT))\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              c(x) = a(x) + b(x)\n            END DO\n          !$acc end parallel\n        !$acc end data\n\n        CALL acc_delete_finalize(a(1), LOOPCOUNT*8)\n        CALL acc_delete_finalize(b(1), LOOPCOUNT*8)\n\n        DO x = 1, LOOPCOUNT\n          IF (abs(c(x) - (a(x) + b(x))) .gt. PRECISION) THEN\n            errors = errors + 1\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "runtime",
                            "data",
                            "executable-data",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "2": {
                        "content": "#ifndef T2\n!T2:runtime,data,executable-data,construct-independent,V:2.5-2.7\n      LOGICAL FUNCTION test2()\n        USE OPENACC\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT):: a, b, c !Data\n        INTEGER :: errors\n        errors = 0\n\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n        CALL RANDOM_NUMBER(a)\n        CALL RANDOM_NUMBER(b)\n        c = 0\n\n        CALL acc_copyin(a(1:LOOPCOUNT))\n        CALL acc_copyin(a(1:LOOPCOUNT))\n        CALL acc_copyin(b(1:LOOPCOUNT))\n        CALL acc_copyin(b(1:LOOPCOUNT))\n\n        !$acc data copyout(c(1:LOOPCOUNT))\n          !$acc parallel present(a(1:LOOPCOUNT), b(1:LOOPCOUNT))\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              c(x) = a(x) + b(x)\n            END DO\n          !$acc end parallel\n        !$acc end data\n\n        CALL acc_delete_finalize(a(1), LOOPCOUNT*8)\n        CALL acc_delete_finalize(b(1), LOOPCOUNT*8)\n\n        DO x = 1, LOOPCOUNT\n          IF (abs(c(x) - (a(x) + b(x))) .gt. PRECISION) THEN\n            errors = errors + 1\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test2 = .FALSE.\n        ELSE\n          test2 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T2\n        LOGICAL :: test2\n#endif\n#ifndef T2\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test2()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2**1\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "runtime",
                            "data",
                            "executable-data",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "acc_delete_with_len.F90": {
                "num tests": 2,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:runtime,data,executable-data,construct-independent,V:2.0-2.7\n      LOGICAL FUNCTION test1()\n        USE OPENACC\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT):: a, b, c !Data\n        INTEGER :: errors\n        errors = 0\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n        CALL RANDOM_NUMBER(a)\n        CALL RANDOM_NUMBER(b)\n        c = 0\n\n        !$acc enter data copyin(a(1:LOOPCOUNT), b(1:LOOPCOUNT))\n\n        !$acc data copyout(c(1:LOOPCOUNT))\n          !$acc parallel present(a(1:LOOPCOUNT), b(1:LOOPCOUNT))\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              c(x) = a(x) + b(x)\n            END DO\n          !$acc end parallel\n        !$acc end data\n\n        CALL acc_delete(a(1), LOOPCOUNT*8)\n        CALL acc_delete(b(1), LOOPCOUNT*8)\n\n        DO x = 1, LOOPCOUNT\n          IF (abs(c(x) - (a(x) + b(x))) .gt. PRECISION) THEN\n            errors = errors + 1\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "runtime",
                            "data",
                            "executable-data",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "2": {
                        "content": "#ifndef T2\n!T2:runtime,data,executable-data,construct-independent,V:2.0-2.7\n      LOGICAL FUNCTION test2()\n        USE OPENACC\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT):: a, b, c !Data\n        INTEGER :: errors\n        errors = 0\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n        CALL RANDOM_NUMBER(a)\n        CALL RANDOM_NUMBER(b)\n        c = 0\n\n        CALL acc_copyin(a(1:LOOPCOUNT))\n        CALL acc_copyin(b(1:LOOPCOUNT))\n\n        !$acc data copyout(c(1:LOOPCOUNT))\n          !$acc parallel present(a(1:LOOPCOUNT), b(1:LOOPCOUNT))\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              c(x) = a(x) + b(x)\n            END DO\n          !$acc end parallel\n        !$acc end data\n\n        CALL acc_delete(a(1), LOOPCOUNT*8)\n        CALL acc_delete(b(1), LOOPCOUNT*8)\n\n        DO x = 1, LOOPCOUNT\n          IF (abs(c(x) - (a(x) + b(x))) .gt. PRECISION) THEN\n            errors = errors + 1\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test2 = .FALSE.\n        ELSE\n          test2 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T2\n        LOGICAL :: test2\n#endif\n#ifndef T2\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test2()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2**1\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "runtime",
                            "data",
                            "executable-data",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "acc_deviceptr.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:runtime,data,executable-data,construct-independent,V:2.0-2.7\nint test1(){\n    int err = 0;\n    real_t *a = (real_t *)malloc(n * sizeof(real_t));\n    real_t *b = (real_t *)malloc(n * sizeof(real_t));\n    real_t *c = (real_t *)malloc(n * sizeof(real_t));\n    real_t *a_ptr;\n    real_t *b_ptr;\n    real_t *c_ptr;\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n        c[x] = 0;\n    }\n\n    #pragma acc enter data copyin(a[0:n], b[0:n]) create(c[0:n])\n\n    a_ptr = acc_deviceptr(a);\n    b_ptr = acc_deviceptr(b);\n    c_ptr = acc_deviceptr(c);\n\n    #pragma acc data deviceptr(a_ptr, b_ptr, c_ptr)\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                c_ptr[x] = a_ptr[x] + b_ptr[x];\n            }\n        }\n    }\n\n    #pragma acc exit data copyout(c[0:n]) delete(a[0:n], b[0:n])\n\n    for (int x = 0; x < n; ++x){\n        if (fabs(c[x] - (a[x] + b[x])) > PRECISION){\n            err += 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "runtime",
                            "data",
                            "executable-data",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "acc_free.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:runtime,data,executable-data,V:2.6-2.7\nint test1(){\n    int err = 0;\n    int *a = (int *)acc_malloc(n * sizeof(int));\n    size_t initial_memory = acc_get_property(acc_get_device_num(acc_get_device_type()), acc_get_device_type(), acc_property_free_memory);\n\n    acc_free(a);\n    size_t final_memory = acc_get_property(acc_get_device_num(acc_get_device_type()), acc_get_device_type(), acc_property_free_memory);\n    if (final_memory < initial_memory + n * sizeof(int)){\n        err += 1;\n    }\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "runtime",
                            "data",
                            "executable-data"
                        ],
                        "versions": [
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "acc_get_default_async.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:runtime,async,construct-independent,internal-control-values,V:2.5-2.7\n      LOGICAL FUNCTION test1()\n        USE OPENACC\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x, holder !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT):: a, b, c !Data\n        INTEGER :: errors\n        INTEGER :: acc_get_default_async\n        errors = 0\n        holder = acc_get_default_async()\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n        CALL RANDOM_NUMBER(a)\n        CALL RANDOM_NUMBER(b)\n        c = 0\n\n        !$acc data copyin(a(1:LOOPCOUNT), b(1:LOOPCOUNT)) copyout(c(1:LOOPCOUNT))\n          !$acc parallel async\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              c(x) = a(x) + b(x)\n            END DO\n          !$acc end parallel\n          !$acc wait(holder)\n        !$acc end data\n\n        DO x = 1, LOOPCOUNT\n          IF (abs(c(x) - (a(x) + b(x))) .gt. PRECISION) THEN\n            errors = errors + 1\n          END IF\n        END DO\n\n        IF (acc_get_default_async() .lt. 0) THEN\n          errors = errors + 1\n        END IF\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "runtime",
                            "async",
                            "construct-independent",
                            "internal-control-values"
                        ],
                        "versions": [
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "acc_get_default_async.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:runtime,async,construct-independent,internal-control-values,V:2.5-2.7\nint test1(){\n    int err = 0;\n    real_t *a = (real_t *)malloc(n * sizeof(real_t));\n    real_t *b = (real_t *)malloc(n * sizeof(real_t));\n    real_t *c = (real_t *)malloc(n * sizeof(real_t));\n    int holder = acc_get_default_async();\n\n    for(int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n        c[x] = 0;\n    }\n\n    #pragma acc data copyin(a[0:n], b[0:n]) copyout(c[0:n])\n    {\n        #pragma acc parallel async\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                c[x] = a[x] + b[x];\n            }\n        }\n        #pragma acc wait(holder)\n    }\n\n    for (int x = 0; x < n; ++x){\n        if (fabs(c[x] - (a[x] + b[x])) > PRECISION){\n            err += 1;\n        }\n    }\n    if (acc_get_default_async() < 0){\n        err += 1;\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "runtime",
                            "async",
                            "construct-independent",
                            "internal-control-values"
                        ],
                        "versions": [
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "acc_get_device_num.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:runtime,construct-independent,internal-control-values,set,V:1.0-2.7\n      LOGICAL FUNCTION test1()\n        USE OPENACC\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x !Iterators\n        INTEGER :: errors\n        errors = 0\n\n        IF (acc_get_device_type() .ne. acc_device_none) THEN\n          DO x = 1, acc_get_num_devices(acc_get_device_type())\n            CALL acc_set_device_num(x, acc_get_device_type())\n            IF (acc_get_device_num(acc_get_device_type()) .ne. x) THEN\n              errors = errors + 1\n            END IF\n          END DO\n        END IF\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "runtime",
                            "construct-independent",
                            "internal-control-values",
                            "set"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "acc_get_device_num.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:runtime,devonly,internal-control-values,syntactic,V:1.0-2.7\nint test1(){\n    int err = 0;\n\n    if (acc_get_device_type() != acc_device_none){\n        for (int x = 0; x < acc_get_num_devices(acc_get_device_type()); ++x){\n            acc_set_device_num(x, acc_get_device_type());\n            if (acc_get_device_num(acc_get_device_type()) != x){\n                err += 1;\n            }\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "runtime",
                            "devonly",
                            "internal-control-values",
                            "syntactic"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "acc_get_num_devices.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:runtime,construct-independent,internal-control-values,V:1.0-2.7\n      LOGICAL FUNCTION test1()\n        USE OPENACC\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: errors\n        errors = 0\n\n        IF (acc_get_device_type() .ne. acc_device_none) THEN\n          IF (acc_get_num_devices(acc_get_device_type()) .eq. 0) THEN\n            errors = errors + 1\n          END IF\n        END IF\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "runtime",
                            "construct-independent",
                            "internal-control-values"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "acc_get_num_devices.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:runtime,devonly,internal-control-values,syntactic,V:1.0-2.7\nint test1(){\n    int err = 0;\n\n    if(acc_get_device_type() != acc_device_none && acc_get_num_devices(acc_get_device_type()) == 0){ //Can't have zero of current device type\n          err += 1;\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "runtime",
                            "devonly",
                            "internal-control-values",
                            "syntactic"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "acc_get_property.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:runtime,construct-independent,internal-control-values,nonvalidating,V:2.6-2.7\n      LOGICAL FUNCTION test1()\n        USE OPENACC\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: output\n        IF (acc_get_device_type() .ne. acc_device_none) THEN\n          output = acc_get_property(acc_get_device_num(acc_get_device_type()), acc_get_device_type(), acc_property_memory)\n          output = acc_get_property(acc_get_device_num(acc_get_device_type()), acc_get_device_type(), acc_property_free_memory)\n        END IF\n        test1 = .FALSE.\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "runtime",
                            "construct-independent",
                            "internal-control-values",
                            "nonvalidating"
                        ],
                        "versions": [
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "acc_get_property.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:runtime,devonly,syntactic,V:2.6-2.7\nint test1(){\n    int err = 0;\n\n    if (acc_get_device_type() != acc_device_none){\n        const char* returned_string1;\n        const char* returned_string2;\n        const char* returned_string3;\n        int returned_int;\n        returned_int = acc_get_property(acc_get_device_num(acc_get_device_type()), acc_get_device_type(), acc_property_memory);\n        returned_int = acc_get_property(acc_get_device_num(acc_get_device_type()), acc_get_device_type(), acc_property_free_memory);\n        returned_string1 = acc_get_property_string(acc_get_device_num(acc_get_device_type()), acc_get_device_type(), acc_property_name);\n        returned_string2 = acc_get_property_string(acc_get_device_num(acc_get_device_type()), acc_get_device_type(), acc_property_vendor);\n        returned_string3 = acc_get_property_string(acc_get_device_num(acc_get_device_type()), acc_get_device_type(), acc_property_driver);\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "runtime",
                            "devonly",
                            "syntactic"
                        ],
                        "versions": [
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "acc_get_property_string.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:runtime,construct-independent,internal-control-values,nonvalidating,V:2.6-2.7\n      LOGICAL FUNCTION test1()\n        USE OPENACC\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        CHARACTER(len=:),ALLOCATABLE :: output1\n        CHARACTER(len=:),ALLOCATABLE :: output2\n        CHARACTER(len=:),ALLOCATABLE :: output3\n        IF (acc_get_device_type() .ne. acc_device_none) THEN\n          CALL acc_get_property_string(acc_get_device_num(acc_get_device_type()), acc_get_device_type, acc_property_name, output1)\n          CALL acc_get_property_string(acc_get_device_num(acc_get_device_type()), acc_get_device_type, acc_property_vendor, output2)\n          CALL acc_get_property_string(acc_get_device_num(acc_get_device_type()), acc_get_device_type, acc_property_driver, output3)\n        END IF\n        test1 = .FALSE.\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "runtime",
                            "construct-independent",
                            "internal-control-values",
                            "nonvalidating"
                        ],
                        "versions": [
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "acc_hostptr.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:runtime,data,V:2.0-2.7\nint test1(){\n    int err = 0;\n    real_t *a = (real_t *)malloc(n * sizeof(real_t));\n    real_t *a_ptr;\n\n    a_ptr = acc_create(a, n * sizeof(real_t));\n\n    if (a != acc_hostptr(acc_deviceptr(a))){\n        err += 1;\n    }\n\n    acc_delete(a, n * sizeof(real_t));\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "runtime",
                            "data"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "acc_init.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:runtime,construct-independent,internal-control-values,init,nonvalidating,V:1.0-2.7\n      LOGICAL FUNCTION test1()\n        USE OPENACC\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        IF (acc_get_device_type() .ne. acc_device_none) THEN\n          CALL acc_init(acc_get_device_type())\n        END IF\n\n        test1 = .FALSE.\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "runtime",
                            "construct-independent",
                            "internal-control-values",
                            "init",
                            "nonvalidating"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "acc_init.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:runtime,init,syntactic,V:2.5-2.7\nint test1(){\n    int err = 0;\n\n    if (acc_get_device_type() != acc_device_none){\n        acc_init(acc_get_device_type());\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "runtime",
                            "init",
                            "syntactic"
                        ],
                        "versions": [
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "acc_is_present.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:runtime,devonly,construct-independent,present,V:2.0-2.7\n      LOGICAL FUNCTION test1()\n        USE OPENACC\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT):: a !Data\n        INTEGER,DIMENSION(1):: devtest\n        INTEGER :: errors\n        errors = 0\n\n        devtest(1) = 1\n        !$acc enter data copyin(devtest(1:1))\n        !$acc parallel present(devtest(1:1))\n          devtest(1) = 0\n        !$acc end parallel\n\n        !$acc enter data create(a(1:LOOPCOUNT))\n        IF (acc_is_present(a(1:LOOPCOUNT)) .eqv. .FALSE.) THEN\n          errors = errors + 1\n          PRINT*, 1\n        END IF\n        !$acc exit data delete(a(1:LOOPCOUNT))\n\n        IF (devtest(1) .eq. 1) THEN\n          IF (acc_is_present(a(1:LOOPCOUNT)) .eqv. .TRUE.) THEN\n            errors = errors + 1\n            PRINT*, 2\n          END IF\n        END IF\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "runtime",
                            "devonly",
                            "construct-independent",
                            "present"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "acc_is_present.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:runtime,data,executable-data,devonly,V:2.0-2.7\nint test1(){\n    int err = 0;\n    real_t *a = (real_t *)malloc(n * sizeof(real_t));\n    int *devtest = (int *)malloc(sizeof(int));\n\n    devtest[0] = 1;\n    #pragma acc enter data copyin(devtest[0:1])\n    #pragma acc parallel present(devtest[0:1])\n    {\n        devtest[0] = 0;\n    }\n\n    #pragma acc enter data create(a[0:n])\n    if (acc_is_present(a, n * sizeof(real_t)) == 0){\n        err += 1;\n    }\n    #pragma acc exit data delete(a[0:n])\n\n    if (devtest[0] == 1){\n        if (acc_is_present(a, n * sizeof(real_t)) != 0){\n            err += 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "runtime",
                            "data",
                            "executable-data",
                            "devonly"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "acc_is_present_with_len.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:runtime,devonly,construct-independent,present,V:2.0-2.7\n      LOGICAL FUNCTION test1()\n        USE OPENACC\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT):: a !Data\n        INTEGER,DIMENSION(1):: devtest\n        INTEGER :: errors = 0\n\n        devtest(1) = 1\n        !$acc enter data copyin(devtest(1:1))\n        !$acc parallel present(devtest(1:1))\n          devtest(1) = 0\n        !$acc end parallel\n\n        !$acc enter data create(a(1:LOOPCOUNT))\n        IF (acc_is_present(a(1), LOOPCOUNT*8) .eqv. .FALSE.) THEN\n          errors = errors + 1\n        END IF\n        !$acc exit data delete(a(1:LOOPCOUNT))\n\n        IF (devtest(1) .eq. 1) THEN\n          IF (acc_is_present(a(1), LOOPCOUNT*8) .eqv. .TRUE.) THEN\n            errors = errors + 1\n          END IF\n        END IF\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "runtime",
                            "devonly",
                            "construct-independent",
                            "present"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "acc_malloc.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:runtime,data,executable-data,V:1.0-2.7\nint test1(){\n    int err = 0;\n    size_t initial_memory = acc_get_property(acc_get_device_num(acc_get_device_type()), acc_get_device_type(), acc_property_free_memory);\n    int *a = (int *)acc_malloc(n * sizeof(int));\n\n    if (initial_memory == 0){\n        return err;\n    }\n    size_t final_memory = acc_get_property(acc_get_device_num(acc_get_device_type()), acc_get_device_type(), acc_property_free_memory);\n    if (final_memory + n * sizeof(int) > initial_memory){\n        err += 1;\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "runtime",
                            "data",
                            "executable-data"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "acc_map_data.c": {
                "num tests": 3,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:runtime,data,executable-data,construct-independent,V:2.0-2.7\nint test1(){\n    int err = 0;\n    real_t *a = (real_t *)malloc(n * sizeof(real_t));\n    real_t *b = (real_t *)malloc(n * sizeof(real_t));\n    real_t *c = (real_t *)malloc(n * sizeof(real_t));\n    real_t *d;\n    real_t *e = (real_t *)malloc(n * sizeof(real_t));\n\n    d = (real_t *)acc_malloc(n * sizeof(real_t));\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n    }\n\n    acc_map_data(c, d, n * sizeof(real_t));\n\n    #pragma acc data copyin(a[0:n], b[0:n]) present(c[0:n])\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                c[x] = a[x] + b[x];\n            }\n        }\n    }\n\n    #pragma acc update host(c[0:n])\n    for (int x = 0; x < n; ++x){\n        if (fabs(c[x] - (a[x] + b[x]))> PRECISION){\n            err += 1;\n        }\n    }\n\n    acc_unmap_data(c);\n    acc_free(d);\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "runtime",
                            "data",
                            "executable-data",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "2": {
                        "content": "#ifndef T2\n//T2:runtime,data,executable-data,construct-independent,V:2.0-2.7\nint test2(){\n    int err = 0;\n    real_t *a = (real_t *)malloc(n * sizeof(real_t));\n    real_t *b = (real_t *)malloc(n * sizeof(real_t));\n    real_t *c = (real_t *)malloc(n * sizeof(real_t));\n    real_t *d;\n    real_t *e = (real_t *)malloc(n * sizeof(real_t));\n\n    d = (real_t *)acc_malloc(2 * n * sizeof(real_t));\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n    }\n    acc_map_data(c, d, n * sizeof(real_t));\n    acc_map_data(e, &(d[n]), n * sizeof(real_t));\n\n    #pragma acc data copyin(a[0:n], b[0:n]) present(c[0:n], e[0:n])\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                c[x] = a[x] + b[x];\n            }\n        }\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                e[x] = a[x] * b[x];\n            }\n        }\n    }\n\n    #pragma acc update host(c[0:n])\n    #pragma acc update host(e[0:n])\n\n    for (int x = 0; x < n; ++x){\n        if (fabs(c[x] - (a[x] + b[x])) > PRECISION){\n            err += 1;\n        }\n        if (fabs(e[x] - (a[x] * b[x])) > PRECISION){\n            err += 1;\n        }\n    }\n    acc_unmap_data(c);\n    acc_unmap_data(e);\n    acc_free(d);\n\n    return err;\n}\n#endif\n#ifndef T2\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test2();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 1);\n    }\n#endif\n",
                        "tags": [
                            "runtime",
                            "data",
                            "executable-data",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "3": {
                        "content": "#ifndef T3\n//T3:runtime,data,executable-data,construct-independent,V:2.0-2.7\nint test3(){\n    int err = 0;\n    real_t *a = (real_t *)malloc(n * sizeof(real_t));\n    real_t *b = (real_t *)malloc(n * sizeof(real_t));\n    real_t *c = (real_t *)malloc(n * sizeof(real_t));\n    real_t *d;\n    real_t *e = (real_t *)malloc(n * sizeof(real_t));\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n    }\n    d = (real_t *)acc_malloc(n * sizeof(real_t));\n\n    #pragma acc data copyin(a[0:n], b[0:n]) deviceptr(d)\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                d[x] = a[x] + b[x];\n            }\n        }\n    }\n\n    acc_map_data(c, d, n * sizeof(real_t));\n    #pragma acc data copyin(a[0:n], b[0:n]) present(c[0:n])\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                c[x] += a[x] + b[x];\n            }\n        }\n    }\n\n    #pragma acc update host(c[0:n])\n\n    for (int x = 0; x < n; ++x){\n        if (fabs(c[x] - 2 * (a[x] + b[x])) > 2 * PRECISION){\n            err += 1;\n        }\n    }\n\n    acc_unmap_data(c);\n    acc_free(d);\n\n    return err;\n}\n#endif\n#ifndef T3\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test3();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 2);\n    }\n#endif\n",
                        "tags": [
                            "runtime",
                            "data",
                            "executable-data",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "acc_memcpy_device.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:runtime,data,executable-data,construct-independent,V:2.5-2.7\nint test1(){\n    int err = 0;\n    real_t *a = (real_t *)malloc(n * sizeof(real_t));\n    real_t *b = (real_t *)malloc(n * sizeof(real_t));\n    real_t *c = (real_t *)malloc(n * sizeof(real_t));\n    real_t *hostdata = (real_t *)malloc(3 * n * sizeof(real_t));\n    real_t *devdata;\n\n    for (int x = 0; x < n; ++x){\n        hostdata[x] = rand() / (real_t)(RAND_MAX / 10);\n        hostdata[n + x] = rand() / (real_t)(RAND_MAX / 10);\n        hostdata[2*n + x] = 1;\n    }\n\n    devdata = acc_copyin(hostdata, 3 * n * sizeof(real_t));\n    #pragma acc enter data create(a[0:n], b[0:n], c[0:n])\n    acc_memcpy_device(a, devdata, n * sizeof(real_t));\n    acc_memcpy_device(b, devdata+n, n * sizeof(real_t));\n    acc_memcpy_device(c, devdata+2*n, n * sizeof(real_t));\n\n    #pragma acc data present(a[0:n], b[0:n], c[0:n])\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                c[x] += a[x] + b[x];\n            }\n        }\n    }\n\n    #pragma acc exit data copyout(a[0:n], b[0:n], c[0:n])\n\n    for (int x = 0; x < n; ++x){\n        if (fabs(a[x] - hostdata[x]) > PRECISION){\n            err += 1;\n        }\n        if (fabs(b[x] - hostdata[n + x]) > PRECISION){\n            err += 1;\n        }\n        if (fabs(c[x] - (1 + a[x] + b[x])) > PRECISION){\n            err += 1;\n        }\n    }\n\n    #pragma acc exit data delete(hostdata[0:3*n])\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "runtime",
                            "data",
                            "executable-data",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "acc_memcpy_from_device.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:runtime,data,executable-data,construct-independent,V:2.0-2.7\nint test1(){\n    int err = 0;\n    real_t *a = (real_t *)malloc(n * sizeof(real_t));\n    real_t *b = (real_t *)malloc(n * sizeof(real_t));\n    real_t *c = (real_t *)malloc(n * sizeof(real_t));\n    real_t *hostdata = (real_t *)malloc(3 * n * sizeof(real_t));\n    real_t *devdata;\n\n    for (int x = 0; x < n; ++x){\n        hostdata[x] = rand() / (real_t)(RAND_MAX / 10);\n        hostdata[n + x] = rand() / (real_t)(RAND_MAX / 10);\n        hostdata[2*n + x] = 1;\n    }\n\n    devdata = acc_copyin(hostdata, 3 * n * sizeof(real_t));\n\n    #pragma acc data deviceptr(devdata)\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                devdata[2*n + x] += devdata[x] + devdata[n + x];\n            }\n        }\n    }\n\n    acc_memcpy_from_device(a, devdata, n * sizeof(real_t));\n    acc_memcpy_from_device(b, &(devdata[n]), n * sizeof(real_t));\n    acc_memcpy_from_device(c, &(devdata[2*n]), n * sizeof(real_t));\n\n\n    for (int x = 0; x < n; ++x){\n        if (fabs(a[x] - hostdata[x]) > PRECISION){\n            err += 1;\n        }\n        if (fabs(b[x] - hostdata[n + x]) > PRECISION){\n            err += 1;\n        }\n        if (fabs(c[x] - (1 + a[x] + b[x])) > PRECISION){\n            err += 1;\n        }\n    }\n\n    #pragma acc exit data delete(hostdata[0:3*n])\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "runtime",
                            "data",
                            "executable-data",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "acc_memcpy_from_device_async.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:runtime,data,executable-data,async,construct-independent,V:2.5-2.7\nint test1(){\n    int err = 0;\n    real_t *a = (real_t *)malloc(n * sizeof(real_t));\n    real_t *b = (real_t *)malloc(n * sizeof(real_t));\n    real_t *c = (real_t *)malloc(n * sizeof(real_t));\n    real_t *d = (real_t *)malloc(n * sizeof(real_t));\n    real_t *e = (real_t *)malloc(n * sizeof(real_t));\n    real_t *f = (real_t *)malloc(n * sizeof(real_t));\n    real_t *hostdata = (real_t *)malloc(6 * n * sizeof(real_t));\n    real_t *hostdata_copy = (real_t *)malloc(6 * n * sizeof(real_t));\n\n    real_t *devdata;\n\n    for (int x = 0; x < n; ++x){\n        hostdata[x] = rand() / (real_t)(RAND_MAX / 10);\n        hostdata[n + x] = rand() / (real_t)(RAND_MAX / 10);\n        hostdata[2*n + x] = 1;\n        hostdata[3*n + x] = rand() / (real_t)(RAND_MAX / 10);\n        hostdata[4*n + x] = rand() / (real_t)(RAND_MAX / 10);\n        hostdata[5*n + x] = 2;\n    }\n\n    for (int x = 0; x < 6*n; ++x){\n        hostdata_copy[x] = hostdata[x];\n    }\n\n    devdata = acc_copyin(hostdata, 6 * n * sizeof(real_t));\n\n    #pragma acc data deviceptr(devdata)\n    {\n        #pragma acc parallel async(1)\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                devdata[x] = devdata[x] * devdata[x];\n            }\n        }\n        acc_memcpy_from_device_async(a, devdata, n * sizeof(real_t), 1);\n        #pragma acc parallel async(2)\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                devdata[n + x] = devdata[n + x] * devdata[n + x];\n            }\n        }\n        acc_memcpy_from_device_async(b, &(devdata[n]), n * sizeof(real_t), 2);\n        #pragma acc parallel async(4)\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                devdata[3*n + x] = devdata[3*n + x] * devdata[3*n + x];\n            }\n        }\n        acc_memcpy_from_device_async(d, &(devdata[3*n]), n * sizeof(real_t), 4);\n        #pragma acc parallel async(5)\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                devdata[4*n + x] = devdata[4*n + x] * devdata[4*n + x];\n            }\n        }\n        acc_memcpy_from_device_async(e, &(devdata[4*n]), n * sizeof(real_t), 5);\n        #pragma acc parallel async(3) wait(1, 2)\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                devdata[2*n + x] += devdata[x] + devdata[n + x];\n            }\n        }\n        acc_memcpy_from_device_async(c, &(devdata[2*n]), n * sizeof(real_t), 3);\n        #pragma acc parallel async(6) wait(4, 5)\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                devdata[5*n + x] += devdata[3*n + x] + devdata[4*n + x];\n            }\n        }\n        acc_memcpy_from_device_async(f, &(devdata[5*n]), n * sizeof(real_t), 6);\n    }\n\n    #pragma acc wait(1)\n    for (int x = 0; x < n; ++x){\n        if (fabs(a[x] - hostdata_copy[x] * hostdata_copy[x]) > PRECISION){\n            err += 1;\n        }\n    }\n    #pragma acc wait(2)\n    for (int x = 0; x < n; ++x){\n        if (fabs(b[x] - hostdata_copy[n + x] * hostdata_copy[n + x]) > PRECISION){\n            err += 1;\n        }\n    }\n    #pragma acc wait(4)\n    for (int x = 0; x < n; ++x){\n        if (fabs(d[x] - hostdata_copy[3*n + x] * hostdata_copy[3*n + x]) > PRECISION){\n            err += 1;\n        }\n    }\n    #pragma acc wait(5)\n    for (int x = 0; x < n; ++x){\n        if (fabs(e[x] - hostdata_copy[4*n + x] * hostdata_copy[4*n + x]) > PRECISION){\n            err += 1;\n        }\n    }\n    #pragma acc wait(3)\n    for (int x = 0; x < n; ++x){\n        if (fabs(c[x] - (1 + a[x] + b[x])) > PRECISION){\n            err += 1;\n        }\n    }\n    #pragma acc wait(6)\n    for (int x = 0; x < n; ++x){\n        if (fabs(f[x] - (2 + d[x] + e[x])) > PRECISION){\n            err += 1;\n        }\n    }\n\n    #pragma acc exit data delete(hostdata[0:6*n])\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "runtime",
                            "data",
                            "executable-data",
                            "async",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "acc_memcpy_to_device.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:runtime,data,executable-data,construct-independent,V:2.0-2.7\nint test1(){\n    int err = 0;\n    real_t *a = (real_t *)malloc(n * sizeof(real_t));\n    real_t *b = (real_t *)malloc(n * sizeof(real_t));\n    real_t *c = (real_t *)malloc(n * sizeof(real_t));\n    real_t *hostdata = (real_t *)malloc(3 * n * sizeof(real_t));\n    real_t *devdata;\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n        c[x] = 1;\n    }\n\n    devdata = acc_create(hostdata, 3 * n * sizeof(real_t));\n\n    acc_memcpy_to_device(devdata, a, n * sizeof(real_t));\n    acc_memcpy_to_device(&(devdata[n]), b, n * sizeof(real_t));\n    acc_memcpy_to_device(&(devdata[2*n]), c, n * sizeof(real_t));\n\n    #pragma acc data deviceptr(devdata)\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                devdata[2*n + x] += devdata[x] + devdata[n + x];\n            }\n        }\n    }\n    #pragma acc exit data copyout(hostdata[0:3*n])\n    for (int x = 0; x < n; ++x){\n        if (fabs(hostdata[2 * n + x] - (1 + hostdata[n + x] + hostdata[x])) > PRECISION){\n            err += 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "runtime",
                            "data",
                            "executable-data",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "acc_memcpy_to_device_async.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:runtime,data,executable-data,async,construct-independent,V:2.5-2.7\nint test1(){\n    int err = 0;\n    real_t *a = (real_t *)malloc(n * sizeof(real_t));\n    real_t *b = (real_t *)malloc(n * sizeof(real_t));\n    real_t *c = (real_t *)malloc(n * sizeof(real_t));\n    real_t *d = (real_t *)malloc(n * sizeof(real_t));\n    real_t *e = (real_t *)malloc(n * sizeof(real_t));\n    real_t *f = (real_t *)malloc(n * sizeof(real_t));\n\n    real_t *a_host = (real_t *)malloc(n * sizeof(real_t));\n    real_t *b_host = (real_t *)malloc(n * sizeof(real_t));\n    real_t *d_host = (real_t *)malloc(n * sizeof(real_t));\n    real_t *e_host = (real_t *)malloc(n * sizeof(real_t));\n\n    real_t *hostdata = (real_t *)malloc(6 * n * sizeof(real_t));\n    real_t *devdata;\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n        c[x] = 1;\n        d[x] = rand() / (real_t)(RAND_MAX / 10);\n        e[x] = rand() / (real_t)(RAND_MAX / 10);\n        f[x] = 2;\n\n        a_host[x] = a[x];\n        b_host[x] = b[x];\n        d_host[x] = d[x];\n        e_host[x] = e[x];\n    }\n\n    devdata = acc_create(hostdata, 6 * n * sizeof(real_t));\n\n    acc_memcpy_to_device_async(devdata, a, n * sizeof(real_t), 1);\n    acc_memcpy_to_device_async(&(devdata[n]), b, n * sizeof(real_t), 2);\n    acc_memcpy_to_device_async(&(devdata[2*n]), c, n * sizeof(real_t), 3);\n    acc_memcpy_to_device_async(&(devdata[3*n]), d, n * sizeof(real_t), 4);\n    acc_memcpy_to_device_async(&(devdata[4*n]), e, n * sizeof(real_t), 5);\n    acc_memcpy_to_device_async(&(devdata[5*n]), f, n * sizeof(real_t), 6);\n\n    #pragma acc data deviceptr(devdata)\n    {\n        #pragma acc parallel async(1)\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                devdata[x] = devdata[x] * devdata[x];\n            }\n        }\n        #pragma acc parallel async(2)\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                devdata[n + x] = devdata[n + x] * devdata[n + x];\n            }\n        }\n        #pragma acc parallel async(4)\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                devdata[3*n + x] = devdata[3*n + x] * devdata[3*n + x];\n            }\n        }\n        #pragma acc parallel async(5)\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                devdata[4*n + x] = devdata[4*n + x] * devdata[4*n + x];\n            }\n        }\n        #pragma acc parallel async(3) wait(1, 2)\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                devdata[2*n + x] += devdata[x] + devdata[n + x];\n            }\n        }\n        #pragma acc parallel async(6) wait(4, 5)\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                devdata[5*n + x] += devdata[3*n + x] + devdata[4*n + x];\n            }\n        }\n    }\n\n    #pragma acc update host(hostdata[2*n:n]) async(3)\n    #pragma acc update host(hostdata[5*n:n]) async(6)\n\n    #pragma acc wait(3)\n    for (int x = 0; x < n; ++x){\n        if (fabs(hostdata[2*n + x] - (1 + a_host[x] * a_host[x] + b_host[x] * b_host[x])) > 4 * PRECISION){\n            err += 1;\n        }\n    }\n\n    #pragma acc wait(6)\n    for (int x = 0; x < n; ++x){\n        if (fabs(hostdata[5*n + x] - (2 + d_host[x] * d_host[x] + e_host[x] * e_host[x])) > PRECISION){\n            err += 1;\n        }\n    }\n\n    #pragma acc exit data delete(hostdata[0:6*n])\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "runtime",
                            "data",
                            "executable-data",
                            "async",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "acc_on_device.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:runtime,construct-independent,internal-control-values,present,V:1.0-2.7\n      LOGICAL FUNCTION test1()\n        USE OPENACC\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: errors\n        INTEGER :: device_type\n        errors = 0\n        device_type = acc_get_device_type()\n        IF (device_type .ne. acc_device_none) THEN\n          !$acc parallel\n            IF (acc_on_device(device_type) .eqv. .FALSE.) THEN\n              errors = errors + 1\n            END IF\n          !$acc end parallel\n        ELSE\n          !$acc parallel\n            IF (acc_on_device(acc_device_host) .eqv. .FALSE.) THEN\n              errors = errors + 1\n            END IF\n          !$acc end parallel\n        END IF\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "runtime",
                            "construct-independent",
                            "internal-control-values",
                            "present"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "acc_on_device.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:runtime,construct-independent,V:1.0-2.7\nint test1(){\n    int err = 0;\n    int device_type = acc_get_device_type();\n\n    if (device_type != acc_device_none){\n        #pragma acc data copy(err)\n        {\n            #pragma acc parallel\n            {\n                if (acc_on_device(device_type) == 0){\n                    err += 1;\n                }\n            }\n        }\n    }\n    else{\n        #pragma acc parallel\n        {\n            if (acc_on_device(acc_device_host) == 0){\n                err += 1;\n            }\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "runtime",
                            "construct-independent"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "acc_set_default_async.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:runtime,async,construct-independent,internal-control-values,set,V:2.5-2.7\n      LOGICAL FUNCTION test1()\n        USE OPENACC\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT):: a, b, c, a_host, b_host !Data\n        INTEGER :: errors = 0\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n        CALL RANDOM_NUMBER(a)\n        CALL RANDOM_NUMBER(b)\n        a_host = a\n        b_host = b\n        c = 0\n\n        !$acc data copyin(a(1:LOOPCOUNT), b(1:LOOPCOUNT)) copyout(c(1:LOOPCOUNT))\n          CALL acc_set_default_async(1)\n          !$acc parallel async\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              a(x) = a(x) * a(x)\n            END DO\n          !$acc end parallel\n          CALL acc_set_default_async(2)\n          !$acc parallel async\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              b(x) = b(x) * b(x)\n            END DO\n          !$acc end parallel\n          !$acc parallel async(1) wait(2)\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              c(x) = a(x) + b(x)\n            END DO\n          !$acc end parallel\n          !$acc wait(1)\n        !$acc end data\n\n        DO x = 1, LOOPCOUNT\n          IF (abs(c(x) - (a_host(x) * a_host(x) + b_host(x) * b_host(x))) .gt. 4 * PRECISION) THEN\n            errors = errors + 1\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "runtime",
                            "async",
                            "construct-independent",
                            "internal-control-values",
                            "set"
                        ],
                        "versions": [
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "acc_set_default_async.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:runtime,async,construct-independent,set,V:2.5-2.7\nint test1(){\n    int err = 0;\n    real_t *a = (real_t *)malloc(n * sizeof(real_t));\n    real_t *b = (real_t *)malloc(n * sizeof(real_t));\n    real_t *c = (real_t *)malloc(n * sizeof(real_t));\n    real_t *a_host = (real_t *)malloc(n * sizeof(real_t));\n    real_t *b_host = (real_t *)malloc(n * sizeof(real_t));\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n        c[x] = 0;\n        a_host[x] = a[x];\n        b_host[x] = b[x];\n    }\n\n    #pragma acc data copyin(a[0:n], b[0:n]) copyout(c[0:n])\n    {\n        acc_set_default_async(1);\n        #pragma acc parallel async\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                a[x] = a[x] * a[x];\n            }\n        }\n        acc_set_default_async(2);\n        #pragma acc parallel async\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                b[x] = b[x] * b[x];\n            }\n        }\n        #pragma acc parallel async(1) wait(2)\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                c[x] = a[x] + b[x];\n            }\n        }\n        #pragma acc wait(1)\n    }\n\n    for (int x = 0; x < n; ++x){\n        if (fabs(c[x] - (a_host[x] * a_host[x] + b_host[x] * b_host[x])) > 4*PRECISION){\n            err += 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "runtime",
                            "async",
                            "construct-independent",
                            "set"
                        ],
                        "versions": [
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "acc_set_device_num.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:runtime,construct-independent,internal-control-values,set,V:2.0-2.7\n      LOGICAL FUNCTION test1()\n        USE OPENACC\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x, y !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT):: a !Data\n        REAL(8),DIMENSION(:, :),ALLOCATABLE :: host_copy\n        INTEGER :: errors = 0\n\n        CALL RANDOM_SEED\n        ALLOCATE(host_copy(acc_get_num_devices(acc_get_device_type()), LOOPCOUNT))\n\n        IF (acc_get_device_type() .ne. acc_device_none) THEN\n          !host_copy(acc_get_num_devices(acc_get_device_type()), LOOPCOUNT)\n          DO x = 1, acc_get_num_devices(acc_get_device_type())\n            DO y = 1, LOOPCOUNT\n              CALL RANDOM_NUMBER(a)\n              host_copy(x) = a\n            END DO\n            acc_set_device_num(x, acc_get_device_type())\n            !$acc enter data copyin(a(1:LOOPCOUNT))\n          END DO\n\n          DO x = 1, acc_get_num_devices(acc_get_device_type)\n            acc_set_device_num(x, acc_get_device_type())\n            !$acc data present(a(1:LOOPCOUNT))\n              !$acc parallel\n                !$acc loop\n                DO y = 1, LOOPCOUNT\n                  a(y) = a(y) + 1\n                END DO\n              !$acc end parallel\n            !$acc end data\n          END DO\n\n          DO x = 1, acc_get_num_devices(acc_get_device_type())\n            acc_set_device_num(x, acc_get_device_type())\n            !$acc exit data copyout(a(1:LOOPCOUNT))\n            DO y = 1, LOOPCOUNT\n              IF (abs(a(y) - (host_copy(x, y) + 1)) .gt. PRECISION) THEN\n                errors = errors + 1\n              END IF\n            END DO\n          END DO\n        END IF\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "runtime",
                            "construct-independent",
                            "internal-control-values",
                            "set"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "acc_set_device_num.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:runtime,devonly,construct-independent,set,V:2.0-2.7\nint test1(){\n    int err = 0;\n\n    if (acc_get_device_type() != acc_device_none){\n        real_t **host_copy = (real_t **)malloc(acc_get_num_devices(acc_get_device_type()) * sizeof(real_t *));\n        for (int x = 0; x < acc_get_num_devices(acc_get_device_type()); ++x){\n            host_copy[x] = (real_t *)malloc(n * sizeof(real_t));\n        }\n        real_t *a = (real_t *)malloc(n * sizeof(real_t));\n        for (int x = 0; x < acc_get_num_devices(acc_get_device_type()); ++x){\n            for (int y = 0; y < n; ++y){\n                a[y] = rand() / (real_t)(RAND_MAX / 10);\n                host_copy[x][y] = a[y];\n            }\n            acc_set_device_num(x, acc_get_device_type());\n            #pragma acc enter data copyin(a[0:n])\n        }\n        for (int x = 0; x < acc_get_num_devices(acc_get_device_type()); ++x){\n            acc_set_device_num(x, acc_get_device_type());\n            #pragma acc data present(a[0:n])\n            {\n                #pragma acc parallel\n                {\n                    #pragma acc loop\n                    for (int y = 0; y < n; ++y){\n                        a[y] = a[y] + 1;\n                    }\n                }\n            }\n        }\n        for (int x = 0; x < acc_get_num_devices(acc_get_device_type()); ++x){\n            acc_set_device_num(x, acc_get_device_type());\n            #pragma acc exit data copyout(a[0:n])\n            for (int y = 0; y < n; ++y){\n                if (fabs(a[y] - (host_copy[x][y] + 1)) > PRECISION){\n                    err += 1;\n                }\n            }\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "runtime",
                            "devonly",
                            "construct-independent",
                            "set"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "acc_set_device_type.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:runtime,construct-independent,internal-control-values,set,V:1.0-2.7\n      LOGICAL FUNCTION test1()\n        USE OPENACC\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.fh\"\n        INTEGER :: errors = 0\n        INTEGER :: device_type\n\n        device_type = acc_get_device_type()\n        CALL acc_set_device_type(device_type)\n        IF (acc_get_device_type() .ne. device_type) THEN\n          errors = errors + 1\n        END IF\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "runtime",
                            "construct-independent",
                            "internal-control-values",
                            "set"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "acc_set_device_type.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:runtime,internal-control-values,syntactic,V:2.0-2.7\nint test1(){\n    int err = 0;\n\n    int device_type = acc_get_device_type();\n\n    acc_set_device_type(device_type);\n    if (acc_get_device_type() != device_type){\n        err += 1;\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "runtime",
                            "internal-control-values",
                            "syntactic"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "acc_shutdown.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:runtime,construct-independent,internal-control-values,shutdown,nonvalidating,V:1.0-2.7\n      LOGICAL FUNCTION test1()\n        USE OPENACC\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        IF (acc_get_device_type() .ne. acc_device_none) THEN\n          CALL acc_shutdown(acc_get_device_type())\n        END IF\n\n        test1 = .FALSE.\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "runtime",
                            "construct-independent",
                            "internal-control-values",
                            "shutdown",
                            "nonvalidating"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "acc_shutdown.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:runtime,devonly,shutdown,V:2.0-2.7\nint test1(){\n    int err = 0;\n\n    if (acc_get_device_type() != acc_device_none){\n        acc_shutdown(acc_get_device_type());\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "runtime",
                            "devonly",
                            "shutdown"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "acc_unmap_data.c": {
                "num tests": 3,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:runtime,data,executable-data,construct-independent,V:2.0-2.7\nint test1(){\n    int err = 0;\n    real_t *a = (real_t *)malloc(n * sizeof(real_t));\n    real_t *b = (real_t *)malloc(n * sizeof(real_t));\n    real_t *c = (real_t *)malloc(n * sizeof(real_t));\n    real_t *d;\n    real_t *e = (real_t *)malloc(n * sizeof(real_t));\n\n    d = (real_t *)acc_malloc(n * sizeof(real_t));\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n    }\n\n    acc_map_data(c, d, n * sizeof(real_t));\n\n    #pragma acc data copyin(a[0:n], b[0:n]) present(c[0:n])\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                c[x] = a[x] + b[x];\n            }\n        }\n    }\n\n    #pragma acc update host(c[0:n])\n    for (int x = 0; x < n; ++x){\n        if (fabs(c[x] - (a[x] + b[x]))> PRECISION){\n            err += 1;\n        }\n    }\n\n    acc_unmap_data(c);\n    acc_free(d);\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "runtime",
                            "data",
                            "executable-data",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "2": {
                        "content": "#ifndef T2\n//T2:runtime,data,executable-data,construct-independent,V:2.0-2.7\nint test2(){\n    int err = 0;\n    real_t *a = (real_t *)malloc(n * sizeof(real_t));\n    real_t *b = (real_t *)malloc(n * sizeof(real_t));\n    real_t *c = (real_t *)malloc(n * sizeof(real_t));\n    real_t *d;\n    real_t *e = (real_t *)malloc(n * sizeof(real_t));\n\n    d = (real_t *)acc_malloc(2 * n * sizeof(real_t));\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n    }\n    acc_map_data(c, d, n * sizeof(real_t));\n    acc_map_data(e, &(d[n]), n * sizeof(real_t));\n\n    #pragma acc data copyin(a[0:n], b[0:n]) present(c[0:n], e[0:n])\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                c[x] = a[x] + b[x];\n            }\n        }\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                e[x] = a[x] * b[x];\n            }\n        }\n    }\n\n    #pragma acc update host(c[0:n])\n    #pragma acc update host(e[0:n])\n\n    for (int x = 0; x < n; ++x){\n        if (fabs(c[x] - (a[x] + b[x])) > PRECISION){\n            err += 1;\n        }\n        if (fabs(e[x] - (a[x] * b[x])) > PRECISION){\n            err += 1;\n        }\n    }\n    acc_unmap_data(c);\n    acc_unmap_data(e);\n    acc_free(d);\n\n    return err;\n}\n#endif\n#ifndef T2\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test2();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 1);\n    }\n#endif\n",
                        "tags": [
                            "runtime",
                            "data",
                            "executable-data",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "3": {
                        "content": "#ifndef T3\n//T3:runtime,data,executable-data,construct-independent,V:2.0-2.7\nint test3(){\n    int err = 0;\n    real_t *a = (real_t *)malloc(n * sizeof(real_t));\n    real_t *b = (real_t *)malloc(n * sizeof(real_t));\n    real_t *c = (real_t *)malloc(n * sizeof(real_t));\n    real_t *d;\n    real_t *e = (real_t *)malloc(n * sizeof(real_t));\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n    }\n    d = (real_t *)acc_malloc(n * sizeof(real_t));\n\n    #pragma acc data copyin(a[0:n], b[0:n]) deviceptr(d)\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                d[x] = a[x] + b[x];\n            }\n        }\n    }\n\n    acc_map_data(c, d, n * sizeof(real_t));\n    #pragma acc data copyin(a[0:n], b[0:n]) present(c[0:n])\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                c[x] += a[x] + b[x];\n            }\n        }\n    }\n\n    #pragma acc update host(c[0:n])\n\n    for (int x = 0; x < n; ++x){\n        if (fabs(c[x] - 2 * (a[x] + b[x])) > 2 * PRECISION){\n            err += 1;\n        }\n    }\n\n    acc_unmap_data(c);\n    acc_free(d);\n\n    return err;\n}\n#endif\n#ifndef T3\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test3();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 2);\n    }\n#endif\n",
                        "tags": [
                            "runtime",
                            "data",
                            "executable-data",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "acc_update_device.F90": {
                "num tests": 2,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:runtime,data,executable-data,construct-independent,update,V:2.0-2.7\n      LOGICAL FUNCTION test1()\n        USE OPENACC\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT):: a, b, c !Data\n        INTEGER :: errors = 0\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n        CALL RANDOM_NUMBER(a)\n        CALL RANDOM_NUMBER(b)\n        c = 0\n\n        !$acc data copyout(c(1:LOOPCOUNT)) create(a(1:LOOPCOUNT), b(1:LOOPCOUNT))\n          CALL acc_update_device(a(1:LOOPCOUNT))\n          CALL acc_update_device(b(1:LOOPCOUNT))\n          !$acc parallel\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              c(x) = a(x) + b(x)\n            END DO\n          !$acc end parallel\n        !$acc end data\n\n        DO x = 1, LOOPCOUNT\n          IF (abs(c(x) - (a(x) + b(x))) .gt. PRECISION) THEN\n            errors = errors + 1\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "runtime",
                            "data",
                            "executable-data",
                            "construct-independent",
                            "update"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "2": {
                        "content": "#ifndef T2\n!T2:runtime,data,executable-data,devonly,construct-independent,update,V:2.0-2.7\n      LOGICAL FUNCTION test2()\n        USE OPENACC\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT):: a, b, c !Data\n        INTEGER,DIMENSION(1):: devtest\n        INTEGER :: errors = 0\n\n        devtest(1) = 1\n        !$acc enter data copyin(devtest(1:1))\n        !$acc parallel present(devtest(1:1))\n          devtest(1) = 0\n        !$acc end parallel\n\n        IF (devtest(1) .eq. 1) THEN\n          CALL RANDOM_NUMBER(a)\n          CALL RANDOM_NUMBER(b)\n          c = 0\n\n          !$acc data copyout(c(1:LOOPCOUNT)) copyin(a(1:LOOPCOUNT), b(1:LOOPCOUNT))\n            !$acc parallel\n              !$acc loop\n              DO x = 1, LOOPCOUNT\n                a(x) = a(x) * a(x)\n              END DO\n            !$acc end parallel\n            CALL acc_update_device(a(1:LOOPCOUNT))\n            !$acc parallel\n              !$acc loop\n              DO x = 1, LOOPCOUNT\n                b(x) = b(x) * b(x)\n              END DO\n            !$acc end parallel\n            CALL acc_update_device(b(1:LOOPCOUNT))\n            !$acc parallel\n              !$acc loop\n              DO x = 1, LOOPCOUNT\n                c(x) = a(x) + b(x)\n              END DO\n            !$acc end parallel\n          !$acc end data\n\n          DO x = 1, LOOPCOUNT\n            IF (abs(c(x) - (a(x) + b(x))) .gt. PRECISION) THEN\n              errors = errors + 1\n            END IF\n          END DO\n        END IF\n\n        IF (errors .eq. 0) THEN\n          test2 = .FALSE.\n        ELSE\n          test2 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T2\n        LOGICAL :: test2\n#endif\n#ifndef T2\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test2()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 1\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "runtime",
                            "data",
                            "executable-data",
                            "devonly",
                            "construct-independent",
                            "update"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "acc_update_device.c": {
                "num tests": 2,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:runtime,data,executable-data,construct-independent,V:2.0-2.7\nint test1(){\n    int err = 0;\n    real_t *a = (real_t *)malloc(n * sizeof(real_t));\n    real_t *b = (real_t *)malloc(n * sizeof(real_t));\n    real_t *c = (real_t *)malloc(n * sizeof(real_t));\n    int *devtest = (int *)malloc(sizeof(int));\n\n    devtest[0] = 1;\n    #pragma acc enter data copyin(devtest[0:1])\n    #pragma acc parallel\n    {\n        devtest[0] = 0;\n    }\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n        c[x] = 0;\n    }\n\n    #pragma acc data copyout(c[0:n]) create(a[0:n], b[0:n])\n    {\n        acc_update_device(a, n * sizeof(real_t));\n        acc_update_device(b, n * sizeof(real_t));\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                c[x] = a[x] + b[x];\n            }\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        if (fabs(c[x] - (a[x] + b[x])) > PRECISION){\n            err += 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "runtime",
                            "data",
                            "executable-data",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "2": {
                        "content": "#ifndef T2\n//T2:runtime,data,executable-data,construct-independent,V:2.0-2.7\nint test2(){\n    int err = 0;\n    real_t *a = (real_t *)malloc(n * sizeof(real_t));\n    real_t *b = (real_t *)malloc(n * sizeof(real_t));\n    real_t *c = (real_t *)malloc(n * sizeof(real_t));\n    int *devtest = (int *)malloc(sizeof(int));\n\n    devtest[0] = 1;\n    #pragma acc enter data copyin(devtest[0:1])\n    #pragma acc parallel\n    {\n        devtest[0] = 0;\n    }\n\n    if (devtest[0] == 1){\n        for (int x = 0; x < n; ++x){\n            a[x] = rand() / (real_t)(RAND_MAX / 10);\n            b[x] = rand() / (real_t)(RAND_MAX / 10);\n            c[x] = 0;\n        }\n\n        #pragma acc data copyout(c[0:n]) copyin(a[0:n], b[0:n])\n        {\n            #pragma acc parallel\n            {\n                #pragma acc loop\n                for (int x = 0; x < n; ++x){\n                    a[x] = a[x] * a[x];\n                }\n            }\n            acc_update_device(a, n * sizeof(real_t));\n            #pragma acc parallel\n            {\n                #pragma acc loop\n                for (int x = 0; x < n; ++x){\n                    b[x] = b[x] * b[x];\n                }\n            }\n            acc_update_device(b, n * sizeof(real_t));\n            #pragma acc parallel\n            {\n                #pragma acc loop\n                for (int x = 0; x < n; ++x){\n                    c[x] = a[x] + b[x];\n                }\n            }\n        }\n\n\n        for (int x = 0; x < n; ++x){\n            if (fabs(c[x] - (a[x] + b[x])) > PRECISION){\n                err += 1;\n            }\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T2\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test2();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 1);\n    }\n#endif\n",
                        "tags": [
                            "runtime",
                            "data",
                            "executable-data",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "acc_update_device_async.F90": {
                "num tests": 2,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:runtime,data,executable-data,async,construct-independent,update,V:2.5-2.7\n      LOGICAL FUNCTION test1()\n        USE OPENACC\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT):: a, b, c, a_host, b_host !Data\n        INTEGER :: errors = 0\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n        CALL RANDOM_NUMBER(a)\n        CALL RANDOM_NUMBER(b)\n        c = 0\n        a_host = a\n        b_host = b\n\n        !$acc data create(a(1:LOOPCOUNT), b(1:LOOPCOUNT)) copyout(c(1:LOOPCOUNT))\n          CALL acc_update_device_async(a(1:LOOPCOUNT), 1)\n          !$acc parallel async(1)\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              a(x) = a(x) * a(x)\n            END DO\n          !$acc end parallel\n          CALL acc_update_device_async(b(1:LOOPCOUNT), 2)\n          !$acc parallel async(2)\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              b(x) = b(x) * b(x)\n            END DO\n          !$acc end parallel\n          !$acc parallel async(1) wait(2)\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              c(x) = a(x) + b(x)\n            END DO\n          !$acc end parallel\n          !$acc wait(1)\n        !$acc end data\n\n        DO x = 1, LOOPCOUNT\n          IF (abs(c(x) - ((a_host(x) * a_host(x)) + (b_host(x) * b_host(x)))) .gt. PRECISION) THEN\n            errors = errors + 1\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "runtime",
                            "data",
                            "executable-data",
                            "async",
                            "construct-independent",
                            "update"
                        ],
                        "versions": [
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "2": {
                        "content": "#ifndef T2\n!T2:runtime,data,executable-data,devonly,async,construct-independent,update,V:2.5-2.7\n      LOGICAL FUNCTION test2()\n        USE OPENACC\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT):: a, b, c !Data\n        INTEGER,DIMENSION(1):: devtest\n        INTEGER :: errors = 0\n\n        devtest(1) = 1\n        !$acc enter data copyin(devtest(1:1))\n        !$acc parallel present(devtest(1:1))\n          devtest(1) = 0\n        !$acc end parallel\n        IF (devtest(1) .eq. 1) THEN\n          CALL RANDOM_NUMBER(a)\n          CALL RANDOM_NUMBER(b)\n          c = 0\n\n          !$acc data copyout(c(1:LOOPCOUNT)) copyin(a(1:LOOPCOUNT), b(1:LOOPCOUNT))\n            !$acc parallel async(1)\n              !$acc loop\n              DO x = 1, LOOPCOUNT\n                a(x) = a(x) * a(x)\n              END DO\n            !$acc end parallel\n            CALL acc_update_device_async(a(1:LOOPCOUNT), 1)\n            !$acc parallel async(2)\n              !$acc loop\n              DO x = 1, LOOPCOUNT\n                b(x) = b(x) * b(x)\n              END DO\n            !$acc end parallel\n            CALL acc_update_device_async(b(1:LOOPCOUNT), 2)\n            !$acc parallel async(1) wait(2)\n              !$acc loop\n              DO x = 1, LOOPCOUNT\n                c(x) = a(x) + b(x)\n              END DO\n            !$acc end parallel\n            !$acc wait(1)\n          !$acc end data\n\n          DO x = 1, LOOPCOUNT\n            IF (abs(c(x) - (a(x) + b(x))) .gt. PRECISION) THEN\n              errors = errors + 1\n            END IF\n          END DO\n        END IF\n\n        IF (errors .eq. 0) THEN\n          test2 = .FALSE.\n        ELSE\n          test2 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T2\n        LOGICAL :: test2\n#endif\n#ifndef T2\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test2()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 1\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "runtime",
                            "data",
                            "executable-data",
                            "devonly",
                            "async",
                            "construct-independent",
                            "update"
                        ],
                        "versions": [
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "acc_update_device_async.c": {
                "num tests": 2,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:runtime,data,executable-data,async,construct-independent,V:2.5-2.7\nint test1(){\n    int err = 0;\n    real_t *a = (real_t *)malloc(n * sizeof(real_t));\n    real_t *b = (real_t *)malloc(n * sizeof(real_t));\n    real_t *c = (real_t *)malloc(n * sizeof(real_t));\n    real_t *a_host = (real_t *)malloc(n * sizeof(real_t));\n    real_t *b_host = (real_t *)malloc(n * sizeof(real_t));\n\n    int *devtest = (int *)malloc(sizeof(int));\n\n    devtest[0] = 1;\n    #pragma acc enter data copyin(devtest[0:1])\n    #pragma acc parallel\n    {\n        devtest[0] = 0;\n    }\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n        c[x] = 0;\n        a_host[x] = a[x];\n        b_host[x] = b[x];\n    }\n\n\n\n    #pragma acc data copyout(c[0:n]) create(a[0:n], b[0:n])\n    {\n        acc_update_device_async(a, n * sizeof(real_t), 1);\n        #pragma acc parallel async(1)\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                a[x] = a[x] * a[x];\n            }\n        }\n        acc_update_device_async(b, n * sizeof(real_t), 2);\n        #pragma acc parallel async(2)\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                b[x] = b[x] * b[x];\n            }\n        }\n        #pragma acc parallel async(1) wait(2)\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                c[x] = a[x] + b[x];\n            }\n        }\n        #pragma acc wait(1)\n    }\n\n    for (int x = 0; x < n; ++x){\n        if (fabs(c[x] - (a_host[x] * a_host[x] + b_host[x] * b_host[x])) > PRECISION){\n            err += 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "runtime",
                            "data",
                            "executable-data",
                            "async",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "2": {
                        "content": "#ifndef T2\n//T2:runtime,data,executable-data,async,devonly,construct-independent,V:2.5-2.7\nint test2(){\n    int err = 0;\n    real_t *a = (real_t *)malloc(n * sizeof(real_t));\n    real_t *b = (real_t *)malloc(n * sizeof(real_t));\n    real_t *c = (real_t *)malloc(n * sizeof(real_t));\n    real_t *a_host = (real_t *)malloc(n * sizeof(real_t));\n    real_t *b_host = (real_t *)malloc(n * sizeof(real_t));\n\n    int *devtest = (int *)malloc(sizeof(int));\n\n    devtest[0] = 1;\n    #pragma acc enter data copyin(devtest[0:1])\n    #pragma acc parallel\n    {\n        devtest[0] = 0;\n    }\n\n    if (devtest[0] == 1){\n        for (int x = 0; x < n; ++x){\n            a[x] = rand() / (real_t)(RAND_MAX / 10);\n            b[x] = rand() / (real_t)(RAND_MAX / 10);\n            c[x] = 0;\n        }\n\n        #pragma acc data copyout(c[0:n]) copyin(a[0:n], b[0:n])\n        {\n            #pragma acc parallel async(1)\n            {\n                #pragma acc loop\n                for (int x = 0; x < n; ++x){\n                    a[x] = a[x] * a[x];\n                }\n            }\n            acc_update_device_async(a, n * sizeof(real_t), 1);\n            #pragma acc parallel async(2)\n            {\n                #pragma acc loop\n                for (int x = 0; x < n; ++x){\n                    b[x] = b[x] * b[x];\n                }\n            }\n            acc_update_device_async(b, n * sizeof(real_t), 2);\n            #pragma acc parallel async(1) wait(2)\n            {\n                #pragma acc loop\n                for (int x = 0; x < n; ++x){\n                    c[x] = a[x] + b[x];\n                }\n            }\n            #pragma acc wait(1)\n        }\n\n\n        for (int x = 0; x < n; ++x){\n            if (fabs(c[x] - (a[x] + b[x])) > PRECISION){\n                err += 1;\n            }\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T2\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test2();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 1);\n    }\n#endif\n",
                        "tags": [
                            "runtime",
                            "data",
                            "executable-data",
                            "async",
                            "devonly",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "acc_update_device_async_with_len.F90": {
                "num tests": 2,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:runtime,data,executable-data,async,construct-independent,update,V:2.5-2.7\n      LOGICAL FUNCTION test1()\n        USE OPENACC\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT):: a, b, c, a_host, b_host !Data\n        INTEGER :: errors\n        errors = 0\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n        CALL RANDOM_NUMBER(a)\n        CALL RANDOM_NUMBER(b)\n        c = 0\n        a_host = a\n        b_host = b\n\n        !$acc data copyin(a(1:LOOPCOUNT), b(1:LOOPCOUNT)) copyout(c(1:LOOPCOUNT))\n          CALL acc_update_device_async(a(1), LOOPCOUNT*8, 1)\n          !$acc parallel async(1)\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              a(x) = a(x) * a(x)\n            END DO\n          !$acc end parallel\n          CALL acc_update_device_async(b(1), LOOPCOUNT*8, 2)\n          !$acc parallel async(2)\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              b(x) = b(x) * b(x)\n            END DO\n          !$acc end parallel\n          !$acc parallel async(1) wait(2)\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              c(x) = a(x) + b(x)\n            END DO\n          !$acc end parallel\n          !$acc wait(1)\n        !$acc end data\n\n        DO x = 1, LOOPCOUNT\n          IF (abs(c(x) - ((a_host(x) * a_host(x)) + (b_host(x) * b_host(x)))) .gt. PRECISION) THEN\n            errors = errors + 1\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "runtime",
                            "data",
                            "executable-data",
                            "async",
                            "construct-independent",
                            "update"
                        ],
                        "versions": [
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "2": {
                        "content": "#ifndef T2\n!T2:runtime,data,executable-data,devonly,async,construct-independent,update,V:2.5-2.7\n      LOGICAL FUNCTION test2()\n        USE OPENACC\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT):: a, b, c !Data\n        INTEGER,DIMENSION(1):: devtest\n        INTEGER :: errors\n        errors = 0\n\n        devtest(1) = 1\n        !$acc enter data copyin(devtest(1:1))\n        !$acc parallel present(devtest(1:1))\n          devtest(1) = 0\n        !$acc end parallel\n        IF (devtest(1) .eq. 1) THEN\n          CALL RANDOM_NUMBER(a)\n          CALL RANDOM_NUMBER(b)\n          c = 0\n\n          !$acc data copyout(c(1:LOOPCOUNT)) copyin(a(1:LOOPCOUNT), b(1:LOOPCOUNT))\n            !$acc parallel async(1)\n              !$acc loop\n              DO x = 1, LOOPCOUNT\n                a(x) = a(x) * a(x)\n              END DO\n            !$acc end parallel\n            CALL acc_update_device_async(a(1), LOOPCOUNT*8, 1)\n            !$acc parallel async(2)\n              !$acc loop\n              DO x = 1, LOOPCOUNT\n                b(x) = b(x) * b(x)\n              END DO\n            !$acc end parallel\n            CALL acc_update_device_async(b(1), LOOPCOUNT*8, 2)\n            !$acc parallel async(1), wait(2)\n              !$acc loop\n               DO x = 1, LOOPCOUNT\n                 c(x) = a(x) + b(x)\n               END DO\n            !$acc end parallel\n            !$acc wait(1)\n          !$acc end data\n\n          DO x = 1, LOOPCOUNT\n            IF (abs(c(x) - (a(x) + b(x))) .gt. PRECISION) THEN\n              errors = errors + 1\n            END IF\n          END DO\n        END IF\n\n        IF (errors .eq. 0) THEN\n          test2 = .FALSE.\n        ELSE\n          test2 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T2\n        LOGICAL :: test2\n#endif\n#ifndef T2\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test2()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 1\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "runtime",
                            "data",
                            "executable-data",
                            "devonly",
                            "async",
                            "construct-independent",
                            "update"
                        ],
                        "versions": [
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "acc_update_device_with_len.F90": {
                "num tests": 2,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:runtime,data,executable-data,devonly,construct-independent,update,V:2.0-2.7\n      LOGICAL FUNCTION test1()\n        USE OPENACC\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT):: a, b, c !Data\n        INTEGER,DIMENSION(1):: devtest\n        REAL(8) :: RAND\n        INTEGER :: errors = 0\n\n        devtest(1) = 1\n        !$acc enter data copyin(devtest(1:1))\n        !$acc parallel\n          devtest(1) = 0\n        !$acc end parallel\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(a)\n        CALL RANDOM_NUMBER(b)\n        c = 0\n\n        !$acc data copyout(c(1:LOOPCOUNT)) create(a(1:LOOPCOUNT), b(1:LOOPCOUNT))\n          CALL acc_update_device(a(1), LOOPCOUNT*8)\n          CALL acc_update_device(b(1), LOOPCOUNT*8)\n          !$acc parallel\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              c(x) = a(x) + b(x)\n            END DO\n          !$acc end parallel\n        !$acc end data\n\n        DO x = 1, LOOPCOUNT\n          IF (abs(c(x) - (a(x) + b(x))) .gt. PRECISION) THEN\n            errors = errors + 1\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "runtime",
                            "data",
                            "executable-data",
                            "devonly",
                            "construct-independent",
                            "update"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "2": {
                        "content": "#ifndef T2\n!T2:runtime,data,executable-data,devonly,construct-independent,update,V:2.0-2.7\n      LOGICAL FUNCTION test2()\n        USE OPENACC\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT):: a, b, c !Data\n        INTEGER,DIMENSION(1):: devtest\n        REAL(8) :: RAND\n        INTEGER :: errors = 0\n\n        devtest(1) = 1\n        !$acc enter data copyin(devtest(1:1))\n        !$acc parallel\n          devtest(1) = 0\n        !$acc end parallel\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        IF (devtest(1) .eq. 1) THEN\n          CALL RANDOM_NUMBER(a)\n          CALL RANDOM_NUMBER(b)\n          c = 0\n\n          !$acc data copyout(c(1:LOOPCOUNT)) copyin(a(1:LOOPCOUNT), b(1:LOOPCOUNT))\n            !$acc parallel\n              !$acc loop\n              DO x = 1, LOOPCOUNT\n                a(x) = a(x) * a(x)\n              END DO\n            !$acc end parallel\n            CALL acc_update_device(a(1), LOOPCOUNT*8)\n            !$acc parallel\n              !$acc loop\n              DO x = 1, LOOPCOUNT\n                b(x) = b(x) * b(x)\n              END DO\n            !$acc end parallel\n            CALL acc_update_device(b(1), LOOPCOUNT*8)\n            !$acc parallel\n              !$acc loop\n              DO x = 1, LOOPCOUNT\n                c(x) = a(x) + b(x)\n              END DO\n            !$acc end parallel\n          !$acc end data\n\n          DO x = 1, LOOPCOUNT\n            IF (abs(c(x) - (a(x) + b(x))) .gt. PRECISION) THEN\n              errors = errors + 1\n            END IF\n          END DO\n        END IF\n\n        IF (errors .eq. 0) THEN\n          test2 = .FALSE.\n        ELSE\n          test2 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T2\n        LOGICAL :: test2\n#endif\n#ifndef T2\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test2()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 1\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "runtime",
                            "data",
                            "executable-data",
                            "devonly",
                            "construct-independent",
                            "update"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "acc_update_self.F90": {
                "num tests": 2,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:runtime,data,executable-data,construct-independent,update,V:2.0-2.7\n      LOGICAL FUNCTION test1()\n        USE OPENACC\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT):: a, b, c !Data\n        REAL(8) :: RAND\n        INTEGER :: errors = 0\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(a)\n        CALL RANDOM_NUMBER(b)\n        c = 0\n\n        !$acc data copyin(a(1:LOOPCOUNT), b(1:LOOPCOUNT)) create(c(1:LOOPCOUNT))\n          !$acc parallel\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              c(x) = a(x) + b(x)\n            END DO\n          !$acc end parallel\n          CALL acc_update_self(c(1:LOOPCOUNT))\n        !$acc end data\n\n        DO x = 1, LOOPCOUNT\n          IF (abs(c(x) - (a(x) + b(x))) .gt. PRECISION) THEN\n            errors = errors + 1\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "runtime",
                            "data",
                            "executable-data",
                            "construct-independent",
                            "update"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "2": {
                        "content": "#ifndef T2\n!T2:runtime,data,executable-data,construct-independent,update,V:2.0-2.7\n      LOGICAL FUNCTION test2()\n        USE OPENACC\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT):: a, b, c !Data\n        REAL(8) :: RAND\n        INTEGER :: errors = 0\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(a)\n        CALL RANDOM_NUMBER(b)\n        c = 0\n\n        !$acc data copyout(c(1:LOOPCOUNT)) copyin(a(1:LOOPCOUNT), b(1:LOOPCOUNT))\n          !$acc parallel\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              a(x) = a(x) * a(x)\n            END DO\n          !$acc end parallel\n          CALL acc_update_self(a(1:LOOPCOUNT))\n          !$acc parallel\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              b(x) = b(x) * b(x)\n            END DO\n          !$acc end parallel\n          CALL acc_update_self(b(1:LOOPCOUNT))\n          !$acc parallel\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              c(x) = a(x) + b(x)\n            END DO\n          !$acc end parallel\n        !$acc end data\n\n        DO x = 1, LOOPCOUNT\n          IF (abs(c(x) - (a(x) + b(x))) .gt. PRECISION) THEN\n            errors = errors + 1\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test2 = .FALSE.\n        ELSE\n          test2 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T2\n        LOGICAL :: test2\n#endif\n#ifndef T2\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test2()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 1\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "runtime",
                            "data",
                            "executable-data",
                            "construct-independent",
                            "update"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "acc_update_self.c": {
                "num tests": 2,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:runtime,data,executable-data,construct-independent,V:2.0-2.7\nint test1(){\n    int err = 0;\n    real_t *a = (real_t *)malloc(n * sizeof(real_t));\n    real_t *b = (real_t *)malloc(n * sizeof(real_t));\n    real_t *c = (real_t *)malloc(n * sizeof(real_t));\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n        c[x] = 0;\n    }\n\n    #pragma acc data create(c[0:n]) copyin(a[0:n], b[0:n])\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                c[x] = a[x] + b[x];\n            }\n        }\n        acc_update_self(c, n * sizeof(real_t));\n    }\n\n    for (int x = 0; x < n; ++x){\n        if (fabs(c[x] - (a[x] + b[x])) > PRECISION){\n            err += 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "runtime",
                            "data",
                            "executable-data",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "2": {
                        "content": "#ifndef T2\n//T2:runtime,data,executable-data,construct-independent,V:2.0-2.7\nint test2(){\n    int err = 0;\n    real_t *a = (real_t *)malloc(n * sizeof(real_t));\n    real_t *b = (real_t *)malloc(n * sizeof(real_t));\n    real_t *c = (real_t *)malloc(n * sizeof(real_t));\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n        c[x] = 0;\n    }\n\n    #pragma acc data copyout(c[0:n]) copyin(a[0:n], b[0:n])\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                a[x] = a[x] * a[x];\n            }\n        }\n        acc_update_self(a, n * sizeof(real_t));\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                b[x] = b[x] * b[x];\n            }\n        }\n        acc_update_self(b, n * sizeof(real_t));\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                c[x] = a[x] + b[x];\n            }\n        }\n    }\n\n\n    for (int x = 0; x < n; ++x){\n        if (fabs(c[x] - (a[x] + b[x])) > PRECISION){\n            err += 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T2\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test2();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 1);\n    }\n#endif\n",
                        "tags": [
                            "runtime",
                            "data",
                            "executable-data",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "acc_update_self_async.F90": {
                "num tests": 2,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:runtime,data,executable-data,devonly,async,construct-independent,update,V:2.5-2.7\n      LOGICAL FUNCTION test1()\n        USE OPENACC\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT):: a, b, c, d !Data\n        INTEGER,DIMENSION(1):: devtest\n        REAL(8) :: RAND\n        INTEGER :: errors = 0\n\n        devtest(1) = 1\n        !$acc enter data copyin(devtest(1:1))\n        !$acc parallel\n          devtest(1) = 0\n        !$acc end parallel\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(a)\n        CALL RANDOM_NUMBER(b)\n        c = 0\n        d = 0\n\n        !$acc data copyin(a(1:LOOPCOUNT), b(1:LOOPCOUNT)) create(c(1:LOOPCOUNT), d(1:LOOPCOUNT))\n          !$acc parallel async(1)\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              c(x) = a(x) + b(x)\n            END DO\n          !$acc end parallel\n          !$acc parallel async(2)\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              d(x) = a(x) * b(x)\n            END DO\n          !$acc end parallel\n          CALL acc_update_self_async(c(1:LOOPCOUNT), 1)\n          CALL acc_update_self_async(d(1:LOOPCOUNT), 2)\n          !$acc wait\n        !$acc end data\n\n        DO x = 1, LOOPCOUNT\n          IF (abs(c(x) - (a(x) + b(x))) .gt. PRECISION) THEN\n            errors = errors + 1\n          END IF\n          IF (abs(d(x) - (a(x) * b(x))) .gt. PRECISION) THEN\n            errors = errors + 1\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "runtime",
                            "data",
                            "executable-data",
                            "devonly",
                            "async",
                            "construct-independent",
                            "update"
                        ],
                        "versions": [
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "2": {
                        "content": "#ifndef T2\n!T2:runtime,data,executable-data,devonly,async,construct-independent,update,V:2.5-2.7\n      LOGICAL FUNCTION test2()\n        USE OPENACC\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT):: a, b, c, d !Data\n        INTEGER,DIMENSION(1):: devtest\n        REAL(8) :: RAND\n        INTEGER :: errors = 0\n\n        devtest(1) = 1\n        !$acc enter data copyin(devtest(1:1))\n        !$acc parallel\n          devtest(1) = 0\n        !$acc end parallel\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        IF (devtest(1) .eq. 1) THEN\n          CALL RANDOM_NUMBER(a)\n          CALL RANDOM_NUMBER(b)\n          c = 0\n\n          !$acc data copyout(c(1:LOOPCOUNT)) copyin(a(1:LOOPCOUNT), b(1:LOOPCOUNT))\n            !$acc parallel async(1)\n              !$acc loop\n              DO x = 1, LOOPCOUNT\n                a(x) = a(x) * a(x)\n              END DO\n            !$acc end parallel\n            CALL acc_update_self_async(a(1:LOOPCOUNT), 1)\n            !$acc parallel async(2)\n              !$acc loop\n              DO x = 1, LOOPCOUNT\n                b(x) = b(x) * b(x)\n              END DO\n            !$acc end parallel\n            CALL acc_update_self_async(b(1:LOOPCOUNT), 2)\n            !$acc parallel async(1)\n              !$acc loop\n              DO x = 1, LOOPCOUNT\n                a(x) = a(x) + 1\n              END DO\n            !$acc end parallel\n            !$acc parallel async(2)\n              !$acc loop\n              DO x = 1, LOOPCOUNT\n                b(x) = b(x) + 1\n              END DO\n            !$acc end parallel\n            !$acc parallel async(1) wait(2)\n              !$acc loop\n              DO x = 1, LOOPCOUNT\n                c(x) = a(x) * b(x)\n              END DO\n            !$acc end parallel\n          !$acc end data\n\n          DO x = 1, LOOPCOUNT\n            IF (abs(c(x) - ((a(x) + 1) * (b(x) + 1))) .gt. PRECISION) THEN\n              errors = errors + 1\n            END IF\n          END DO\n        END IF\n\n        IF (errors .eq. 0) THEN\n          test2 = .FALSE.\n        ELSE\n          test2 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T2\n        LOGICAL :: test2\n#endif\n#ifndef T2\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test2()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 1\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "runtime",
                            "data",
                            "executable-data",
                            "devonly",
                            "async",
                            "construct-independent",
                            "update"
                        ],
                        "versions": [
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "acc_update_self_async.c": {
                "num tests": 2,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:runtime,data,executable-data,async,construct-independent,V:2.5-2.7\nint test1(){\n    int err = 0;\n    real_t *a = (real_t *)malloc(n * sizeof(real_t));\n    real_t *b = (real_t *)malloc(n * sizeof(real_t));\n    real_t *c = (real_t *)malloc(n * sizeof(real_t));\n    real_t *d = (real_t *)malloc(n * sizeof(real_t));\n\n    int *devtest = (int *)malloc(sizeof(int));\n\n    devtest[0] = 1;\n    #pragma acc enter data copyin(devtest[0:1])\n    #pragma acc parallel\n    {\n        devtest[0] = 0;\n    }\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n        c[x] = 0;\n        d[x] = 0;\n    }\n\n\n\n    #pragma acc data create(c[0:n], d[0:n]) copyin(a[0:n], b[0:n])\n    {\n        #pragma acc parallel async(1)\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                c[x] = a[x] + b[x];\n            }\n        }\n        #pragma acc parallel async(2)\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                d[x] = a[x] * b[x];\n            }\n        }\n        acc_update_self_async(c, n * sizeof(real_t), 1);\n        acc_update_self_async(d, n * sizeof(real_t), 2);\n        #pragma acc wait\n    }\n\n    for (int x = 0; x < n; ++x){\n        if (fabs(c[x] - (a[x] + b[x])) > PRECISION){\n            err += 1;\n        }\n        if (fabs(d[x] - (a[x] * b[x])) > PRECISION){\n            err += 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "runtime",
                            "data",
                            "executable-data",
                            "async",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "2": {
                        "content": "#ifndef T2\n//T2:runtime,data,executable-data,devonly,async,construct-independent,V:2.5-2.7\nint test2(){\n\tint err = 0;\n    real_t *a = (real_t *)malloc(n * sizeof(real_t));\n    real_t *b = (real_t *)malloc(n * sizeof(real_t));\n    real_t *c = (real_t *)malloc(n * sizeof(real_t));\n    real_t *d = (real_t *)malloc(n * sizeof(real_t));\n\n    int *devtest = (int *)malloc(sizeof(int));\n\n    devtest[0] = 1;\n    #pragma acc enter data copyin(devtest[0:1])\n    #pragma acc parallel\n    {\n        devtest[0] = 0;\n    }\n\n    if (devtest[0] == 1){\n        for (int x = 0; x < n; ++x){\n            a[x] = rand() / (real_t)(RAND_MAX / 10);\n            b[x] = rand() / (real_t)(RAND_MAX / 10);\n            c[x] = 0;\n        }\n\n        #pragma acc data copyout(c[0:n]) copyin(a[0:n], b[0:n])\n        {\n            #pragma acc parallel async(1)\n            {\n                #pragma acc loop\n                for (int x = 0; x < n; ++x){\n                    a[x] = a[x] * a[x];\n                }\n            }\n            acc_update_self_async(a, n * sizeof(real_t), 1);\n            #pragma acc parallel async(2)\n            {\n                #pragma acc loop\n                for (int x = 0; x < n; ++x){\n                    b[x] = b[x] * b[x];\n                }\n            }\n            acc_update_self_async(b, n * sizeof(real_t), 2);\n            #pragma acc parallel async(1)\n            {\n                #pragma acc loop\n                for (int x = 0; x < n; ++x){\n                    a[x] = a[x] + 1;\n                }\n            }\n            #pragma acc parallel async(2)\n            {\n                #pragma acc loop\n                for (int x = 0; x < n; ++x){\n                    b[x] = b[x] + 1;\n                }\n            }\n            #pragma acc parallel async(1) wait(2)\n            {\n                #pragma acc loop\n                for (int x = 0; x < n; ++x){\n                    c[x] = a[x] * b[x];\n                }\n            }\n            #pragma acc wait(1)\n        }\n\n\n        for (int x = 0; x < n; ++x){\n            if (fabs(c[x] - ((a[x] + 1) * (b[x] + 1))) > 4 * PRECISION){\n                err += 1;\n            }\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T2\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test2();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 1);\n    }\n#endif\n",
                        "tags": [
                            "runtime",
                            "data",
                            "executable-data",
                            "devonly",
                            "async",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "acc_update_self_async_with_len.F90": {
                "num tests": 2,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:runtime,data,executable-data,devonly,async,construct-independent,update,V:2.5-2.7\n      LOGICAL FUNCTION test1()\n        USE OPENACC\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT):: a, b, c, d !Data\n        INTEGER,DIMENSION(1):: devtest\n        REAL(8) :: RAND\n        INTEGER :: errors = 0\n\n        devtest(1) = 1\n        !$acc enter data copyin(devtest(1:1))\n        !$acc parallel present(devtest(1:1))\n          devtest(1) = 0\n        !$acc end parallel\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(a)\n        CALL RANDOM_NUMBER(b)\n        c = 0\n        d = 0\n\n        !$acc data copyin(a(1:LOOPCOUNT), b(1:LOOPCOUNT)) create(c(1:LOOPCOUNT), d(1:LOOPCOUNT))\n          !$acc parallel async(1)\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              c(x) = a(x) + b(x)\n            END DO\n          !$acc end parallel\n          !$acc parallel async(2)\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              d(x) = a(x) * b(x)\n            END DO\n          !$acc end parallel\n          CALL acc_update_self_async(c(1), LOOPCOUNT*8, 1)\n          CALL acc_update_self_async(d(1), LOOPCOUNT*8, 2)\n          !$acc wait\n        !$acc end data\n        DO x = 1, LOOPCOUNT\n          IF (abs(c(x) - (a(x) + b(x))) .gt. PRECISION) THEN\n            errors = errors + 1\n          END IF\n          IF (abs(d(x) - (a(x) * b(x))) .gt. PRECISION) THEN\n            errors = errors + 1\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "runtime",
                            "data",
                            "executable-data",
                            "devonly",
                            "async",
                            "construct-independent",
                            "update"
                        ],
                        "versions": [
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "2": {
                        "content": "#ifndef T2\n!T2:runtime,data,executable-data,devonly,async,construct-independent,update,V:2.5-2.7\n      LOGICAL FUNCTION test2()\n        USE OPENACC\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT):: a, b, c, d !Data\n        INTEGER,DIMENSION(1):: devtest\n        REAL(8) :: RAND\n        INTEGER :: errors = 0\n\n        devtest(1) = 1\n        !$acc enter data copyin(devtest(1:1))\n        !$acc parallel present(devtest(1:1))\n          devtest(1) = 0\n        !$acc end parallel\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        IF (devtest(1) .eq. 1) THEN\n          CALL RANDOM_NUMBER(a)\n          CALL RANDOM_NUMBER(b)\n          c = 0\n\n          !$acc data copyout(c(1:LOOPCOUNT)) copyin(a(1:LOOPCOUNT), b(1:LOOPCOUNT))\n            !$acc parallel async(1)\n              !$acc loop\n              DO x = 1, LOOPCOUNT\n                a(x) = a(x) * a(x)\n              END DO\n            !$acc end parallel\n            CALL acc_update_self_async(a(1), LOOPCOUNT*8, 1)\n            !$acc parallel async(2)\n              !$acc loop\n              DO x = 1, LOOPCOUNT\n                b(x) = b(x) * b(x)\n              END DO\n            !$acc end parallel\n            CALL acc_update_self_async(b(1), LOOPCOUNT*8, 2)\n            !$acc parallel async(1)\n              !$acc loop\n              DO x = 1, LOOPCOUNT\n                a(x) = a(x) + 1\n              END DO\n            !$acc end parallel\n            !$acc parallel async(2)\n              !$acc loop\n              DO x = 1, LOOPCOUNT\n                b(x) = b(x) + 1\n              END DO\n            !$acc end parallel\n            !$acc parallel async(1) wait(2)\n              !$acc loop\n              DO x = 1, LOOPCOUNT\n                c(x) = a(x) * b(x)\n              END DO\n            !$acc end parallel\n            !$acc wait(1)\n          !$acc end data\n\n          DO x = 1, LOOPCOUNT\n            IF (abs(c(x) - ((a(x) + 1) * (b(x) + 1))) .gt. PRECISION) THEN\n              errors = errors + 1\n            END IF\n          END DO\n        END IF\n\n        IF (errors .eq. 0) THEN\n          test2 = .FALSE.\n        ELSE\n          test2 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T2\n        LOGICAL :: test2\n#endif\n#ifndef T2\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test2()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 1\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "runtime",
                            "data",
                            "executable-data",
                            "devonly",
                            "async",
                            "construct-independent",
                            "update"
                        ],
                        "versions": [
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "acc_update_self_with_len.F90": {
                "num tests": 2,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:runtime,data,executable-data,construct-independent,update,V:2.0-2.7\n      LOGICAL FUNCTION test1()\n        USE OPENACC\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT):: a, b, c !Data\n        REAL(8) :: RAND\n        INTEGER :: errors = 0\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(a)\n        CALL RANDOM_NUMBER(b)\n        c = 0\n\n        !$acc data copyin(a(1:LOOPCOUNT), b(1:LOOPCOUNT)) create(c(1:LOOPCOUNT))\n          !$acc parallel\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              c(x) = a(x) + b(x)\n            END DO\n          !$acc end parallel\n          CALL acc_update_self(c(1), LOOPCOUNT*8)\n        !$acc end data\n\n        DO x = 1, LOOPCOUNT\n          IF (abs(c(x) - (a(x) + b(x))) .gt. PRECISION) THEN\n            errors = errors + 1\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "runtime",
                            "data",
                            "executable-data",
                            "construct-independent",
                            "update"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "2": {
                        "content": "#ifndef T2\n!T2:runtime,data,executable-data,construct-independent,update,V:2.0-2.7\n      LOGICAL FUNCTION test2()\n        USE OPENACC\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT):: a, b, c !Data\n        REAL(8) :: RAND\n        INTEGER :: errors = 0\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(a)\n        CALL RANDOM_NUMBER(b)\n        c = 0\n\n        !$acc data copyout(c(1:LOOPCOUNT)) copyin(a(1:LOOPCOUNT), b(1:LOOPCOUNT))\n          !$acc parallel\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              a(x) = a(x) * a(x)\n            END DO\n          !$acc end parallel\n          CALL acc_update_self(a(1), LOOPCOUNT*8)\n          !$acc parallel\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              b(x) = b(x) * b(x)\n            END DO\n          !$acc end parallel\n          CALL acc_update_self(b(1), LOOPCOUNT*8)\n          !$acc parallel\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              c(x) = a(x) + b(x)\n            END DO\n          !$acc end parallel\n        !$acc end data\n\n        DO x = 1, LOOPCOUNT\n          IF (abs(c(x) - (a(x) + b(x))) .gt. PRECISION) THEN\n            errors = errors + 1\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test2 = .FALSE.\n        ELSE\n          test2 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T2\n        LOGICAL :: test2\n#endif\n#ifndef T2\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test2()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 1\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "runtime",
                            "data",
                            "executable-data",
                            "construct-independent",
                            "update"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "acc_wait.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:runtime,async,construct-independent,V:2.0-2.7\n      LOGICAL FUNCTION test1()\n        USE OPENACC\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT):: a, b, c, d, e !Data\n        REAL(8) :: RAND\n        INTEGER :: errors = 0\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(a)\n        CALL RANDOM_NUMBER(b)\n        c = 0\n        CALL RANDOM_NUMBER(d)\n        e = 0\n\n        !$acc enter data  copyin(a(1:LOOPCOUNT), b(1:LOOPCOUNT)) create(c(1:LOOPCOUNT)) async(1)\n        !$acc enter data copyin(d(1:LOOPCOUNT)) create(e(1:LOOPCOUNT)) async(2)\n        !$acc parallel present(a(1:LOOPCOUNT), b(1:LOOPCOUNT), c(1:LOOPCOUNT)) async(1)\n          !$acc loop\n          DO x = 1, LOOPCOUNT\n            c(x) = a(x) + b(x)\n          END DO\n        !$acc end parallel\n        !$acc parallel present(c(1:LOOPCOUNT), d(1:LOOPCOUNT), e(1:LOOPCOUNT)) async(1) wait(2)\n          !$acc loop\n          DO x = 1, LOOPCOUNT\n            e(x) = c(x) + d(x)\n          END DO\n        !$acc end parallel\n        !$acc exit data copyout(e(1:LOOPCOUNT)) async(1)\n\n        CALL acc_wait(1)\n\n        DO x = 1, LOOPCOUNT\n          IF (abs(e(x) - (a(x) + b(x) + d(x))) .gt. PRECISION) THEN\n            errors = errors + 1\n          END IF\n        END DO\n\n        !$acc exit data delete(a(1:LOOPCOUNT), b(1:LOOPCOUNT), c(1:LOOPCOUNT), d(1:LOOPCOUNT))\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "runtime",
                            "async",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "acc_wait.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:runtime,async,construct-independent,wait,V:2.0-2.7\nint test1(){\n    int err = 0;\n    real_t *a = (real_t *)malloc(n * sizeof(real_t));\n    real_t *b = (real_t *)malloc(n * sizeof(real_t));\n    real_t *c = (real_t *)malloc(n * sizeof(real_t));\n    real_t *d = (real_t *)malloc(n * sizeof(real_t));\n    real_t *e = (real_t *)malloc(n * sizeof(real_t));\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n        c[x] = 0;\n        d[x] = rand() / (real_t)(RAND_MAX / 10);\n        e[x] = 0;\n    }\n\n    #pragma acc enter data copyin(a[0:n], b[0:n]) create(c[0:n]) async(1)\n    #pragma acc enter data copyin(d[0:n]) create(e[0:n]) async(2)\n    #pragma acc parallel present(a[0:n], b[0:n], c[0:n]) async(1)\n    {\n        #pragma acc loop\n        for (int x = 0; x < n; ++x){\n            c[x] = a[x] + b[x];\n        }\n    }\n    #pragma acc parallel present(c[0:n], d[0:n], e[0:n]) async(1) wait(2)\n    {\n        #pragma acc loop\n        for (int x = 0; x < n; ++x){\n            e[x] = c[x] + d[x];\n        }\n    }\n    #pragma acc exit data copyout(e[0:n]) async(1)\n\n    acc_wait(1);\n    for (int x = 0; x < n; ++x){\n        if (fabs(e[x] - (a[x] + b[x] + d[x])) > PRECISION){\n            err += 1;\n        }\n    }\n\n    #pragma acc exit data delete(a[0:n], b[0:n], c[0:n], d[0:n])\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "runtime",
                            "async",
                            "construct-independent",
                            "wait"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "acc_wait_all.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:runtime,async,construct-independent,V:2.0-2.7\n      LOGICAL FUNCTION test1()\n        USE OPENACC\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT):: a, b, c, d, a_host, b_host, c_host !Data\n        REAL(8) :: RAND\n        INTEGER :: errors = 0\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(a)\n        CALL RANDOM_NUMBER(b)\n        CALL RANDOM_NUMBER(c)\n        d = 0\n        a_host = a\n        b_host = b\n        c_host = c\n\n        !$acc data copyin(a(1:LOOPCOUNT), b(1:LOOPCOUNT), c(1:LOOPCOUNT)) copyout(d(1:LOOPCOUNT))\n          !$acc parallel async(1)\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              a(x) = a(x) * a(x)\n            END DO\n          !$acc end parallel\n          !$acc parallel async(2)\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              b(x) = b(x) * b(x)\n            END DO\n          !$acc end parallel\n          !$acc parallel async(3)\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              c(x) = c(x) * c(x)\n            END DO\n          !$acc end parallel\n          CALL acc_wait_all()\n          !$acc parallel\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              d(x) = a(x) + b(x) + c(x)\n            END DO\n          !$acc end parallel\n        !$acc end data\n\n        DO x = 1, LOOPCOUNT\n          IF (abs(d(x) - ((a_host(x) * a_host(x)) + (b_host(x) * b_host(x)) + (c_host(x) * c_host(x)))) .gt. PRECISION) THEN\n            errors = errors + 1\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "runtime",
                            "async",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "acc_wait_all.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:runtime,async,construct-independent,wait,V:2.0-2.7\nint test1(){\n    int err = 0;\n    real_t *a = (real_t *)malloc(n * sizeof(real_t));\n    real_t *b = (real_t *)malloc(n * sizeof(real_t));\n    real_t *c = (real_t *)malloc(n * sizeof(real_t));\n    real_t *d = (real_t *)malloc(n * sizeof(real_t));\n    real_t *a_host = (real_t *)malloc(n * sizeof(real_t));\n    real_t *b_host = (real_t *)malloc(n * sizeof(real_t));\n    real_t *c_host = (real_t *)malloc(n * sizeof(real_t));\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n        c[x] = rand() / (real_t)(RAND_MAX / 10);\n        d[x] = 0;\n        a_host[x] = a[x];\n        b_host[x] = b[x];\n        c_host[x] = c[x];\n    }\n\n    #pragma acc data copyin(a[0:n], b[0:n], c[0:n]) copyout(d[0:n])\n    {\n        #pragma acc parallel async(1)\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                a[x] = a[x] * a[x];\n            }\n        }\n        #pragma acc parallel async(2)\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                b[x] = b[x] * b[x];\n            }\n        }\n        #pragma acc parallel async(3)\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                c[x] = c[x] * c[x];\n            }\n        }\n        acc_wait_all();\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                d[x] = a[x] + b[x] + c[x];\n            }\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        if (fabs(d[x] - (a_host[x] * a_host[x] + b_host[x] * b_host[x] + c_host[x] * c_host[x])) > PRECISION) {\n            err += 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "runtime",
                            "async",
                            "construct-independent",
                            "wait"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "acc_wait_all_async.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:runtime,async,construct-independent,V:2.0-2.7\n      LOGICAL FUNCTION test1()\n        USE OPENACC\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT):: a, b, c, d, e, f, g, h, i, j, k !Data\n        REAL(8),DIMENSION(LOOPCOUNT):: a_host, d_host, g_host\n        REAL(8) :: RAND\n        REAL(8) :: temp\n        INTEGER :: errors = 0\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(a)\n        CALL RANDOM_NUMBER(b)\n        c = 0\n        CALL RANDOM_NUMBER(d)\n        CALL RANDOM_NUMBER(e)\n        f = 0\n        CALL RANDOM_NUMBER(g)\n        CALL RANDOM_NUMBER(h)\n        i = 0\n        j = 0\n        k = 0\n        a_host = a\n        d_host = d\n        g_host = g\n\n        !$acc data copyin(a(1:LOOPCOUNT), b(1:LOOPCOUNT), d(1:LOOPCOUNT), e(1:LOOPCOUNT), g(1:LOOPCOUNT), h(1:LOOPCOUNT)) create(c(1:LOOPCOUNT), f(1:LOOPCOUNT), i(1:LOOPCOUNT), j(1:LOOPCOUNT)) copyout(k(1:LOOPCOUNT))\n          !$acc parallel async(1)\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              c(x) = a(x) + b(x)\n            END DO\n          !$acc end parallel\n          !$acc parallel async(2)\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              f(x) = d(x) + e(x)\n            END DO\n          !$acc end parallel\n          !$acc parallel async(3)\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              i(x) = g(x) + h(x)\n            END DO\n          !$acc end parallel\n          CALL acc_wait_all_async(4)\n          !$acc parallel async(4)\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              j(x) = c(x) + f(x) + i(x)\n            END DO\n          !$acc end parallel\n          !$acc parallel async(1)\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              a(x) = b(x) * c(x)\n            END DO\n          !$acc end parallel\n          !$acc parallel async(2)\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              d(x) = e(x) * f(x)\n            END DO\n          !$acc end parallel\n          !$acc parallel async(3)\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              g(x) = h(x) * i(x)\n            END DO\n          !$acc end parallel\n          CALL acc_wait_all_async(4)\n          !$acc parallel async(4)\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              k(x) = j(x) + a(x) + d(x) + g(x)\n            END DO\n          !$acc end parallel\n          !$acc wait(4)\n        !$acc end data\n\n        DO x = 1, LOOPCOUNT\n          temp = a_host(x) + b(x) + d_host(x) + e(x) + g_host(x) + h(x)\n          temp = temp + (b(x) * (a_host(x) + b(x))) + (e(x) * (d_host(x) + e(x))) + (h(x) * (g_host(x) + h(x)))\n          IF (abs(k(x) - temp) .gt. PRECISION * 10) THEN\n            errors = errors + 1\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "runtime",
                            "async",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "acc_wait_all_async.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:runtime,async,construct-independent,wait,V:2.0-2.7\nint test1(){\n    int err = 0;\n    real_t *a = (real_t *)malloc(n * sizeof(real_t));\n    real_t *b = (real_t *)malloc(n * sizeof(real_t));\n    real_t *c = (real_t *)malloc(n * sizeof(real_t));\n    real_t *d = (real_t *)malloc(n * sizeof(real_t));\n    real_t *e = (real_t *)malloc(n * sizeof(real_t));\n    real_t *f = (real_t *)malloc(n * sizeof(real_t));\n    real_t *g = (real_t *)malloc(n * sizeof(real_t));\n    real_t *h = (real_t *)malloc(n * sizeof(real_t));\n    real_t *i = (real_t *)malloc(n * sizeof(real_t));\n    real_t *j = (real_t *)malloc(n * sizeof(real_t));\n    real_t *k = (real_t *)malloc(n * sizeof(real_t));\n    real_t *a_host = (real_t *)malloc(n * sizeof(real_t));\n    real_t *d_host = (real_t *)malloc(n * sizeof(real_t));\n    real_t *g_host = (real_t *)malloc(n * sizeof(real_t));\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n        c[x] = 0;\n        d[x] = rand() / (real_t)(RAND_MAX / 10);\n        e[x] = rand() / (real_t)(RAND_MAX / 10);\n        f[x] = 0;\n        g[x] = rand() / (real_t)(RAND_MAX / 10);\n        h[x] = rand() / (real_t)(RAND_MAX / 10);\n        i[x] = 0;\n        j[x] = 0;\n        k[x] = 0;\n        a_host[x] = a[x];\n        d_host[x] = d[x];\n        g_host[x] = g[x];\n    }\n\n    #pragma acc data copyin(a[0:n], b[0:n], d[0:n], e[0:n], g[0:n], h[0:n]) create(c[0:n], f[0:n], i[0:n], j[0:n]) copyout(k[0:n])\n    {\n        #pragma acc parallel async(1)\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                c[x] = a[x] + b[x];\n            }\n        }\n        #pragma acc parallel async(2)\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                f[x] = d[x] + e[x];\n            }\n        }\n        #pragma acc parallel async(3)\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                i[x] = g[x] + h[x];\n            }\n        }\n        acc_wait_all_async(4);\n        #pragma acc parallel async(4)\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                j[x] = c[x] + f[x] + i[x];\n            }\n        }\n        #pragma acc parallel async(1)\n        {\n            for (int x = 0; x < n; ++x){\n                a[x] = b[x] * c[x];\n            }\n        }\n        #pragma acc parallel async(2)\n        {\n            for (int x = 0; x < n; ++x){\n                d[x] = e[x] * f[x];\n            }\n        }\n        #pragma acc parallel async(3)\n        {\n            for (int x = 0; x < n; ++x){\n                g[x] = h[x] * i[x];\n            }\n        }\n        acc_wait_all_async(4);\n        #pragma acc parallel async(4)\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                k[x] = j[x] + a[x] + d[x] + g[x];\n            }\n        }\n        #pragma acc wait(4)\n    }\n\n    real_t temp;\n    for (int x = 0; x < n; ++x){\n        temp = a_host[x] + b[x] + d_host[x] + e[x] + g_host[x] + h[x];\n        temp += b[x] * (a_host[x] + b[x]) + e[x] * (d_host[x] + e[x]) + h[x] * (g_host[x] + h[x]);\n        if (fabs(k[x] - temp) > PRECISION * 10){\n            err += 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "runtime",
                            "async",
                            "construct-independent",
                            "wait"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "acc_wait_async.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:runtime,async,construct-independent,V:2.0-2.7\n      LOGICAL FUNCTION test1()\n        USE OPENACC\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT):: a, b, c, d, e, f, g, h, i !Data\n        REAL(8) :: RAND\n        INTEGER :: errors = 0\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(a)\n        CALL RANDOM_NUMBER(b)\n        c = 0\n        CALL RANDOM_NUMBER(d)\n        CALL RANDOM_NUMBER(e)\n        f = 0\n        CALL RANDOM_NUMBER(g)\n        h = 0\n        i = 0\n\n        !$acc data copyin(a(1:LOOPCOUNT), b(1:LOOPCOUNT), d(1:LOOPCOUNT), e(1:LOOPCOUNT), g(1:LOOPCOUNT)) create(c(1:LOOPCOUNT), f(1:LOOPCOUNT), h(1:LOOPCOUNT)) copyout(i(1:LOOPCOUNT))\n          !$acc parallel async(1)\n            !$acc loop\n              DO x = 1, LOOPCOUNT\n                c(x) = a(x) + b(x)\n              END DO\n          !$acc end parallel\n          CALL acc_wait_async(1, 2)\n          !$acc parallel async(2)\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              h(x) = c(x) + g(x)\n            END DO\n          !$acc end parallel\n          !$acc parallel async(1)\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              f(x) = d(x) + e(x)\n            END DO\n          !$acc end parallel\n          CALL acc_wait_async(1, 2)\n          !$acc parallel async(2)\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              i(x) = h(x) + f(x)\n            END DO\n          !$acc end parallel\n          !$acc wait(2)\n        !$acc end data\n\n        DO x = 1, LOOPCOUNT\n          IF (abs(i(x) - (a(x) + b(x) + g(x) + d(x) + e(x))) .gt. PRECISION) THEN\n            errors = errors + 1\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "runtime",
                            "async",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "acc_wait_async.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:runtime,async,construct-independent,wait,V:2.0-2.7\nint test1(){\n    int err = 0;\n    real_t *a = (real_t *)malloc(n * sizeof(real_t));\n    real_t *b = (real_t *)malloc(n * sizeof(real_t));\n    real_t *c = (real_t *)malloc(n * sizeof(real_t));\n    real_t *d = (real_t *)malloc(n * sizeof(real_t));\n    real_t *e = (real_t *)malloc(n * sizeof(real_t));\n    real_t *f = (real_t *)malloc(n * sizeof(real_t));\n    real_t *g = (real_t *)malloc(n * sizeof(real_t));\n    real_t *h = (real_t *)malloc(n * sizeof(real_t));\n    real_t *i = (real_t *)malloc(n * sizeof(real_t));\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n        c[x] = 0;\n        d[x] = rand() / (real_t)(RAND_MAX / 10);\n        e[x] = rand() / (real_t)(RAND_MAX / 10);\n        f[x] = 0;\n        g[x] = rand() / (real_t)(RAND_MAX / 10);\n        h[x] = 0;\n        i[x] = 0;\n    }\n\n    #pragma acc data copyin(a[0:n], b[0:n], d[0:n], e[0:n], g[0:n]) create(c[0:n], f[0:n], h[0:n]) copyout(i[0:n])\n    {\n        #pragma acc parallel async(1)\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                c[x] = a[x] + b[x];\n            }\n        }\n        acc_wait_async(1, 2);\n        #pragma acc parallel async(2)\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                h[x] = c[x] + g[x];\n            }\n        }\n        #pragma acc parallel async(1)\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                f[x] = d[x] + e[x];\n            }\n        }\n        acc_wait_async(1, 2);\n        #pragma acc parallel async(2)\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                i[x] = h[x] + f[x];\n            }\n        }\n        #pragma acc wait(2)\n    }\n\n    for (int x = 0; x < n; ++x){\n        if (fabs(i[x] - (a[x] + b[x] + g[x] + d[x] + e[x])) > PRECISION){\n            err += 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "runtime",
                            "async",
                            "construct-independent",
                            "wait"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_bitand_equals.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:atomic,construct-independent,V:2.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    int  *a = (int *)malloc(n * sizeof(int));\n    int *totals = (int *)malloc((n/10 + 1) * sizeof(int));\n    int *totals_comparison = (int *)malloc((n/10 + 1) * sizeof(int));\n\n    for (int x = 0; x < n; ++x){\n        for (int y = 0; y < 8; ++y){\n            if (rand()/(real_t)(RAND_MAX) < .933){ //.933 gets close to a 50/50 distribution for a collescence of 10 values\n                a[x] += 1<<y;\n            }\n        }\n    }\n    for (int x = 0; x < n/10 + 1; ++x){\n        for (int y = 0; y < 8; ++y){\n            totals[x] +=  1<<y;\n        }\n\n    }\n\n    #pragma acc data copyin(a[0:n]) copy(totals[0:n/10 + 1])\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                #pragma acc atomic\n                    totals[x%(n/10 + 1)] &= a[x];\n            }\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        totals_comparison[x%(n/10 + 1)] &= a[x];\n    }\n    for (int x = 0; x < 10; ++x){\n        if (fabs(totals_comparison[x] - totals[x]) > PRECISION){\n            err += 1;\n            break;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "atomic",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_bitor_equals.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:atomic,construct-independent,V:2.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    int  *a = (int *)malloc(n * sizeof(int));\n    int *totals = (int *)malloc((n/10 + 1) * sizeof(int));\n    int *totals_comparison = (int *)malloc((n/10 + 1) * sizeof(int));\n\n    for (int x = 0; x < n; ++x){\n        for (int y = 0; y < 8; ++y){\n            if (rand()/(real_t)(RAND_MAX) > .933){ //.933 gets close to a 50/50 distribution for a collescence of 10 values\n                a[x] += 1<<y;\n            }\n        }\n    }\n    for (int x = 0; x < n/10 + 1; ++x){\n        totals[x] = 0;\n\n    }\n\n    #pragma acc data copyin(a[0:n]) copy(totals[0:n/10 + 1])\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                #pragma acc atomic\n                    totals[x%(n/10 + 1)] |= a[x];\n            }\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        totals_comparison[x%(n/10 + 1)] |= a[x];\n    }\n    for (int x = 0; x < 10; ++x){\n        if (fabs(totals_comparison[x] - totals[x]) > PRECISION){\n            err += 1;\n            break;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "atomic",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_bitxor_equals.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:atomic,construct-independent,V:2.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    int  *a = (int *)malloc(n * sizeof(int));\n    int *totals = (int *)malloc((n/10 + 1) * sizeof(int));\n    int *totals_comparison = (int *)malloc((n/10 + 1) * sizeof(int));\n\n    for (int x = 0; x < n; ++x){\n        for (int y = 0; y < 8; ++y){\n            if (rand()/(real_t)(RAND_MAX) > .5){\n                a[x] += 1<<y;\n            }\n        }\n    }\n    for (int x = 0; x < n/10 + 1; ++x){\n        totals[x] = 0;\n        totals_comparison[x] = 0;\n    }\n\n    #pragma acc data copyin(a[0:n]) copy(totals[0:n/10 + 1])\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                #pragma acc atomic\n                    totals[x%(n/10 + 1)] ^= a[x];\n            }\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        totals_comparison[x%(n/10 + 1)] ^= a[x];\n    }\n    for (int x = 0; x < 10; ++x){\n        if (fabs(totals_comparison[x] - totals[x]) > PRECISION){\n            err += 1;\n            break;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "atomic",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_capture_assign_expr_and_x.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:construct-independent,atomic,V:2.0-2.7\n      LOGICAL FUNCTION test1()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x, y !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT, 10):: randoms\n        LOGICAL,DIMENSION(LOOPCOUNT, 10):: a, b !Data\n        LOGICAL,DIMENSION(10):: passed_a, passed_b\n        LOGICAL IS_POSSIBLE\n        LOGICAL,DIMENSION(LOOPCOUNT):: totals, totals_comparison\n        INTEGER :: errors = 0\n        LOGICAL :: init\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(randoms)\n        DO x = 1, LOOPCOUNT\n          DO y = 1, 10\n            IF (randoms(x, y) < .933) THEN\n              a(x, y) = .TRUE.\n            ELSE\n              a(x, y) = .FALSE.\n            END IF\n          END DO\n        END DO\n\n        totals = .FALSE.\n        totals_comparison = .FALSE.\n\n        !$acc data copyin(a(1:LOOPCOUNT,1:10)) copy(totals(1:LOOPCOUNT)) copyout(b(1:LOOPCOUNT,1:10))\n          !$acc parallel\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              DO y = 1, 10\n                !$acc atomic capture\n                  b(x, y) = totals(x)\n                  totals(x) = a(x, y) .AND. totals(x)\n                !$acc end atomic\n              END DO\n            END DO\n          !$acc end parallel\n        !$acc end data\n\n        DO x = 1, LOOPCOUNT\n          DO y = 1, 10\n            totals_comparison(x) = totals_comparison(x) .AND. a(x, y)\n          END DO\n        END DO\n\n        DO x = 1, LOOPCOUNT\n          IF (totals_comparison(x) .NEQV. totals(x)) THEN\n            errors = errors + 1\n            WRITE(*, *) totals_comparison(x)\n          END IF\n        END DO\n\n        DO x = 1, LOOPCOUNT\n          DO y = 1, 10\n            passed_a(y) = a(x, y)\n            passed_b(y) = b(x, y)\n          END DO\n          init = .FALSE.\n          IF (.FALSE. .eqv. IS_POSSIBLE(a(x, 1:10), b(x, 1:10), 10, .FALSE.)) THEN\n            errors = errors + 1\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "construct-independent",
                            "atomic"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_capture_assign_expr_divided_x.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:construct-independent,atomic,V:2.0-2.7\n      LOGICAL FUNCTION test1()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x, y !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT, 10):: a !Data\n        REAL(8),DIMENSION(LOOPCOUNT, 10):: b\n        REAL(8),DIMENSION(LOOPCOUNT):: totals\n        REAL(8),DIMENSION(10):: passed\n        REAL(8),DIMENSION(10):: passed_b\n        REAL(8) :: holder\n        INTEGER :: errors = 0\n        LOGICAL IS_POSSIBLE\n        LOGICAL IS_POSSIBLE_2\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(a)\n\n        totals = 1\n\n        !$acc data copyin(a(1:LOOPCOUNT, 1:10)) copy(totals(1:LOOPCOUNT)) copyout(b(1:LOOPCOUNT,1:10))\n          !$acc parallel\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              DO y = 1, 10\n                !$acc atomic capture\n                  b(x, y) = totals(x)\n                  totals(x) = a(x, y) / totals(x)\n                !$acc end atomic\n              END DO\n            END DO\n          !$acc end parallel\n        !$acc end data\n\n        DO x = 1, LOOPCOUNT\n          DO y = 1, 10\n            passed(y) = a(x, y)\n          END DO\n          holder = 1\n          IF (IS_POSSIBLE(passed, totals(x), 10, holder) .eqv. .FALSE.) THEN\n            errors = errors + 1\n          END IF\n        END DO\n\n        DO x = 1, LOOPCOUNT\n          DO y = 1, 10\n            passed(y) = a(x, y)\n            passed_b(y) = b(x, y)\n          END DO\n          holder = 1\n          IF (IS_POSSIBLE_2(passed, passed_b, 10, holder) .eqv. .FALSE.) THEN\n            errors = errors + 1\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "construct-independent",
                            "atomic"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_capture_assign_expr_eqv_x.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:construct-independent,atomic,V:2.0-2.7\n      LOGICAL FUNCTION test1()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x, y !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT, 10):: randoms\n        LOGICAL,DIMENSION(LOOPCOUNT, 10):: a, b !Data\n        LOGICAL,DIMENSION(LOOPCOUNT):: totals, totals_comparison\n        LOGICAL,DIMENSION(10):: passed_a, passed_b\n        LOGICAL:: init\n        INTEGER :: errors = 0\n        LOGICAL IS_POSSIBLE\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(randoms)\n        DO x = 1, LOOPCOUNT\n          DO y = 1, 10\n            IF (randoms(x, y) > .5) THEN\n              a(x, y) = .TRUE.\n            ELSE\n              a(x, y) = .FALSE.\n            END IF\n          END DO\n        END DO\n\n        totals = .FALSE.\n        totals_comparison = .FALSE.\n\n        !$acc data copyin(a(1:LOOPCOUNT,1:10)) copy(totals(1:LOOPCOUNT)) copyout(b(1:LOOPCOUNT,1:10))\n          !$acc parallel\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              DO y = 1, 10\n                !$acc atomic capture\n                  b(x, y) = totals(x)\n                  totals(x) = a(x, y) .EQV. totals(x)\n                !$acc end atomic\n              END DO\n            END DO\n          !$acc end parallel\n        !$acc end data\n\n        DO x = 1, LOOPCOUNT\n          DO y = 1, 10\n            totals_comparison(x) = totals_comparison(x) .EQV. a(x, y)\n          END DO\n        END DO\n\n        DO x = 1, LOOPCOUNT\n          DO y = 1, 10\n            passed_a(y) = a(x, y)\n            passed_b(y) = b(x, y)\n          END DO\n          init = .FALSE.\n          IF (IS_POSSIBLE(passed_a, passed_b, 10, init) .EQV. .FALSE.) THEN\n            errors = errors + 1\n          END IF\n        END DO\n\n        DO x = 1, LOOPCOUNT\n          IF (totals_comparison(x) .NEQV. totals(x)) THEN\n            errors = errors + 1\n            WRITE(*, *) totals_comparison(x)\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "construct-independent",
                            "atomic"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_capture_assign_expr_minus_x.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:construct-independent,atomic,V:2.0-2.7\n      LOGICAL FUNCTION test1()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x, y !Iterators\n        LOGICAL IS_POSSIBLE\n        LOGICAL IS_POSSIBLE_2\n        REAL(8),DIMENSION(LOOPCOUNT, 10):: a, b !Data\n        REAL(8),DIMENSION(LOOPCOUNT):: totals\n        REAL(8),DIMENSION(10):: passed_a, passed_b\n        REAL(8):: init\n        INTEGER :: errors = 0\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(a)\n\n        totals = 0\n\n        !$acc data copyin(a(1:LOOPCOUNT, 1:10)) copy(totals(1:LOOPCOUNT)) copyout(b(1:LOOPCOUNT, 1:10))\n          !$acc parallel\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              DO y = 1, 10\n                !$acc atomic capture\n                  b(x, y) = totals(x)\n                  totals(x) = a(x, y) - totals(x)\n                !$acc end atomic\n              END DO\n            END DO\n          !$acc end parallel\n        !$acc end data\n\n        DO x = 1, LOOPCOUNT\n          DO y = 1, 10\n            passed_a(y) = a(x, y)\n          END DO\n          IF (IS_POSSIBLE(passed_a, totals(x), 10, 0) .eqv. .FALSE.) THEN\n            errors = errors + 1\n          END IF\n        END DO\n\n        DO x = 1, LOOPCOUNT\n          DO y = 1, 10\n            passed_a(y) = a(x, y)\n            passed_b(y) = b(x, y)\n          END DO\n          init = 0\n          IF (IS_POSSIBLE_2(passed_a, passed_b, 10, init) .EQV. .FALSE.) THEN\n            errors = errors + 1\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "construct-independent",
                            "atomic"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_capture_assign_expr_neqv_x.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:construct-independent,atomic,V:2.0-2.7\n      LOGICAL FUNCTION test1()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x, y !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT, 10):: randoms\n        LOGICAL,DIMENSION(LOOPCOUNT, 10):: a, b !Data\n        LOGICAL,DIMENSION(10):: passed_a, passed_b\n        LOGICAL,DIMENSION(LOOPCOUNT):: totals, totals_comparison\n        LOGICAL IS_POSSIBLE\n        INTEGER :: errors = 0\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(randoms)\n        DO x = 1, LOOPCOUNT\n          DO y = 1, 10\n            IF (randoms(x, y) > .5) THEN\n              a(x, y) = .TRUE.\n            ELSE\n              a(x, y) = .FALSE.\n            END IF\n          END DO\n        END DO\n\n        totals = .FALSE.\n        totals_comparison = .FALSE.\n\n        !$acc data copyin(a(1:LOOPCOUNT,1:10)) copy(totals(1:LOOPCOUNT)) copyout(b(1:LOOPCOUNT,1:10))\n          !$acc parallel\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              DO y = 1, 10\n                !$acc atomic capture\n                  b(x, y) = totals(x)\n                  totals(x) = a(x, y) .NEQV. totals(x)\n                !$acc end atomic\n              END DO\n            END DO\n          !$acc end parallel\n        !$acc end data\n\n        DO x = 1, LOOPCOUNT\n          DO y = 1, 10\n            totals_comparison(x) = totals_comparison(x) .NEQV. a(x, y)\n          END DO\n        END DO\n\n        DO x = 1, LOOPCOUNT\n          IF (totals_comparison(x) .NEQV. totals(x)) THEN\n            errors = errors + 1\n            WRITE(*, *) totals_comparison(x)\n          END IF\n        END DO\n\n        DO x = 1, LOOPCOUNT\n          DO y = 1, 10\n            passed_a(y) = a(x, y)\n            passed_b(y) = b(x, y)\n          END DO\n          IF (IS_POSSIBLE(passed_a, passed_b, 10, .FALSE.) .eqv. .FALSE.) THEN\n            errors = errors + 1\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "construct-independent",
                            "atomic"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_capture_assign_expr_or_x.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:construct-independent,atomic,V:2.0-2.7\n      LOGICAL FUNCTION test1()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x, y !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT, 10):: randoms\n        LOGICAL,DIMENSION(LOOPCOUNT, 10):: a, b !Data\n        LOGICAL,DIMENSION(LOOPCOUNT):: totals, totals_comparison\n        LOGICAL,DIMENSION(10):: passed_a, passed_b\n        LOGICAL IS_POSSIBLE\n        LOGICAL:: init\n        INTEGER :: errors = 0\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(randoms)\n        DO x = 1, LOOPCOUNT\n          DO y = 1, 10\n            IF (randoms(x, y) > .933) THEN\n              a(x, y) = .TRUE.\n            ELSE\n              a(x, y) = .FALSE.\n            END IF\n          END DO\n        END DO\n\n        totals = .FALSE.\n        totals_comparison = .FALSE.\n\n        !$acc data copyin(a(1:LOOPCOUNT,1:10)) copy(totals(1:LOOPCOUNT)) copyout(b(1:LOOPCOUNT,1:10))\n          !$acc parallel\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              DO y = 1, 10\n                !$acc atomic capture\n                  b(x, y) = totals(x)\n                  totals(x) = a(x, y) .OR. totals(x)\n                !$acc end atomic\n              END DO\n            END DO\n          !$acc end parallel\n        !$acc end data\n\n        DO x = 1, LOOPCOUNT\n          DO y = 1, 10\n            totals_comparison(x) = totals_comparison(x) .OR. a(x, y)\n          END DO\n        END DO\n\n        DO x = 1, LOOPCOUNT\n          IF (totals_comparison(x) .NEQV. totals(x)) THEN\n            errors = errors + 1\n            WRITE(*, *) totals_comparison(x)\n          END IF\n        END DO\n\n        DO x = 1, LOOPCOUNT\n          DO y = 1, 10\n            passed_a(y) = a(x, y)\n            passed_b(y) = b(x, y)\n          END DO\n          init = .FALSE.\n          IF (IS_POSSIBLE(passed_a, passed_b, 10, init) .eqv. .FALSE.) THEN\n            errors = errors + 1\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "construct-independent",
                            "atomic"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_capture_assign_expr_plus_x.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:construct-independent,atomic,V:2.0-2.7\n      LOGICAL FUNCTION test1()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x, y !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT, 10):: a, b !Data\n        REAL(8),DIMENSION(LOOPCOUNT):: totals, totals_comparison\n        REAL(8),DIMENSION(10):: passed_a, passed_b\n        REAL(8):: init\n        LOGICAL IS_POSSIBLE\n        INTEGER :: errors = 0\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(a)\n\n        totals = 0\n        totals_comparison = 0\n\n        !$acc data copyin(a(1:LOOPCOUNT, 1:10)) copy(totals(1:LOOPCOUNT)) copyout(b(1:LOOPCOUNT,1:10))\n          !$acc parallel\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              DO y = 1, 10\n                !$acc atomic capture\n                  b(x, y) = totals(x)\n                  totals(x) = a(x, y) + totals(x)\n                !$acc end atomic\n              END DO\n            END DO\n          !$acc end parallel\n        !$acc end data\n        DO x = 1, LOOPCOUNT\n          DO y = 1, 10\n            totals_comparison(x) = totals_comparison(x) + a(x, y)\n          END DO\n        END DO\n\n        DO x = 1, LOOPCOUNT\n          IF (totals_comparison(x) .NE. totals(x)) THEN\n            errors = errors + 1\n            WRITE(*, *) totals_comparison(x)\n          END IF\n        END DO\n\n        DO x = 1, LOOPCOUNT\n          DO y = 1, 10\n            passed_a(y) = a(x, y)\n            passed_b(y) = b(x, y)\n          END DO\n          init = 0\n          IF (IS_POSSIBLE(passed_a, passed_b, 10, init) .eqv. .FALSE.) THEN\n            errors = errors + 1\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "construct-independent",
                            "atomic"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_capture_assign_expr_times_x.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:construct-independent,atomic,V:2.0-2.7\n      LOGICAL FUNCTION test1()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x, y !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT, 10):: a, b !Data\n        REAL(8),DIMENSION(LOOPCOUNT):: totals, totals_comparison\n        REAL(8),DIMENSION(10):: passed_a, passed_b\n        REAL(8):: init\n        LOGICAL IS_POSSIBLE\n        INTEGER :: errors = 0\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(a)\n\n        totals = 1\n        totals_comparison = 1\n\n        !$acc data copyin(a(1:LOOPCOUNT, 1:10)) copy(totals(1:LOOPCOUNT)) copyout(b(1:LOOPCOUNT,1:10))\n          !$acc parallel\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              DO y = 1, 10\n                !$acc atomic capture\n                  b(x, y) = totals(x)\n                  totals(x) = a(x, y) * totals(x)\n                !$acc end atomic\n              END DO\n            END DO\n          !$acc end parallel\n        !$acc end data\n        DO x = 1, LOOPCOUNT\n          DO y = 1, 10\n            totals_comparison(x) = totals_comparison(x) * a(x, y)\n          END DO\n        END DO\n\n        DO x = 1, LOOPCOUNT\n          IF (totals_comparison(x) .NE. totals(x)) THEN\n            errors = errors + 1\n            WRITE(*, *) totals_comparison(x)\n          END IF\n        END DO\n\n        DO x = 1, LOOPCOUNT\n          DO y = 1, 10\n            passed_a(y) = a(x, y)\n            passed_b(y) = b(x, y)\n          END DO\n          init = 1\n          IF (IS_POSSIBLE(passed_a, passed_b, 10, init) .eqv. .TRUE.) THEN\n            errors = errors + 1\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "construct-independent",
                            "atomic"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_capture_assign_iand_expr_x.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:construct-independent,atomic,V:2.0-2.7\n      LOGICAL FUNCTION test1()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x, y, z !Iterators\n        INTEGER,DIMENSION(LOOPCOUNT, 10):: a, b !Data\n        REAL(8),DIMENSION(LOOPCOUNT, 10, 8):: randoms\n        INTEGER,DIMENSION(LOOPCOUNT):: totals, totals_comparison\n        INTEGER,DIMENSION(10):: passed_a, passed_b\n        INTEGER:: init\n        LOGICAL IS_POSSIBLE\n        INTEGER :: errors = 0\n\n        CALL RANDOM_NUMBER(randoms)\n        a = 0\n        DO x = 1, LOOPCOUNT\n          DO y = 1, 10\n            DO z = 1, 8\n              IF (randoms(x, y, z) .lt. .933) THEN\n                a(x, y) = a(x, y) + ISHFT(1, z - 1)\n              END IF\n            END DO\n          END DO\n        END DO\n        totals = 0\n        totals_comparison = 0\n        DO x = 1, LOOPCOUNT\n          DO y = 0, 7\n            totals(x) = totals(x) + ISHFT(1, y)\n            totals_comparison(x) = totals_comparison(x) + ISHFT(1, y)\n          END DO\n        END DO\n\n        !$acc data copyin(a(1:LOOPCOUNT, 1:10)) copy(totals(1:LOOPCOUNT)) copyout(b(1:LOOPCOUNT, 1:10))\n          !$acc parallel\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              DO y = 1, 10\n                !$acc atomic capture\n                  b(x, y) = totals(x)\n                  totals(x) = iand(a(x, y), totals(x))\n                !$acc end atomic\n              END DO\n            END DO\n          !$acc end parallel\n        !$acc end data\n        DO x = 1, LOOPCOUNT\n          DO y = 1, 10\n            totals_comparison(x) = iand(totals_comparison(x), a(x, y))\n          END DO\n        END DO\n        DO x = 1, LOOPCOUNT\n          IF (totals_comparison(x) .NE. totals(x)) THEN\n            errors = errors + 1\n            WRITE(*, *) totals_comparison(x)\n          END IF\n        END DO\n\n        DO x = 1, LOOPCOUNT\n          DO y = 1, 10\n            passed_a(y) = a(x, y)\n            passed_b(y) = b(x, y)\n          END DO\n          init = 0\n          DO y = 0, 7\n            init = init + ISHFT(1, y)\n          END DO\n          IF (IS_POSSIBLE(passed_a, passed_b, 10, init) .eqv. .FALSE.) THEN\n            errors = errors + 1\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "construct-independent",
                            "atomic"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_capture_assign_iand_x_expr.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:construct-independent,atomic,V:2.0-2.7\n      LOGICAL FUNCTION test1()\n  IMPLICIT NONE\n  INCLUDE \"acc_testsuite.Fh\"\n  INTEGER :: x, y, z !Iterators\n  INTEGER,DIMENSION(LOOPCOUNT, 10):: a, b !Data\n  REAL(8),DIMENSION(LOOPCOUNT, 10, 8):: randoms\n  INTEGER,DIMENSION(LOOPCOUNT):: totals, totals_comparison\n  INTEGER,DIMENSION(10):: passed_a, passed_b\n  INTEGER:: init\n  LOGICAL IS_POSSIBLE\n  INTEGER :: errors = 0\n\n  !Initilization\n  SEEDDIM(1) = 1\n# ifdef SEED\n  SEEDDIM(1) = SEED\n# endif\n  CALL RANDOM_SEED(PUT=SEEDDIM)\n\n  CALL RANDOM_NUMBER(randoms)\n  a = 0\n  DO x = 1, LOOPCOUNT\n    DO y = 1, 10\n      DO z = 1, 8\n        IF (randoms(x, y, z) .lt. .933) THEN\n          a(x, y) = a(x, y) + ISHFT(1, z - 1)\n        END IF\n      END DO\n    END DO\n  END DO\n  totals = 0\n  totals_comparison = 0\n  DO x = 1, LOOPCOUNT\n    DO y = 0, 7\n      totals(x) = totals(x) + ISHFT(1, y)\n      totals_comparison(x) = totals_comparison(x) + ISHFT(1, y)\n    END DO\n  END DO\n\n  !$acc data copyin(a(1:LOOPCOUNT, 1:10)) copy(totals(1:LOOPCOUNT)) copyout(b(1:LOOPCOUNT, 1:10))\n    !$acc parallel\n      !$acc loop\n      DO x = 1, LOOPCOUNT\n        DO y = 1, 10\n          !$acc atomic capture\n            b(x, y) = totals(x)\n            totals(x) = iand(totals(x), a(x, y))\n          !$acc end atomic\n        END DO\n      END DO\n    !$acc end parallel\n  !$acc end data\n  DO x = 1, LOOPCOUNT\n    DO y = 1, 10\n      totals_comparison(x) = iand(totals_comparison(x), a(x, y))\n    END DO\n  END DO\n  DO x = 1, LOOPCOUNT\n    IF (totals_comparison(x) .NE. totals(x)) THEN\n      errors = errors + 1\n      WRITE(*, *) totals_comparison(x)\n    END IF\n  END DO\n\n  DO x = 1, LOOPCOUNT\n    DO y = 1, 10\n      passed_a(y) = a(x, y)\n      passed_b(y) = b(x, y)\n    END DO\n    init = 0\n    DO y = 0, 7\n      init = init + ISHFT(1, y)\n    END DO\n    IF (IS_POSSIBLE(passed_a, passed_b, 10, init) .eqv. .FALSE.) THEN\n      errors = errors + 1\n    END IF\n  END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "construct-independent",
                            "atomic"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_capture_assign_ior_expr_x.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:construct-independent,atomic,V:2.0-2.7\n      LOGICAL FUNCTION test1()\n  IMPLICIT NONE\n  INCLUDE \"acc_testsuite.Fh\"\n  INTEGER :: x, y, z !Iterators\n  INTEGER,DIMENSION(LOOPCOUNT, 10):: a, b !Data\n  REAL(8),DIMENSION(LOOPCOUNT, 10, 8):: randoms\n  INTEGER,DIMENSION(LOOPCOUNT):: totals, totals_comparison\n  INTEGER,DIMENSION(10):: passed_a, passed_b\n  INTEGER:: init\n  LOGICAL IS_POSSIBLE\n  INTEGER :: errors = 0\n\n  !Initilization\n  SEEDDIM(1) = 1\n# ifdef SEED\n  SEEDDIM(1) = SEED\n# endif\n  CALL RANDOM_SEED(PUT=SEEDDIM)\n\n  CALL RANDOM_NUMBER(randoms)\n  a = 0\n  DO x = 1, LOOPCOUNT\n    DO y = 1, 10\n      DO z = 1, 8\n        IF (randoms(x, y, z) .gt. .933) THEN\n          a(x, y) = a(x, y) + ISHFT(1, z - 1)\n        END IF\n      END DO\n    END DO\n  END DO\n  totals = 0\n  totals_comparison = 0\n\n  !$acc data copyin(a(1:LOOPCOUNT, 1:10)) copy(totals(1:LOOPCOUNT)) copyout(b(1:LOOPCOUNT, 1:10))\n    !$acc parallel\n      !$acc loop\n      DO x = 1, LOOPCOUNT\n        DO y = 1, 10\n          !$acc atomic capture\n            b(x, y) = totals(x)\n            totals(x) = ior(a(x, y), totals(x))\n          !$acc end atomic\n        END DO\n      END DO\n    !$acc end parallel\n  !$acc end data\n  DO x = 1, LOOPCOUNT\n    DO y = 1, 10\n      totals_comparison(x) = ior(totals_comparison(x), a(x, y))\n    END DO\n  END DO\n  DO x = 1, LOOPCOUNT\n    IF (totals_comparison(x) .NE. totals(x)) THEN\n      errors = errors + 1\n      WRITE(*, *) totals_comparison(x)\n    END IF\n  END DO\n\n  DO x = 1, LOOPCOUNT\n    DO y = 1, 10\n      passed_a(y) = a(x, y)\n      passed_b(y) = b(x, y)\n    END DO\n    init = 0\n    IF (IS_POSSIBLE(passed_a, passed_b, 10, init) .eqv. .FALSE.) THEN\n      errors = errors + 1\n    END IF\n  END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "construct-independent",
                            "atomic"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_capture_assign_ior_x_expr.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:construct-independent,atomic,V:2.0-2.7\n      LOGICAL FUNCTION test1()\n  IMPLICIT NONE\n  INCLUDE \"acc_testsuite.Fh\"\n  INTEGER :: x, y, z !Iterators\n  INTEGER,DIMENSION(LOOPCOUNT, 10):: a, b !Data\n  REAL(8),DIMENSION(LOOPCOUNT, 10, 8):: randoms\n  INTEGER,DIMENSION(LOOPCOUNT):: totals, totals_comparison\n  INTEGER,DIMENSION(10):: passed_a, passed_b\n  INTEGER:: init\n  LOGICAL IS_POSSIBLE\n  INTEGER :: errors = 0\n\n  !Initilization\n  SEEDDIM(1) = 1\n# ifdef SEED\n  SEEDDIM(1) = SEED\n# endif\n  CALL RANDOM_SEED(PUT=SEEDDIM)\n\n  CALL RANDOM_NUMBER(randoms)\n  a = 0\n  DO x = 1, LOOPCOUNT\n    DO y = 1, 10\n      DO z = 1, 8\n        IF (randoms(x, y, z) .gt. .933) THEN\n          a(x, y) = a(x, y) + ISHFT(1, z - 1)\n        END IF\n      END DO\n    END DO\n  END DO\n  totals = 0\n  totals_comparison = 0\n\n  !$acc data copyin(a(1:LOOPCOUNT, 1:10)) copy(totals(1:LOOPCOUNT)) copyout(b(1:LOOPCOUNT, 1:10))\n    !$acc parallel\n      !$acc loop\n      DO x = 1, LOOPCOUNT\n        DO y = 1, 10\n          !$acc atomic capture\n            b(x, y) = totals(x)\n            totals(x) = ior(totals(x), a(x, y))\n          !$acc end atomic\n        END DO\n      END DO\n    !$acc end parallel\n  !$acc end data\n  DO x = 1, LOOPCOUNT\n    DO y = 1, 10\n      totals_comparison(x) = ior(totals_comparison(x), a(x, y))\n    END DO\n  END DO\n  DO x = 1, LOOPCOUNT\n    IF (totals_comparison(x) .NE. totals(x)) THEN\n      errors = errors + 1\n      WRITE(*, *) totals_comparison(x)\n    END IF\n  END DO\n\n  DO x = 1, LOOPCOUNT\n    DO y = 1, 10\n      passed_a(y) = a(x, y)\n      passed_b(y) = b(x, y)\n    END DO\n    init = 0\n    IF (IS_POSSIBLE(passed_a, passed_b, 10, init) .eqv. .FALSE.) THEN\n      errors = errors + 1\n    END IF\n  END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "construct-independent",
                            "atomic"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_capture_assign_ixor_expr_x.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:construct-independent,atomic,V:2.0-2.7\n      LOGICAL FUNCTION test1()\n  IMPLICIT NONE\n  INCLUDE \"acc_testsuite.Fh\"\n  INTEGER :: x, y, z !Iterators\n  INTEGER,DIMENSION(LOOPCOUNT, 10):: a, b !Data\n  REAL(8),DIMENSION(LOOPCOUNT, 10, 8):: randoms\n  INTEGER,DIMENSION(LOOPCOUNT):: totals, totals_comparison\n  INTEGER,DIMENSION(10):: passed_a, passed_b\n  INTEGER:: init\n  LOGICAL IS_POSSIBLE\n  INTEGER :: errors = 0\n\n  !Initilization\n  SEEDDIM(1) = 1\n# ifdef SEED\n  SEEDDIM(1) = SEED\n# endif\n  CALL RANDOM_SEED(PUT=SEEDDIM)\n\n  CALL RANDOM_NUMBER(randoms)\n  a = 0\n  DO x = 1, LOOPCOUNT\n    DO y = 1, 10\n      DO z = 1, 8\n        IF (randoms(x, y, z) .gt. .5) THEN\n          a(x, y) = a(x, y) + ISHFT(1, z - 1)\n        END IF\n      END DO\n    END DO\n  END DO\n  totals = 0\n  totals_comparison = 0\n\n  !$acc data copyin(a(1:LOOPCOUNT, 1:10)) copy(totals(1:LOOPCOUNT)) copyout(b(1:LOOPCOUNT, 1:10))\n    !$acc parallel\n      !$acc loop\n      DO x = 1, LOOPCOUNT\n        DO y = 1, 10\n          !$acc atomic capture\n            b(x, y) = totals(x)\n            totals(x) = ieor(a(x, y), totals(x))\n          !$acc end atomic\n        END DO\n      END DO\n    !$acc end parallel\n  !$acc end data\n  DO x = 1, LOOPCOUNT\n    DO y = 1, 10\n      totals_comparison(x) = ieor(totals_comparison(x), a(x, y))\n    END DO\n  END DO\n  DO x = 1, LOOPCOUNT\n    IF (totals_comparison(x) .NE. totals(x)) THEN\n      errors = errors + 1\n      WRITE(*, *) totals_comparison(x)\n    END IF\n  END DO\n\n  DO x = 1, LOOPCOUNT\n    DO y = 1, 10\n      passed_a(y) = a(x, y)\n      passed_b(y) = b(x, y)\n    END DO\n    init = 0\n    IF (IS_POSSIBLE(passed_a, passed_b, 10, init) .eqv. .FALSE.) THEN\n      errors = errors + 1\n    END IF\n  END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "construct-independent",
                            "atomic"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_capture_assign_ixor_x_expr.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:construct-independent,atomic,V:2.0-2.7\nLOGICAL FUNCTION test1()\n  IMPLICIT NONE\n  INCLUDE \"acc_testsuite.Fh\"\n  INTEGER :: x, y, z !Iterators\n  INTEGER,DIMENSION(LOOPCOUNT, 10):: a, b !Data\n  REAL(8),DIMENSION(LOOPCOUNT, 10, 8):: randoms\n  INTEGER,DIMENSION(LOOPCOUNT):: totals, totals_comparison\n  INTEGER,DIMENSION(10):: passed_a, passed_b\n  INTEGER:: init\n  LOGICAL IS_POSSIBLE\n  INTEGER :: errors = 0\n\n  !Initilization\n  SEEDDIM(1) = 1\n# ifdef SEED\n  SEEDDIM(1) = SEED\n# endif\n  CALL RANDOM_SEED(PUT=SEEDDIM)\n\n  CALL RANDOM_NUMBER(randoms)\n  a = 0\n  DO x = 1, LOOPCOUNT\n    DO y = 1, 10\n      DO z = 1, 8\n        IF (randoms(x, y, z) .gt. .5) THEN\n          a(x, y) = a(x, y) + ISHFT(1, z - 1)\n        END IF\n      END DO\n    END DO\n  END DO\n  totals = 0\n  totals_comparison = 0\n\n  !$acc data copyin(a(1:LOOPCOUNT, 1:10)) copy(totals(1:LOOPCOUNT)) copyout(b(1:LOOPCOUNT, 1:10))\n    !$acc parallel\n      !$acc loop\n      DO x = 1, LOOPCOUNT\n        DO y = 1, 10\n          !$acc atomic capture\n            b(x, y) = totals(x)\n            totals(x) = ieor(totals(x), a(x, y))\n          !$acc end atomic\n        END DO\n      END DO\n    !$acc end parallel\n  !$acc end data\n  DO x = 1, LOOPCOUNT\n    DO y = 1, 10\n      totals_comparison(x) = ieor(totals_comparison(x), a(x, y))\n    END DO\n  END DO\n  DO x = 1, LOOPCOUNT\n    IF (totals_comparison(x) .NE. totals(x)) THEN\n      errors = errors + 1\n      WRITE(*, *) totals_comparison(x)\n    END IF\n  END DO\n\n  DO x = 1, LOOPCOUNT\n    DO y = 1, 10\n      passed_a(y) = a(x, y)\n      passed_b(y) = b(x, y)\n    END DO\n    init = 0\n    IF (IS_POSSIBLE(passed_a, passed_b, 10, init) .eqv. .FALSE.) THEN\n      errors = errors + 1\n    END IF\n  END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "construct-independent",
                            "atomic"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_capture_assign_max_expr_list_x.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:construct-independent,atomic,V:2.0-2.7\n      LOGICAL FUNCTION test1()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x, y !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT, 10):: a, b, c !Data\n        REAL(8),DIMENSION(LOOPCOUNT):: totals, totals_comparison\n        REAL(8),DIMENSION(10):: passed_a, passed_b, passed_c\n        REAL(8):: init\n        LOGICAL IS_POSSIBLE\n        INTEGER :: errors = 0\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n        CALL RANDOM_NUMBER(a)\n        CALL RANDOM_NUMBER(b)\n\n        totals = 0\n        totals_comparison = 0\n\n        !$acc data copyin(a(1:LOOPCOUNT, 1:10), b(1:LOOPCOUNT, 1:10)) copy(totals(1:LOOPCOUNT)) copyout(c(1:LOOPCOUNT, 1:10))\n          !$acc parallel\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              DO y = 1, 10\n                !$acc atomic capture\n                  c(x, y) = totals(x)\n                  totals(x) = max(a(x, y), b(x, y), totals(x))\n                !$acc end atomic\n              END DO\n            END DO\n          !$acc end parallel\n        !$acc end data\n        DO x = 1, LOOPCOUNT\n          DO y = 1, 10\n            totals_comparison(x) = max(totals_comparison(x), a(x, y), b(x, y))\n          END DO\n        END DO\n        DO x = 1, LOOPCOUNT\n          IF (totals_comparison(x) .NE. totals(x)) THEN\n            errors = errors + 1\n            WRITE(*, *) totals_comparison(x)\n          END IF\n        END DO\n\n        DO x = 1, LOOPCOUNT\n          DO y = 1, 10\n            passed_a(y) = a(x, y)\n            passed_b(y) = b(x, y)\n            passed_c(y) = c(x, y)\n          END DO\n          init = 0\n          IF (IS_POSSIBLE(passed_a, passed_b, passed_c, 10, init) .eqv. .FALSE.) THEN\n            errors = errors + 1\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n      LOGICAL :: test1\n#endif\n#ifndef T1\n      DO testrun = 1, NUM_TEST_CALLS\n        failed = failed .or. test1()\n      END DO\n      IF (failed) THEN\n        failcode = failcode + 2 ** 0\n        failed = .FALSE.\n      END IF\n#endif\n",
                        "tags": [
                            "construct-independent",
                            "atomic"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_capture_assign_max_expr_x.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:construct-independent,atomic,V:2.0-2.7\n      LOGICAL FUNCTION test1()\n  IMPLICIT NONE\n  INCLUDE \"acc_testsuite.Fh\"\n  INTEGER :: x, y !Iterators\n  REAL(8),DIMENSION(LOOPCOUNT, 10):: a, b !Data\n  REAL(8),DIMENSION(LOOPCOUNT):: totals, totals_comparison\n  REAL(8),DIMENSION(10):: passed_a, passed_b\n  REAL(8):: init\n  LOGICAL IS_POSSIBLE\n  INTEGER :: errors = 0\n\n  !Initilization\n  SEEDDIM(1) = 1\n# ifdef SEED\n  SEEDDIM(1) = SEED\n# endif\n  CALL RANDOM_SEED(PUT=SEEDDIM)\n\n  CALL RANDOM_NUMBER(a)\n\n  totals = 0\n  totals_comparison = 0\n\n  !$acc data copyin(a(1:LOOPCOUNT, 1:10)) copy(totals(1:LOOPCOUNT)) copyout(b(1:LOOPCOUNT, 1:10))\n    !$acc parallel\n      !$acc loop\n      DO x = 1, LOOPCOUNT\n        DO y = 1, 10\n          !$acc atomic capture\n            b(x, y) = totals(x)\n            totals(x) = max(a(x, y), totals(x))\n          !$acc end atomic\n        END DO\n      END DO\n    !$acc end parallel\n  !$acc end data\n  DO x = 1, LOOPCOUNT\n    DO y = 1, 10\n      totals_comparison(x) = max(totals_comparison(x), a(x, y))\n    END DO\n  END DO\n  DO x = 1, LOOPCOUNT\n    IF (totals_comparison(x) .NE. totals(x)) THEN\n      errors = errors + 1\n      WRITE(*, *) totals_comparison(x)\n    END IF\n  END DO\n\n  DO x = 1, LOOPCOUNT\n    DO y = 1, 10\n      passed_a(y) = a(x, y)\n      passed_b(y) = b(x, y)\n    END DO\n    init = 0\n    IF (IS_POSSIBLE(passed_a, passed_b, 10, init) .eqv. .FALSE.) THEN\n      errors = errors + 1\n    END IF\n  END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "construct-independent",
                            "atomic"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_capture_assign_max_x_expr.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:construct-independent,atomic,V:2.0-2.7\n      LOGICAL FUNCTION test1()\n  IMPLICIT NONE\n  INCLUDE \"acc_testsuite.Fh\"\n  INTEGER :: x, y !Iterators\n  REAL(8),DIMENSION(LOOPCOUNT, 10):: a, b !Data\n  REAL(8),DIMENSION(LOOPCOUNT):: totals, totals_comparison\n  REAL(8),DIMENSION(10):: passed_a, passed_b\n  REAL(8):: init\n  LOGICAL IS_POSSIBLE\n  INTEGER :: errors = 0\n\n  !Initilization\n  SEEDDIM(1) = 1\n# ifdef SEED\n  SEEDDIM(1) = SEED\n# endif\n  CALL RANDOM_SEED(PUT=SEEDDIM)\n\n  CALL RANDOM_NUMBER(a)\n\n  totals = 0\n  totals_comparison = 0\n\n  !$acc data copyin(a(1:LOOPCOUNT, 1:10)) copy(totals(1:LOOPCOUNT)) copyout(b(1:LOOPCOUNT, 1:10))\n    !$acc parallel\n      !$acc loop\n      DO x = 1, LOOPCOUNT\n        DO y = 1, 10\n          !$acc atomic capture\n            b(x, y) = totals(x)\n            totals(x) = max(totals(x), a(x, y))\n          !$acc end atomic\n        END DO\n      END DO\n    !$acc end parallel\n  !$acc end data\n  DO x = 1, LOOPCOUNT\n    DO y = 1, 10\n      totals_comparison(x) = max(totals_comparison(x), a(x, y))\n    END DO\n  END DO\n  DO x = 1, LOOPCOUNT\n    IF (totals_comparison(x) .NE. totals(x)) THEN\n      errors = errors + 1\n      WRITE(*, *) totals_comparison(x)\n    END IF\n  END DO\n\n  DO x = 1, LOOPCOUNT\n    DO y = 1, 10\n      passed_a(y) = a(x, y)\n      passed_b(y) = b(x, y)\n    END DO\n    init = 0\n    IF (IS_POSSIBLE(passed_a, passed_b, 10, init) .eqv. .FALSE.) THEN\n      errors = errors + 1\n    END IF\n  END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "construct-independent",
                            "atomic"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_capture_assign_max_x_expr_list.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:construct-independent,atomic,V:2.0-2.7\n      LOGICAL FUNCTION test1()\nIMPLICIT NONE\nINCLUDE \"acc_testsuite.Fh\"\nINTEGER :: x, y !Iterators\nREAL(8),DIMENSION(LOOPCOUNT, 10):: a, b, c !Data\nREAL(8),DIMENSION(LOOPCOUNT):: totals, totals_comparison\nREAL(8),DIMENSION(10):: passed_a, passed_b, passed_c\nREAL(8):: init\nLOGICAL IS_POSSIBLE\nINTEGER :: errors = 0\n\n!Initilization\nSEEDDIM(1) = 1\n#ifdef SEED\nSEEDDIM(1) = SEED\n#endif\n",
                        "tags": [
                            "construct-independent",
                            "atomic"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_capture_assign_min_expr_list_x.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:construct-independent,atomic,V:2.0-2.7\n      LOGICAL FUNCTION test1()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x, y !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT, 10):: a, b, c !Data\n        REAL(8),DIMENSION(LOOPCOUNT):: totals, totals_comparison\n        REAL(8),DIMENSION(10):: passed_a, passed_b, passed_c\n        REAL(8):: init\n        LOGICAL IS_POSSIBLE\n        INTEGER :: errors = 0\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(a)\n        CALL RANDOM_NUMBER(b)\n\n        totals = 0\n        totals_comparison = 0\n\n        !$acc data copyin(a(1:LOOPCOUNT, 1:10), b(1:LOOPCOUNT, 1:10)) copy(totals(1:LOOPCOUNT)) copyout(c(1:LOOPCOUNT, 1:10))\n          !$acc parallel\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              DO y = 1, 10\n                !$acc atomic capture\n                  c(x, y) = totals(x)\n                  totals(x) = min(a(x, y), b(x, y), totals(x))\n                !$acc end atomic\n              END DO\n            END DO\n          !$acc end parallel\n        !$acc end data\n        DO x = 1, LOOPCOUNT\n          DO y = 1, 10\n            totals_comparison(x) = min(totals_comparison(x), a(x, y), b(x, y))\n          END DO\n        END DO\n        DO x = 1, LOOPCOUNT\n          IF (totals_comparison(x) .NE. totals(x)) THEN\n            errors = errors + 1\n            WRITE(*, *) totals_comparison(x)\n          END IF\n        END DO\n\n        DO x = 1, LOOPCOUNT\n          DO y = 1, 10\n            passed_a(y) = a(x, y)\n            passed_b(y) = b(x, y)\n            passed_c(y) = c(x, y)\n          END DO\n          init = 0\n          IF (IS_POSSIBLE(passed_a, passed_b, passed_c, 10, init) .eqv. .FALSE.) THEN\n            errors = errors + 1\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "construct-independent",
                            "atomic"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_capture_assign_min_expr_x.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:construct-independent,atomic,V:2.0-2.7\n      LOGICAL FUNCTION test1()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x, y !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT, 10):: a, b !Data\n        REAL(8),DIMENSION(LOOPCOUNT):: totals, totals_comparison\n        REAL(8),DIMENSION(10):: passed_a, passed_b\n        REAL(8):: init\n        LOGICAL IS_POSSIBLE\n        INTEGER :: errors = 0\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(a)\n\n        totals = 0\n        totals_comparison = 0\n\n        !$acc data copyin(a(1:LOOPCOUNT, 1:10)) copy(totals(1:LOOPCOUNT)) copyout(b(1:LOOPCOUNT, 1:10))\n          !$acc parallel\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              DO y = 1, 10\n                !$acc atomic capture\n                  b(x, y) = totals(x)\n                  totals(x) = min(a(x, y), totals(x))\n                !$acc end atomic\n              END DO\n            END DO\n          !$acc end parallel\n        !$acc end data\n        DO x = 1, LOOPCOUNT\n          DO y = 1, 10\n            totals_comparison(x) = min(totals_comparison(x), a(x, y))\n          END DO\n        END DO\n        DO x = 1, LOOPCOUNT\n          IF (totals_comparison(x) .NE. totals(x)) THEN\n            errors = errors + 1\n            WRITE(*, *) totals_comparison(x)\n          END IF\n        END DO\n\n        DO x = 1, LOOPCOUNT\n          DO y = 1, 10\n            passed_a(y) = a(x, y)\n            passed_b(y) = b(x, y)\n          END DO\n          init = 0\n          IF (IS_POSSIBLE(passed_a, passed_b, 10, init) .eqv. .FALSE.) THEN\n            errors = errors + 1\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "construct-independent",
                            "atomic"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_capture_assign_min_x_expr.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:construct-independent,atomic,V:2.0-2.7\n      LOGICAL FUNCTION test1()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x, y !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT, 10):: a, b !Data\n        REAL(8),DIMENSION(LOOPCOUNT):: totals, totals_comparison\n        REAL(8),DIMENSION(10):: passed_a, passed_b\n        REAL(8):: init\n        LOGICAL IS_POSSIBLE\n        INTEGER :: errors = 0\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(a)\n\n        totals = 0\n        totals_comparison = 0\n\n        !$acc data copyin(a(1:LOOPCOUNT, 1:10)) copy(totals(1:LOOPCOUNT)) copyout(b(1:LOOPCOUNT, 1:10))\n          !$acc parallel\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              DO y = 1, 10\n                !$acc atomic capture\n                  b(x, y) = totals(x)\n                  totals(x) = min(totals(x), a(x, y))\n                !$acc end atomic\n              END DO\n            END DO\n          !$acc end parallel\n        !$acc end data\n        DO x = 1, LOOPCOUNT\n          DO y = 1, 10\n            totals_comparison(x) = min(totals_comparison(x), a(x, y))\n          END DO\n        END DO\n        DO x = 1, LOOPCOUNT\n          IF (totals_comparison(x) .NE. totals(x)) THEN\n            errors = errors + 1\n            WRITE(*, *) totals_comparison(x)\n          END IF\n        END DO\n\n        DO x = 1, LOOPCOUNT\n          DO y = 1, 10\n            passed_a(y) = a(x, y)\n            passed_b(y) = b(x, y)\n          END DO\n          init = 0\n          IF (IS_POSSIBLE(passed_a, passed_b, 10, init) .eqv. .FALSE.) THEN\n            errors = errors + 1\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "construct-independent",
                            "atomic"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_capture_assign_min_x_expr_list.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:construct-independent,atomic,V:2.0-2.7\n      LOGICAL FUNCTION test1()\n      IMPLICIT NONE\n      INCLUDE \"acc_testsuite.Fh\"\n      INTEGER :: x, y !Iterators\n      REAL(8),DIMENSION(LOOPCOUNT, 10):: a, b, c !Data\n      REAL(8),DIMENSION(LOOPCOUNT):: totals, totals_comparison\n      REAL(8),DIMENSION(10):: passed_a, passed_b, passed_c\n      REAL(8):: init\n      LOGICAL IS_POSSIBLE\n      INTEGER :: errors = 0\n\n      !Initilization\n      SEEDDIM(1) = 1\n#     ifdef SEED\n      SEEDDIM(1) = SEED\n#     endif\n      CALL RANDOM_SEED(PUT=SEEDDIM)\n\n      CALL RANDOM_NUMBER(a)\n      CALL RANDOM_NUMBER(b)\n\n      totals = 1\n      totals_comparison = 1\n\n      !$acc data copyin(a(1:LOOPCOUNT, 1:10), b(1:LOOPCOUNT, 1:10)) copy(totals(1:LOOPCOUNT)) copyout(c(1:LOOPCOUNT, 1:10))\n        !$acc parallel\n          !$acc loop\n          DO x = 1, LOOPCOUNT\n            DO y = 1, 10\n              !$acc atomic capture\n                c(x, y) = totals(x)\n                totals(x) = min(totals(x), a(x, y), b(x, y))\n              !$acc end atomic\n            END DO\n          END DO\n        !$acc end parallel\n      !$acc end data\n      DO x = 1, LOOPCOUNT\n        DO y = 1, 10\n          totals_comparison(x) = min(totals_comparison(x), a(x, y), b(x, y))\n        END DO\n      END DO\n      DO x = 1, LOOPCOUNT\n        IF (totals_comparison(x) .NE. totals(x)) THEN\n          errors = errors + 1\n          WRITE(*, *) totals_comparison(x)\n        END IF\n      END DO\n\n      DO x = 1, LOOPCOUNT\n        DO y = 1, 10\n          passed_a(y) = a(x, y)\n          passed_b(y) = b(x, y)\n          passed_c(y) = c(x, y)\n        END DO\n        init = 1\n        IF (IS_POSSIBLE(passed_a, passed_b, passed_c, 10, init) .eqv. .FALSE.) THEN\n          errors = errors + 1\n        END IF\n      END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "construct-independent",
                            "atomic"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_capture_assign_x_and_expr.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:construct-independent,atomic,V:2.0-2.7\nLOGICAL FUNCTION test1()\n  IMPLICIT NONE\n  INCLUDE \"acc_testsuite.Fh\"\n  INTEGER :: x, y !Iterators\n  REAL(8),DIMENSION(LOOPCOUNT, 10):: randoms\n  LOGICAL,DIMENSION(LOOPCOUNT, 10):: a, b !Data\n  LOGICAL,DIMENSION(10):: passed_a, passed_b\n  LOGICAL IS_POSSIBLE\n  LOGICAL,DIMENSION(LOOPCOUNT):: totals, totals_comparison\n  INTEGER :: errors = 0\n  LOGICAL :: init\n\n  !Initilization\n  SEEDDIM(1) = 1\n# ifdef SEED\n  SEEDDIM(1) = SEED\n# endif\n  CALL RANDOM_SEED(PUT=SEEDDIM)\n\n  CALL RANDOM_NUMBER(randoms)\n  DO x = 1, LOOPCOUNT\n    DO y = 1, 10\n      IF (randoms(x, y) < .933) THEN\n        a(x, y) = .TRUE.\n      ELSE\n        a(x, y) = .FALSE.\n      END IF\n    END DO\n  END DO\n\n  totals = .FALSE.\n  totals_comparison = .FALSE.\n\n  !$acc data copyin(a(1:LOOPCOUNT,1:10)) copy(totals(1:LOOPCOUNT)) copyout(b(1:LOOPCOUNT,1:10))\n    !$acc parallel\n      !$acc loop\n      DO x = 1, LOOPCOUNT\n        DO y = 1, 10\n          !$acc atomic capture\n            b(x, y) = totals(x)\n            totals(x) = totals(x) .AND. a(x, y)\n          !$acc end atomic\n        END DO\n      END DO\n    !$acc end parallel\n  !$acc end data\n\n  DO x = 1, LOOPCOUNT\n    DO y = 1, 10\n      totals_comparison(x) = totals_comparison(x) .AND. a(x, y)\n    END DO\n  END DO\n\n  DO x = 1, LOOPCOUNT\n    IF (totals_comparison(x) .NEQV. totals(x)) THEN\n      errors = errors + 1\n      WRITE(*, *) totals_comparison(x)\n    END IF\n  END DO\n\n  DO x = 1, LOOPCOUNT\n    DO y = 1, 10\n      passed_a(y) = a(x, y)\n      passed_b(y) = b(x, y)\n    END DO\n    init = .FALSE.\n    IF (.FALSE. .eqv. IS_POSSIBLE(a(x, 1:10), b(x, 1:10), 10, .FALSE.)) THEN\n      errors = errors + 1\n    END IF\n  END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "construct-independent",
                            "atomic"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_capture_assign_x_divided_expr.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:construct-independent,atomic,V:2.0-2.7\n      LOGICAL FUNCTION test1()\n  IMPLICIT NONE\n  INCLUDE \"acc_testsuite.Fh\"\n  INTEGER :: x, y !Iterators\n  REAL(8),DIMENSION(LOOPCOUNT, 10):: a !Data\n  REAL(8),DIMENSION(LOOPCOUNT, 10):: b\n  REAL(8),DIMENSION(LOOPCOUNT):: totals\n  REAL(8),DIMENSION(10):: passed\n  REAL(8),DIMENSION(10):: passed_b\n  REAL(8) :: holder\n  INTEGER :: errors = 0\n  LOGICAL IS_POSSIBLE\n  LOGICAL IS_POSSIBLE_2\n\n  !Initilization\n  SEEDDIM(1) = 1\n# ifdef SEED\n  SEEDDIM(1) = SEED\n# endif\n  CALL RANDOM_SEED(PUT=SEEDDIM)\n\n  CALL RANDOM_NUMBER(a)\n\n  totals = 1\n\n  !$acc data copyin(a(1:LOOPCOUNT, 1:10)) copy(totals(1:LOOPCOUNT)) copyout(b(1:LOOPCOUNT,1:10))\n    !$acc parallel\n      !$acc loop\n      DO x = 1, LOOPCOUNT\n        DO y = 1, 10\n          !$acc atomic capture\n            b(x, y) = totals(x)\n            totals(x) = totals(x) / a(x, y)\n          !$acc end atomic\n        END DO\n      END DO\n    !$acc end parallel\n  !$acc end data\n\n  DO x = 1, LOOPCOUNT\n    DO y = 1, 10\n      passed(y) = a(x, y)\n    END DO\n    holder = 1\n    IF (IS_POSSIBLE(passed, totals(x), 10, holder) .eqv. .FALSE.) THEN\n      errors = errors + 1\n    END IF\n  END DO\n\n  DO x = 1, LOOPCOUNT\n    DO y = 1, 10\n      passed(y) = a(x, y)\n      passed_b(y) = b(x, y)\n    END DO\n    holder = 1\n    IF (IS_POSSIBLE_2(passed, passed_b, 10, holder) .eqv. .FALSE.) THEN\n      errors = errors + 1\n    END IF\n  END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "construct-independent",
                            "atomic"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_capture_assign_x_eqv_expr.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:construct-independent,atomic,V:2.0-2.7\n      LOGICAL FUNCTION test1()\n  IMPLICIT NONE\n  INCLUDE \"acc_testsuite.Fh\"\n  INTEGER :: x, y !Iterators\n  REAL(8),DIMENSION(LOOPCOUNT, 10):: randoms\n  LOGICAL,DIMENSION(LOOPCOUNT, 10):: a, b !Data\n  LOGICAL,DIMENSION(LOOPCOUNT):: totals, totals_comparison\n  LOGICAL,DIMENSION(10):: passed_a, passed_b\n  LOGICAL:: init\n  INTEGER :: errors = 0\n  LOGICAL IS_POSSIBLE\n\n  !Initilization\n  SEEDDIM(1) = 1\n# ifdef SEED\n  SEEDDIM(1) = SEED\n# endif\n  CALL RANDOM_SEED(PUT=SEEDDIM)\n\n  CALL RANDOM_NUMBER(randoms)\n  DO x = 1, LOOPCOUNT\n    DO y = 1, 10\n      IF (randoms(x, y) > .5) THEN\n        a(x, y) = .TRUE.\n      ELSE\n        a(x, y) = .FALSE.\n      END IF\n    END DO\n  END DO\n\n  totals = .FALSE.\n  totals_comparison = .FALSE.\n\n  !$acc data copyin(a(1:LOOPCOUNT,1:10)) copy(totals(1:LOOPCOUNT)) copyout(b(1:LOOPCOUNT,1:10))\n    !$acc parallel\n      !$acc loop\n      DO x = 1, LOOPCOUNT\n        DO y = 1, 10\n          !$acc atomic capture\n            b(x, y) = totals(x)\n            totals(x) = totals(x) .EQV. a(x, y)\n          !$acc end atomic\n        END DO\n      END DO\n    !$acc end parallel\n  !$acc end data\n\n  DO x = 1, LOOPCOUNT\n    DO y = 1, 10\n      totals_comparison(x) = totals_comparison(x) .EQV. a(x, y)\n    END DO\n  END DO\n\n  DO x = 1, LOOPCOUNT\n    DO y = 1, 10\n      passed_a(y) = a(x, y)\n      passed_b(y) = b(x, y)\n    END DO\n    init = .FALSE.\n    IF (IS_POSSIBLE(passed_a, passed_b, 10, init) .EQV. .FALSE.) THEN\n      errors = errors + 1\n    END IF\n  END DO\n\n  DO x = 1, LOOPCOUNT\n    IF (totals_comparison(x) .NEQV. totals(x)) THEN\n      errors = errors + 1\n      WRITE(*, *) totals_comparison(x)\n    END IF\n  END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "construct-independent",
                            "atomic"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_capture_assign_x_minus_expr.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:construct-independent,atomic,V:2.0-2.7\n      LOGICAL FUNCTION test1()\n  IMPLICIT NONE\n  INCLUDE \"acc_testsuite.Fh\"\n  INTEGER :: x, y !Iterators\n  LOGICAL IS_POSSIBLE\n  LOGICAL IS_POSSIBLE_2\n  REAL(8),DIMENSION(LOOPCOUNT, 10):: a, b !Data\n  REAL(8),DIMENSION(LOOPCOUNT):: totals\n  REAL(8),DIMENSION(10):: passed_a, passed_b\n  REAL(8):: init\n  INTEGER :: errors = 0\n\n  !Initilization\n  SEEDDIM(1) = 1\n# ifdef SEED\n  SEEDDIM(1) = SEED\n# endif\n  CALL RANDOM_SEED(PUT=SEEDDIM)\n\n  CALL RANDOM_NUMBER(a)\n\n  totals = 0\n\n  !$acc data copyin(a(1:LOOPCOUNT, 1:10)) copy(totals(1:LOOPCOUNT)) copyout(b(1:LOOPCOUNT, 1:10))\n    !$acc parallel\n      !$acc loop\n      DO x = 1, LOOPCOUNT\n        DO y = 1, 10\n          !$acc atomic capture\n            b(x, y) = totals(x)\n            totals(x) = totals(x) - a(x, y)\n          !$acc end atomic\n        END DO\n      END DO\n    !$acc end parallel\n  !$acc end data\n\n  DO x = 1, LOOPCOUNT\n    DO y = 1, 10\n      passed_a(y) = a(x, y)\n    END DO\n    IF (IS_POSSIBLE(passed_a, totals(x), 10, 0) .eqv. .FALSE.) THEN\n      errors = errors + 1\n    END IF\n  END DO\n\n  DO x = 1, LOOPCOUNT\n    DO y = 1, 10\n      passed_a(y) = a(x, y)\n      passed_b(y) = b(x, y)\n    END DO\n    init = 0\n    IF (IS_POSSIBLE_2(passed_a, passed_b, 10, init) .EQV. .FALSE.) THEN\n      errors = errors + 1\n    END IF\n  END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "construct-independent",
                            "atomic"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_capture_assign_x_neqv_expr.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:construct-independent,atomic,V:2.0-2.7\n      LOGICAL FUNCTION test1()\n  IMPLICIT NONE\n  INCLUDE \"acc_testsuite.Fh\"\n  INTEGER :: x, y !Iterators\n  REAL(8),DIMENSION(LOOPCOUNT, 10):: randoms\n  LOGICAL,DIMENSION(LOOPCOUNT, 10):: a, b !Data\n  LOGICAL,DIMENSION(10):: passed_a, passed_b\n  LOGICAL,DIMENSION(LOOPCOUNT):: totals, totals_comparison\n  LOGICAL IS_POSSIBLE\n  INTEGER :: errors = 0\n\n  !Initilization\n  SEEDDIM(1) = 1\n# ifdef SEED\n  SEEDDIM(1) = SEED\n# endif\n  CALL RANDOM_SEED(PUT=SEEDDIM)\n\n  CALL RANDOM_NUMBER(randoms)\n  DO x = 1, LOOPCOUNT\n    DO y = 1, 10\n      IF (randoms(x, y) > .5) THEN\n        a(x, y) = .TRUE.\n      ELSE\n        a(x, y) = .FALSE.\n      END IF\n    END DO\n  END DO\n\n  totals = .FALSE.\n  totals_comparison = .FALSE.\n\n  !$acc data copyin(a(1:LOOPCOUNT,1:10)) copy(totals(1:LOOPCOUNT)) copyout(b(1:LOOPCOUNT,1:10))\n    !$acc parallel\n      !$acc loop\n      DO x = 1, LOOPCOUNT\n        DO y = 1, 10\n          !$acc atomic capture\n            b(x, y) = totals(x)\n            totals(x) = totals(x) .NEQV. a(x, y)\n          !$acc end atomic\n        END DO\n      END DO\n    !$acc end parallel\n  !$acc end data\n\n  DO x = 1, LOOPCOUNT\n    DO y = 1, 10\n      totals_comparison(x) = totals_comparison(x) .NEQV. a(x, y)\n    END DO\n  END DO\n\n  DO x = 1, LOOPCOUNT\n    IF (totals_comparison(x) .NEQV. totals(x)) THEN\n      errors = errors + 1\n      WRITE(*, *) totals_comparison(x)\n    END IF\n  END DO\n\n  DO x = 1, LOOPCOUNT\n    DO y = 1, 10\n      passed_a(y) = a(x, y)\n      passed_b(y) = b(x, y)\n    END DO\n    IF (IS_POSSIBLE(passed_a, passed_b, 10, .FALSE.) .eqv. .FALSE.) THEN\n      errors = errors + 1\n    END IF\n  END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "construct-independent",
                            "atomic"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_capture_assign_x_or_expr.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:construct-independent,atomic,V:2.0-2.7\n      LOGICAL FUNCTION test1()\n  IMPLICIT NONE\n  INCLUDE \"acc_testsuite.Fh\"\n  INTEGER :: x, y !Iterators\n  REAL(8),DIMENSION(LOOPCOUNT, 10):: randoms\n  LOGICAL,DIMENSION(LOOPCOUNT, 10):: a, b !Data\n  LOGICAL,DIMENSION(LOOPCOUNT):: totals, totals_comparison\n  LOGICAL,DIMENSION(10):: passed_a, passed_b\n  LOGICAL IS_POSSIBLE\n  LOGICAL:: init\n  INTEGER :: errors = 0\n\n  !Initilization\n  SEEDDIM(1) = 1\n# ifdef SEED\n  SEEDDIM(1) = SEED\n# endif\n  CALL RANDOM_SEED(PUT=SEEDDIM)\n\n  CALL RANDOM_NUMBER(randoms)\n  DO x = 1, LOOPCOUNT\n    DO y = 1, 10\n      IF (randoms(x, y) > .933) THEN\n        a(x, y) = .TRUE.\n      ELSE\n        a(x, y) = .FALSE.\n      END IF\n    END DO\n  END DO\n\n  totals = .FALSE.\n  totals_comparison = .FALSE.\n\n  !$acc data copyin(a(1:LOOPCOUNT,1:10)) copy(totals(1:LOOPCOUNT)) copyout(b(1:LOOPCOUNT,1:10))\n    !$acc parallel\n      !$acc loop\n      DO x = 1, LOOPCOUNT\n        DO y = 1, 10\n          !$acc atomic capture\n            b(x, y) = totals(x)\n            totals(x) = totals(x) .OR. a(x, y)\n          !$acc end atomic\n        END DO\n      END DO\n    !$acc end parallel\n  !$acc end data\n\n  DO x = 1, LOOPCOUNT\n    DO y = 1, 10\n      totals_comparison(x) = totals_comparison(x) .OR. a(x, y)\n    END DO\n  END DO\n\n  DO x = 1, LOOPCOUNT\n    IF (totals_comparison(x) .NEQV. totals(x)) THEN\n      errors = errors + 1\n      WRITE(*, *) totals_comparison(x)\n    END IF\n  END DO\n\n  DO x = 1, LOOPCOUNT\n    DO y = 1, 10\n      passed_a(y) = a(x, y)\n      passed_b(y) = b(x, y)\n    END DO\n    init = .FALSE.\n    IF (IS_POSSIBLE(passed_a, passed_b, 10, init) .eqv. .FALSE.) THEN\n      errors = errors + 1\n    END IF\n  END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "construct-independent",
                            "atomic"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_capture_assign_x_plus_expr.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:construct-independent,atomic,V:2.0-2.7\n      LOGICAL FUNCTION test1()\n  IMPLICIT NONE\n  INCLUDE \"acc_testsuite.Fh\"\n  INTEGER :: x, y !Iterators\n  REAL(8),DIMENSION(LOOPCOUNT, 10):: a, b !Data\n  REAL(8),DIMENSION(LOOPCOUNT):: totals, totals_comparison\n  REAL(8),DIMENSION(10):: passed_a, passed_b\n  REAL(8):: init\n  LOGICAL IS_POSSIBLE\n  INTEGER :: errors = 0\n\n  !Initilization\n  SEEDDIM(1) = 1\n# ifdef SEED\n  SEEDDIM(1) = SEED\n# endif\n  CALL RANDOM_SEED(PUT=SEEDDIM)\n\n  CALL RANDOM_NUMBER(a)\n\n  totals = 0\n  totals_comparison = 0\n\n  !$acc data copyin(a(1:LOOPCOUNT, 1:10)) copy(totals(1:LOOPCOUNT)) copyout(b(1:LOOPCOUNT,1:10))\n    !$acc parallel\n      !$acc loop\n      DO x = 1, LOOPCOUNT\n        DO y = 1, 10\n          !$acc atomic capture\n            b(x, y) = totals(x)\n            totals(x) = totals(x) + a(x, y)\n          !$acc end atomic\n        END DO\n      END DO\n    !$acc end parallel\n  !$acc end data\n  DO x = 1, LOOPCOUNT\n    DO y = 1, 10\n      totals_comparison(x) = totals_comparison(x) + a(x, y)\n    END DO\n  END DO\n\n  DO x = 1, LOOPCOUNT\n    IF (totals_comparison(x) .NE. totals(x)) THEN\n      errors = errors + 1\n      WRITE(*, *) totals_comparison(x)\n    END IF\n  END DO\n\n  DO x = 1, LOOPCOUNT\n    DO y = 1, 10\n      passed_a(y) = a(x, y)\n      passed_b(y) = b(x, y)\n    END DO\n    init = 0\n    IF (IS_POSSIBLE(passed_a, passed_b, 10, init) .eqv. .FALSE.) THEN\n      errors = errors + 1\n    END IF\n  END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "construct-independent",
                            "atomic"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_capture_assign_x_times_expr.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:construct-independent,atomic,V:2.0-2.7\n      LOGICAL FUNCTION test1()\n  IMPLICIT NONE\n  INCLUDE \"acc_testsuite.Fh\"\n  INTEGER :: x, y !Iterators\n  REAL(8),DIMENSION(LOOPCOUNT, 10):: a, b !Data\n  REAL(8),DIMENSION(LOOPCOUNT):: totals, totals_comparison\n  REAL(8),DIMENSION(10):: passed_a, passed_b\n  REAL(8):: init\n  LOGICAL IS_POSSIBLE\n  INTEGER :: errors = 0\n\n  !Initilization\n  SEEDDIM(1) = 1\n# ifdef SEED\n  SEEDDIM(1) = SEED\n# endif\n  CALL RANDOM_SEED(PUT=SEEDDIM)\n\n  CALL RANDOM_NUMBER(a)\n\n  totals = 1\n  totals_comparison = 1\n\n  !$acc data copyin(a(1:LOOPCOUNT, 1:10)) copy(totals(1:LOOPCOUNT)) copyout(b(1:LOOPCOUNT,1:10))\n    !$acc parallel\n      !$acc loop\n      DO x = 1, LOOPCOUNT\n        DO y = 1, 10\n          !$acc atomic capture\n            b(x, y) = totals(x)\n            totals(x) = totals(x) * a(x, y)\n          !$acc end atomic\n        END DO\n      END DO\n    !$acc end parallel\n  !$acc end data\n  DO x = 1, LOOPCOUNT\n    DO y = 1, 10\n      totals_comparison(x) = totals_comparison(x) * a(x, y)\n    END DO\n  END DO\n\n  DO x = 1, LOOPCOUNT\n    IF (totals_comparison(x) .NE. totals(x)) THEN\n      errors = errors + 1\n      WRITE(*, *) totals_comparison(x)\n    END IF\n  END DO\n\n  DO x = 1, LOOPCOUNT\n    DO y = 1, 10\n      passed_a(y) = a(x, y)\n      passed_b(y) = b(x, y)\n    END DO\n    init = 1\n    IF (IS_POSSIBLE(passed_a, passed_b, 10, init) .eqv. .TRUE.) THEN\n      errors = errors + 1\n    END IF\n  END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "construct-independent",
                            "atomic"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_capture_bitand_equals.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:atomic,construct-independent,V:2.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    int *a = (int *)malloc(n * sizeof(int));\n    int *b = (int *)malloc(n * sizeof(int));\n    int *totals = (int *)malloc((n/10 + 1) * sizeof(int));\n    int *totals_comparison = (int *)malloc((n/10 + 1) * sizeof(int));\n    int *temp_a = (int *)malloc(10 * sizeof(int));\n    int *temp_b = (int *)malloc(10 * sizeof(int));\n    int iterator;\n    int iterator2;\n    int init;\n\n    for (int x = 0; x < n; ++x){\n        for (int y = 0; y < 8; ++y){\n            if (rand()/(real_t)(RAND_MAX) < .933){ //.933 gets close to a 50/50 distribution for a collescence of 10 values\n                a[x] += 1<<y;\n            }\n        }\n    }\n    for (int x = 0; x < n/10 + 1; ++x){\n        for (int y = 0; y < 8; ++y){\n            totals[x] +=  1<<y;\n            totals_comparison[x] += 1<<y;\n        }\n    }\n    for (int x = 0; x < n; ++x){\n        for (int y = 0; y < 8; ++y){\n            b[x] += 1<<y;\n        }\n    }\n    #pragma acc data copyin(a[0:n]) copy(totals[0:n/10 + 1]) copyout(b[0:n])\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                #pragma acc atomic capture\n                    b[x] = totals[x%(n/10 + 1)] &= a[x];\n            }\n        }\n    }\n    for (int x = 0; x < n; ++x){\n        totals_comparison[x%(n/10 + 1)] &= a[x];\n    }\n    for (int x = 0; x < (n/10 + 1); ++x){\n        if (totals_comparison[x] != totals[x]){\n            err += 1;\n            break;\n        }\n    }\n\n    for (int x = 0; x < 8; ++x){\n        init += 1<<x;\n    }\n    for (int x = 0; x < (n/10 + 1); ++x){\n        for (iterator = x, iterator2 = 0; iterator < n; iterator += n/10 + 1, iterator2++){\n            temp_a[iterator2] = a[iterator];\n            temp_b[iterator2] = b[iterator];\n        }\n        if (!is_possible(temp_a, temp_b, iterator2, init)){\n            err += 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "atomic",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_capture_bitor_equals.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:atomic,construct-independent,V:2.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    int *a = (int *)malloc(n * sizeof(int));\n    int *b = (int *)malloc(n * sizeof(int));\n    int *totals = (int *)malloc((n/10 + 1) * sizeof(int));\n    int *totals_comparison = (int *)malloc((n/10 + 1) * sizeof(int));\n    int *temp_a = (int *)malloc(10 * sizeof(int));\n    int *temp_b = (int *)malloc(10 * sizeof(int));\n    int temp_indexer = 0;\n    int absolute_indexer = 0;\n\n    for (int x = 0; x < n; ++x){\n        for (int y = 0; y < 8; ++y){\n            if (rand()/(real_t)(RAND_MAX) > .933){ //.933 gets close to a 50/50 distribution for a collescence of 10 values\n                a[x] += 1<<y;\n            }\n        }\n    }\n    for (int x = 0; x < n/10 + 1; ++x){\n        totals[x] = 0;\n        totals_comparison[x] = 0;\n    }\n    for (int x = 0; x < n; ++x){\n        b[x] = 0;\n    }\n\n    #pragma acc data copyin(a[0:n]) copy(totals[0:n/10 + 1]) copyout(b[0:n])\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                #pragma acc atomic capture\n                    b[x] = totals[x%(n/10 + 1)] |= a[x];\n            }\n        }\n    }\n    for (int x = 0; x < n; ++x){\n        totals_comparison[x%(n/10 + 1)] |= a[x];\n    }\n    for (int x = 0; x < 10; ++x){\n        if (fabs(totals_comparison[x] - totals[x]) > PRECISION){\n            err += 1;\n            break;\n        }\n    }\n\n    for (int x = 0; x < (n/10 + 1); ++x){\n        for (absolute_indexer = x, temp_indexer = 0; absolute_indexer < n; absolute_indexer += n/10 + 1, temp_indexer++){\n            temp_a[temp_indexer] = a[absolute_indexer];\n            temp_b[temp_indexer] = b[absolute_indexer];\n        }\n        if (!(is_possible(temp_a, temp_b, temp_indexer, 0))){\n            err += 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "atomic",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_capture_bitxor_equals.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:atomic,construct-independent,V:2.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    int *a = (int *)malloc(n * sizeof(int));\n    int *b = (int *)malloc(n * sizeof(int));\n    int *totals = (int *)malloc((n/10 + 1) * sizeof(int));\n    int *totals_comparison = (int *)malloc((n/10 + 1) * sizeof(int));\n    int * temp_a = (int *)malloc(10 * sizeof(int));\n    int * temp_b = (int *)malloc(10 * sizeof(int));\n    int temp_iterator;\n    int ab_iterator;\n\n    for (int x = 0; x < n; ++x){\n        for (int y = 0; y < 8; ++y){\n            if (rand()/(real_t)(RAND_MAX) > .5){\n                a[x] += 1<<y;\n            }\n        }\n    }\n    for (int x = 0; x < n/10 + 1; ++x){\n        totals[x] = 0;\n        totals_comparison[x] = 0;\n    }\n\n    #pragma acc data copyin(a[0:n]) copy(totals[0:n/10 + 1]) copyout(b[0:n])\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                #pragma acc atomic capture\n                    b[x] = totals[x%(n/10 + 1)] ^= a[x];\n            }\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        totals_comparison[x%(n/10 + 1)] ^= a[x];\n    }\n    for (int x = 0; x < 10; ++x){\n        if (fabs(totals_comparison[x] - totals[x]) > PRECISION){\n            err += 1;\n            break;\n        }\n    }\n\n    for (int x = 0; x < n/10 + 1; ++x){\n        for (temp_iterator = 0, ab_iterator = x; ab_iterator < n; temp_iterator++, ab_iterator += n/10 + 1){\n            temp_a[temp_iterator] = a[ab_iterator];\n            temp_b[temp_iterator] = b[ab_iterator];\n        }\n        if (!(is_possible(temp_a, temp_b, temp_iterator, 0))){\n            err++;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "atomic",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_capture_divided_equals.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:atomic,construct-independent,V:2.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t *a = (real_t *)malloc(n * sizeof(real_t));\n    real_t *b = (real_t *)malloc(n * sizeof(real_t));\n    real_t *c = (real_t *)malloc(n * sizeof(real_t));\n    real_t *totals = (real_t *)malloc((n/10 + 1) * sizeof(real_t));\n    real_t *totals_comparison = (real_t *)malloc((n/10 + 1) * sizeof(real_t));\n    real_t *temp_a = (real_t *)malloc(10 * sizeof(real_t));\n    real_t *temp_b = (real_t *)malloc(10 * sizeof(real_t));\n    real_t *temp_c = (real_t *)malloc(10 * sizeof(real_t));\n    int temp_iterator;\n    int ab_iterator;\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n        c[x] = 0;\n    }\n    for (int x = 0; x < n/10 + 1; ++x){\n        totals[x] = 1;\n        totals_comparison[x] = 1;\n    }\n\n    #pragma acc data copyin(a[0:n], b[0:n]) copy(totals[0:n/10 + 1]) copyout(c[0:n])\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                #pragma acc atomic capture\n                    c[x] = totals[x%(n/10 + 1)] /= (a[x] + b[x]);\n            }\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        totals_comparison[x%(n/10 + 1)] /= a[x] + b[x];\n    }\n    for (int x = 0; x < 10; ++x){\n        if (fabs(totals_comparison[x] - totals[x]) > PRECISION){\n            err += 1;\n            break;\n        }\n    }\n\n    for (int x = 0; x < (n/10 + 1); ++x){\n        temp_iterator = 0;\n        for (ab_iterator = x; ab_iterator < n;  ab_iterator+=((n/10) + 1)){\n            temp_a[temp_iterator] = a[ab_iterator];\n            temp_b[temp_iterator] = b[ab_iterator];\n            temp_c[temp_iterator] = c[ab_iterator];\n            temp_iterator++;\n        }\n        if (!(is_possible(temp_a, temp_b, temp_c, temp_iterator, 1))){\n            err++;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "atomic",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_capture_expr_and_x_assign.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:construct-independent,atomic,V:2.0-2.7\n      LOGICAL FUNCTION test1()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x, y !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT, 10):: randoms\n        LOGICAL,DIMENSION(LOOPCOUNT, 10):: a !Data\n        LOGICAL,DIMENSION(LOOPCOUNT, 10):: b\n        LOGICAL IS_POSSIBLE\n        LOGICAL,DIMENSION(LOOPCOUNT):: totals, totals_comparison\n        INTEGER :: errors = 0\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(randoms)\n        DO x = 1, LOOPCOUNT\n          DO y = 1, 10\n            IF (randoms(x, y) < .933) THEN\n              a(x, y) = .TRUE.\n            ELSE\n              a(x, y) = .FALSE.\n            END IF\n          END DO\n        END DO\n\n        totals = .FALSE.\n        totals_comparison = .FALSE.\n\n        !$acc data copyin(a(1:LOOPCOUNT,1:10)) copy(totals(1:LOOPCOUNT)) copyout(b(1:LOOPCOUNT,1:10))\n          !$acc parallel\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              DO y = 1, 10\n                !$acc atomic capture\n                  totals(x) = a(x, y) .AND. totals(x)\n                  b(x, y) = totals(x)\n                !$acc end atomic\n              END DO\n            END DO\n          !$acc end parallel\n        !$acc end data\n\n        DO x = 1, LOOPCOUNT\n          DO y = 1, 10\n            totals_comparison(x) = totals_comparison(x) .AND. a(x, y)\n          END DO\n        END DO\n\n        DO x = 1, LOOPCOUNT\n          IF (totals_comparison(x) .NEQV. totals(x)) THEN\n            errors = errors + 1\n            WRITE(*, *) totals_comparison(x)\n          END IF\n        END DO\n\n        DO x = 1, LOOPCOUNT\n          IF (.FALSE. .eqv. IS_POSSIBLE(a(x, 1:10), b(x, 1:10), 10, .FALSE.)) THEN\n            errors = errors + 1\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "construct-independent",
                            "atomic"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_capture_expr_bitand_x.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:atomic,construct-independent,V:2.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    int *a = (int *)malloc(n * sizeof(int));\n    int *b = (int *)malloc(n * sizeof(int));\n    int *totals = (int *)malloc((n/10 + 1) * sizeof(int));\n    int *totals_comparison = (int *)malloc((n/10 + 1) * sizeof(int));\n    int *passed_a = (int *)malloc(10 * sizeof(int));\n    int *passed_b = (int *)malloc(10 * sizeof(int));\n    int passed_total = 0;\n    int absolute_indexer;\n    int passed_indexer;\n\n    for (int x = 0; x < n; ++x){\n        for (int y = 0; y < 8; ++y){\n            if (rand()/(real_t)(RAND_MAX) < .933){ //.933 gets close to a 50/50 distribution for a collescence of 10 values\n                a[x] += 1<<y;\n            }\n        }\n    }\n    for (int x = 0; x < n/10 + 1; ++x){\n        for (int y = 0; y < 8; ++y){\n            totals[x] +=  1<<y;\n            totals_comparison[x] += 1<<y;\n        }\n    }\n\n    #pragma acc data copyin(a[0:n]) copy(totals[0:n/10 + 1]) copyout(b[0:n])\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                #pragma acc atomic capture\n                     b[x] = totals[x%(n/10 + 1)] = a[x] & totals[x%(n/10 + 1)];\n            }\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        totals_comparison[x%(n/10 + 1)] &= a[x];\n    }\n\n    for (int x = 0; x < 10; ++x){\n        if (fabs(totals_comparison[x] - totals[x]) > PRECISION){\n            err += 1;\n            break;\n        }\n    }\n\n    for (int x = 0; x < 8; ++x){\n        passed_total += 1<<x;\n    }\n    for (int x = 0; x < (n/10 + 1); ++x){\n        for (absolute_indexer = x, passed_indexer = 0; absolute_indexer < n; absolute_indexer += (n/10 + 1), passed_indexer++){\n            passed_a[passed_indexer] = a[absolute_indexer];\n            passed_b[passed_indexer] = b[absolute_indexer];\n        }\n        if (!is_possible(passed_a, passed_b, passed_indexer - 1, passed_total)){\n            err += 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "atomic",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_capture_expr_bitor_x.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:atomic,construct-independent,V:2.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    int *a = (int *)malloc(n * sizeof(int));\n    int *b = (int *)malloc(n * sizeof(int));\n    int *totals = (int *)malloc((n/10 + 1) * sizeof(int));\n    int *totals_comparison = (int *)malloc((n/10 + 1) * sizeof(int));\n    int *passed_a = (int *)malloc(10 * sizeof(int));\n    int *passed_b = (int *)malloc(10 * sizeof(int));\n    int passed_indexer;\n    int absolute_indexer;\n\n    for (int x = 0; x < n; ++x){\n        for (int y = 0; y < 8; ++y){\n            if (rand()/(real_t)(RAND_MAX) > .933){ //.933 gets close to a 50/50 distribution for a collescence of 10 values\n                a[x] += 1<<y;\n            }\n        }\n    }\n    for (int x = 0; x < n/10 + 1; ++x){\n        totals[x] = 0;\n\n    }\n\n    #pragma acc data copyin(a[0:n]) copy(totals[0:n/10 + 1])\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                #pragma acc atomic capture\n                    b[x] = totals[x%(n/10 + 1)] = totals[x%(n/10 + 1)] | a[x];\n            }\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        totals_comparison[x%(n/10 + 1)] |= a[x];\n    }\n    for (int x = 0; x < 10; ++x){\n        if (fabs(totals_comparison[x] - totals[x]) > PRECISION){\n            err += 1;\n            break;\n        }\n    }\n    for (int x = 0; x < (n/10 + 1); ++x){\n        for (passed_indexer = 0, absolute_indexer = x; absolute_indexer < n; passed_indexer++, absolute_indexer += n/10 + 1){\n            passed_a[passed_indexer] = a[absolute_indexer];\n            passed_b[passed_indexer] = b[absolute_indexer];\n        }\n        if (!is_possible(passed_a, passed_b, passed_indexer - 1, 0)){\n            err++;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "atomic",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_capture_expr_bitxor_x.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:atomic,construct-independent,V:2.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    int *a = (int *)malloc(n * sizeof(int));\n    int *b = (int *)malloc(n * sizeof(int));\n    int *totals = (int *)malloc((n/10 + 1) * sizeof(int));\n    int *totals_comparison = (int *)malloc((n/10 + 1) * sizeof(int));\n    int *passed_a = (int *)malloc(10 * sizeof(int));\n    int *passed_b = (int *)malloc(10 * sizeof(int));\n    int passed_indexer;\n    int absolute_indexer;\n\n    for (int x = 0; x < n; ++x){\n        for (int y = 0; y < 8; ++y){\n            if (rand()/(real_t)(RAND_MAX) > .5){\n                a[x] += 1<<y;\n            }\n        }\n    }\n    for (int x = 0; x < n/10 + 1; ++x){\n        totals[x] = 0;\n        totals_comparison[x] = 0;\n    }\n\n    #pragma acc data copyin(a[0:n]) copy(totals[0:n/10 + 1]) copyout(b[0:n])\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                #pragma acc atomic capture\n                    b[x] = totals[x%(n/10 + 1)] = a[x] ^ totals[x%(n/10 + 1)];\n            }\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        totals_comparison[x%(n/10 + 1)] ^= a[x];\n    }\n    for (int x = 0; x < 10; ++x){\n        if (fabs(totals_comparison[x] - totals[x]) > PRECISION){\n            err += 1;\n            break;\n        }\n    }\n\n    for (int x = 0; x < n/10 + 1; ++x){\n        for (passed_indexer = 0, absolute_indexer = x; absolute_indexer < n; passed_indexer++, absolute_indexer += n/10 + 1){\n            passed_a[passed_indexer] = a[absolute_indexer];\n            passed_b[passed_indexer] = b[absolute_indexer];\n        }\n        if (!(is_possible(passed_a, passed_b, passed_indexer - 1, 0))){\n            err++;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "atomic",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_capture_expr_divided_x.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:atomic,construct-independent,V:2.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t *a = (real_t *)malloc(n * sizeof(real_t));\n    real_t *b = (real_t *)malloc(n * sizeof(real_t));\n    real_t *c = (real_t *)malloc(n * sizeof(real_t));\n    real_t *totals = (real_t *)malloc((n/10 + 1) * sizeof(real_t));\n    real_t *passed_ab = (real_t *)malloc(10 * sizeof(real_t));\n    real_t *passed_c = (real_t *)malloc(10 * sizeof(real_t));\n    int passed_indexer;\n    int absolute_indexer;\n    real_t * passed = (real_t *)malloc(10 * sizeof(real_t));\n    int indexer;\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n    }\n    for (int x = 0; x < n/10 + 1; ++x){\n        totals[x] = 1;\n    }\n\n    #pragma acc data copyin(a[0:n], b[0:n]) copy(totals[0:n/10 + 1]) copyout(c[0:n])\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                #pragma acc atomic capture\n                    c[x] = totals[x%(n/10 + 1)] = (a[x] + b[x]) / totals[x%(n/10 + 1)];\n            }\n        }\n    }\n\n\n    for (int x = 0; x < (n/10 + 1); ++x){\n        indexer = x;\n        while (indexer < n){\n            passed[indexer/(n/10 + 1)] = (a[x] + b[x]);\n            indexer += (n/10 + 1);\n        }\n        if (!(possible_result(passed, 10, 1, totals[x]))){\n            err += 1;\n        }\n    }\n\n    for (int x = 0; x < (n/10 + 1); ++x){\n        for (passed_indexer = 0, absolute_indexer = x; absolute_indexer < n; passed_indexer++, absolute_indexer += n/10 + 1){\n            passed_ab[passed_indexer] = a[absolute_indexer] + b[absolute_indexer];\n            passed_c[passed_indexer] = c[absolute_indexer];\n        }\n        if (!is_possible(passed_ab, passed_c, passed_indexer - 1, 1)){\n            err++;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "atomic",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_capture_expr_divided_x_assign.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:construct-independent,atomic,V:2.0-2.7\n      LOGICAL FUNCTION test1()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x, y !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT, 10):: a !Data\n        REAL(8),DIMENSION(LOOPCOUNT, 10):: b\n        REAL(8),DIMENSION(LOOPCOUNT):: totals\n        REAL(8),DIMENSION(10):: passed\n        REAL(8),DIMENSION(10):: passed_b\n        REAL(8) :: holder\n        INTEGER :: errors = 0\n        LOGICAL IS_POSSIBLE\n        LOGICAL IS_POSSIBLE_2\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(a)\n\n        totals = 1\n\n        !$acc data copyin(a(1:LOOPCOUNT, 1:10)) copy(totals(1:LOOPCOUNT)) copyout(b(1:LOOPCOUNT,1:10))\n          !$acc parallel\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              DO y = 1, 10\n                !$acc atomic capture\n                  totals(x) = a(x, y) / totals(x)\n                  b(x, y) = totals(x)\n                !$acc end atomic\n              END DO\n            END DO\n          !$acc end parallel\n        !$acc end data\n\n        DO x = 1, LOOPCOUNT\n          DO y = 1, 10\n            passed(y) = a(x, y)\n          END DO\n          holder = 1\n          IF (IS_POSSIBLE(passed, totals(x), 10, holder) .eqv. .FALSE.) THEN\n            errors = errors + 1\n          END IF\n        END DO\n\n        DO x = 1, LOOPCOUNT\n          DO y = 1, 10\n            passed(y) = a(x, y)\n            passed_b(y) = b(x, y)\n          END DO\n          holder = 1\n          IF (IS_POSSIBLE_2(passed, passed_b, 10, holder) .eqv. .FALSE.) THEN\n            errors = errors + 1\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "construct-independent",
                            "atomic"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_capture_expr_eqv_x_assign.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:construct-independent,atomic,V:2.0-2.7\n      LOGICAL FUNCTION test1()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x, y !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT, 10):: randoms\n        LOGICAL,DIMENSION(LOOPCOUNT, 10):: a, b !Data\n        LOGICAL,DIMENSION(LOOPCOUNT):: totals, totals_comparison\n        LOGICAL,DIMENSION(10):: passed_a, passed_b\n        LOGICAL:: init\n        INTEGER :: errors = 0\n        LOGICAL IS_POSSIBLE\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(randoms)\n        DO x = 1, LOOPCOUNT\n          DO y = 1, 10\n            IF (randoms(x, y) > .5) THEN\n              a(x, y) = .TRUE.\n            ELSE\n              a(x, y) = .FALSE.\n            END IF\n          END DO\n        END DO\n\n        totals = .FALSE.\n        totals_comparison = .FALSE.\n\n        !$acc data copyin(a(1:LOOPCOUNT,1:10)) copy(totals(1:LOOPCOUNT)) copyout(b(1:LOOPCOUNT,1:10))\n          !$acc parallel\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              DO y = 1, 10\n                !$acc atomic capture\n                  totals(x) = a(x, y) .EQV. totals(x)\n                  b(x, y) = totals(x)\n                !$acc end atomic\n              END DO\n            END DO\n          !$acc end parallel\n        !$acc end data\n\n        DO x = 1, LOOPCOUNT\n          DO y = 1, 10\n            totals_comparison(x) = totals_comparison(x) .EQV. a(x, y)\n          END DO\n        END DO\n\n        DO x = 1, LOOPCOUNT\n          DO y = 1, 10\n            passed_a(y) = a(x, y)\n            passed_b(y) = b(x, y)\n          END DO\n          init = .FALSE.\n          IF (IS_POSSIBLE(passed_a, passed_b, 10, init) .EQV. .FALSE.) THEN\n            errors = errors + 1\n          END IF\n        END DO\n\n        DO x = 1, LOOPCOUNT\n          IF (totals_comparison(x) .NEQV. totals(x)) THEN\n            errors = errors + 1\n            WRITE(*, *) totals_comparison(x)\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "construct-independent",
                            "atomic"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_capture_expr_lshift_x.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:atomic,construct-independent,V:2.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    unsigned int *a = (unsigned int *)malloc(3 * n * sizeof(int));\n    unsigned int *b = (unsigned int *)malloc(n * sizeof(int));\n    unsigned int *c = (unsigned int *)malloc(3 * n * sizeof(int));\n    int orders[18] = {1, 2, 0, 1, 0, 2, 2, 1, 0, 2, 0, 1, 0, 1, 2, 0, 2, 1};\n    int result;\n\n    for (int x = 0; x < n; ++x){\n        for (int y = 0; y < 3; ++y){\n            a[x * 3 + y] = (int) (rand() / (unsigned int) (RAND_MAX / 4));\n        }\n        b[x] = 0;\n    }\n\n    #pragma acc data copyin(a[0:3 * n]) copy(b[0:n]) copyout(c[0:3*n])\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                #pragma acc loop\n                for (int y = 0; y < 3; ++y){\n                    #pragma acc atomic capture\n                        c[x * 3 + y] = b[x] = a[x * 3 + y] << b[x];\n                }\n            }\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        for (int y = 0; y < 6; ++y){\n            result = 0;\n            for (int z = 0; z < 3; ++z){\n                result = a[x * 3 + orders[y * 3 + z]] << result;\n            }\n            if (result == b[x]){\n                break;\n            }\n        }\n        if (result != b[x]){\n            err += 1;\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        if (!(is_possible(&(a[x*3]), &(c[x*3]), 3, 0))){\n            err += 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "atomic",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_capture_expr_minus_x.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:atomic,construct-independent,V:2.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t *a = (real_t *)malloc(n * sizeof(real_t));\n    real_t *b = (real_t *)malloc(n * sizeof(real_t));\n    real_t *totals = (real_t *)malloc(((n/10) + 1) * sizeof(real_t));\n    int indexer = 0;\n    real_t * passed = (real_t *)malloc(10 * sizeof(real_t));\n    real_t *passed_a = (real_t *)malloc(10 * sizeof(real_t));\n    real_t *passed_b = (real_t *)malloc(10 * sizeof(real_t));\n    int passed_indexer;\n    int absolute_indexer;\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n    }\n    for (int x = 0; x < (n/10) + 1; ++x){\n        totals[x] = 0;\n    }\n\n    #pragma acc data copyin(a[0:n]) copy(totals[0:(n/10) + 1]) copyout(b[0:n])\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                #pragma acc atomic capture\n                    b[x] = totals[x%((int) (n/10) + 1)] = a[x] - totals[x%((int) (n/10) + 1)];\n            }\n        }\n    }\n    for (int x = 0; x < (n/10) + 1; ++x){\n        indexer = x;\n        while (indexer < n){\n            passed[indexer/((int) (n/10) + 1)] = a[indexer];\n            indexer += (n/10) + 1;\n        }\n        if (!(possible_result(passed, 10, 0, totals[x]))){\n            err += 1;\n        }\n    }\n\n    for (int x = 0; x < n/10 + 1; ++x){\n        for (passed_indexer = 0, absolute_indexer = x; absolute_indexer < n; passed_indexer++, absolute_indexer += n/10 + 1){\n            passed_a[passed_indexer] = a[absolute_indexer];\n            passed_b[passed_indexer] = b[absolute_indexer];\n        }\n        if (!is_possible(passed_a, passed_b, passed_indexer - 1, 0)){\n            err += 1;\n        }\n        break;\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "atomic",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_capture_expr_minus_x_assign.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:construct-independent,atomic,V:2.0-2.7\n      LOGICAL FUNCTION test1()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x, y !Iterators\n        LOGICAL IS_POSSIBLE\n        LOGICAL IS_POSSIBLE_2\n        REAL(8),DIMENSION(LOOPCOUNT, 10):: a, b !Data\n        REAL(8),DIMENSION(LOOPCOUNT):: totals\n        REAL(8),DIMENSION(10):: passed_a, passed_b\n        REAL(8):: init\n        INTEGER :: errors = 0\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(a)\n\n        totals = 0\n\n        !$acc data copyin(a(1:LOOPCOUNT, 1:10)) copy(totals(1:LOOPCOUNT)) copyout(b(1:LOOPCOUNT, 1:10))\n          !$acc parallel\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              DO y = 1, 10\n                !$acc atomic capture\n                  totals(x) = a(x, y) - totals(x)\n                  b(x, y) = totals(x)\n                !$acc end atomic\n              END DO\n            END DO\n          !$acc end parallel\n        !$acc end data\n\n        DO x = 1, LOOPCOUNT\n          DO y = 1, 10\n            passed_a(y) = a(x, y)\n          END DO\n          IF (IS_POSSIBLE(passed_a, totals(x), 10, 0) .eqv. .FALSE.) THEN\n            errors = errors + 1\n          END IF\n        END DO\n\n        DO x = 1, LOOPCOUNT\n          DO y = 1, 10\n            passed_a(y) = a(x, y)\n            passed_b(y) = b(x, y)\n          END DO\n          init = 0\n          IF (IS_POSSIBLE_2(passed_a, passed_b, 10, init) .EQV. .FALSE.) THEN\n            errors = errors + 1\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "construct-independent",
                            "atomic"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_capture_expr_multiply_x.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:atomic,construct-independent,V:2.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t *a = (real_t *)malloc(n * sizeof(real_t));\n    real_t *b = (real_t *)malloc(n * sizeof(real_t));\n    real_t *c = (real_t *)malloc(n * sizeof(real_t));\n    real_t *totals = (real_t *)malloc((n/10 + 1) * sizeof(real_t));\n    real_t *totals_comparison = (real_t *)malloc((n/10 + 1) * sizeof(real_t));\n    real_t *passed_ab = (real_t *)malloc(10 * sizeof(real_t));\n    real_t *passed_c = (real_t *)malloc(10 * sizeof(real_t));\n    int passed_indexer;\n    int absolute_indexer;\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n    }\n    for (int x = 0; x < n/10 + 1; ++x){\n        totals[x] = 1;\n        totals_comparison[x] = 1;\n    }\n\n    #pragma acc data copyin(a[0:n], b[0:n]) copy(totals[0:n/10 + 1]) copyout(c[0:n])\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                #pragma acc atomic capture\n                    c[x] = totals[x%(n/10 + 1)] = (a[x] + b[x]) * totals[x%(n/10 + 1)];\n            }\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        totals_comparison[x%(n/10 + 1)] *= a[x] + b[x];\n    }\n    for (int x = 0; x < 10; ++x){\n        if (fabs(totals_comparison[x] - totals[x]) > PRECISION * totals_comparison[x]){\n            err += 1;\n            break;\n        }\n    }\n\n    for (int x = 0; x < n/10 + 1; ++x){\n        for (passed_indexer = 0, absolute_indexer = x; absolute_indexer < n; passed_indexer++, absolute_indexer += n/10 + 1){\n            passed_ab[passed_indexer] = a[absolute_indexer] + b[absolute_indexer];\n            passed_c[passed_indexer] = c[absolute_indexer];\n        }\n        if (!is_possible(passed_ab, passed_c, passed_indexer - 1, 1)){\n            err++;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "atomic",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_capture_expr_neqv_x_assign.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:construct-independent,atomic,V:2.0-2.7\n      LOGICAL FUNCTION test1()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x, y !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT, 10):: randoms\n        LOGICAL,DIMENSION(LOOPCOUNT, 10):: a, b !Data\n        LOGICAL,DIMENSION(10):: passed_a, passed_b\n        LOGICAL,DIMENSION(LOOPCOUNT):: totals, totals_comparison\n        LOGICAL IS_POSSIBLE\n        INTEGER :: errors = 0\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(randoms)\n        DO x = 1, LOOPCOUNT\n          DO y = 1, 10\n            IF (randoms(x, y) > .5) THEN\n              a(x, y) = .TRUE.\n            ELSE\n              a(x, y) = .FALSE.\n            END IF\n          END DO\n        END DO\n\n        totals = .FALSE.\n        totals_comparison = .FALSE.\n\n        !$acc data copyin(a(1:LOOPCOUNT,1:10)) copy(totals(1:LOOPCOUNT)) copyout(b(1:LOOPCOUNT,1:10))\n          !$acc parallel\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              DO y = 1, 10\n                !$acc atomic capture\n                  totals(x) = a(x, y) .NEQV. totals(x)\n                  b(x, y) = totals(x)\n                !$acc end atomic\n              END DO\n            END DO\n          !$acc end parallel\n        !$acc end data\n\n        DO x = 1, LOOPCOUNT\n          DO y = 1, 10\n            totals_comparison(x) = totals_comparison(x) .NEQV. a(x, y)\n          END DO\n        END DO\n\n        DO x = 1, LOOPCOUNT\n          IF (totals_comparison(x) .NEQV. totals(x)) THEN\n            errors = errors + 1\n            WRITE(*, *) totals_comparison(x)\n          END IF\n        END DO\n\n        DO x = 1, LOOPCOUNT\n          DO y = 1, 10\n            passed_a(y) = a(x, y)\n            passed_b(y) = b(x, y)\n          END DO\n          IF (IS_POSSIBLE(passed_a, passed_b, 10, .FALSE.) .eqv. .FALSE.) THEN\n            errors = errors + 1\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "construct-independent",
                            "atomic"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_capture_expr_or_x_assign.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:construct-independent,atomic,V:2.0-2.7\n      LOGICAL FUNCTION test1()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x, y !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT, 10):: randoms\n        LOGICAL,DIMENSION(LOOPCOUNT, 10):: a, b !Data\n        LOGICAL,DIMENSION(LOOPCOUNT):: totals, totals_comparison\n        LOGICAL,DIMENSION(10):: passed_a, passed_b\n        LOGICAL IS_POSSIBLE\n        LOGICAL:: init\n        INTEGER :: errors = 0\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(randoms)\n        DO x = 1, LOOPCOUNT\n          DO y = 1, 10\n            IF (randoms(x, y) > .933) THEN\n              a(x, y) = .TRUE.\n            ELSE\n              a(x, y) = .FALSE.\n            END IF\n          END DO\n        END DO\n\n        totals = .FALSE.\n        totals_comparison = .FALSE.\n\n        !$acc data copyin(a(1:LOOPCOUNT,1:10)) copy(totals(1:LOOPCOUNT)) copyout(b(1:LOOPCOUNT,1:10))\n          !$acc parallel\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              DO y = 1, 10\n                !$acc atomic capture\n                  totals(x) = a(x, y) .OR. totals(x)\n                  b(x, y) = totals(x)\n                !$acc end atomic\n              END DO\n            END DO\n          !$acc end parallel\n        !$acc end data\n\n        DO x = 1, LOOPCOUNT\n          DO y = 1, 10\n            totals_comparison(x) = totals_comparison(x) .OR. a(x, y)\n          END DO\n        END DO\n\n        DO x = 1, LOOPCOUNT\n          IF (totals_comparison(x) .NEQV. totals(x)) THEN\n            errors = errors + 1\n            WRITE(*, *) totals_comparison(x)\n          END IF\n        END DO\n\n        DO x = 1, LOOPCOUNT\n          DO y = 1, 10\n            passed_a(y) = a(x, y)\n            passed_b(y) = b(x, y)\n          END DO\n          init = .FALSE.\n          IF (IS_POSSIBLE(passed_a, passed_b, 10, init) .eqv. .FALSE.) THEN\n            errors = errors + 1\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "construct-independent",
                            "atomic"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_capture_expr_plus_x.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:atomic,construct-independent,V:2.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t *a = (real_t *)malloc(n * sizeof(real_t));\n    real_t *b = (real_t *)malloc(n * sizeof(real_t));\n    real_t *c = (real_t *)malloc(n * sizeof(real_t));\n    real_t *totals = (real_t *)malloc((int)(n/10 + 1) * sizeof(real_t));\n    real_t *totals_comparison = (real_t *)malloc((int)(n/10 + 1) * sizeof(real_t));\n    real_t *passed_ab = (real_t *)malloc(10 * sizeof(real_t));\n    real_t *passed_c = (real_t *)malloc(10 * sizeof(real_t));\n    int passed_indexer;\n    int absolute_indexer;\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n    }\n    for (int x = 0; x < n/10 + 1; ++x){\n        totals[x] = 0;\n        totals_comparison[x] = 0;\n    }\n\n    #pragma acc data copyin(a[0:n], b[0:n]) copy(totals[0:10]) copyout(c[0:n])\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                #pragma acc atomic capture\n                    c[x] = totals[x%((int)(n/10 + 1))] = (a[x] + b[x]) + totals[x%((int) n/10 + 1)];\n            }\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        totals_comparison[x%((int)(n/10 + 1))] += (a[x] + b[x]);\n    }\n    for (int x = 0; x < 10; ++x){\n        if (fabs(totals_comparison[x] - totals[x]) > PRECISION){\n            err += 1;\n            break;\n        }\n    }\n\n    for (int x = 0; x < n/10 + 1; ++x){\n        for (passed_indexer = 0, absolute_indexer = x; absolute_indexer < n; passed_indexer++, absolute_indexer += n/10 + 1){\n            passed_ab[passed_indexer] = a[absolute_indexer] + b[absolute_indexer];\n            passed_c[passed_indexer] = c[absolute_indexer];\n        }\n        if (!is_possible(passed_ab, passed_c, passed_indexer - 1, 0)){\n            err++;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "atomic",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_capture_expr_plus_x_assign.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:construct-independent,atomic,V:2.0-2.7\n      LOGICAL FUNCTION test1()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x, y !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT, 10):: a, b !Data\n        REAL(8),DIMENSION(LOOPCOUNT):: totals, totals_comparison\n        REAL(8),DIMENSION(10):: passed_a, passed_b\n        REAL(8):: init\n        LOGICAL IS_POSSIBLE\n        INTEGER :: errors = 0\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(a)\n\n        totals = 0\n        totals_comparison = 0\n\n        !$acc data copyin(a(1:LOOPCOUNT, 1:10)) copy(totals(1:LOOPCOUNT)) copyout(b(1:LOOPCOUNT,1:10))\n          !$acc parallel\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              DO y = 1, 10\n                !$acc atomic capture\n                  totals(x) = a(x, y) + totals(x)\n                  b(x, y) = totals(x)\n                !$acc end atomic\n              END DO\n            END DO\n          !$acc end parallel\n        !$acc end data\n        DO x = 1, LOOPCOUNT\n          DO y = 1, 10\n            totals_comparison(x) = totals_comparison(x) + a(x, y)\n          END DO\n        END DO\n\n        DO x = 1, LOOPCOUNT\n          IF (totals_comparison(x) .NE. totals(x)) THEN\n            errors = errors + 1\n            WRITE(*, *) totals_comparison(x)\n          END IF\n        END DO\n\n        DO x = 1, LOOPCOUNT\n          DO y = 1, 10\n            passed_a(y) = a(x, y)\n            passed_b(y) = b(x, y)\n          END DO\n          init = 0\n          IF (IS_POSSIBLE(passed_a, passed_b, 10, init) .eqv. .FALSE.) THEN\n            errors = errors + 1\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "construct-independent",
                            "atomic"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_capture_expr_rshift_x.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:atomic,construct-independent,V:2.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    unsigned int *a = (unsigned int *)malloc(3 * n * sizeof(int));\n    unsigned int *b = (unsigned int *)malloc(n * sizeof(int));\n    unsigned int *c = (unsigned int *)malloc(3 * n * sizeof(int));\n    int orders[18] = {1, 2, 0, 1, 0, 2, 2, 1, 0, 2, 0, 1, 0, 1, 2, 0, 2, 1};\n    int result;\n\n    for (int x = 0; x < n; ++x){\n        for (int y = 0; y < 3; ++y){\n            a[x * 3 + y] = (int) (rand() / (unsigned int) (RAND_MAX / 4));\n        }\n        b[x] = 0;\n    }\n\n    #pragma acc data copyin(a[0:3 * n]) copy(b[0:n]) copyout(c[0:3*n])\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                #pragma acc loop independent\n                for (int y = 0; y < 3; ++y){\n                    #pragma acc atomic capture\n                        c[x * 3 + y] = b[x] = a[x * 3 + y] >> b[x];\n                }\n            }\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        for (int y = 0; y < 6; ++y){\n            result = 0;\n            for (int z = 0; z < 3; ++z){\n                result = a[x * 3 + orders[y * 3 + z]] >> result;\n            }\n            if (result == b[x]){\n                break;\n            }\n        }\n        if (result != b[x]){\n            err += 1;\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        if (!is_possible(&(a[3*x]), &(c[3*x]), 3, 0)){\n            err += 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "atomic",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_capture_expr_times_x_assign.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:construct-independent,atomic,V:2.0-2.7\n      LOGICAL FUNCTION test1()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x, y !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT, 10):: a, b !Data\n        REAL(8),DIMENSION(LOOPCOUNT):: totals, totals_comparison\n        REAL(8),DIMENSION(10):: passed_a, passed_b\n        REAL(8):: init\n        LOGICAL IS_POSSIBLE\n        INTEGER :: errors = 0\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(a)\n\n        totals = 1\n        totals_comparison = 1\n\n        !$acc data copyin(a(1:LOOPCOUNT, 1:10)) copy(totals(1:LOOPCOUNT)) copyout(b(1:LOOPCOUNT,1:10))\n          !$acc parallel\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              DO y = 1, 10\n                !$acc atomic capture\n                  totals(x) = a(x, y) * totals(x)\n                  b(x, y) = totals(x)\n                !$acc end atomic\n              END DO\n            END DO\n          !$acc end parallel\n        !$acc end data\n        DO x = 1, LOOPCOUNT\n          DO y = 1, 10\n            totals_comparison(x) = totals_comparison(x) * a(x, y)\n          END DO\n        END DO\n\n        DO x = 1, LOOPCOUNT\n          IF (totals_comparison(x) .NE. totals(x)) THEN\n            errors = errors + 1\n            WRITE(*, *) totals_comparison(x)\n          END IF\n        END DO\n\n        DO x = 1, LOOPCOUNT\n          DO y = 1, 10\n            passed_a(y) = a(x, y)\n            passed_b(y) = b(x, y)\n          END DO\n          init = 1\n          IF (IS_POSSIBLE(passed_a, passed_b, 10, init) .eqv. .TRUE.) THEN\n            errors = errors + 1\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "construct-independent",
                            "atomic"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_capture_iand_expr_x_assign.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:construct-independent,atomic,V:2.0-2.7\n      LOGICAL FUNCTION test1()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x, y, z !Iterators\n        INTEGER,DIMENSION(LOOPCOUNT, 10):: a, b !Data\n        REAL(8),DIMENSION(LOOPCOUNT, 10, 8):: randoms\n        INTEGER,DIMENSION(LOOPCOUNT):: totals, totals_comparison\n        INTEGER,DIMENSION(10):: passed_a, passed_b\n        INTEGER:: init\n        LOGICAL IS_POSSIBLE\n        INTEGER :: errors = 0\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(randoms)\n        a = 0\n        DO x = 1, LOOPCOUNT\n          DO y = 1, 10\n            DO z = 1, 8\n              IF (randoms(x, y, z) .lt. .933) THEN\n                a(x, y) = a(x, y) + ISHFT(1, z - 1)\n              END IF\n            END DO\n          END DO\n        END DO\n        totals = 0\n        totals_comparison = 0\n        DO x = 1, LOOPCOUNT\n          DO y = 0, 7\n            totals(x) = totals(x) + ISHFT(1, y)\n            totals_comparison(x) = totals_comparison(x) + ISHFT(1, y)\n          END DO\n        END DO\n\n        !$acc data copyin(a(1:LOOPCOUNT, 1:10)) copy(totals(1:LOOPCOUNT)) copyout(b(1:LOOPCOUNT, 1:10))\n          !$acc parallel\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              DO y = 1, 10\n                !$acc atomic capture\n                  totals(x) = iand(a(x, y), totals(x))\n                  b(x, y) = totals(x)\n                !$acc end atomic\n              END DO\n            END DO\n          !$acc end parallel\n        !$acc end data\n        DO x = 1, LOOPCOUNT\n          DO y = 1, 10\n            totals_comparison(x) = iand(totals_comparison(x), a(x, y))\n          END DO\n        END DO\n        DO x = 1, LOOPCOUNT\n          IF (totals_comparison(x) .NE. totals(x)) THEN\n            errors = errors + 1\n            WRITE(*, *) totals_comparison(x)\n          END IF\n        END DO\n\n        DO x = 1, LOOPCOUNT\n          DO y = 1, 10\n            passed_a(y) = a(x, y)\n            passed_b(y) = b(x, y)\n          END DO\n          init = 0\n          DO y = 0, 7\n            init = init + ISHFT(1, y)\n          END DO\n          IF (IS_POSSIBLE(passed_a, passed_b, 10, init) .eqv. .FALSE.) THEN\n            errors = errors + 1\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "construct-independent",
                            "atomic"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_capture_iand_x_expr_assign.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:construct-independent,atomic,V:2.0-2.7\n      LOGICAL FUNCTION test1()\n  IMPLICIT NONE\n  INCLUDE \"acc_testsuite.Fh\"\n  INTEGER :: x, y, z !Iterators\n  INTEGER,DIMENSION(LOOPCOUNT, 10):: a, b !Data\n  REAL(8),DIMENSION(LOOPCOUNT, 10, 8):: randoms\n  INTEGER,DIMENSION(LOOPCOUNT):: totals, totals_comparison\n  INTEGER,DIMENSION(10):: passed_a, passed_b\n  INTEGER:: init\n  LOGICAL IS_POSSIBLE\n  INTEGER :: errors = 0\n\n  !Initilization\n  SEEDDIM(1) = 1\n# ifdef SEED\n  SEEDDIM(1) = SEED\n# endif\n  CALL RANDOM_SEED(PUT=SEEDDIM)\n\n  CALL RANDOM_NUMBER(randoms)\n  a = 0\n  DO x = 1, LOOPCOUNT\n    DO y = 1, 10\n      DO z = 1, 8\n        IF (randoms(x, y, z) .lt. .933) THEN\n          a(x, y) = a(x, y) + ISHFT(1, z - 1)\n        END IF\n      END DO\n    END DO\n  END DO\n  totals = 0\n  totals_comparison = 0\n  DO x = 1, LOOPCOUNT\n    DO y = 0, 7\n      totals(x) = totals(x) + ISHFT(1, y)\n      totals_comparison(x) = totals_comparison(x) + ISHFT(1, y)\n    END DO\n  END DO\n\n  !$acc data copyin(a(1:LOOPCOUNT, 1:10)) copy(totals(1:LOOPCOUNT)) copyout(b(1:LOOPCOUNT, 1:10))\n    !$acc parallel\n      !$acc loop\n      DO x = 1, LOOPCOUNT\n        DO y = 1, 10\n          !$acc atomic capture\n            totals(x) = iand(totals(x), a(x, y))\n            b(x, y) = totals(x)\n          !$acc end atomic\n        END DO\n      END DO\n    !$acc end parallel\n  !$acc end data\n  DO x = 1, LOOPCOUNT\n    DO y = 1, 10\n      totals_comparison(x) = iand(totals_comparison(x), a(x, y))\n    END DO\n  END DO\n  DO x = 1, LOOPCOUNT\n    IF (totals_comparison(x) .NE. totals(x)) THEN\n      errors = errors + 1\n      WRITE(*, *) totals_comparison(x)\n    END IF\n  END DO\n\n  DO x = 1, LOOPCOUNT\n    DO y = 1, 10\n      passed_a(y) = a(x, y)\n      passed_b(y) = b(x, y)\n    END DO\n    init = 0\n    DO y = 0, 7\n      init = init + ISHFT(1, y)\n    END DO\n    IF (IS_POSSIBLE(passed_a, passed_b, 10, init) .eqv. .FALSE.) THEN\n      errors = errors + 1\n    END IF\n  END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "construct-independent",
                            "atomic"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_capture_ior_expr_x_assign.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:construct-independent,atomic,V:2.0-2.7\n      LOGICAL FUNCTION test1()\n  IMPLICIT NONE\n  INCLUDE \"acc_testsuite.Fh\"\n  INTEGER :: x, y, z !Iterators\n  INTEGER,DIMENSION(LOOPCOUNT, 10):: a, b !Data\n  REAL(8),DIMENSION(LOOPCOUNT, 10, 8):: randoms\n  INTEGER,DIMENSION(LOOPCOUNT):: totals, totals_comparison\n  INTEGER,DIMENSION(10):: passed_a, passed_b\n  INTEGER:: init\n  LOGICAL IS_POSSIBLE\n  INTEGER :: errors = 0\n\n  !Initilization\n  SEEDDIM(1) = 1\n# ifdef SEED\n  SEEDDIM(1) = SEED\n# endif\n  CALL RANDOM_SEED(PUT=SEEDDIM)\n\n  CALL RANDOM_NUMBER(randoms)\n  a = 0\n  DO x = 1, LOOPCOUNT\n    DO y = 1, 10\n      DO z = 1, 8\n        IF (randoms(x, y, z) .gt. .933) THEN\n          a(x, y) = a(x, y) + ISHFT(1, z - 1)\n        END IF\n      END DO\n    END DO\n  END DO\n  totals = 0\n  totals_comparison = 0\n\n  !$acc data copyin(a(1:LOOPCOUNT, 1:10)) copy(totals(1:LOOPCOUNT)) copyout(b(1:LOOPCOUNT, 1:10))\n    !$acc parallel\n      !$acc loop\n      DO x = 1, LOOPCOUNT\n        DO y = 1, 10\n          !$acc atomic capture\n            totals(x) = ior(a(x, y), totals(x))\n            b(x, y) = totals(x)\n          !$acc end atomic\n        END DO\n      END DO\n    !$acc end parallel\n  !$acc end data\n  DO x = 1, LOOPCOUNT\n    DO y = 1, 10\n      totals_comparison(x) = ior(totals_comparison(x), a(x, y))\n    END DO\n  END DO\n  DO x = 1, LOOPCOUNT\n    IF (totals_comparison(x) .NE. totals(x)) THEN\n      errors = errors + 1\n      WRITE(*, *) totals_comparison(x)\n    END IF\n  END DO\n\n  DO x = 1, LOOPCOUNT\n    DO y = 1, 10\n      passed_a(y) = a(x, y)\n      passed_b(y) = b(x, y)\n    END DO\n    init = 0\n    IF (IS_POSSIBLE(passed_a, passed_b, 10, init) .eqv. .FALSE.) THEN\n      errors = errors + 1\n    END IF\n  END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "construct-independent",
                            "atomic"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_capture_ior_x_expr_assign.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:construct-independent,atomic,V:2.0-2.7\n      LOGICAL FUNCTION test1()\n  IMPLICIT NONE\n  INCLUDE \"acc_testsuite.Fh\"\n  INTEGER :: x, y, z !Iterators\n  INTEGER,DIMENSION(LOOPCOUNT, 10):: a, b !Data\n  REAL(8),DIMENSION(LOOPCOUNT, 10, 8):: randoms\n  INTEGER,DIMENSION(LOOPCOUNT):: totals, totals_comparison\n  INTEGER,DIMENSION(10):: passed_a, passed_b\n  INTEGER:: init\n  LOGICAL IS_POSSIBLE\n  INTEGER :: errors = 0\n\n  !Initilization\n  SEEDDIM(1) = 1\n# ifdef SEED\n  SEEDDIM(1) = SEED\n# endif\n  CALL RANDOM_SEED(PUT=SEEDDIM)\n\n  CALL RANDOM_NUMBER(randoms)\n  a = 0\n  DO x = 1, LOOPCOUNT\n    DO y = 1, 10\n      DO z = 1, 8\n        IF (randoms(x, y, z) .gt. .933) THEN\n          a(x, y) = a(x, y) + ISHFT(1, z - 1)\n        END IF\n      END DO\n    END DO\n  END DO\n  totals = 0\n  totals_comparison = 0\n\n  !$acc data copyin(a(1:LOOPCOUNT, 1:10)) copy(totals(1:LOOPCOUNT)) copyout(b(1:LOOPCOUNT, 1:10))\n    !$acc parallel\n      !$acc loop\n      DO x = 1, LOOPCOUNT\n        DO y = 1, 10\n          !$acc atomic capture\n            totals(x) = ior(totals(x), a(x, y))\n            b(x, y) = totals(x)\n          !$acc end atomic\n        END DO\n      END DO\n    !$acc end parallel\n  !$acc end data\n  DO x = 1, LOOPCOUNT\n    DO y = 1, 10\n      totals_comparison(x) = ior(totals_comparison(x), a(x, y))\n    END DO\n  END DO\n  DO x = 1, LOOPCOUNT\n    IF (totals_comparison(x) .NE. totals(x)) THEN\n      errors = errors + 1\n      WRITE(*, *) totals_comparison(x)\n    END IF\n  END DO\n\n  DO x = 1, LOOPCOUNT\n    DO y = 1, 10\n      passed_a(y) = a(x, y)\n      passed_b(y) = b(x, y)\n    END DO\n    init = 0\n    IF (IS_POSSIBLE(passed_a, passed_b, 10, init) .eqv. .FALSE.) THEN\n      errors = errors + 1\n    END IF\n  END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "construct-independent",
                            "atomic"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_capture_ixor_expr_x_assign.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:construct-independent,atomic,V:2.0-2.7\n      LOGICAL FUNCTION test1()\n  IMPLICIT NONE\n  INCLUDE \"acc_testsuite.Fh\"\n  INTEGER :: x, y, z !Iterators\n  INTEGER,DIMENSION(LOOPCOUNT, 10):: a, b !Data\n  REAL(8),DIMENSION(LOOPCOUNT, 10, 8):: randoms\n  INTEGER,DIMENSION(LOOPCOUNT):: totals, totals_comparison\n  INTEGER,DIMENSION(10):: passed_a, passed_b\n  INTEGER:: init\n  LOGICAL IS_POSSIBLE\n  INTEGER :: errors = 0\n\n  !Initilization\n  SEEDDIM(1) = 1\n# ifdef SEED\n  SEEDDIM(1) = SEED\n# endif\n  CALL RANDOM_SEED(PUT=SEEDDIM)\n\n  CALL RANDOM_NUMBER(randoms)\n  a = 0\n  DO x = 1, LOOPCOUNT\n    DO y = 1, 10\n      DO z = 1, 8\n        IF (randoms(x, y, z) .gt. .5) THEN\n          a(x, y) = a(x, y) + ISHFT(1, z - 1)\n        END IF\n      END DO\n    END DO\n  END DO\n  totals = 0\n  totals_comparison = 0\n\n  !$acc data copyin(a(1:LOOPCOUNT, 1:10)) copy(totals(1:LOOPCOUNT)) copyout(b(1:LOOPCOUNT, 1:10))\n    !$acc parallel\n      !$acc loop\n      DO x = 1, LOOPCOUNT\n        DO y = 1, 10\n          !$acc atomic capture\n            totals(x) = ieor(a(x, y), totals(x))\n            b(x, y) = totals(x)\n          !$acc end atomic\n        END DO\n      END DO\n    !$acc end parallel\n  !$acc end data\n  DO x = 1, LOOPCOUNT\n    DO y = 1, 10\n      totals_comparison(x) = ieor(totals_comparison(x), a(x, y))\n    END DO\n  END DO\n  DO x = 1, LOOPCOUNT\n    IF (totals_comparison(x) .NE. totals(x)) THEN\n      errors = errors + 1\n      WRITE(*, *) totals_comparison(x)\n    END IF\n  END DO\n\n  DO x = 1, LOOPCOUNT\n    DO y = 1, 10\n      passed_a(y) = a(x, y)\n      passed_b(y) = b(x, y)\n    END DO\n    init = 0\n    IF (IS_POSSIBLE(passed_a, passed_b, 10, init) .eqv. .FALSE.) THEN\n      errors = errors + 1\n    END IF\n  END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "construct-independent",
                            "atomic"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_capture_ixor_x_expr_assign.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:construct-independent,atomic,V:2.0-2.7\n      LOGICAL FUNCTION test1()\n  IMPLICIT NONE\n  INCLUDE \"acc_testsuite.Fh\"\n  INTEGER :: x, y, z !Iterators\n  INTEGER,DIMENSION(LOOPCOUNT, 10):: a, b !Data\n  REAL(8),DIMENSION(LOOPCOUNT, 10, 8):: randoms\n  INTEGER,DIMENSION(LOOPCOUNT):: totals, totals_comparison\n  INTEGER,DIMENSION(10):: passed_a, passed_b\n  INTEGER:: init\n  LOGICAL IS_POSSIBLE\n  INTEGER :: errors = 0\n\n  !Initilization\n  SEEDDIM(1) = 1\n# ifdef SEED\n  SEEDDIM(1) = SEED\n# endif\n  CALL RANDOM_SEED(PUT=SEEDDIM)\n\n  CALL RANDOM_NUMBER(randoms)\n  a = 0\n  DO x = 1, LOOPCOUNT\n    DO y = 1, 10\n      DO z = 1, 8\n        IF (randoms(x, y, z) .gt. .5) THEN\n          a(x, y) = a(x, y) + ISHFT(1, z - 1)\n        END IF\n      END DO\n    END DO\n  END DO\n  totals = 0\n  totals_comparison = 0\n\n  !$acc data copyin(a(1:LOOPCOUNT, 1:10)) copy(totals(1:LOOPCOUNT)) copyout(b(1:LOOPCOUNT, 1:10))\n    !$acc parallel\n      !$acc loop\n      DO x = 1, LOOPCOUNT\n        DO y = 1, 10\n          !$acc atomic capture\n            totals(x) = ieor(totals(x), a(x, y))\n            b(x, y) = totals(x)\n          !$acc end atomic\n        END DO\n      END DO\n    !$acc end parallel\n  !$acc end data\n  DO x = 1, LOOPCOUNT\n    DO y = 1, 10\n      totals_comparison(x) = ieor(totals_comparison(x), a(x, y))\n    END DO\n  END DO\n  DO x = 1, LOOPCOUNT\n    IF (totals_comparison(x) .NE. totals(x)) THEN\n      errors = errors + 1\n      WRITE(*, *) totals_comparison(x)\n    END IF\n  END DO\n\n  DO x = 1, LOOPCOUNT\n    DO y = 1, 10\n      passed_a(y) = a(x, y)\n      passed_b(y) = b(x, y)\n    END DO\n    init = 0\n    IF (IS_POSSIBLE(passed_a, passed_b, 10, init) .eqv. .FALSE.) THEN\n      errors = errors + 1\n    END IF\n  END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "construct-independent",
                            "atomic"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_capture_lshift_equals.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:atomic,construct-independent,V:2.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    unsigned int *a = (unsigned int *)malloc(n * sizeof(int));\n    unsigned int *b = (unsigned int *)malloc(n * sizeof(int));\n    unsigned int *c = (unsigned int *)malloc(7 * n * sizeof(int));\n    unsigned int passed = 1;\n\n    for (int x = 0; x < n; ++x){\n        a[x] = 1;\n        for (int y = 0; y < 7; ++y){\n            if ((rand()/(real_t) (RAND_MAX)) > .5){\n                b[x] += 1<<y;\n            }\n        }\n    }\n\n    #pragma acc data copyin(b[0:n]) copy(a[0:n]) copyout(c[0:7*n])\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                #pragma acc loop\n                for (int y = 0; y < 7; ++y){\n                    c[x * 7 + y] = a[x];\n                    if ((b[x]>>y)%2 == 1){\n                        #pragma acc atomic capture\n                            c[x * 7 + y] = a[x] <<= 1;\n                    }\n                }\n            }\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        for (int y = 0; y < 7; ++y){\n            if ((b[x]>>y)%2 == 1){\n                a[x] >>= 1;\n            }\n        }\n        if (a[x] != 1){\n            err += 1;\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        if (!is_possible(b[x], &(c[x * 7]), 7, passed)){\n            err++;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "atomic",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_capture_max_expr_list_x_assign.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:construct-independent,atomic,V:2.0-2.7\n      LOGICAL FUNCTION test1()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x, y !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT, 10):: a, b, c !Data\n        REAL(8),DIMENSION(LOOPCOUNT):: totals, totals_comparison\n        REAL(8),DIMENSION(10):: passed_a, passed_b, passed_c\n        REAL(8):: init\n        LOGICAL IS_POSSIBLE\n        INTEGER :: errors = 0\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(a)\n        CALL RANDOM_NUMBER(b)\n\n        totals = 0\n        totals_comparison = 0\n\n        !$acc data copyin(a(1:LOOPCOUNT, 1:10), b(1:LOOPCOUNT, 1:10)) copy(totals(1:LOOPCOUNT)) copyout(c(1:LOOPCOUNT, 1:10))\n          !$acc parallel\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              DO y = 1, 10\n                !$acc atomic capture\n                  totals(x) = max(a(x, y), b(x, y), totals(x))\n                  c(x, y) = totals(x)\n                !$acc end atomic\n              END DO\n            END DO\n          !$acc end parallel\n        !$acc end data\n        DO x = 1, LOOPCOUNT\n          DO y = 1, 10\n            totals_comparison(x) = max(totals_comparison(x), a(x, y), b(x, y))\n          END DO\n        END DO\n        DO x = 1, LOOPCOUNT\n          IF (totals_comparison(x) .NE. totals(x)) THEN\n            errors = errors + 1\n            WRITE(*, *) totals_comparison(x)\n          END IF\n        END DO\n\n        DO x = 1, LOOPCOUNT\n          DO y = 1, 10\n            passed_a(y) = a(x, y)\n            passed_b(y) = b(x, y)\n            passed_c(y) = c(x, y)\n          END DO\n          init = 0\n          IF (IS_POSSIBLE(passed_a, passed_b, passed_c, 10, init) .eqv. .FALSE.) THEN\n            errors = errors + 1\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "construct-independent",
                            "atomic"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_capture_max_expr_x_assign.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:construct-independent,atomic,V:2.0-2.7\n      LOGICAL FUNCTION test1()\n  IMPLICIT NONE\n  INCLUDE \"acc_testsuite.Fh\"\n  INTEGER :: x, y !Iterators\n  REAL(8),DIMENSION(LOOPCOUNT, 10):: a, b !Data\n  REAL(8),DIMENSION(LOOPCOUNT):: totals, totals_comparison\n  REAL(8),DIMENSION(10):: passed_a, passed_b\n  REAL(8):: init\n  LOGICAL IS_POSSIBLE\n  INTEGER :: errors = 0\n\n  !Initilization\n  SEEDDIM(1) = 1\n# ifdef SEED\n  SEEDDIM(1) = SEED\n# endif\n  CALL RANDOM_SEED(PUT=SEEDDIM)\n\n  CALL RANDOM_NUMBER(a)\n\n  totals = 0\n  totals_comparison = 0\n\n  !$acc data copyin(a(1:LOOPCOUNT, 1:10)) copy(totals(1:LOOPCOUNT)) copyout(b(1:LOOPCOUNT, 1:10))\n    !$acc parallel\n      !$acc loop\n      DO x = 1, LOOPCOUNT\n        DO y = 1, 10\n          !$acc atomic capture\n            totals(x) = max(a(x, y), totals(x))\n            b(x, y) = totals(x)\n          !$acc end atomic\n        END DO\n      END DO\n    !$acc end parallel\n  !$acc end data\n  DO x = 1, LOOPCOUNT\n    DO y = 1, 10\n      totals_comparison(x) = max(totals_comparison(x), a(x, y))\n    END DO\n  END DO\n  DO x = 1, LOOPCOUNT\n    IF (totals_comparison(x) .NE. totals(x)) THEN\n      errors = errors + 1\n      WRITE(*, *) totals_comparison(x)\n    END IF\n  END DO\n\n  DO x = 1, LOOPCOUNT\n    DO y = 1, 10\n      passed_a(y) = a(x, y)\n      passed_b(y) = b(x, y)\n    END DO\n    init = 0\n    IF (IS_POSSIBLE(passed_a, passed_b, 10, init) .eqv. .FALSE.) THEN\n      errors = errors + 1\n    END IF\n  END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "construct-independent",
                            "atomic"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_capture_max_x_expr_assign.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:construct-independent,atomic,V:2.0-2.7\n      LOGICAL FUNCTION test1()\n  IMPLICIT NONE\n  INCLUDE \"acc_testsuite.Fh\"\n  INTEGER :: x, y !Iterators\n  REAL(8),DIMENSION(LOOPCOUNT, 10):: a, b !Data\n  REAL(8),DIMENSION(LOOPCOUNT):: totals, totals_comparison\n  REAL(8),DIMENSION(10):: passed_a, passed_b\n  REAL(8):: init\n  LOGICAL IS_POSSIBLE\n  INTEGER :: errors = 0\n\n  !Initilization\n  SEEDDIM(1) = 1\n# ifdef SEED\n  SEEDDIM(1) = SEED\n# endif\n  CALL RANDOM_SEED(PUT=SEEDDIM)\n\n  CALL RANDOM_NUMBER(a)\n\n  totals = 0\n  totals_comparison = 0\n\n  !$acc data copyin(a(1:LOOPCOUNT, 1:10)) copy(totals(1:LOOPCOUNT)) copyout(b(1:LOOPCOUNT, 1:10))\n    !$acc parallel\n      !$acc loop\n      DO x = 1, LOOPCOUNT\n        DO y = 1, 10\n          !$acc atomic capture\n            totals(x) = max(totals(x), a(x, y))\n            b(x, y) = totals(x)\n          !$acc end atomic\n        END DO\n      END DO\n    !$acc end parallel\n  !$acc end data\n  DO x = 1, LOOPCOUNT\n    DO y = 1, 10\n      totals_comparison(x) = max(totals_comparison(x), a(x, y))\n    END DO\n  END DO\n  DO x = 1, LOOPCOUNT\n    IF (totals_comparison(x) .NE. totals(x)) THEN\n      errors = errors + 1\n      WRITE(*, *) totals_comparison(x)\n    END IF\n  END DO\n\n  DO x = 1, LOOPCOUNT\n    DO y = 1, 10\n      passed_a(y) = a(x, y)\n      passed_b(y) = b(x, y)\n    END DO\n    init = 0\n    IF (IS_POSSIBLE(passed_a, passed_b, 10, init) .eqv. .FALSE.) THEN\n      errors = errors + 1\n    END IF\n  END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "construct-independent",
                            "atomic"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_capture_max_x_expr_list_assign.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:construct-independent,atomic,V:2.0-2.7\n      LOGICAL FUNCTION test1()\nIMPLICIT NONE\nINCLUDE \"acc_testsuite.Fh\"\nINTEGER :: x, y !Iterators\nREAL(8),DIMENSION(LOOPCOUNT, 10):: a, b, c !Data\nREAL(8),DIMENSION(LOOPCOUNT):: totals, totals_comparison\nREAL(8),DIMENSION(10):: passed_a, passed_b, passed_c\nREAL(8):: init\nLOGICAL IS_POSSIBLE\nINTEGER :: errors = 0\n\n!Initilization\nSEEDDIM(1) = 1\n#ifdef SEED\nSEEDDIM(1) = SEED\n#endif\n",
                        "tags": [
                            "construct-independent",
                            "atomic"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_capture_min_expr_list_x_assign.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:construct-independent,atomic,V:2.0-2.7\n      LOGICAL FUNCTION test1()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x, y !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT, 10):: a, b, c !Data\n        REAL(8),DIMENSION(LOOPCOUNT):: totals, totals_comparison\n        REAL(8),DIMENSION(10):: passed_a, passed_b, passed_c\n        REAL(8):: init\n        LOGICAL IS_POSSIBLE\n        INTEGER :: errors = 0\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(a)\n        CALL RANDOM_NUMBER(b)\n\n        totals = 0\n        totals_comparison = 0\n\n        !$acc data copyin(a(1:LOOPCOUNT, 1:10), b(1:LOOPCOUNT, 1:10)) copy(totals(1:LOOPCOUNT)) copyout(c(1:LOOPCOUNT, 1:10))\n          !$acc parallel\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              DO y = 1, 10\n                !$acc atomic capture\n                  totals(x) = min(a(x, y), b(x, y), totals(x))\n                  c(x, y) = totals(x)\n                !$acc end atomic\n              END DO\n            END DO\n          !$acc end parallel\n        !$acc end data\n        DO x = 1, LOOPCOUNT\n          DO y = 1, 10\n            totals_comparison(x) = min(totals_comparison(x), a(x, y), b(x, y))\n          END DO\n        END DO\n        DO x = 1, LOOPCOUNT\n          IF (totals_comparison(x) .NE. totals(x)) THEN\n            errors = errors + 1\n            WRITE(*, *) totals_comparison(x)\n          END IF\n        END DO\n\n        DO x = 1, LOOPCOUNT\n          DO y = 1, 10\n            passed_a(y) = a(x, y)\n            passed_b(y) = b(x, y)\n            passed_c(y) = c(x, y)\n          END DO\n          init = 0\n          IF (IS_POSSIBLE(passed_a, passed_b, passed_c, 10, init) .eqv. .FALSE.) THEN\n            errors = errors + 1\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "construct-independent",
                            "atomic"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_capture_min_expr_x_assign.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:construct-independent,atomic,V:2.0-2.7\n      LOGICAL FUNCTION test1()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x, y !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT, 10):: a, b !Data\n        REAL(8),DIMENSION(LOOPCOUNT):: totals, totals_comparison\n        REAL(8),DIMENSION(10):: passed_a, passed_b\n        REAL(8):: init\n        LOGICAL IS_POSSIBLE\n        INTEGER :: errors = 0\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(a)\n\n        totals = 0\n        totals_comparison = 0\n\n        !$acc data copyin(a(1:LOOPCOUNT, 1:10)) copy(totals(1:LOOPCOUNT)) copyout(b(1:LOOPCOUNT, 1:10))\n          !$acc parallel\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              DO y = 1, 10\n                !$acc atomic capture\n                  totals(x) = min(a(x, y), totals(x))\n                  b(x, y) = totals(x)\n                !$acc end atomic\n              END DO\n            END DO\n          !$acc end parallel\n        !$acc end data\n        DO x = 1, LOOPCOUNT\n          DO y = 1, 10\n            totals_comparison(x) = min(totals_comparison(x), a(x, y))\n          END DO\n        END DO\n        DO x = 1, LOOPCOUNT\n          IF (totals_comparison(x) .NE. totals(x)) THEN\n            errors = errors + 1\n            WRITE(*, *) totals_comparison(x)\n          END IF\n        END DO\n\n        DO x = 1, LOOPCOUNT\n          DO y = 1, 10\n            passed_a(y) = a(x, y)\n            passed_b(y) = b(x, y)\n          END DO\n          init = 0\n          IF (IS_POSSIBLE(passed_a, passed_b, 10, init) .eqv. .FALSE.) THEN\n            errors = errors + 1\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "construct-independent",
                            "atomic"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_capture_min_x_expr_assign.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:construct-independent,atomic,V:2.0-2.7\n      LOGICAL FUNCTION test1()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x, y !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT, 10):: a, b !Data\n        REAL(8),DIMENSION(LOOPCOUNT):: totals, totals_comparison\n        REAL(8),DIMENSION(10):: passed_a, passed_b\n        REAL(8):: init\n        LOGICAL IS_POSSIBLE\n        INTEGER :: errors = 0\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(a)\n\n        totals = 0\n        totals_comparison = 0\n\n        !$acc data copyin(a(1:LOOPCOUNT, 1:10)) copy(totals(1:LOOPCOUNT)) copyout(b(1:LOOPCOUNT, 1:10))\n          !$acc parallel\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              DO y = 1, 10\n                !$acc atomic capture\n                  totals(x) = min(totals(x), a(x, y))\n                  b(x, y) = totals(x)\n                !$acc end atomic\n              END DO\n            END DO\n          !$acc end parallel\n        !$acc end data\n        DO x = 1, LOOPCOUNT\n          DO y = 1, 10\n            totals_comparison(x) = min(totals_comparison(x), a(x, y))\n          END DO\n        END DO\n        DO x = 1, LOOPCOUNT\n          IF (totals_comparison(x) .NE. totals(x)) THEN\n            errors = errors + 1\n            WRITE(*, *) totals_comparison(x)\n          END IF\n        END DO\n\n        DO x = 1, LOOPCOUNT\n          DO y = 1, 10\n            passed_a(y) = a(x, y)\n            passed_b(y) = b(x, y)\n          END DO\n          init = 0\n          IF (IS_POSSIBLE(passed_a, passed_b, 10, init) .eqv. .FALSE.) THEN\n            errors = errors + 1\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "construct-independent",
                            "atomic"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_capture_min_x_expr_list_assign.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:construct-independent,atomic,V:2.0-2.7\n      LOGICAL FUNCTION test1()\n      IMPLICIT NONE\n      INCLUDE \"acc_testsuite.Fh\"\n      INTEGER :: x, y !Iterators\n      REAL(8),DIMENSION(LOOPCOUNT, 10):: a, b, c !Data\n      REAL(8),DIMENSION(LOOPCOUNT):: totals, totals_comparison\n      REAL(8),DIMENSION(10):: passed_a, passed_b, passed_c\n      REAL(8):: init\n      LOGICAL IS_POSSIBLE\n      INTEGER :: errors = 0\n\n      !Initilization\n      SEEDDIM(1) = 1\n#     ifdef SEED\n      SEEDDIM(1) = SEED\n#     endif\n      CALL RANDOM_SEED(PUT=SEEDDIM)\n\n      CALL RANDOM_NUMBER(a)\n      CALL RANDOM_NUMBER(b)\n\n      totals = 1\n      totals_comparison = 1\n\n      !$acc data copyin(a(1:LOOPCOUNT, 1:10), b(1:LOOPCOUNT, 1:10)) copy(totals(1:LOOPCOUNT)) copyout(c(1:LOOPCOUNT, 1:10))\n        !$acc parallel\n          !$acc loop\n          DO x = 1, LOOPCOUNT\n            DO y = 1, 10\n              !$acc atomic capture\n                totals(x) = min(totals(x), a(x, y), b(x, y))\n                c(x, y) = totals(x)\n              !$acc end atomic\n            END DO\n          END DO\n        !$acc end parallel\n      !$acc end data\n      DO x = 1, LOOPCOUNT\n        DO y = 1, 10\n          totals_comparison(x) = min(totals_comparison(x), a(x, y), b(x, y))\n        END DO\n      END DO\n      DO x = 1, LOOPCOUNT\n        IF (totals_comparison(x) .NE. totals(x)) THEN\n          errors = errors + 1\n          WRITE(*, *) totals_comparison(x)\n        END IF\n      END DO\n\n      DO x = 1, LOOPCOUNT\n        DO y = 1, 10\n          passed_a(y) = a(x, y)\n          passed_b(y) = b(x, y)\n          passed_c(y) = c(x, y)\n        END DO\n        init = 1\n        IF (IS_POSSIBLE(passed_a, passed_b, passed_c, 10, init) .eqv. .FALSE.) THEN\n          errors = errors + 1\n        END IF\n      END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "construct-independent",
                            "atomic"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_capture_minus_equals.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:atomic,construct-independent,V:2.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t *a = (real_t *)malloc(n * sizeof(real_t));\n    real_t *b = (real_t *)malloc(n * sizeof(real_t));\n    real_t *c = (real_t *)malloc(n * sizeof(real_t));\n    real_t *totals = (real_t *)malloc(10 * sizeof(real_t));\n    real_t *totals_host = (real_t *)malloc(10 * sizeof(real_t));\n    real_t * passed_ab = (real_t *)malloc((n/10 + 1) * sizeof(real_t));\n    real_t * passed_c = (real_t *)malloc((n/10 + 1) * sizeof(real_t));\n    int passed_indexer;\n    int absolute_indexer;\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n    }\n    for (int x = 0; x < 10; ++x){\n        totals[x] = 0;\n    }\n\n    #pragma acc data copyin(a[0:n], b[0:n]) copy(totals[0:10])\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                #pragma acc atomic capture\n                    c[x] = totals[x%10] -= (a[x] + b[x]);\n            }\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        totals_host[x%10] = totals_host[x%10] - (a[x] + b[x]);\n    }\n    for (int x = 0; x < 10; ++x){\n        if (fabs(totals_host[x] - totals[x]) > PRECISION){\n            err += 1;\n        }\n    }\n\n    for (int x = 0; x < 10; ++x){\n        for (passed_indexer = 0, absolute_indexer = x; absolute_indexer < n; passed_indexer++, absolute_indexer+= 10){\n            passed_ab[passed_indexer] = a[absolute_indexer] + b[absolute_indexer];\n            passed_c[passed_indexer] = c[absolute_indexer];\n        }\n        if (!is_possible(passed_ab, passed_c, passed_indexer - 1, 0)){\n            err++;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "atomic",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_capture_multiply_equals.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:atomic,construct-independent,V:2.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t *a = (real_t *)malloc(n * sizeof(real_t));\n    real_t *b = (real_t *)malloc(n * sizeof(real_t));\n    real_t *c = (real_t *)malloc(n * sizeof(real_t));\n    real_t *totals = (real_t *)malloc((n/10 + 1) * sizeof(real_t));\n    real_t *totals_comparison = (real_t *)malloc((n/10 + 1) * sizeof(real_t));\n    real_t * passed_ab = (real_t *)malloc(10 * sizeof(real_t));\n    real_t * passed_c = (real_t *)malloc(10 * sizeof(real_t));\n    int passed_indexer;\n    int absolute_indexer;\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n    }\n    for (int x = 0; x < n/10 + 1; ++x){\n        totals[x] = 1;\n        totals_comparison[x] = 1;\n    }\n\n    #pragma acc data copyin(a[0:n], b[0:n]) copy(totals[0:n/10 + 1]) copyout(c[0:n])\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                #pragma acc atomic capture\n                    c[x] = totals[x%(n/10 + 1)] *= a[x] + b[x];\n            }\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        totals_comparison[x%(n/10 + 1)] *= a[x] + b[x];\n    }\n    for (int x = 0; x < 10; ++x){\n        if (fabs(totals_comparison[x] - totals[x]) > PRECISION * totals_comparison[x]){\n            err += 1;\n            break;\n        }\n    }\n\n    for (int x = 0; x < n/10 + 1; ++x){\n        for (passed_indexer = 0, absolute_indexer = x; absolute_indexer < n; passed_indexer++, absolute_indexer += n/10 + 1){\n            passed_ab[passed_indexer] = a[absolute_indexer] + b[absolute_indexer];\n            passed_c[passed_indexer] = c[absolute_indexer];\n        }\n        if (!is_possible(passed_ab, passed_c, passed_indexer - 1, 1)){\n            err++;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "atomic",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_capture_plus_equals.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:atomic,construct-independent,V:2.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t *a = (real_t *)malloc(n * sizeof(real_t));\n    real_t *b = (real_t *)malloc(n * sizeof(real_t));\n    real_t *c = (real_t *)malloc(n * sizeof(real_t));\n    real_t *totals = (real_t *)malloc((n/10 + 1) * sizeof(real_t));\n    real_t *totals_comparison = (real_t *)malloc((n/10 + 1) * sizeof(real_t));\n    real_t *passed_ab = (real_t *)malloc(10 * sizeof(real_t));\n    real_t *passed_c = (real_t *)malloc(10 * sizeof(real_t));\n    int passed_indexer;\n    int absolute_indexer;\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n    }\n    for (int x = 0; x < n/10 + 1; ++x){\n        totals[x] = 0;\n        totals_comparison[x] = 0;\n    }\n\n    #pragma acc data copyin(a[0:n], b[0:n]) copy(totals[0:n/10 + 1]) copyout(c[0:n])\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                #pragma acc atomic capture\n                    c[x] = totals[x%(n/10 + 1)] += a[x] * b[x];\n            }\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        totals_comparison[x%(n/10 + 1)] += a[x] * b[x];\n    }\n    for (int x = 0; x < n/10 + 1; ++x){\n        if (fabs(totals_comparison[x] - totals[x]) > PRECISION){\n            err += 1;\n            break;\n        }\n    }\n\n    for (int x = 0; x < n/10 + 1; ++x){\n        for (passed_indexer = 0, absolute_indexer = x; absolute_indexer < n; passed_indexer++, absolute_indexer+= (n/10 + 1)){\n            passed_ab[passed_indexer] = a[absolute_indexer] * b[absolute_indexer];\n            passed_c[passed_indexer] = c[absolute_indexer];\n        }\n        if (!is_possible(passed_ab, passed_c, passed_indexer - 1, 0)){\n            err++;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "atomic",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_capture_postdecrement.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:atomic,construct-independent,V:2.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t *a = (real_t *)malloc(n * sizeof(real_t));\n    real_t *b = (real_t *)malloc(n * sizeof(real_t));\n    int *c = (int *)malloc(n * sizeof(int));\n    int *distribution = (int *)malloc(10 * sizeof(int));\n    int *distribution_comparison = (int *)malloc(10 * sizeof(int));\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n    }\n    for (int x = 0; x < 10; ++x){\n        distribution[x] = 0;\n        distribution_comparison[x] = 0;\n    }\n\n    #pragma acc data copyin(a[0:n], b[0:n]) copy(distribution[0:10]) copyout(c[0:n])\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                #pragma acc atomic capture\n                    c[x] = (distribution[(int) (a[x]*b[x]/10)])--;\n            }\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        distribution_comparison[(int) (a[x]*b[x]/10)]--;\n    }\n    for (int x = 0; x < 10; ++x){\n        if (distribution_comparison[x] != distribution[x]){\n            err += 1;\n            break;\n        }\n    }\n\n    bool found = false;\n    for (int x = 0; x < 10; ++x){\n        for (int y = 0; y > -distribution_comparison[x]; --y){\n            for (int z = 0; z < n; ++z){\n                if (y == c[z] && x == (int) (a[x] * b[x] / 10)){\n                    found = true;\n                    break;\n                }\n            }\n            if (!found){\n                err++;\n            }\n            found = false;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "atomic",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_capture_postincrement.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:atomic,construct-independent,V:2.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t *a = (real_t *)malloc(n * sizeof(real_t));\n    real_t *b = (real_t *)malloc(n * sizeof(real_t));\n    int *c = (int *)malloc(n * sizeof(int));\n    int *distribution = (int *)malloc(10 * sizeof(int));\n    int *distribution_comparison = (int *)malloc(10 * sizeof(int));\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n    }\n    for (int x = 0; x < 10; ++x){\n        distribution[x] = 0;\n        distribution_comparison[x] = 0;\n    }\n\n    #pragma acc data copyin(a[0:n], b[0:n]) copy(distribution[0:10]) copyout(c[0:n])\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                #pragma acc atomic capture\n                    c[x] = distribution[(int) (a[x]*b[x]/10)]++;\n            }\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        distribution_comparison[(int) (a[x]*b[x]/10)]++;\n    }\n    for (int x = 0; x < 10; ++x){\n        if (distribution_comparison[x] != distribution[x]){\n            err += 1;\n            break;\n        }\n    }\n\n    bool found = false;\n    for (int x = 0; x < 10; ++x){\n        for (int y = 0; y < distribution_comparison[x]; ++y){\n            for (int z = 0; z < n; ++z){\n                if (c[z] == y && (int) (a[z]*b[z]/10) == x){\n                    found = true;\n                    break;\n                }\n            }\n            if (!found){\n                err++;\n            }\n            found = false;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "atomic",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_capture_predecrement.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:atomic,construct-independent,V:2.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t *a = (real_t *)malloc(n * sizeof(real_t));\n    real_t *b = (real_t *)malloc(n * sizeof(real_t));\n    int *c = (int *)malloc(n * sizeof(int));\n    int *distribution = (int *)malloc(10 * sizeof(int));\n    int *distribution_comparison = (int *)malloc(10 * sizeof(int));\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n    }\n    for (int x = 0; x < 10; ++x){\n        distribution[x] = 0;\n        distribution_comparison[x] = 0;\n    }\n\n    #pragma acc data copyin(a[0:n], b[0:n]) copy(distribution[0:10]) copyout(c[0:n])\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                #pragma acc atomic capture\n                    c[x] = --distribution[(int) (a[x]*b[x]/10)];\n            }\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        distribution_comparison[(int) (a[x]*b[x]/10)]--;\n    }\n    for (int x = 0; x < 10; ++x){\n        if (distribution_comparison[x] != distribution[x]){\n            err += 1;\n            break;\n        }\n    }\n\n    bool found = false;\n    for (int x = 0; x < 10; ++x){\n        for (int y = 0; y > distribution[x]; --y){\n            for (int z = 0; z < n; ++z){\n                if (c[z] == y - 1 && x == (int) (a[z] * b[z] / 10)){\n                    found = true;\n                    break;\n                }\n            }\n            if (!found){\n                err++;\n            }\n            found = false;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "atomic",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_capture_preincrement.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:atomic,construct-independent,V:2.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t *a = (real_t *)malloc(n * sizeof(real_t));\n    real_t *b = (real_t *)malloc(n * sizeof(real_t));\n    int *c = (int *)malloc(n * sizeof(int));\n    int *distribution = (int *)malloc(10 * sizeof(int));\n    int *distribution_comparison = (int *)malloc(10 * sizeof(int));\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n    }\n    for (int x = 0; x < 10; ++x){\n        distribution[x] = 0;\n        distribution_comparison[x] = 0;\n    }\n\n    #pragma acc data copyin(a[0:n], b[0:n]) copy(distribution[0:10]) copyout(c[0:n])\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                #pragma acc atomic capture\n                    c[x] = ++distribution[(int) (a[x]*b[x]/10)];\n            }\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        distribution_comparison[(int) (a[x]*b[x]/10)]++;\n    }\n    for (int x = 0; x < 10; ++x){\n        if (distribution_comparison[x] != distribution[x]){\n            err += 1;\n            break;\n        }\n    }\n\n    bool found = false;\n    for (int x = 0; x < 10; ++x){\n        for (int y = 0; y < distribution[x]; ++y){\n            for (int z = 0; z < n; ++z){\n                if (c[z] == y + 1 && x == (int) (a[z] * b[z] / 10)){\n                    found = true;\n                    break;\n                }\n            }\n            if (!found){\n                err++;\n            }\n            found = false;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "atomic",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_capture_rshift_equals.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:atomic,construct-independent,V:2.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    unsigned int *a = (unsigned int *)malloc(n * sizeof(int));\n    unsigned int *b = (unsigned int *)malloc(n * sizeof(int));\n    unsigned int *c = (unsigned int *)malloc(7 * n * sizeof(int));\n    unsigned int passed = 1<<8;\n\n    for (int x = 0; x < n; ++x){\n        a[x] = 1<<8;\n        for (int y = 0; y < 7; ++y){\n            if ((rand()/(real_t) (RAND_MAX)) > .5){\n                b[x] += 1<<y;\n            }\n        }\n    }\n\n    #pragma acc data copyin(b[0:n]) copy(a[0:n]) copyout(c[0:7*n])\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                #pragma acc loop\n                for (int y = 0; y < 7; ++y){\n                    c[x * 7 + y] = a[x];\n                    if ((b[x]>>y)%2 == 1){\n                        #pragma acc atomic capture\n                            c[x * 7 + y] = a[x] >>= 1;\n                    }\n                }\n            }\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        for (int y = 0; y < 7; ++y){\n            if ((b[x]>>y)%2 == 1){\n                a[x] <<= 1;\n            }\n        }\n        if (a[x] != 1<<8){\n            err += 1;\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        if (!is_possible(b[x], &(c[x * 7]), 7, passed)){\n            err++;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "atomic",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_capture_x_and_expr_assign.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:construct-independent,atomic,V:2.0-2.7\n      LOGICAL FUNCTION test1()\n  IMPLICIT NONE\n  INCLUDE \"acc_testsuite.Fh\"\n  INTEGER :: x, y !Iterators\n  REAL(8),DIMENSION(LOOPCOUNT, 10):: randoms\n  LOGICAL,DIMENSION(LOOPCOUNT, 10):: a, b !Data\n  LOGICAL,DIMENSION(10):: passed_a, passed_b\n  LOGICAL IS_POSSIBLE\n  LOGICAL,DIMENSION(LOOPCOUNT):: totals, totals_comparison\n  INTEGER :: errors = 0\n  LOGICAL :: init\n\n  !Initilization\n  SEEDDIM(1) = 1\n# ifdef SEED\n  SEEDDIM(1) = SEED\n# endif\n  CALL RANDOM_SEED(PUT=SEEDDIM)\n\n  CALL RANDOM_NUMBER(randoms)\n  DO x = 1, LOOPCOUNT\n    DO y = 1, 10\n      IF (randoms(x, y) < .933) THEN\n        a(x, y) = .TRUE.\n      ELSE\n        a(x, y) = .FALSE.\n      END IF\n    END DO\n  END DO\n\n  totals = .FALSE.\n  totals_comparison = .FALSE.\n\n  !$acc data copyin(a(1:LOOPCOUNT,1:10)) copy(totals(1:LOOPCOUNT)) copyout(b(1:LOOPCOUNT,1:10))\n    !$acc parallel\n      !$acc loop\n      DO x = 1, LOOPCOUNT\n        DO y = 1, 10\n          !$acc atomic capture\n            totals(x) = totals(x) .AND. a(x, y)\n            b(x, y) = totals(x)\n          !$acc end atomic\n        END DO\n      END DO\n    !$acc end parallel\n  !$acc end data\n\n  DO x = 1, LOOPCOUNT\n    DO y = 1, 10\n      totals_comparison(x) = totals_comparison(x) .AND. a(x, y)\n    END DO\n  END DO\n\n  DO x = 1, LOOPCOUNT\n    IF (totals_comparison(x) .NEQV. totals(x)) THEN\n      errors = errors + 1\n      WRITE(*, *) totals_comparison(x)\n    END IF\n  END DO\n\n  DO x = 1, LOOPCOUNT\n    DO y = 1, 10\n      passed_a(y) = a(x, y)\n      passed_b(y) = b(x, y)\n    END DO\n    init = .FALSE.\n    IF (.FALSE. .eqv. IS_POSSIBLE(a(x, 1:10), b(x, 1:10), 10, .FALSE.)) THEN\n      errors = errors + 1\n    END IF\n  END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "construct-independent",
                            "atomic"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_capture_x_divided_expr_assign.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:construct-independent,atomic,V:2.0-2.7\n      LOGICAL FUNCTION test1()\n  IMPLICIT NONE\n  INCLUDE \"acc_testsuite.Fh\"\n  INTEGER :: x, y !Iterators\n  REAL(8),DIMENSION(LOOPCOUNT, 10):: a !Data\n  REAL(8),DIMENSION(LOOPCOUNT, 10):: b\n  REAL(8),DIMENSION(LOOPCOUNT):: totals\n  REAL(8),DIMENSION(10):: passed\n  REAL(8),DIMENSION(10):: passed_b\n  REAL(8) :: holder\n  INTEGER :: errors = 0\n  LOGICAL IS_POSSIBLE\n  LOGICAL IS_POSSIBLE_2\n\n  !Initilization\n  SEEDDIM(1) = 1\n# ifdef SEED\n  SEEDDIM(1) = SEED\n# endif\n  CALL RANDOM_SEED(PUT=SEEDDIM)\n\n  CALL RANDOM_NUMBER(a)\n\n  totals = 1\n\n  !$acc data copyin(a(1:LOOPCOUNT, 1:10)) copy(totals(1:LOOPCOUNT)) copyout(b(1:LOOPCOUNT,1:10))\n    !$acc parallel\n      !$acc loop\n      DO x = 1, LOOPCOUNT\n        DO y = 1, 10\n          !$acc atomic capture\n            totals(x) = totals(x) / a(x, y)\n            b(x, y) = totals(x)\n          !$acc end atomic\n        END DO\n      END DO\n    !$acc end parallel\n  !$acc end data\n\n  DO x = 1, LOOPCOUNT\n    DO y = 1, 10\n      passed(y) = a(x, y)\n    END DO\n    holder = 1\n    IF (IS_POSSIBLE(passed, totals(x), 10, holder) .eqv. .FALSE.) THEN\n      errors = errors + 1\n    END IF\n  END DO\n\n  DO x = 1, LOOPCOUNT\n    DO y = 1, 10\n      passed(y) = a(x, y)\n      passed_b(y) = b(x, y)\n    END DO\n    holder = 1\n    IF (IS_POSSIBLE_2(passed, passed_b, 10, holder) .eqv. .FALSE.) THEN\n      errors = errors + 1\n    END IF\n  END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "construct-independent",
                            "atomic"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_capture_x_eqv_expr_assign.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:construct-independent,atomic,V:2.0-2.7\n      LOGICAL FUNCTION test1()\n  IMPLICIT NONE\n  INCLUDE \"acc_testsuite.Fh\"\n  INTEGER :: x, y !Iterators\n  REAL(8),DIMENSION(LOOPCOUNT, 10):: randoms\n  LOGICAL,DIMENSION(LOOPCOUNT, 10):: a, b !Data\n  LOGICAL,DIMENSION(LOOPCOUNT):: totals, totals_comparison\n  LOGICAL,DIMENSION(10):: passed_a, passed_b\n  LOGICAL:: init\n  INTEGER :: errors = 0\n  LOGICAL IS_POSSIBLE\n\n  !Initilization\n  SEEDDIM(1) = 1\n# ifdef SEED\n  SEEDDIM(1) = SEED\n# endif\n  CALL RANDOM_SEED(PUT=SEEDDIM)\n\n  CALL RANDOM_NUMBER(randoms)\n  DO x = 1, LOOPCOUNT\n    DO y = 1, 10\n      IF (randoms(x, y) > .5) THEN\n        a(x, y) = .TRUE.\n      ELSE\n        a(x, y) = .FALSE.\n      END IF\n    END DO\n  END DO\n\n  totals = .FALSE.\n  totals_comparison = .FALSE.\n\n  !$acc data copyin(a(1:LOOPCOUNT,1:10)) copy(totals(1:LOOPCOUNT)) copyout(b(1:LOOPCOUNT,1:10))\n    !$acc parallel\n      !$acc loop\n      DO x = 1, LOOPCOUNT\n        DO y = 1, 10\n          !$acc atomic capture\n            totals(x) = totals(x) .EQV. a(x, y)\n            b(x, y) = totals(x)\n          !$acc end atomic\n        END DO\n      END DO\n    !$acc end parallel\n  !$acc end data\n\n  DO x = 1, LOOPCOUNT\n    DO y = 1, 10\n      totals_comparison(x) = totals_comparison(x) .EQV. a(x, y)\n    END DO\n  END DO\n\n  DO x = 1, LOOPCOUNT\n    DO y = 1, 10\n      passed_a(y) = a(x, y)\n      passed_b(y) = b(x, y)\n    END DO\n    init = .FALSE.\n    IF (IS_POSSIBLE(passed_a, passed_b, 10, init) .EQV. .FALSE.) THEN\n      errors = errors + 1\n    END IF\n  END DO\n\n  DO x = 1, LOOPCOUNT\n    IF (totals_comparison(x) .NEQV. totals(x)) THEN\n      errors = errors + 1\n      WRITE(*, *) totals_comparison(x)\n    END IF\n  END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "construct-independent",
                            "atomic"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_capture_x_minus_expr_assign.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:construct-independent,atomic,V:2.0-2.7\n      LOGICAL FUNCTION test1()\n  IMPLICIT NONE\n  INCLUDE \"acc_testsuite.Fh\"\n  INTEGER :: x, y !Iterators\n  LOGICAL IS_POSSIBLE\n  LOGICAL IS_POSSIBLE_2\n  REAL(8),DIMENSION(LOOPCOUNT, 10):: a, b !Data\n  REAL(8),DIMENSION(LOOPCOUNT):: totals\n  REAL(8),DIMENSION(10):: passed_a, passed_b\n  REAL(8):: init\n  INTEGER :: errors = 0\n\n  !Initilization\n  SEEDDIM(1) = 1\n# ifdef SEED\n  SEEDDIM(1) = SEED\n# endif\n  CALL RANDOM_SEED(PUT=SEEDDIM)\n\n  CALL RANDOM_NUMBER(a)\n\n  totals = 0\n\n  !$acc data copyin(a(1:LOOPCOUNT, 1:10)) copy(totals(1:LOOPCOUNT)) copyout(b(1:LOOPCOUNT, 1:10))\n    !$acc parallel\n      !$acc loop\n      DO x = 1, LOOPCOUNT\n        DO y = 1, 10\n          !$acc atomic capture\n            totals(x) = totals(x) - a(x, y)\n            b(x, y) = totals(x)\n          !$acc end atomic\n        END DO\n      END DO\n    !$acc end parallel\n  !$acc end data\n\n  DO x = 1, LOOPCOUNT\n    DO y = 1, 10\n      passed_a(y) = a(x, y)\n    END DO\n    IF (IS_POSSIBLE(passed_a, totals(x), 10, 0) .eqv. .FALSE.) THEN\n      errors = errors + 1\n    END IF\n  END DO\n\n  DO x = 1, LOOPCOUNT\n    DO y = 1, 10\n      passed_a(y) = a(x, y)\n      passed_b(y) = b(x, y)\n    END DO\n    init = 0\n    IF (IS_POSSIBLE_2(passed_a, passed_b, 10, init) .EQV. .FALSE.) THEN\n      errors = errors + 1\n    END IF\n  END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "construct-independent",
                            "atomic"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_capture_x_neqv_expr_assign.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:construct-independent,atomic,V:2.0-2.7\n      LOGICAL FUNCTION test1()\n  IMPLICIT NONE\n  INCLUDE \"acc_testsuite.Fh\"\n  INTEGER :: x, y !Iterators\n  REAL(8),DIMENSION(LOOPCOUNT, 10):: randoms\n  LOGICAL,DIMENSION(LOOPCOUNT, 10):: a, b !Data\n  LOGICAL,DIMENSION(10):: passed_a, passed_b\n  LOGICAL,DIMENSION(LOOPCOUNT):: totals, totals_comparison\n  LOGICAL IS_POSSIBLE\n  INTEGER :: errors = 0\n\n  !Initilization\n  SEEDDIM(1) = 1\n# ifdef SEED\n  SEEDDIM(1) = SEED\n# endif\n  CALL RANDOM_SEED(PUT=SEEDDIM)\n\n  CALL RANDOM_NUMBER(randoms)\n  DO x = 1, LOOPCOUNT\n    DO y = 1, 10\n      IF (randoms(x, y) > .5) THEN\n        a(x, y) = .TRUE.\n      ELSE\n        a(x, y) = .FALSE.\n      END IF\n    END DO\n  END DO\n\n  totals = .FALSE.\n  totals_comparison = .FALSE.\n\n  !$acc data copyin(a(1:LOOPCOUNT,1:10)) copy(totals(1:LOOPCOUNT)) copyout(b(1:LOOPCOUNT,1:10))\n    !$acc parallel\n      !$acc loop\n      DO x = 1, LOOPCOUNT\n        DO y = 1, 10\n          !$acc atomic capture\n            totals(x) = totals(x) .NEQV. a(x, y)\n            b(x, y) = totals(x)\n          !$acc end atomic\n        END DO\n      END DO\n    !$acc end parallel\n  !$acc end data\n\n  DO x = 1, LOOPCOUNT\n    DO y = 1, 10\n      totals_comparison(x) = totals_comparison(x) .NEQV. a(x, y)\n    END DO\n  END DO\n\n  DO x = 1, LOOPCOUNT\n    IF (totals_comparison(x) .NEQV. totals(x)) THEN\n      errors = errors + 1\n      WRITE(*, *) totals_comparison(x)\n    END IF\n  END DO\n\n  DO x = 1, LOOPCOUNT\n    DO y = 1, 10\n      passed_a(y) = a(x, y)\n      passed_b(y) = b(x, y)\n    END DO\n    IF (IS_POSSIBLE(passed_a, passed_b, 10, .FALSE.) .eqv. .FALSE.) THEN\n      errors = errors + 1\n    END IF\n  END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "construct-independent",
                            "atomic"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_capture_x_or_expr_assign.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:construct-independent,atomic,V:2.0-2.7\n      LOGICAL FUNCTION test1()\n  IMPLICIT NONE\n  INCLUDE \"acc_testsuite.Fh\"\n  INTEGER :: x, y !Iterators\n  REAL(8),DIMENSION(LOOPCOUNT, 10):: randoms\n  LOGICAL,DIMENSION(LOOPCOUNT, 10):: a, b !Data\n  LOGICAL,DIMENSION(LOOPCOUNT):: totals, totals_comparison\n  LOGICAL,DIMENSION(10):: passed_a, passed_b\n  LOGICAL IS_POSSIBLE\n  LOGICAL:: init\n  INTEGER :: errors = 0\n\n  !Initilization\n  SEEDDIM(1) = 1\n# ifdef SEED\n  SEEDDIM(1) = SEED\n# endif\n  CALL RANDOM_SEED(PUT=SEEDDIM)\n\n  CALL RANDOM_NUMBER(randoms)\n  DO x = 1, LOOPCOUNT\n    DO y = 1, 10\n      IF (randoms(x, y) > .933) THEN\n        a(x, y) = .TRUE.\n      ELSE\n        a(x, y) = .FALSE.\n      END IF\n    END DO\n  END DO\n\n  totals = .FALSE.\n  totals_comparison = .FALSE.\n\n  !$acc data copyin(a(1:LOOPCOUNT,1:10)) copy(totals(1:LOOPCOUNT)) copyout(b(1:LOOPCOUNT,1:10))\n    !$acc parallel\n      !$acc loop\n      DO x = 1, LOOPCOUNT\n        DO y = 1, 10\n          !$acc atomic capture\n            totals(x) = totals(x) .OR. a(x, y)\n            b(x, y) = totals(x)\n          !$acc end atomic\n        END DO\n      END DO\n    !$acc end parallel\n  !$acc end data\n\n  DO x = 1, LOOPCOUNT\n    DO y = 1, 10\n      totals_comparison(x) = totals_comparison(x) .OR. a(x, y)\n    END DO\n  END DO\n\n  DO x = 1, LOOPCOUNT\n    IF (totals_comparison(x) .NEQV. totals(x)) THEN\n      errors = errors + 1\n      WRITE(*, *) totals_comparison(x)\n    END IF\n  END DO\n\n  DO x = 1, LOOPCOUNT\n    DO y = 1, 10\n      passed_a(y) = a(x, y)\n      passed_b(y) = b(x, y)\n    END DO\n    init = .FALSE.\n    IF (IS_POSSIBLE(passed_a, passed_b, 10, init) .eqv. .FALSE.) THEN\n      errors = errors + 1\n    END IF\n  END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "construct-independent",
                            "atomic"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_capture_x_plus_expr_assign.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:construct-independent,atomic,V:2.0-2.7\n      LOGICAL FUNCTION test1()\n  IMPLICIT NONE\n  INCLUDE \"acc_testsuite.Fh\"\n  INTEGER :: x, y !Iterators\n  REAL(8),DIMENSION(LOOPCOUNT, 10):: a, b !Data\n  REAL(8),DIMENSION(LOOPCOUNT):: totals, totals_comparison\n  REAL(8),DIMENSION(10):: passed_a, passed_b\n  REAL(8):: init\n  LOGICAL IS_POSSIBLE\n  INTEGER :: errors = 0\n\n  !Initilization\n  SEEDDIM(1) = 1\n# ifdef SEED\n  SEEDDIM(1) = SEED\n# endif\n  CALL RANDOM_SEED(PUT=SEEDDIM)\n\n  CALL RANDOM_NUMBER(a)\n\n  totals = 0\n  totals_comparison = 0\n\n  !$acc data copyin(a(1:LOOPCOUNT, 1:10)) copy(totals(1:LOOPCOUNT)) copyout(b(1:LOOPCOUNT,1:10))\n    !$acc parallel\n      !$acc loop\n      DO x = 1, LOOPCOUNT\n        DO y = 1, 10\n          !$acc atomic capture\n            totals(x) = totals(x) + a(x, y)\n            b(x, y) = totals(x)\n          !$acc end atomic\n        END DO\n      END DO\n    !$acc end parallel\n  !$acc end data\n  DO x = 1, LOOPCOUNT\n    DO y = 1, 10\n      totals_comparison(x) = totals_comparison(x) + a(x, y)\n    END DO\n  END DO\n\n  DO x = 1, LOOPCOUNT\n    IF (totals_comparison(x) .NE. totals(x)) THEN\n      errors = errors + 1\n      WRITE(*, *) totals_comparison(x)\n    END IF\n  END DO\n\n  DO x = 1, LOOPCOUNT\n    DO y = 1, 10\n      passed_a(y) = a(x, y)\n      passed_b(y) = b(x, y)\n    END DO\n    init = 0\n    IF (IS_POSSIBLE(passed_a, passed_b, 10, init) .eqv. .FALSE.) THEN\n      errors = errors + 1\n    END IF\n  END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "construct-independent",
                            "atomic"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_capture_x_times_expr_assign.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:construct-independent,atomic,V:2.0-2.7\n      LOGICAL FUNCTION test1()\n  IMPLICIT NONE\n  INCLUDE \"acc_testsuite.Fh\"\n  INTEGER :: x, y !Iterators\n  REAL(8),DIMENSION(LOOPCOUNT, 10):: a, b !Data\n  REAL(8),DIMENSION(LOOPCOUNT):: totals, totals_comparison\n  REAL(8),DIMENSION(10):: passed_a, passed_b\n  REAL(8):: init\n  LOGICAL IS_POSSIBLE\n  INTEGER :: errors = 0\n\n  !Initilization\n  SEEDDIM(1) = 1\n# ifdef SEED\n  SEEDDIM(1) = SEED\n# endif\n  CALL RANDOM_SEED(PUT=SEEDDIM)\n\n  CALL RANDOM_NUMBER(a)\n\n  totals = 1\n  totals_comparison = 1\n\n  !$acc data copyin(a(1:LOOPCOUNT, 1:10)) copy(totals(1:LOOPCOUNT)) copyout(b(1:LOOPCOUNT,1:10))\n    !$acc parallel\n      !$acc loop\n      DO x = 1, LOOPCOUNT\n        DO y = 1, 10\n          !$acc atomic capture\n            totals(x) = totals(x) * a(x, y)\n            b(x, y) = totals(x)\n          !$acc end atomic\n        END DO\n      END DO\n    !$acc end parallel\n  !$acc end data\n  DO x = 1, LOOPCOUNT\n    DO y = 1, 10\n      totals_comparison(x) = totals_comparison(x) * a(x, y)\n    END DO\n  END DO\n\n  DO x = 1, LOOPCOUNT\n    IF (totals_comparison(x) .NE. totals(x)) THEN\n      errors = errors + 1\n      WRITE(*, *) totals_comparison(x)\n    END IF\n  END DO\n\n  DO x = 1, LOOPCOUNT\n    DO y = 1, 10\n      passed_a(y) = a(x, y)\n      passed_b(y) = b(x, y)\n    END DO\n    init = 1\n    IF (IS_POSSIBLE(passed_a, passed_b, 10, init) .eqv. .TRUE.) THEN\n      errors = errors + 1\n    END IF\n  END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "construct-independent",
                            "atomic"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_divided_equals.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:atomic,construct-independent,V:2.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t *a = (real_t *)malloc(n * sizeof(real_t));\n    real_t *b = (real_t *)malloc(n * sizeof(real_t));\n    real_t *totals = (real_t *)malloc((n/10 + 1) * sizeof(real_t));\n    real_t *totals_comparison = (real_t *)malloc((n/10 + 1) * sizeof(real_t));\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n    }\n    for (int x = 0; x < n/10 + 1; ++x){\n        totals[x] = 1;\n        totals_comparison[x] = 1;\n    }\n\n    #pragma acc data copyin(a[0:n], b[0:n]) copy(totals[0:n/10 + 1])\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                #pragma acc atomic\n                    totals[x%(n/10 + 1)] /= (a[x] + b[x]);\n            }\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        totals_comparison[x%(n/10 + 1)] /= a[x] + b[x];\n    }\n    for (int x = 0; x < 10; ++x){\n        if (fabs(totals_comparison[x] - totals[x]) > PRECISION){\n            err += 1;\n            break;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "atomic",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_expr_and_x.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:construct-independent,atomic,V:2.0-2.7\n      LOGICAL FUNCTION test1()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x, y !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT, 10):: randoms\n        LOGICAL,DIMENSION(LOOPCOUNT, 10):: a !Data\n        LOGICAL,DIMENSION(LOOPCOUNT):: totals, totals_comparison\n        INTEGER :: errors = 0\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(randoms)\n        DO x = 1, LOOPCOUNT\n          DO y = 1, 10\n            IF (randoms(x, y) < .933) THEN\n              a(x, y) = .TRUE.\n            ELSE\n              a(x, y) = .FALSE.\n            END IF\n          END DO\n        END DO\n\n        totals = .FALSE.\n        totals_comparison = .FALSE.\n\n        !$acc data copyin(a(1:LOOPCOUNT,1:10)) copy(totals(1:LOOPCOUNT))\n          !$acc parallel\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              DO y = 1, 10\n                !$acc atomic\n                  totals(x) = a(x, y) .AND. totals(x)\n              END DO\n            END DO\n          !$acc end parallel\n        !$acc end data\n\n        DO x = 1, LOOPCOUNT\n          DO y = 1, 10\n            totals_comparison(x) = totals_comparison(x) .AND. a(x, y)\n          END DO\n        END DO\n\n        DO x = 1, LOOPCOUNT\n          IF (totals_comparison(x) .NEQV. totals(x)) THEN\n            errors = errors + 1\n            WRITE(*, *) totals_comparison(x)\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "construct-independent",
                            "atomic"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_expr_and_x_end.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:construct-independent,atomic,V:2.0-2.7\n      LOGICAL FUNCTION test1()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x, y !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT, 10):: randoms\n        LOGICAL,DIMENSION(LOOPCOUNT, 10):: a !Data\n        LOGICAL,DIMENSION(LOOPCOUNT):: totals, totals_comparison\n        INTEGER :: errors = 0\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(randoms)\n        DO x = 1, LOOPCOUNT\n          DO y = 1, 10\n            IF (randoms(x, y) < .933) THEN\n              a(x, y) = .TRUE.\n            ELSE\n              a(x, y) = .FALSE.\n            END IF\n          END DO\n        END DO\n\n        totals = .FALSE.\n        totals_comparison = .FALSE.\n\n        !$acc data copyin(a(1:LOOPCOUNT,1:10)) copy(totals(1:LOOPCOUNT))\n          !$acc parallel\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              DO y = 1, 10\n                !$acc atomic\n                  totals(x) = a(x, y) .AND. totals(x)\n                !$acc end atomic\n              END DO\n            END DO\n          !$acc end parallel\n        !$acc end data\n\n        DO x = 1, LOOPCOUNT\n          DO y = 1, 10\n            totals_comparison(x) = totals_comparison(x) .AND. a(x, y)\n          END DO\n        END DO\n\n        DO x = 1, LOOPCOUNT\n          IF (totals_comparison(x) .NEQV. totals(x)) THEN\n            errors = errors + 1\n            WRITE(*, *) totals_comparison(x)\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "construct-independent",
                            "atomic"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_expr_bitand_x.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:atomic,construct-independent,V:2.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    int  *a = (int *)malloc(n * sizeof(int));\n    int *totals = (int *)malloc((n/10 + 1) * sizeof(int));\n    int *totals_comparison = (int *)malloc((n/10 + 1) * sizeof(int));\n\n    for (int x = 0; x < n; ++x){\n        for (int y = 0; y < 8; ++y){\n            if (rand()/(real_t)(RAND_MAX) < .933){ //.933 gets close to a 50/50 distribution for a collescence of 10 values\n                a[x] += 1<<y;\n            }\n        }\n    }\n    for (int x = 0; x < n/10 + 1; ++x){\n        for (int y = 0; y < 8; ++y){\n            totals[x] +=  1<<y;\n            totals_comparison[x] += 1<<y;\n        }\n\n    }\n\n    #pragma acc data copyin(a[0:n]) copy(totals[0:n/10 + 1])\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                #pragma acc atomic\n                    totals[x%(n/10 + 1)] = a[x] & totals[x%(n/10 + 1)];\n            }\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        totals_comparison[x%(n/10 + 1)] &= a[x];\n    }\n    for (int x = 0; x < 10; ++x){\n        if (fabs(totals_comparison[x] - totals[x]) > PRECISION){\n            err += 1;\n            break;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "atomic",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_expr_bitor_x.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:atomic,construct-independent,V:2.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    int  *a = (int *)malloc(n * sizeof(int));\n    int *totals = (int *)malloc((n/10 + 1) * sizeof(int));\n    int *totals_comparison = (int *)malloc((n/10 + 1) * sizeof(int));\n\n    for (int x = 0; x < n; ++x){\n        for (int y = 0; y < 8; ++y){\n            if (rand()/(real_t)(RAND_MAX) > .933){ //.933 gets close to a 50/50 distribution for a collescence of 10 values\n                a[x] += 1<<y;\n            }\n        }\n    }\n    for (int x = 0; x < n/10 + 1; ++x){\n        totals[x] = 0;\n\n    }\n\n    #pragma acc data copyin(a[0:n]) copy(totals[0:n/10 + 1])\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                #pragma acc atomic\n                    totals[x%(n/10 + 1)] = totals[x%(n/10 + 1)] | a[x];\n            }\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        totals_comparison[x%(n/10 + 1)] |= a[x];\n    }\n    for (int x = 0; x < 10; ++x){\n        if (fabs(totals_comparison[x] - totals[x]) > PRECISION){\n            err += 1;\n            break;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "atomic",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_expr_bitxor_x.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:atomic,construct-independent,V:2.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    int  *a = (int *)malloc(n * sizeof(int));\n    int *totals = (int *)malloc((n/10 + 1) * sizeof(int));\n    int *totals_comparison = (int *)malloc((n/10 + 1) * sizeof(int));\n\n    for (int x = 0; x < n; ++x){\n        for (int y = 0; y < 8; ++y){\n            if (rand()/(real_t)(RAND_MAX) > .5){\n                a[x] += 1<<y;\n            }\n        }\n    }\n    for (int x = 0; x < n/10 + 1; ++x){\n        totals[x] = 0;\n        totals_comparison[x] = 0;\n    }\n\n    #pragma acc data copyin(a[0:n]) copy(totals[0:n/10 + 1])\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                #pragma acc atomic\n                    totals[x%(n/10 + 1)] = a[x] ^ totals[x%(n/10 + 1)];\n            }\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        totals_comparison[x%(n/10 + 1)] ^= a[x];\n    }\n    for (int x = 0; x < 10; ++x){\n        if (fabs(totals_comparison[x] - totals[x]) > PRECISION){\n            err += 1;\n            break;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "atomic",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_expr_divided_x.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:construct-independent,atomic,V:2.0-2.7\n      LOGICAL FUNCTION test1()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x, y !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT, 10):: a !Data\n        REAL(8),DIMENSION(LOOPCOUNT):: totals\n        REAL(8),DIMENSION(10):: passed\n        INTEGER :: errors = 0\n        LOGICAL IS_POSSIBLE\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(a)\n\n        totals = 1\n\n        !$acc data copyin(a(1:LOOPCOUNT, 1:10)) copy(totals(1:LOOPCOUNT))\n          !$acc parallel\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              DO y = 1, 10\n                !$acc atomic\n                  totals(x) = a(x, y) / totals(x)\n              END DO\n            END DO\n          !$acc end parallel\n        !$acc end data\n\n\n        DO x = 1, LOOPCOUNT\n          DO y = 1, 10\n            passed(y) = a(x, y)\n          END DO\n          IF (IS_POSSIBLE(passed, totals(x), 10, 1) .eqv. .FALSE.) THEN\n            errors = errors + 1\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "construct-independent",
                            "atomic"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_expr_divided_x.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:atomic,construct-independent,V:2.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t *a = (real_t *)malloc(n * sizeof(real_t));\n    real_t *b = (real_t *)malloc(n * sizeof(real_t));\n    real_t *totals = (real_t *)malloc((n/10 + 1) * sizeof(real_t));\n    real_t * passed = (real_t *)malloc(10 * sizeof(real_t));\n    int indexer;\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n    }\n    for (int x = 0; x < n/10 + 1; ++x){\n        totals[x] = 1;\n    }\n\n    #pragma acc data copyin(a[0:n], b[0:n]) copy(totals[0:n/10 + 1])\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                #pragma acc atomic\n                    totals[x%(n/10 + 1)] = (a[x] + b[x]) / totals[x%(n/10 + 1)];\n            }\n        }\n    }\n\n\n    for (int x = 0; x < (n/10 + 1); ++x){\n        indexer = x;\n        while (indexer < n){\n            passed[indexer/(n/10 + 1)] = (a[x] + b[x]);\n            indexer += (n/10 + 1);\n        }\n        if (!(possible_result(passed, 10, 1, totals[x]))){\n            err += 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "atomic",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_expr_divided_x_end.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:construct-independent,atomic,V:2.0-2.7\n      LOGICAL FUNCTION test1()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x, y !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT, 10):: a !Data\n        REAL(8),DIMENSION(LOOPCOUNT):: totals\n        REAL(8),DIMENSION(10):: passed\n        INTEGER :: errors = 0\n        LOGICAL IS_POSSIBLE\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(a)\n\n        totals = 1\n\n        !$acc data copyin(a(1:LOOPCOUNT, 1:10)) copy(totals(1:LOOPCOUNT))\n          !$acc parallel\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              DO y = 1, 10\n                !$acc atomic\n                  totals(x) = a(x, y) / totals(x)\n                !$acc end atomic\n              END DO\n            END DO\n          !$acc end parallel\n        !$acc end data\n\n\n        DO x = 1, LOOPCOUNT\n          DO y = 1, 10\n            passed(y) = a(x, y)\n          END DO\n          IF (IS_POSSIBLE(passed, totals(x), 10, 1) .eqv. .FALSE.) THEN\n            errors = errors + 1\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "construct-independent",
                            "atomic"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_expr_eqv_x.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:construct-independent,atomic,V:2.0-2.7\n      LOGICAL FUNCTION test1()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x, y !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT, 10):: randoms\n        LOGICAL,DIMENSION(LOOPCOUNT, 10):: a !Data\n        LOGICAL,DIMENSION(LOOPCOUNT):: totals, totals_comparison\n        INTEGER :: errors = 0\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(randoms)\n        DO x = 1, LOOPCOUNT\n          DO y = 1, 10\n            IF (randoms(x, y) > .5) THEN\n              a(x, y) = .TRUE.\n            ELSE\n              a(x, y) = .FALSE.\n            END IF\n          END DO\n        END DO\n\n        totals = .FALSE.\n        totals_comparison = .FALSE.\n\n        !$acc data copyin(a(1:LOOPCOUNT,1:10)) copy(totals(1:LOOPCOUNT))\n          !$acc parallel\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              DO y = 1, 10\n                !$acc atomic\n                  totals(x) = a(x, y) .EQV. totals(x)\n              END DO\n            END DO\n          !$acc end parallel\n        !$acc end data\n\n        DO x = 1, LOOPCOUNT\n          DO y = 1, 10\n            totals_comparison(x) = totals_comparison(x) .EQV. a(x, y)\n          END DO\n        END DO\n\n        DO x = 1, LOOPCOUNT\n          IF (totals_comparison(x) .NEQV. totals(x)) THEN\n            errors = errors + 1\n            WRITE(*, *) totals_comparison(x)\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "construct-independent",
                            "atomic"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_expr_eqv_x_end.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:construct-independent,atomic,V:2.0-2.7\n      LOGICAL FUNCTION test1()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x, y !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT, 10):: randoms\n        LOGICAL,DIMENSION(LOOPCOUNT, 10):: a !Data\n        LOGICAL,DIMENSION(LOOPCOUNT):: totals, totals_comparison\n        INTEGER :: errors = 0\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(randoms)\n        DO x = 1, LOOPCOUNT\n          DO y = 1, 10\n            IF (randoms(x, y) > .5) THEN\n              a(x, y) = .TRUE.\n            ELSE\n              a(x, y) = .FALSE.\n            END IF\n          END DO\n        END DO\n\n        totals = .FALSE.\n        totals_comparison = .FALSE.\n\n        !$acc data copyin(a(1:LOOPCOUNT,1:10)) copy(totals(1:LOOPCOUNT))\n          !$acc parallel\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              DO y = 1, 10\n                !$acc atomic\n                  totals(x) = a(x, y) .EQV. totals(x)\n                !$acc end atomic\n              END DO\n            END DO\n          !$acc end parallel\n        !$acc end data\n\n        DO x = 1, LOOPCOUNT\n          DO y = 1, 10\n            totals_comparison(x) = totals_comparison(x) .EQV. a(x, y)\n          END DO\n        END DO\n\n        DO x = 1, LOOPCOUNT\n          IF (totals_comparison(x) .NEQV. totals(x)) THEN\n            errors = errors + 1\n            WRITE(*, *) totals_comparison(x)\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "construct-independent",
                            "atomic"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_expr_lshift_x.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:atomic,construct-independent,V:2.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    unsigned int *a = (unsigned int *)malloc(3 * n * sizeof(int));\n    unsigned int *b = (unsigned int *)malloc(n * sizeof(int));\n    int orders[18] = {1, 2, 0, 1, 0, 2, 2, 1, 0, 2, 0, 1, 0, 1, 2, 0, 2, 1};\n    int result;\n\n    for (int x = 0; x < n; ++x){\n        for (int y = 0; y < 3; ++y){\n            a[x * 3 + y] = (int) (rand() / (unsigned int) (RAND_MAX / 4));\n        }\n        b[x] = 0;\n    }\n\n    #pragma acc data copyin(a[0:3 * n]) copy(b[0:n])\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                #pragma acc loop\n                for (int y = 0; y < 3; ++y){\n                    #pragma acc atomic\n                        b[x] = a[x * 3 + y] << b[x];\n                }\n            }\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        for (int y = 0; y < 6; ++y){\n            result = 0;\n            for (int z = 0; z < 3; ++z){\n                result = a[x * 3 + orders[y * 3 + z]] << result;\n            }\n            if (result == b[x]){\n                break;\n            }\n        }\n        if (result != b[x]){\n            err += 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "atomic",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_expr_minus_x.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:construct-independent,atomic,V:2.0-2.7\n      LOGICAL FUNCTION test1()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x, y !Iterators\n        LOGICAL IS_POSSIBLE\n        REAL(8),DIMENSION(LOOPCOUNT, 10):: a !Data\n        REAL(8),DIMENSION(LOOPCOUNT):: totals\n        INTEGER :: errors = 0\n        REAL(8),DIMENSION(10):: passed\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(a)\n\n        totals = 0\n\n        !$acc data copyin(a(1:LOOPCOUNT, 1:10)) copy(totals(1:LOOPCOUNT))\n          !$acc parallel\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              DO y = 1, 10\n                !$acc atomic\n                  totals(x) = a(x, y) - totals(x)\n              END DO\n            END DO\n          !$acc end parallel\n        !$acc end data\n\n        DO x = 1, LOOPCOUNT\n          DO y = 1, 10\n            passed(y) = a(x, y)\n          END DO\n          IF (IS_POSSIBLE(passed, totals(x), 10, 0) .eqv. .FALSE.) THEN\n            errors = errors + 1\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "construct-independent",
                            "atomic"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_expr_minus_x.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:atomic,construct-independent,V:2.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t *a = (real_t *)malloc(n * sizeof(real_t));\n    real_t *totals = (real_t *)malloc(((n/10) + 1) * sizeof(real_t));\n    int indexer = 0;\n    real_t * passed = (real_t *)malloc(10 * sizeof(real_t));\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n    }\n    for (int x = 0; x < (n/10) + 1; ++x){\n        totals[x] = 0;\n    }\n\n    #pragma acc data copyin(a[0:n]) copy(totals[0:(n/10) + 1])\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                #pragma acc atomic\n                    totals[x%((int) (n/10) + 1)] = a[x] - totals[x%((int) (n/10) + 1)];\n            }\n        }\n    }\n    for (int x = 0; x < (n/10) + 1; ++x){\n        indexer = x;\n        while (indexer < n){\n            passed[indexer/((int) (n/10) + 1)] = a[indexer];\n            indexer += (n/10) + 1;\n        }\n        if (!(possible_result(passed, 10, 0, totals[x]))){\n            err += 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "atomic",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_expr_minus_x_end.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:construct-independent,atomic,V:2.0-2.7\n      LOGICAL FUNCTION test1()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x, y !Iterators\n        LOGICAL IS_POSSIBLE\n        REAL(8),DIMENSION(LOOPCOUNT, 10):: a !Data\n        REAL(8),DIMENSION(LOOPCOUNT):: totals\n        INTEGER :: errors = 0\n        REAL(8),DIMENSION(10):: passed\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(a)\n\n        totals = 0\n\n        !$acc data copyin(a(1:LOOPCOUNT, 1:10)) copy(totals(1:LOOPCOUNT))\n          !$acc parallel\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              DO y = 1, 10\n                !$acc atomic\n                  totals(x) = a(x, y) - totals(x)\n                !$acc end atomic\n              END DO\n            END DO\n          !$acc end parallel\n        !$acc end data\n\n        DO x = 1, LOOPCOUNT\n          DO y = 1, 10\n            passed(y) = a(x, y)\n          END DO\n          IF (IS_POSSIBLE(passed, totals(x), 10, 0) .eqv. .FALSE.) THEN\n            errors = errors + 1\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "construct-independent",
                            "atomic"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_expr_multiply_x.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:atomic,construct-independent,V:2.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t *a = (real_t *)malloc(n * sizeof(real_t));\n    real_t *b = (real_t *)malloc(n * sizeof(real_t));\n    real_t *totals = (real_t *)malloc((n/10 + 1) * sizeof(real_t));\n    real_t *totals_comparison = (real_t *)malloc((n/10 + 1) * sizeof(real_t));\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n    }\n    for (int x = 0; x < n/10 + 1; ++x){\n        totals[x] = 1;\n        totals_comparison[x] = 1;\n    }\n\n    #pragma acc data copyin(a[0:n], b[0:n]) copy(totals[0:n/10 + 1])\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                #pragma acc atomic\n                    totals[x%(n/10 + 1)] = (a[x] + b[x]) * totals[x%(n/10 + 1)];\n            }\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        totals_comparison[x%(n/10 + 1)] *= a[x] + b[x];\n    }\n    for (int x = 0; x < 10; ++x){\n        if (fabs(totals_comparison[x] - totals[x]) > PRECISION * totals_comparison[x]){\n            err += 1;\n            break;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "atomic",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_expr_neqv_x.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:construct-independent,atomic,V:2.0-2.7\n      LOGICAL FUNCTION test1()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x, y !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT, 10):: randoms\n        LOGICAL,DIMENSION(LOOPCOUNT, 10):: a !Data\n        LOGICAL,DIMENSION(LOOPCOUNT):: totals, totals_comparison\n        INTEGER :: errors = 0\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(randoms)\n        DO x = 1, LOOPCOUNT\n          DO y = 1, 10\n            IF (randoms(x, y) > .5) THEN\n              a(x, y) = .TRUE.\n            ELSE\n              a(x, y) = .FALSE.\n            END IF\n          END DO\n        END DO\n\n        totals = .FALSE.\n        totals_comparison = .FALSE.\n\n        !$acc data copyin(a(1:LOOPCOUNT,1:10)) copy(totals(1:LOOPCOUNT))\n          !$acc parallel\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              DO y = 1, 10\n                !$acc atomic\n                  totals(x) = a(x, y) .NEQV. totals(x)\n              END DO\n            END DO\n          !$acc end parallel\n        !$acc end data\n\n        DO x = 1, LOOPCOUNT\n          DO y = 1, 10\n            totals_comparison(x) = totals_comparison(x) .NEQV. a(x, y)\n          END DO\n        END DO\n\n        DO x = 1, LOOPCOUNT\n          IF (totals_comparison(x) .NE. totals(x)) THEN\n            errors = errors + 1\n            WRITE(*, *) totals_comparison(x)\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "construct-independent",
                            "atomic"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_expr_neqv_x_end.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:construct-independent,atomic,V:2.0-2.7\n      LOGICAL FUNCTION test1()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x, y !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT, 10):: randoms\n        LOGICAL,DIMENSION(LOOPCOUNT, 10):: a !Data\n        LOGICAL,DIMENSION(LOOPCOUNT):: totals, totals_comparison\n        INTEGER :: errors = 0\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(randoms)\n        DO x = 1, LOOPCOUNT\n          DO y = 1, 10\n            IF (randoms(x, y) > .5) THEN\n              a(x, y) = .TRUE.\n            ELSE\n              a(x, y) = .FALSE.\n            END IF\n          END DO\n        END DO\n\n        totals = .FALSE.\n        totals_comparison = .FALSE.\n\n        !$acc data copyin(a(1:LOOPCOUNT,1:10)) copy(totals(1:LOOPCOUNT))\n          !$acc parallel\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              DO y = 1, 10\n                !$acc atomic\n                  totals(x) = a(x, y) .NEQV. totals(x)\n                !$acc end atomic\n              END DO\n            END DO\n          !$acc end parallel\n        !$acc end data\n\n        DO x = 1, LOOPCOUNT\n          DO y = 1, 10\n            totals_comparison(x) = totals_comparison(x) .NEQV. a(x, y)\n          END DO\n        END DO\n\n        DO x = 1, LOOPCOUNT\n          IF (totals_comparison(x) .NE. totals(x)) THEN\n            errors = errors + 1\n            WRITE(*, *) totals_comparison(x)\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "construct-independent",
                            "atomic"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_expr_or_x.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:construct-independent,atomic,V:2.0-2.7\n      LOGICAL FUNCTION test1()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x, y !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT, 10):: randoms\n        LOGICAL,DIMENSION(LOOPCOUNT, 10):: a !Data\n        LOGICAL,DIMENSION(LOOPCOUNT):: totals, totals_comparison\n        INTEGER :: errors = 0\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(randoms)\n        DO x = 1, LOOPCOUNT\n          DO y = 1, 10\n            IF (randoms(x, y) > .933) THEN\n              a(x, y) = .TRUE.\n            ELSE\n              a(x, y) = .FALSE.\n            END IF\n          END DO\n        END DO\n\n        totals = .FALSE.\n        totals_comparison = .FALSE.\n\n        !$acc data copyin(a(1:LOOPCOUNT,1:10)) copy(totals(1:LOOPCOUNT))\n          !$acc parallel\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              DO y = 1, 10\n                !$acc atomic\n                  totals(x) = a(x, y) .OR. totals(x)\n              END DO\n            END DO\n          !$acc end parallel\n        !$acc end data\n\n        DO x = 1, LOOPCOUNT\n          DO y = 1, 10\n            totals_comparison(x) = totals_comparison(x) .OR. a(x, y)\n          END DO\n        END DO\n\n        DO x = 1, LOOPCOUNT\n          IF (totals_comparison(x) .NEQV. totals(x)) THEN\n            errors = errors + 1\n            WRITE(*, *) totals_comparison(x)\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "construct-independent",
                            "atomic"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_expr_or_x_end.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:construct-independent,atomic,V:2.0-2.7\n      LOGICAL FUNCTION test1()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x, y !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT, 10):: randoms\n        LOGICAL,DIMENSION(LOOPCOUNT, 10):: a !Data\n        LOGICAL,DIMENSION(LOOPCOUNT):: totals, totals_comparison\n        INTEGER :: errors = 0\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(randoms)\n        DO x = 1, LOOPCOUNT\n          DO y = 1, 10\n            IF (randoms(x, y) > .933) THEN\n              a(x, y) = .TRUE.\n            ELSE\n              a(x, y) = .FALSE.\n            END IF\n          END DO\n        END DO\n\n        totals = .FALSE.\n        totals_comparison = .FALSE.\n\n        !$acc data copyin(a(1:LOOPCOUNT,1:10)) copy(totals(1:LOOPCOUNT))\n          !$acc parallel\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              DO y = 1, 10\n                !$acc atomic\n                  totals(x) = a(x, y) .OR. totals(x)\n                !$acc end atomic\n              END DO\n            END DO\n          !$acc end parallel\n        !$acc end data\n\n        DO x = 1, LOOPCOUNT\n          DO y = 1, 10\n            totals_comparison(x) = totals_comparison(x) .OR. a(x, y)\n          END DO\n        END DO\n\n        DO x = 1, LOOPCOUNT\n          IF (totals_comparison(x) .NEQV. totals(x)) THEN\n            errors = errors + 1\n            WRITE(*, *) totals_comparison(x)\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "construct-independent",
                            "atomic"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_expr_plus_x.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:construct-independent,atomic,V:2.0-2.7\n      LOGICAL FUNCTION test1()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x, y !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT, 10):: a !Data\n        REAL(8),DIMENSION(LOOPCOUNT):: totals, totals_comparison\n        INTEGER :: errors = 0\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(a)\n\n        totals = 0\n        totals_comparison = 0\n\n        !$acc data copyin(a(1:LOOPCOUNT, 1:10)) copy(totals(1:LOOPCOUNT))\n          !$acc parallel\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              DO y = 1, 10\n                !$acc atomic\n                  totals(x) = a(x, y) + totals(x)\n              END DO\n            END DO\n          !$acc end parallel\n        !$acc end data\n        DO x = 1, LOOPCOUNT\n          DO y = 1, 10\n            totals_comparison(x) = totals_comparison(x) + a(x, y)\n          END DO\n        END DO\n\n        DO x = 1, LOOPCOUNT\n          IF (totals_comparison(x) .NE. totals(x)) THEN\n            errors = errors + 1\n            WRITE(*, *) totals_comparison(x)\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "construct-independent",
                            "atomic"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_expr_plus_x.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:atomic,construct-independent,V:2.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t *a = (real_t *)malloc(n * sizeof(real_t));\n    real_t *b = (real_t *)malloc(n * sizeof(real_t));\n    real_t *totals = (real_t *)malloc(10 * sizeof(real_t));\n    real_t *totals_comparison = (real_t *)malloc(10 * sizeof(real_t));\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n    }\n    for (int x = 0; x < 10; ++x){\n        totals[x] = 0;\n        totals_comparison[x] = 0;\n    }\n\n    #pragma acc data copyin(a[0:n], b[0:n]) copy(totals[0:10])\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                #pragma acc loop\n                for (int y = 0; y < n; ++y){\n                    #pragma acc atomic\n                        totals[(int) ((a[x] + b[x])/2)] = a[x] * b[x] + totals[(int) ((a[x] + b[x])/2)];\n                }\n            }\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        for (int y = 0; y < n; ++y){\n            totals_comparison[(int) ((a[x] + b[x])/2)] += a[x] * b[x];\n        }\n    }\n    for (int x = 0; x < 10; ++x){\n        if (fabs(totals_comparison[x] != totals[x]) > PRECISION){\n            err += 1;\n            break;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "atomic",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_expr_plus_x_end.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:construct-independent,atomic,V:2.0-2.7\n      LOGICAL FUNCTION test1()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x, y !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT, 10):: a !Data\n        REAL(8),DIMENSION(LOOPCOUNT):: totals, totals_comparison\n        INTEGER :: errors = 0\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(a)\n\n        totals = 0\n        totals_comparison = 0\n\n        !$acc data copyin(a(1:LOOPCOUNT, 1:10)) copy(totals(1:LOOPCOUNT))\n          !$acc parallel\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              DO y = 1, 10\n                !$acc atomic\n                  totals(x) = a(x, y) + totals(x)\n                !$acc end atomic\n              END DO\n            END DO\n          !$acc end parallel\n        !$acc end data\n        DO x = 1, LOOPCOUNT\n          DO y = 1, 10\n            totals_comparison(x) = totals_comparison(x) + a(x, y)\n          END DO\n        END DO\n\n        DO x = 1, LOOPCOUNT\n          IF (totals_comparison(x) .NE. totals(x)) THEN\n            errors = errors + 1\n            WRITE(*, *) totals_comparison(x)\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "construct-independent",
                            "atomic"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_expr_rshift_x.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:atomic,construct-independent,V:2.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    unsigned int *a = (unsigned int *)malloc(3 * n * sizeof(int));\n    unsigned int *b = (unsigned int *)malloc(n * sizeof(int));\n    int orders[18] = {1, 2, 0, 1, 0, 2, 2, 1, 0, 2, 0, 1, 0, 1, 2, 0, 2, 1};\n    int result;\n\n    for (int x = 0; x < n; ++x){\n        for (int y = 0; y < 3; ++y){\n            a[x * 3 + y] = (int) (rand() / (unsigned int) (RAND_MAX / 4));\n        }\n        b[x] = 0;\n    }\n\n    #pragma acc data copyin(a[0:3 * n]) copy(b[0:n])\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                #pragma acc loop independent\n                for (int y = 0; y < 3; ++y){\n                    #pragma acc atomic\n                        b[x] = a[x * 3 + y] >> b[x];\n                }\n            }\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        for (int y = 0; y < 6; ++y){\n            result = 0;\n            for (int z = 0; z < 3; ++z){\n                result = a[x * 3 + orders[y * 3 + z]] >> result;\n            }\n            if (result == b[x]){\n                break;\n            }\n        }\n        if (result != b[x]){\n            err += 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "atomic",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_expr_times_x.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:construct-independent,atomic,V:2.0-2.7\n      LOGICAL FUNCTION test1()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x, y !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT, 10):: a !Data\n        REAL(8),DIMENSION(LOOPCOUNT):: totals, totals_comparison\n        INTEGER :: errors = 0\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(a)\n\n        totals = 1\n        totals_comparison = 1\n\n        !$acc data copyin(a(1:LOOPCOUNT, 1:10)) copy(totals(1:LOOPCOUNT))\n          !$acc parallel\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              DO y = 1, 10\n                !$acc atomic\n                  totals(x) = a(x, y) * totals(x)\n              END DO\n            END DO\n          !$acc end parallel\n        !$acc end data\n        DO x = 1, LOOPCOUNT\n          DO y = 1, 10\n            totals_comparison(x) = totals_comparison(x) * a(x, y)\n          END DO\n        END DO\n\n        DO x = 1, LOOPCOUNT\n          IF (totals_comparison(x) .NE. totals(x)) THEN\n            errors = errors + 1\n            WRITE(*, *) totals_comparison(x)\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "construct-independent",
                            "atomic"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_expr_times_x_end.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:construct-independent,atomic,V:2.0-2.7\n      LOGICAL FUNCTION test1()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x, y !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT, 10):: a !Data\n        REAL(8),DIMENSION(LOOPCOUNT):: totals, totals_comparison\n        INTEGER :: errors = 0\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(a)\n\n        totals = 1\n        totals_comparison = 1\n\n        !$acc data copyin(a(1:LOOPCOUNT, 1:10)) copy(totals(1:LOOPCOUNT))\n          !$acc parallel\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              DO y = 1, 10\n                !$acc atomic\n                  totals(x) = a(x, y) * totals(x)\n                !$acc end atomic\n              END DO\n            END DO\n          !$acc end parallel\n        !$acc end data\n        DO x = 1, LOOPCOUNT\n          DO y = 1, 10\n            totals_comparison(x) = totals_comparison(x) * a(x, y)\n          END DO\n        END DO\n\n        DO x = 1, LOOPCOUNT\n          IF (totals_comparison(x) .NE. totals(x)) THEN\n            errors = errors + 1\n            WRITE(*, *) totals_comparison(x)\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "construct-independent",
                            "atomic"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_iand_expr_x.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:construct-independent,atomic,V:2.0-2.7\n      LOGICAL FUNCTION test1()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x, y !Iterators\n        INTEGER,DIMENSION(LOOPCOUNT):: a !Data\n        REAL(8),DIMENSION(LOOPCOUNT, 8):: randoms\n        INTEGER,DIMENSION(LOOPCOUNT/10 + 1):: totals, totals_comparison\n        INTEGER :: errors = 0\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(randoms)\n        a = 0\n        DO x = 1, LOOPCOUNT\n          DO y = 1, 8\n            IF (randoms(x, y) .gt. .933) THEN\n              a(x) = a(x) + ISHFT(1, y - 1)\n            END IF\n          END DO\n        END DO\n        totals = 0\n        totals_comparison = 0\n        DO x = 1, LOOPCOUNT/10 + 1\n          DO y = 0, 7\n            totals(x) = totals(x) + ISHFT(1, y)\n            totals_comparison(x) = totals_comparison(x) + ISHFT(1, y)\n          END DO\n        END DO\n\n        !$acc data copyin(a(1:LOOPCOUNT)) copy(totals(1:(LOOPCOUNT/10 + 1)))\n          !$acc parallel\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              !$acc atomic\n                totals(MOD(x, LOOPCOUNT/10 + 1) + 1) = iand(a(x), totals(MOD(x, LOOPCOUNT/10 + 1) + 1))\n            END DO\n          !$acc end parallel\n        !$acc end data\n        DO x = 1, LOOPCOUNT\n          totals_comparison(MOD(x, LOOPCOUNT/10 + 1) + 1) = iand(totals_comparison(MOD(x, LOOPCOUNT/10 + 1) + 1), a(x))\n        END DO\n        DO x = 1, LOOPCOUNT/10 + 1\n          IF (totals_comparison(x) .NE. totals(x)) THEN\n            errors = errors + 1\n            WRITE(*, *) totals_comparison(x)\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "construct-independent",
                            "atomic"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_iand_expr_x_end.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:construct-independent,atomic,V:2.0-2.7\n      LOGICAL FUNCTION test1()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x, y !Iterators\n        INTEGER,DIMENSION(LOOPCOUNT):: a !Data\n        REAL(8),DIMENSION(LOOPCOUNT, 8):: randoms\n        INTEGER,DIMENSION(LOOPCOUNT/10 + 1):: totals, totals_comparison\n        INTEGER :: errors = 0\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(randoms)\n        a = 0\n        DO x = 1, LOOPCOUNT\n          DO y = 1, 8\n            IF (randoms(x, y) .gt. .933) THEN\n              a(x) = a(x) + ISHFT(1, y - 1)\n            END IF\n          END DO\n        END DO\n        totals = 0\n        totals_comparison = 0\n        DO x = 1, LOOPCOUNT/10 + 1\n          DO y = 0, 7\n            totals(x) = totals(x) + ISHFT(1, y)\n            totals_comparison(x) = totals_comparison(x) + ISHFT(1, y)\n          END DO\n        END DO\n\n        !$acc data copyin(a(1:LOOPCOUNT)) copy(totals(1:(LOOPCOUNT/10 + 1)))\n          !$acc parallel\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              !$acc atomic\n                totals(MOD(x, LOOPCOUNT/10 + 1) + 1) = iand(a(x), totals(MOD(x, LOOPCOUNT/10 + 1) + 1))\n              !$acc end atomic\n            END DO\n          !$acc end parallel\n        !$acc end data\n        DO x = 1, LOOPCOUNT\n          totals_comparison(MOD(x, LOOPCOUNT/10 + 1) + 1) = iand(totals_comparison(MOD(x, LOOPCOUNT/10 + 1) + 1), a(x))\n        END DO\n        DO x = 1, LOOPCOUNT/10 + 1\n          IF (totals_comparison(x) .NE. totals(x)) THEN\n            errors = errors + 1\n            WRITE(*, *) totals_comparison(x)\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "construct-independent",
                            "atomic"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_iand_x_expr.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:construct-independent,atomic,V:2.0-2.7\n      LOGICAL FUNCTION test1()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x, y !Iterators\n        INTEGER,DIMENSION(LOOPCOUNT):: a !Data\n        REAL(8),DIMENSION(LOOPCOUNT, 8):: randoms\n        INTEGER,DIMENSION(LOOPCOUNT/10 + 1):: totals, totals_comparison\n        INTEGER :: errors = 0\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(randoms)\n        a = 0\n        DO x = 1, LOOPCOUNT\n          DO y = 1, 8\n            IF (randoms(x, y) .gt. .933) THEN\n              a(x) = a(x) + ISHFT(1, y - 1)\n            END IF\n          END DO\n        END DO\n        totals = 0\n        totals_comparison = 0\n        DO x = 1, LOOPCOUNT/10 + 1\n          DO y = 0, 7\n            totals(x) = totals(x) + ISHFT(1, y)\n            totals_comparison(x) = totals_comparison(x) + ISHFT(1, y)\n          END DO\n        END DO\n\n        !$acc data copyin(a(1:LOOPCOUNT)) copy(totals(1:(LOOPCOUNT/10 + 1)))\n          !$acc parallel\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              !$acc atomic\n                totals(MOD(x, LOOPCOUNT/10 + 1) + 1) = iand(totals(MOD(x, LOOPCOUNT/10 + 1) + 1), a(x))\n            END DO\n          !$acc end parallel\n        !$acc end data\n        DO x = 1, LOOPCOUNT\n          totals_comparison(MOD(x, LOOPCOUNT/10 + 1) + 1) = iand(totals_comparison(MOD(x, LOOPCOUNT/10 + 1) + 1), a(x))\n        END DO\n        DO x = 1, LOOPCOUNT/10 + 1\n          IF (totals_comparison(x) .NE. totals(x)) THEN\n            errors = errors + 1\n            WRITE(*, *) totals_comparison(x)\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "construct-independent",
                            "atomic"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_iand_x_expr_end.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:construct-independent,atomic,V:2.0-2.7\n      LOGICAL FUNCTION test1()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x, y !Iterators\n        INTEGER,DIMENSION(LOOPCOUNT):: a !Data\n        REAL(8),DIMENSION(LOOPCOUNT, 8):: randoms\n        INTEGER,DIMENSION(LOOPCOUNT/10 + 1):: totals, totals_comparison\n        INTEGER :: errors = 0\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(randoms)\n        a = 0\n        DO x = 1, LOOPCOUNT\n          DO y = 1, 8\n            IF (randoms(x, y) .gt. .933) THEN\n              a(x) = a(x) + ISHFT(1, y - 1)\n            END IF\n          END DO\n        END DO\n        totals = 0\n        totals_comparison = 0\n        DO x = 1, LOOPCOUNT/10 + 1\n          DO y = 0, 7\n            totals(x) = totals(x) + ISHFT(1, y)\n            totals_comparison(x) = totals_comparison(x) + ISHFT(1, y)\n          END DO\n        END DO\n\n        !$acc data copyin(a(1:LOOPCOUNT)) copy(totals(1:(LOOPCOUNT/10 + 1)))\n          !$acc parallel\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              !$acc atomic\n                totals(MOD(x, LOOPCOUNT/10 + 1) + 1) = iand(totals(MOD(x, LOOPCOUNT/10 + 1) + 1), a(x))\n              !$acc end atomic\n            END DO\n          !$acc end parallel\n        !$acc end data\n        DO x = 1, LOOPCOUNT\n          totals_comparison(MOD(x, LOOPCOUNT/10 + 1) + 1) = iand(totals_comparison(MOD(x, LOOPCOUNT/10 + 1) + 1), a(x))\n        END DO\n        DO x = 1, LOOPCOUNT/10 + 1\n          IF (totals_comparison(x) .NE. totals(x)) THEN\n            errors = errors + 1\n            WRITE(*, *) totals_comparison(x)\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "construct-independent",
                            "atomic"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_ior_expr_x.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:construct-independent,atomic,V:2.0-2.7\n      LOGICAL FUNCTION test1()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x, y !Iterators\n        INTEGER,DIMENSION(LOOPCOUNT):: a !Data\n        REAL(8),DIMENSION(LOOPCOUNT, 8):: randoms\n        INTEGER,DIMENSION(LOOPCOUNT/10 + 1):: totals, totals_comparison\n        INTEGER :: errors = 0\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(randoms)\n        a = 0\n        DO x = 1, LOOPCOUNT\n          DO y = 1, 8\n            IF (randoms(x, y) .lt. .933) THEN\n              a(x) = a(x) + ISHFT(1, y - 1)\n            END IF\n          END DO\n        END DO\n        totals = 0\n        totals_comparison = 0\n        DO x = 1, LOOPCOUNT/10 + 1\n          totals(x) = 0\n          totals_comparison(x) = 0\n        END DO\n\n        !$acc data copyin(a(1:LOOPCOUNT)) copy(totals(1:(LOOPCOUNT/10 + 1)))\n          !$acc parallel\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              !$acc atomic\n                totals(MOD(x, LOOPCOUNT/10 + 1) + 1) = ior(a(x), totals(MOD(x, LOOPCOUNT/10 + 1) + 1))\n            END DO\n          !$acc end parallel\n        !$acc end data\n        DO x = 1, LOOPCOUNT\n          totals_comparison(MOD(x, LOOPCOUNT/10 + 1) + 1) = ior(totals_comparison(MOD(x, LOOPCOUNT/10 + 1) + 1), a(x))\n        END DO\n        DO x = 1, LOOPCOUNT/10 + 1\n          IF (totals_comparison(x) .NE. totals(x)) THEN\n            errors = errors + 1\n            WRITE(*, *) totals_comparison(x)\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "construct-independent",
                            "atomic"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_ior_expr_x_end.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:construct-independent,atomic,V:2.0-2.7\n      LOGICAL FUNCTION test1()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x, y !Iterators\n        INTEGER,DIMENSION(LOOPCOUNT):: a !Data\n        REAL(8),DIMENSION(LOOPCOUNT, 8):: randoms\n        INTEGER,DIMENSION(LOOPCOUNT/10 + 1):: totals, totals_comparison\n        INTEGER :: errors = 0\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(randoms)\n        a = 0\n        DO x = 1, LOOPCOUNT\n          DO y = 1, 8\n            IF (randoms(x, y) .lt. .933) THEN\n              a(x) = a(x) + ISHFT(1, y - 1)\n            END IF\n          END DO\n        END DO\n        totals = 0\n        totals_comparison = 0\n        DO x = 1, LOOPCOUNT/10 + 1\n          totals(x) = 0\n          totals_comparison(x) = 0\n        END DO\n\n        !$acc data copyin(a(1:LOOPCOUNT)) copy(totals(1:(LOOPCOUNT/10 + 1)))\n          !$acc parallel\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              !$acc atomic\n                totals(MOD(x, LOOPCOUNT/10 + 1) + 1) = ior(a(x), totals(MOD(x, LOOPCOUNT/10 + 1) + 1))\n              !$acc end atomic\n            END DO\n          !$acc end parallel\n        !$acc end data\n        DO x = 1, LOOPCOUNT\n          totals_comparison(MOD(x, LOOPCOUNT/10 + 1) + 1) = ior(totals_comparison(MOD(x, LOOPCOUNT/10 + 1) + 1), a(x))\n        END DO\n        DO x = 1, LOOPCOUNT/10 + 1\n          IF (totals_comparison(x) .NE. totals(x)) THEN\n            errors = errors + 1\n            WRITE(*, *) totals_comparison(x)\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "construct-independent",
                            "atomic"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_ior_x_expr.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:construct-independent,atomic,V:2.0-2.7\n      LOGICAL FUNCTION test1()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x, y !Iterators\n        INTEGER,DIMENSION(LOOPCOUNT):: a !Data\n        REAL(8),DIMENSION(LOOPCOUNT, 8):: randoms\n        INTEGER,DIMENSION(LOOPCOUNT/10 + 1):: totals, totals_comparison\n        INTEGER :: errors = 0\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(randoms)\n        a = 0\n        DO x = 1, LOOPCOUNT\n          DO y = 1, 8\n            IF (randoms(x, y) .lt. .933) THEN\n              a(x) = a(x) + ISHFT(1, y - 1)\n            END IF\n          END DO\n        END DO\n        totals = 0\n        totals_comparison = 0\n        DO x = 1, LOOPCOUNT/10 + 1\n          totals(x) = 0\n          totals_comparison(x) = 0\n        END DO\n\n        !$acc data copyin(a(1:LOOPCOUNT)) copy(totals(1:(LOOPCOUNT/10 + 1)))\n          !$acc parallel\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              !$acc atomic\n                totals(MOD(x, LOOPCOUNT/10 + 1) + 1) = ior(totals(MOD(x, LOOPCOUNT/10 + 1) + 1), a(x))\n            END DO\n          !$acc end parallel\n        !$acc end data\n        DO x = 1, LOOPCOUNT\n          totals_comparison(MOD(x, LOOPCOUNT/10 + 1) + 1) = ior(totals_comparison(MOD(x, LOOPCOUNT/10 + 1) + 1), a(x))\n        END DO\n        DO x = 1, LOOPCOUNT/10 + 1\n          IF (totals_comparison(x) .NE. totals(x)) THEN\n            errors = errors + 1\n            WRITE(*, *) totals_comparison(x)\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "construct-independent",
                            "atomic"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_ior_x_expr_end.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:construct-independent,atomic,V:2.0-2.7\n      LOGICAL FUNCTION test1()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x, y !Iterators\n        INTEGER,DIMENSION(LOOPCOUNT):: a !Data\n        REAL(8),DIMENSION(LOOPCOUNT, 8):: randoms\n        INTEGER,DIMENSION(LOOPCOUNT/10 + 1):: totals, totals_comparison\n        INTEGER :: errors = 0\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(randoms)\n        a = 0\n        DO x = 1, LOOPCOUNT\n          DO y = 1, 8\n            IF (randoms(x, y) .lt. .933) THEN\n              a(x) = a(x) + ISHFT(1, y - 1)\n            END IF\n          END DO\n        END DO\n        totals = 0\n        totals_comparison = 0\n        DO x = 1, LOOPCOUNT/10 + 1\n          totals(x) = 0\n          totals_comparison(x) = 0\n        END DO\n\n        !$acc data copyin(a(1:LOOPCOUNT)) copy(totals(1:(LOOPCOUNT/10 + 1)))\n          !$acc parallel\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              !$acc atomic\n                totals(MOD(x, LOOPCOUNT/10 + 1) + 1) = ior(totals(MOD(x, LOOPCOUNT/10 + 1) + 1), a(x))\n              !$acc end atomic\n            END DO\n          !$acc end parallel\n        !$acc end data\n        DO x = 1, LOOPCOUNT\n          totals_comparison(MOD(x, LOOPCOUNT/10 + 1) + 1) = ior(totals_comparison(MOD(x, LOOPCOUNT/10 + 1) + 1), a(x))\n        END DO\n        DO x = 1, LOOPCOUNT/10 + 1\n          IF (totals_comparison(x) .NE. totals(x)) THEN\n            errors = errors + 1\n            WRITE(*, *) totals_comparison(x)\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "construct-independent",
                            "atomic"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_ixor_expr_x.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:construct-independent,atomic,V:2.0-2.7\n      LOGICAL FUNCTION test1()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x, y !Iterators\n        INTEGER,DIMENSION(LOOPCOUNT):: a !Data\n        REAL(8),DIMENSION(LOOPCOUNT, 8):: randoms\n        INTEGER,DIMENSION(LOOPCOUNT/10 + 1):: totals, totals_comparison\n        INTEGER :: errors = 0\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(randoms)\n        a = 0\n        DO x = 1, LOOPCOUNT\n          DO y = 1, 8\n            IF (randoms(x, y) .lt. .5) THEN\n              a(x) = a(x) + ISHFT(1, y - 1)\n            END IF\n          END DO\n        END DO\n        totals = 0\n        totals_comparison = 0\n        DO x = 1, LOOPCOUNT/10 + 1\n          totals(x) = 0\n          totals_comparison(x) = 0\n        END DO\n\n        !$acc data copyin(a(1:LOOPCOUNT)) copy(totals(1:(LOOPCOUNT/10 + 1)))\n          !$acc parallel\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              !$acc atomic\n                totals(MOD(x, LOOPCOUNT/10 + 1) + 1) = ieor(a(x), totals(MOD(x, LOOPCOUNT/10 + 1) + 1))\n            END DO\n          !$acc end parallel\n        !$acc end data\n        DO x = 1, LOOPCOUNT\n          totals_comparison(MOD(x, LOOPCOUNT/10 + 1) + 1) = ieor(totals_comparison(MOD(x, LOOPCOUNT/10 + 1) + 1), a(x))\n        END DO\n        DO x = 1, LOOPCOUNT/10 + 1\n          IF (totals_comparison(x) .NE. totals(x)) THEN\n            errors = errors + 1\n            WRITE(*, *) totals_comparison(x)\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "construct-independent",
                            "atomic"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_ixor_expr_x_end.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:construct-independent,atomic,V:2.0-2.7\n      LOGICAL FUNCTION test1()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x, y !Iterators\n        INTEGER,DIMENSION(LOOPCOUNT):: a !Data\n        REAL(8),DIMENSION(LOOPCOUNT, 8):: randoms\n        INTEGER,DIMENSION(LOOPCOUNT/10 + 1):: totals, totals_comparison\n        INTEGER :: errors = 0\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(randoms)\n        a = 0\n        DO x = 1, LOOPCOUNT\n          DO y = 1, 8\n            IF (randoms(x, y) .lt. .5) THEN\n              a(x) = a(x) + ISHFT(1, y - 1)\n            END IF\n          END DO\n        END DO\n        totals = 0\n        totals_comparison = 0\n        DO x = 1, LOOPCOUNT/10 + 1\n          totals(x) = 0\n          totals_comparison(x) = 0\n        END DO\n\n        !$acc data copyin(a(1:LOOPCOUNT)) copy(totals(1:(LOOPCOUNT/10 + 1)))\n          !$acc parallel\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              !$acc atomic\n                totals(MOD(x, LOOPCOUNT/10 + 1) + 1) = ieor(a(x), totals(MOD(x, LOOPCOUNT/10 + 1) + 1))\n              !$acc end atomic\n            END DO\n          !$acc end parallel\n        !$acc end data\n        DO x = 1, LOOPCOUNT\n          totals_comparison(MOD(x, LOOPCOUNT/10 + 1) + 1) = ieor(totals_comparison(MOD(x, LOOPCOUNT/10 + 1) + 1), a(x))\n        END DO\n        DO x = 1, LOOPCOUNT/10 + 1\n          IF (totals_comparison(x) .NE. totals(x)) THEN\n            errors = errors + 1\n            WRITE(*, *) totals_comparison(x)\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "construct-independent",
                            "atomic"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_ixor_x_expr.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:construct-independent,atomic,V:2.0-2.7\n      LOGICAL FUNCTION test1()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x, y !Iterators\n        INTEGER,DIMENSION(LOOPCOUNT):: a !Data\n        REAL(8),DIMENSION(LOOPCOUNT, 8):: randoms\n        INTEGER,DIMENSION(LOOPCOUNT/10 + 1):: totals, totals_comparison\n        INTEGER :: errors = 0\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(randoms)\n        a = 0\n        DO x = 1, LOOPCOUNT\n          DO y = 1, 8\n            IF (randoms(x, y) .lt. .5) THEN\n              a(x) = a(x) + ISHFT(1, y - 1)\n            END IF\n          END DO\n        END DO\n        totals = 0\n        totals_comparison = 0\n        DO x = 1, LOOPCOUNT/10 + 1\n          totals(x) = 0\n          totals_comparison(x) = 0\n        END DO\n\n        !$acc data copyin(a(1:LOOPCOUNT)) copy(totals(1:(LOOPCOUNT/10 + 1)))\n          !$acc parallel\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              !$acc atomic\n                totals(MOD(x, LOOPCOUNT/10 + 1) + 1) = ieor(totals(MOD(x, LOOPCOUNT/10 + 1) + 1), a(x))\n            END DO\n          !$acc end parallel\n        !$acc end data\n        DO x = 1, LOOPCOUNT\n          totals_comparison(MOD(x, LOOPCOUNT/10 + 1) + 1) = ieor(totals_comparison(MOD(x, LOOPCOUNT/10 + 1) + 1), a(x))\n        END DO\n        DO x = 1, LOOPCOUNT/10 + 1\n          IF (totals_comparison(x) .NE. totals(x)) THEN\n            errors = errors + 1\n            WRITE(*, *) totals_comparison(x)\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "construct-independent",
                            "atomic"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_ixor_x_expr_end.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:construct-independent,atomic,V:2.0-2.7\n      LOGICAL FUNCTION test1()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x, y !Iterators\n        INTEGER,DIMENSION(LOOPCOUNT):: a !Data\n        REAL(8),DIMENSION(LOOPCOUNT, 8):: randoms\n        INTEGER,DIMENSION(LOOPCOUNT/10 + 1):: totals, totals_comparison\n        INTEGER :: errors = 0\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(randoms)\n        a = 0\n        DO x = 1, LOOPCOUNT\n          DO y = 1, 8\n            IF (randoms(x, y) .lt. .5) THEN\n              a(x) = a(x) + ISHFT(1, y - 1)\n            END IF\n          END DO\n        END DO\n        totals = 0\n        totals_comparison = 0\n        DO x = 1, LOOPCOUNT/10 + 1\n          totals(x) = 0\n          totals_comparison(x) = 0\n        END DO\n\n        !$acc data copyin(a(1:LOOPCOUNT)) copy(totals(1:(LOOPCOUNT/10 + 1)))\n          !$acc parallel\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              !$acc atomic\n                totals(MOD(x, LOOPCOUNT/10 + 1) + 1) = ieor(totals(MOD(x, LOOPCOUNT/10 + 1) + 1), a(x))\n              !$acc end atomic\n            END DO\n          !$acc end parallel\n        !$acc end data\n        DO x = 1, LOOPCOUNT\n          totals_comparison(MOD(x, LOOPCOUNT/10 + 1) + 1) = ieor(totals_comparison(MOD(x, LOOPCOUNT/10 + 1) + 1), a(x))\n        END DO\n        DO x = 1, LOOPCOUNT/10 + 1\n          IF (totals_comparison(x) .NE. totals(x)) THEN\n            errors = errors + 1\n            WRITE(*, *) totals_comparison(x)\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "construct-independent",
                            "atomic"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_lshift_equals.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:atomic,construct-independent,V:2.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    unsigned int *a = (unsigned int *)malloc(n * sizeof(int));\n    unsigned int *b = (unsigned int *)malloc(n * sizeof(int));\n\n    for (int x = 0; x < n; ++x){\n        a[x] = 1;\n        for (int y = 0; y < 7; ++y){\n            if ((rand()/(unsigned int) (RAND_MAX)) > .5){\n                b[x] += 1<<y;\n            }\n        }\n    }\n\n    #pragma acc data copyin(b[0:n]) copy(a[0:n])\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                #pragma acc loop\n                for (int y = 0; y < 7; ++y){\n                    if ((b[x]>>y)%2 == 1){\n                        #pragma acc atomic\n                            a[x] <<= 1;\n                    }\n                }\n            }\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        for (int y = 0; y < 7; ++y){\n            if ((b[x]>>y)%2 == 1){\n                a[x] >>= 1;\n            }\n        }\n        if (a[x] != 1){\n            err += 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "atomic",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_max_expr_list_x.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:construct-independent,atomic,V:2.0-2.7\n      LOGICAL FUNCTION test1()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.f90\"\n        INTEGER :: x, y !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT):: a, b !Data\n        REAL(8),DIMENSION(LOOPCOUNT/10 + 1):: totals, totals_comparison\n        INTEGER :: errors = 0\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n        CALL RANDOM_NUMBER(a)\n        CALL RANDOM_NUMBER(b)\n\n        totals = 0\n        totals_comparison = 0\n\n        !$acc data copyin(a(1:LOOPCOUNT), b(1:LOOPCOUNT)) copy(totals(1:(LOOPCOUNT/10 + 1)))\n          !$acc parallel\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              !$acc atomic\n                totals(MOD(x, LOOPCOUNT/10 + 1) + 1) = max(a(x), b(x), totals(MOD(x, LOOPCOUNT/10 + 1) + 1))\n            END DO\n          !$acc end parallel\n        !$acc end data\n        DO x = 1, LOOPCOUNT\n          totals_comparison(MOD(x, LOOPCOUNT/10 + 1) + 1) = max(totals_comparison(MOD(x, LOOPCOUNT/10 + 1) + 1), a(x), b(x))\n        END DO\n        DO x = 1, LOOPCOUNT/10 + 1\n          IF (totals_comparison(x) .NE. totals(x)) THEN\n            errors = errors + 1\n            WRITE(*, *) totals_comparison(x)\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "construct-independent",
                            "atomic"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_max_expr_list_x_end.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:construct-independent,atomic,V:2.0-2.7\n      LOGICAL FUNCTION test1()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x, y !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT):: a, b !Data\n        REAL(8),DIMENSION(LOOPCOUNT/10 + 1):: totals, totals_comparison\n        INTEGER :: errors = 0\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(a)\n        CALL RANDOM_NUMBER(b)\n\n        totals = 0\n        totals_comparison = 0\n\n        !$acc data copyin(a(1:LOOPCOUNT), b(1:LOOPCOUNT)) copy(totals(1:(LOOPCOUNT/10 + 1)))\n          !$acc parallel\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              !$acc atomic\n                totals(MOD(x, LOOPCOUNT/10 + 1) + 1) = max(a(x), b(x), totals(MOD(x, LOOPCOUNT/10 + 1) + 1))\n              !$acc end atomic\n            END DO\n          !$acc end parallel\n        !$acc end data\n        DO x = 1, LOOPCOUNT\n          totals_comparison(MOD(x, LOOPCOUNT/10 + 1) + 1) = max(totals_comparison(MOD(x, LOOPCOUNT/10 + 1) + 1), a(x), b(x))\n        END DO\n        DO x = 1, LOOPCOUNT/10 + 1\n          IF (totals_comparison(x) .NE. totals(x)) THEN\n            errors = errors + 1\n            WRITE(*, *) totals_comparison(x)\n          END IF\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "construct-independent",
                            "atomic"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_max_expr_x.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:construct-independent,atomic,V:2.0-2.7\n      LOGICAL FUNCTION test1()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x, y !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT):: a !Data\n        REAL(8),DIMENSION(LOOPCOUNT/10 + 1):: totals, totals_comparison\n        INTEGER :: errors = 0\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(a)\n\n        totals = 0\n        totals_comparison = 0\n\n        !$acc data copyin(a(1:LOOPCOUNT)) copy(totals(1:(LOOPCOUNT/10 + 1)))\n          !$acc parallel\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              !$acc atomic\n                totals(MOD(x, LOOPCOUNT/10 + 1) + 1) = max(a(x), totals(MOD(x, LOOPCOUNT/10 + 1) + 1))\n            END DO\n          !$acc end parallel\n        !$acc end data\n        DO x = 1, LOOPCOUNT\n          totals_comparison(MOD(x, LOOPCOUNT/10 + 1) + 1) = max(totals_comparison(MOD(x, LOOPCOUNT/10 + 1) + 1), a(x))\n        END DO\n        DO x = 1, LOOPCOUNT/10 + 1\n          IF (totals_comparison(x) .NE. totals(x)) THEN\n            errors = errors + 1\n            WRITE(*, *) totals_comparison(x)\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "construct-independent",
                            "atomic"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_max_expr_x_end.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:construct-independent,atomic,V:2.0-2.7\n      LOGICAL FUNCTION test1()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x, y !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT):: a !Data\n        REAL(8),DIMENSION(LOOPCOUNT/10 + 1):: totals, totals_comparison\n        INTEGER :: errors = 0\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(a)\n\n        totals = 0\n        totals_comparison = 0\n\n        !$acc data copyin(a(1:LOOPCOUNT)) copy(totals(1:(LOOPCOUNT/10 + 1)))\n          !$acc parallel\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              !$acc atomic\n                totals(MOD(x, LOOPCOUNT/10 + 1) + 1) = max(a(x), totals(MOD(x, LOOPCOUNT/10 + 1) + 1))\n              !$acc end atomic\n            END DO\n          !$acc end parallel\n        !$acc end data\n        DO x = 1, LOOPCOUNT\n          totals_comparison(MOD(x, LOOPCOUNT/10 + 1) + 1) = max(totals_comparison(MOD(x, LOOPCOUNT/10 + 1) + 1), a(x))\n        END DO\n        DO x = 1, LOOPCOUNT/10 + 1\n          IF (totals_comparison(x) .NE. totals(x)) THEN\n            errors = errors + 1\n            WRITE(*, *) totals_comparison(x)\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "construct-independent",
                            "atomic"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_max_x_expr.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:construct-independent,atomic,V:2.0-2.7\n      LOGICAL FUNCTION test1()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x, y !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT):: a !Data\n        REAL(8),DIMENSION(LOOPCOUNT/10 + 1):: totals, totals_comparison\n        INTEGER :: errors = 0\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(a)\n\n        totals = 0\n        totals_comparison = 0\n\n        !$acc data copyin(a(1:LOOPCOUNT)) copy(totals(1:(LOOPCOUNT/10 + 1)))\n          !$acc parallel\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              !$acc atomic\n                totals(MOD(x, LOOPCOUNT/10 + 1) + 1) = max(totals(MOD(x, LOOPCOUNT/10 + 1) + 1), a(x))\n            END DO\n          !$acc end parallel\n        !$acc end data\n        DO x = 1, LOOPCOUNT\n          totals_comparison(MOD(x, LOOPCOUNT/10 + 1) + 1) = max(totals_comparison(MOD(x, LOOPCOUNT/10 + 1) + 1), a(x))\n        END DO\n        DO x = 1, LOOPCOUNT/10 + 1\n          IF (totals_comparison(x) .NE. totals(x)) THEN\n            errors = errors + 1\n            WRITE(*, *) totals_comparison(x)\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "construct-independent",
                            "atomic"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_max_x_expr_end.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:construct-independent,atomic,V:2.0-2.7\n      LOGICAL FUNCTION test1()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x, y !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT):: a !Data\n        REAL(8),DIMENSION(LOOPCOUNT/10 + 1):: totals, totals_comparison\n        INTEGER :: errors = 0\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(a)\n\n        totals = 0\n        totals_comparison = 0\n\n        !$acc data copyin(a(1:LOOPCOUNT)) copy(totals(1:(LOOPCOUNT/10 + 1)))\n          !$acc parallel\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              !$acc atomic\n                totals(MOD(x, LOOPCOUNT/10 + 1) + 1) = max(totals(MOD(x, LOOPCOUNT/10 + 1) + 1), a(x))\n              !$acc end atomic\n            END DO\n          !$acc end parallel\n        !$acc end data\n        DO x = 1, LOOPCOUNT\n          totals_comparison(MOD(x, LOOPCOUNT/10 + 1) + 1) = max(totals_comparison(MOD(x, LOOPCOUNT/10 + 1) + 1), a(x))\n        END DO\n        DO x = 1, LOOPCOUNT/10 + 1\n          IF (totals_comparison(x) .NE. totals(x)) THEN\n            errors = errors + 1\n            WRITE(*, *) totals_comparison(x)\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "construct-independent",
                            "atomic"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_max_x_expr_list.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:construct-independent,atomic,V:2.0-2.7\n      LOGICAL FUNCTION test1()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x, y !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT):: a, b !Data\n        REAL(8),DIMENSION(LOOPCOUNT/10 + 1):: totals, totals_comparison\n        INTEGER :: errors = 0\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(a)\n        CALL RANDOM_NUMBER(b)\n\n        totals = 0\n        totals_comparison = 0\n\n        !$acc data copyin(a(1:LOOPCOUNT), b(1:LOOPCOUNT)) copy(totals(1:(LOOPCOUNT/10 + 1)))\n          !$acc parallel\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              !$acc atomic\n                totals(MOD(x, LOOPCOUNT/10 + 1) + 1) = max(totals(MOD(x, LOOPCOUNT/10 + 1) + 1), a(x), b(x))\n            END DO\n          !$acc end parallel\n        !$acc end data\n        DO x = 1, LOOPCOUNT\n          totals_comparison(MOD(x, LOOPCOUNT/10 + 1) + 1) = max(totals_comparison(MOD(x, LOOPCOUNT/10 + 1) + 1), a(x), b(x))\n        END DO\n        DO x = 1, LOOPCOUNT/10 + 1\n          IF (totals_comparison(x) .NE. totals(x)) THEN\n            errors = errors + 1\n            WRITE(*, *) totals_comparison(x)\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "construct-independent",
                            "atomic"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_max_x_expr_list_end.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:construct-independent,atomic,V:2.0-2.7\n      LOGICAL FUNCTION test1()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x, y !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT):: a, b !Data\n        REAL(8),DIMENSION(LOOPCOUNT/10 + 1):: totals, totals_comparison\n        INTEGER :: errors = 0\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(a)\n        CALL RANDOM_NUMBER(b)\n\n        totals = 0\n        totals_comparison = 0\n\n        !$acc data copyin(a(1:LOOPCOUNT), b(1:LOOPCOUNT)) copy(totals(1:(LOOPCOUNT/10 + 1)))\n          !$acc parallel\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              !$acc atomic\n                totals(MOD(x, LOOPCOUNT/10 + 1) + 1) = max(totals(MOD(x, LOOPCOUNT/10 + 1) + 1), a(x), b(x))\n              !$acc end atomic\n            END DO\n          !$acc end parallel\n        !$acc end data\n        DO x = 1, LOOPCOUNT\n          totals_comparison(MOD(x, LOOPCOUNT/10 + 1) + 1) = max(totals_comparison(MOD(x, LOOPCOUNT/10 + 1) + 1), a(x), b(x))\n        END DO\n        DO x = 1, LOOPCOUNT/10 + 1\n          IF (totals_comparison(x) .NE. totals(x)) THEN\n            errors = errors + 1\n            WRITE(*, *) totals_comparison(x)\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "construct-independent",
                            "atomic"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_min_expr_list_x.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:construct-independent,atomic,V:2.0-2.7\n      LOGICAL FUNCTION test1()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x, y !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT):: a, b !Data\n        REAL(8),DIMENSION(LOOPCOUNT/10 + 1):: totals, totals_comparison\n        INTEGER :: errors = 0\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(a)\n        CALL RANDOM_NUMBER(b)\n\n        totals = 1\n        totals_comparison = 1\n\n        !$acc data copyin(a(1:LOOPCOUNT), b(1:LOOPCOUNT)) copy(totals(1:(LOOPCOUNT/10 + 1)))\n          !$acc parallel\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              !$acc atomic\n                totals(MOD(x, LOOPCOUNT/10 + 1) + 1) = min(a(x), b(x), totals(MOD(x, LOOPCOUNT/10 + 1) + 1))\n            END DO\n          !$acc end parallel\n        !$acc end data\n        DO x = 1, LOOPCOUNT\n          totals_comparison(MOD(x, LOOPCOUNT/10 + 1) + 1) = min(totals_comparison(MOD(x, LOOPCOUNT/10 + 1) + 1), a(x), b(x))\n        END DO\n        DO x = 1, LOOPCOUNT/10 + 1\n          IF (totals_comparison(x) .NE. totals(x)) THEN\n            errors = errors + 1\n            WRITE(*, *) totals_comparison(x)\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "construct-independent",
                            "atomic"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_min_expr_list_x_end.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:construct-independent,atomic,V:2.0-2.7\n      LOGICAL FUNCTION test1()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x, y !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT):: a, b !Data\n        REAL(8),DIMENSION(LOOPCOUNT/10 + 1):: totals, totals_comparison\n        INTEGER :: errors = 0\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(a)\n        CALL RANDOM_NUMBER(b)\n\n        totals = 1\n        totals_comparison = 1\n\n        !$acc data copyin(a(1:LOOPCOUNT), b(1:LOOPCOUNT)) copy(totals(1:(LOOPCOUNT/10 + 1)))\n          !$acc parallel\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              !$acc atomic\n                totals(MOD(x, LOOPCOUNT/10 + 1) + 1) = min(a(x), b(x), totals(MOD(x, LOOPCOUNT/10 + 1) + 1))\n              !$acc end atomic\n            END DO\n          !$acc end parallel\n        !$acc end data\n        DO x = 1, LOOPCOUNT\n          totals_comparison(MOD(x, LOOPCOUNT/10 + 1) + 1) = min(totals_comparison(MOD(x, LOOPCOUNT/10 + 1) + 1), a(x), b(x))\n        END DO\n        DO x = 1, LOOPCOUNT/10 + 1\n          IF (totals_comparison(x) .NE. totals(x)) THEN\n            errors = errors + 1\n            WRITE(*, *) totals_comparison(x)\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "construct-independent",
                            "atomic"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_min_expr_x.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:construct-independent,atomic,V:2.0-2.7\n      LOGICAL FUNCTION test1()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x, y !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT):: a !Data\n        REAL(8),DIMENSION(LOOPCOUNT/10 + 1):: totals, totals_comparison\n        INTEGER :: errors = 0\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(a)\n\n        totals = 1\n        totals_comparison = 1\n\n        !$acc data copyin(a(1:LOOPCOUNT)) copy(totals(1:(LOOPCOUNT/10 + 1)))\n          !$acc parallel\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              !$acc atomic\n                totals(MOD(x, LOOPCOUNT/10 + 1) + 1) = min(a(x), totals(MOD(x, LOOPCOUNT/10 + 1) + 1))\n            END DO\n          !$acc end parallel\n        !$acc end data\n        DO x = 1, LOOPCOUNT\n          totals_comparison(MOD(x, LOOPCOUNT/10 + 1) + 1) = min(totals_comparison(MOD(x, LOOPCOUNT/10 + 1) + 1), a(x))\n        END DO\n        DO x = 1, LOOPCOUNT/10 + 1\n          IF (totals_comparison(x) .NE. totals(x)) THEN\n            errors = errors + 1\n            WRITE(*, *) totals_comparison(x)\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "construct-independent",
                            "atomic"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_min_expr_x_end.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:construct-independent,atomic,V:2.0-2.7\n      LOGICAL FUNCTION test1()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x, y !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT):: a !Data\n        REAL(8),DIMENSION(LOOPCOUNT/10 + 1):: totals, totals_comparison\n        INTEGER :: errors = 0\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(a)\n\n        totals = 1\n        totals_comparison = 1\n\n        !$acc data copyin(a(1:LOOPCOUNT)) copy(totals(1:(LOOPCOUNT/10 + 1)))\n          !$acc parallel\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              !$acc atomic\n                totals(MOD(x, LOOPCOUNT/10 + 1) + 1) = min(a(x), totals(MOD(x, LOOPCOUNT/10 + 1) + 1))\n              !$acc end atomic\n            END DO\n          !$acc end parallel\n        !$acc end data\n        DO x = 1, LOOPCOUNT\n          totals_comparison(MOD(x, LOOPCOUNT/10 + 1) + 1) = min(totals_comparison(MOD(x, LOOPCOUNT/10 + 1) + 1), a(x))\n        END DO\n        DO x = 1, LOOPCOUNT/10 + 1\n          IF (totals_comparison(x) .NE. totals(x)) THEN\n            errors = errors + 1\n            WRITE(*, *) totals_comparison(x)\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "construct-independent",
                            "atomic"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_min_x_expr.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:construct-independent,atomic,V:2.0-2.7\n      LOGICAL FUNCTION test1()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x, y !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT):: a !Data\n        REAL(8),DIMENSION(LOOPCOUNT/10 + 1):: totals, totals_comparison\n        INTEGER :: errors = 0\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(a)\n\n        totals = 0\n        totals_comparison = 0\n\n        !$acc data copyin(a(1:LOOPCOUNT)) copy(totals(1:(LOOPCOUNT/10 + 1)))\n          !$acc parallel\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              !$acc atomic\n                totals(MOD(x, LOOPCOUNT/10 + 1) + 1) = min(totals(MOD(x, LOOPCOUNT/10 + 1) + 1), a(x))\n            END DO\n          !$acc end parallel\n        !$acc end data\n        DO x = 1, LOOPCOUNT\n          totals_comparison(MOD(x, LOOPCOUNT/10 + 1) + 1) = min(totals_comparison(MOD(x, LOOPCOUNT/10 + 1) + 1), a(x))\n        END DO\n        DO x = 1, LOOPCOUNT/10 + 1\n          IF (totals_comparison(x) .NE. totals(x)) THEN\n            errors = errors + 1\n            WRITE(*, *) totals_comparison(x)\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "construct-independent",
                            "atomic"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_min_x_expr_end.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:construct-independent,atomic,V:2.0-2.7\n      LOGICAL FUNCTION test1()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x, y !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT):: a !Data\n        REAL(8),DIMENSION(LOOPCOUNT/10 + 1):: totals, totals_comparison\n        INTEGER :: errors = 0\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(a)\n\n        totals = 0\n        totals_comparison = 0\n\n        !$acc data copyin(a(1:LOOPCOUNT)) copy(totals(1:(LOOPCOUNT/10 + 1)))\n          !$acc parallel\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              !$acc atomic\n                totals(MOD(x, LOOPCOUNT/10 + 1) + 1) = min(totals(MOD(x, LOOPCOUNT/10 + 1) + 1), a(x))\n              !$acc end atomic\n            END DO\n          !$acc end parallel\n        !$acc end data\n        DO x = 1, LOOPCOUNT\n          totals_comparison(MOD(x, LOOPCOUNT/10 + 1) + 1) = min(totals_comparison(MOD(x, LOOPCOUNT/10 + 1) + 1), a(x))\n        END DO\n        DO x = 1, LOOPCOUNT/10 + 1\n          IF (totals_comparison(x) .NE. totals(x)) THEN\n            errors = errors + 1\n            WRITE(*, *) totals_comparison(x)\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "construct-independent",
                            "atomic"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_min_x_expr_list.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:construct-independent,atomic,V:2.0-2.7\n      LOGICAL FUNCTION test1()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x, y !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT):: a, b !Data\n        REAL(8),DIMENSION(LOOPCOUNT/10 + 1):: totals, totals_comparison\n        INTEGER :: errors = 0\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(a)\n        CALL RANDOM_NUMBER(b)\n\n        totals = 1\n        totals_comparison = 1\n\n        !$acc data copyin(a(1:LOOPCOUNT), b(1:LOOPCOUNT)) copy(totals(1:(LOOPCOUNT/10 + 1)))\n          !$acc parallel\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              !$acc atomic\n                totals(MOD(x, LOOPCOUNT/10 + 1) + 1) = min(totals(MOD(x, LOOPCOUNT/10 + 1) + 1), a(x), b(x))\n            END DO\n          !$acc end parallel\n        !$acc end data\n        DO x = 1, LOOPCOUNT\n          totals_comparison(MOD(x, LOOPCOUNT/10 + 1) + 1) = min(totals_comparison(MOD(x, LOOPCOUNT/10 + 1) + 1), a(x), b(x))\n        END DO\n        DO x = 1, LOOPCOUNT/10 + 1\n          IF (totals_comparison(x) .NE. totals(x)) THEN\n            errors = errors + 1\n            WRITE(*, *) totals_comparison(x)\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "construct-independent",
                            "atomic"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_min_x_expr_list_end.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:construct-independent,atomic,V:2.0-2.7\n      LOGICAL FUNCTION test1()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x, y !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT):: a, b !Data\n        REAL(8),DIMENSION(LOOPCOUNT/10 + 1):: totals, totals_comparison\n        INTEGER :: errors = 0\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(a)\n        CALL RANDOM_NUMBER(b)\n\n        totals = 1\n        totals_comparison = 1\n\n        !$acc data copyin(a(1:LOOPCOUNT), b(1:LOOPCOUNT)) copy(totals(1:(LOOPCOUNT/10 + 1)))\n          !$acc parallel\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              !$acc atomic\n                totals(MOD(x, LOOPCOUNT/10 + 1) + 1) = min(totals(MOD(x, LOOPCOUNT/10 + 1) + 1), a(x), b(x))\n              !$acc end atomic\n            END DO\n          !$acc end parallel\n        !$acc end data\n        DO x = 1, LOOPCOUNT\n          totals_comparison(MOD(x, LOOPCOUNT/10 + 1) + 1) = min(totals_comparison(MOD(x, LOOPCOUNT/10 + 1) + 1), a(x), b(x))\n        END DO\n        DO x = 1, LOOPCOUNT/10 + 1\n          IF (totals_comparison(x) .NE. totals(x)) THEN\n            errors = errors + 1\n            WRITE(*, *) totals_comparison(x)\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "construct-independent",
                            "atomic"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_minus_equals.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:atomic,construct-independent,V:2.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t *a = (real_t *)malloc(n * sizeof(real_t));\n    real_t *b = (real_t *)malloc(n * sizeof(real_t));\n    real_t *totals = (real_t *)malloc(10 * sizeof(real_t));\n    real_t *totals_host = (real_t *)malloc(10 * sizeof(real_t));\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n    }\n    for (int x = 0; x < 10; ++x){\n        totals[x] = 0;\n    }\n\n    #pragma acc data copyin(a[0:n], b[0:n]) copy(totals[0:10])\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                #pragma acc atomic\n                    totals[x%10] -= (a[x] + b[x]);\n            }\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        totals_host[x%10] = totals_host[x%10] - (a[x] + b[x]);\n    }\n    for (int x = 0; x < 10; ++x){\n        if (fabs(totals_host[x] - totals[x]) > PRECISION){\n            err += 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "atomic",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_multiply_equals.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:atomic,construct-independent,V:2.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t *a = (real_t *)malloc(n * sizeof(real_t));\n    real_t *b = (real_t *)malloc(n * sizeof(real_t));\n    real_t *totals = (real_t *)malloc((n/10 + 1) * sizeof(real_t));\n    real_t *totals_comparison = (real_t *)malloc((n/10 + 1) * sizeof(real_t));\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n    }\n    for (int x = 0; x < n/10 + 1; ++x){\n        totals[x] = 1;\n        totals_comparison[x] = 1;\n    }\n\n    #pragma acc data copyin(a[0:n], b[0:n]) copy(totals[0:n/10 + 1])\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                #pragma acc atomic\n                    totals[x%(n/10 + 1)] *= a[x] + b[x];\n            }\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        totals_comparison[x%(n/10 + 1)] *= a[x] + b[x];\n    }\n    for (int x = 0; x < 10; ++x){\n        if (fabs(totals_comparison[x] - totals[x]) > PRECISION * totals_comparison[x]){\n            err += 1;\n            break;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "atomic",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_plus_equals.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:atomic,construct-independent,V:2.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t *a = (real_t *)malloc(n * sizeof(real_t));\n    real_t *b = (real_t *)malloc(n * sizeof(real_t));\n    real_t *totals = (real_t *)malloc((n/10 + 1) * sizeof(real_t));\n    real_t *totals_comparison = (real_t *)malloc((n/10 + 1) * sizeof(real_t));\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n    }\n    for (int x = 0; x < n/10 + 1; ++x){\n        totals[x] = 0;\n        totals_comparison[x] = 0;\n    }\n\n    #pragma acc data copyin(a[0:n], b[0:n]) copy(totals[0:n/10 + 1])\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                #pragma acc atomic\n                    totals[x%(n/10 + 1)] += a[x] * b[x];\n            }\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        totals_comparison[x%(n/10 + 1)] += a[x] * b[x];\n    }\n    for (int x = 0; x < n/10 + 1; ++x){\n        if (fabs(totals_comparison[x] - totals[x]) > (n/10 + 1) * PRECISION){\n            err += 1;\n            break;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "atomic",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_postdecrement.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:atomic,construct-independent,V:2.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t *a = (real_t *)malloc(n * sizeof(real_t));\n    real_t *b = (real_t *)malloc(n * sizeof(real_t));\n    int *distribution = (int *)malloc(10 * sizeof(int));\n    int *distribution_comparison = (int *)malloc(10 * sizeof(int));\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n    }\n    for (int x = 0; x < 10; ++x){\n        distribution[x] = 0;\n        distribution_comparison[x] = 0;\n    }\n\n    #pragma acc data copyin(a[0:n], b[0:n]) copy(distribution[0:10])\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                #pragma acc atomic\n                    distribution[(int) (a[x] * b[x] / 10)]--;\n            }\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        distribution_comparison[(int) (a[x]*b[x]/10)]--;\n    }\n    for (int x = 0; x < 10; ++x){\n        if (distribution_comparison[x] != distribution[x]){\n            err += 1;\n            break;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "atomic",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_postincrement.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:atomic,construct-independent,V:2.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t *a = (real_t *)malloc(n * sizeof(real_t));\n    real_t *b = (real_t *)malloc(n * sizeof(real_t));\n    int *distribution = (int *)malloc(10 * sizeof(int));\n    int *distribution_comparison = (int *)malloc(10 * sizeof(int));\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n    }\n    for (int x = 0; x < 10; ++x){\n        distribution[x] = 0;\n        distribution_comparison[x] = 0;\n    }\n\n    #pragma acc data copyin(a[0:n], b[0:n]) copy(distribution[0:10])\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                #pragma acc loop\n                for (int y = 0; y < n; ++y){\n                    #pragma acc atomic\n                        distribution[(int) (a[x]*b[y]/10)]++;\n                }\n            }\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        for (int y = 0; y < n; ++y){\n            distribution_comparison[(int) (a[x]*b[y]/10)]++;\n        }\n    }\n    for (int x = 0; x < 10; ++x){\n        if (distribution_comparison[x] != distribution[x]){\n            err += 1;\n            break;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "atomic",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_predecrement.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:atomic,construct-independent,V:2.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t *a = (real_t *)malloc(n * sizeof(real_t));\n    real_t *b = (real_t *)malloc(n * sizeof(real_t));\n    int *distribution = (int *)malloc(10 * sizeof(int));\n    int *distribution_comparison = (int *)malloc(10 * sizeof(int));\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n    }\n    for (int x = 0; x < 10; ++x){\n        distribution[x] = 0;\n        distribution_comparison[x] = 0;\n    }\n\n    #pragma acc data copyin(a[0:n], b[0:n]) copy(distribution[0:10])\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                #pragma acc loop\n                for (int y = 0; y < n; ++y){\n                    #pragma acc atomic\n                        --distribution[(int) (a[x]*b[y]/10)];\n                }\n            }\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        for (int y = 0; y < n; ++y){\n            distribution_comparison[(int) (a[x]*b[y]/10)]--;\n        }\n    }\n    for (int x = 0; x < 10; ++x){\n        if (distribution_comparison[x] != distribution[x]){\n            err += 1;\n            break;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "atomic",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_preincrement.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:atomic,construct-independent,V:2.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t *a = (real_t *)malloc(n * sizeof(real_t));\n    real_t *b = (real_t *)malloc(n * sizeof(real_t));\n    int *distribution = (int *)malloc(10 * sizeof(int));\n    int *distribution_comparison = (int *)malloc(10 * sizeof(int));\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n    }\n    for (int x = 0; x < 10; ++x){\n        distribution[x] = 0;\n        distribution_comparison[x] = 0;\n    }\n\n    #pragma acc data copyin(a[0:n], b[0:n]) copy(distribution[0:10])\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                #pragma acc loop\n                for (int y = 0; y < n; ++y){\n                    #pragma acc atomic\n                        ++distribution[(int) (a[x]*b[y]/10)];\n                }\n            }\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        for (int y = 0; y < n; ++y){\n            distribution_comparison[(int) (a[x]*b[y]/10)]++;\n        }\n    }\n    for (int x = 0; x < 10; ++x){\n        if (distribution_comparison[x] != distribution[x]){\n            err += 1;\n            break;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "atomic",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_rshift_equals.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:atomic,construct-independent,V:2.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    unsigned int *a = (unsigned int *)malloc(n * sizeof(int));\n    unsigned int *b = (unsigned int *)malloc(n * sizeof(int));\n\n    for (int x = 0; x < n; ++x){\n        a[x] = 1<<7;\n        for (int y = 0; y < 7; ++y){\n            if ((rand()/(unsigned int) (RAND_MAX)) > .5){\n                b[x] += 1<<y;\n            }\n        }\n    }\n\n    #pragma acc data copyin(b[0:n]) copy(a[0:n])\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                #pragma acc loop\n                for (int y = 0; y < 7; ++y){\n                    if ((b[x]>>y)%2 == 1){\n                        #pragma acc atomic\n                            a[x] >>= 1;\n                    }\n                }\n            }\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        for (int y = 0; y < 7; ++y){\n            if ((b[x]>>y)%2 == 1){\n                a[x] <<= 1;\n            }\n        }\n        if (a[x] != 1<<7){\n            err += 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "atomic",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_structured_assign_assign.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:atomic,construct-independent,V:2.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t *a = (real_t *)malloc(n * sizeof(real_t));\n    real_t *b = (real_t *)malloc(n * sizeof(real_t));\n    real_t *c = (real_t *)malloc(n * sizeof(real_t));\n    real_t *b_copy = (real_t *)malloc(n * sizeof(real_t));\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n        b_copy[x] = b[x];\n    }\n\n    #pragma acc data copyin(a[0:n]) copy(b[0:n]) copyout(c[0:n])\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                #pragma acc atomic update capture\n                {\n                    c[x] = b[x];\n                    b[x] = a[x];\n                }\n            }\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        if (abs(c[x] - b_copy[x]) > PRECISION){\n            err++;\n        }\n        if (abs(b[x] - a[x]) > PRECISION){\n            err++;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "atomic",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_structured_assign_bitand_equals.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:atomic,construct-independent,V:2.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    int *a = (int *)malloc(n * sizeof(int));\n    int *b = (int *)malloc(n * sizeof(int));\n    int *totals = (int *)malloc((n/10 + 1) * sizeof(int));\n    int *totals_comparison = (int *)malloc((n/10 + 1) * sizeof(int));\n    int *temp_a = (int *)malloc(10 * sizeof(int));\n    int *temp_b = (int *)malloc(10 * sizeof(int));\n    int iterator;\n    int iterator2;\n    int init;\n\n    for (int x = 0; x < n; ++x){\n        for (int y = 0; y < 8; ++y){\n            if (rand()/(real_t)(RAND_MAX) < .933){ //.933 gets close to a 50/50 distribution for a collescence of 10 values\n                a[x] += 1<<y;\n            }\n        }\n    }\n    for (int x = 0; x < n/10 + 1; ++x){\n        for (int y = 0; y < 8; ++y){\n            totals[x] +=  1<<y;\n            totals_comparison[x] += 1<<y;\n        }\n    }\n    for (int x = 0; x < n; ++x){\n        b[x] = 0;\n    }\n    #pragma acc data copyin(a[0:n]) copy(totals[0:n/10 + 1]) copyout(b[0:n])\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                #pragma acc atomic update capture\n                    {\n                        b[x] = totals[x/10];\n                        totals[x/10] &= a[x];\n                    }\n            }\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        totals_comparison[x/10] &= a[x];\n    }\n    for (int x = 0; x < (n/10 + 1); ++x){\n        if (totals_comparison[x] != totals[x]){\n            err += 1;\n            break;\n        }\n    }\n    for (int x = 0; x < 8; ++x){\n        init += 1<<x;\n    }\n\n    for (int x = 0; x < n; x = x + 10){\n        int y = x;\n        for (; y < x + 10 && y < n; y++){\n            temp_a[y - x] = a[y];\n            temp_b[y - x] = b[y];\n        }\n        if (!is_possible(temp_a, temp_b, y - x, init)){\n            err += 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "atomic",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_structured_assign_bitor_equals.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:atomic,construct-independent,V:2.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    int *a = (int *)malloc(n * sizeof(int));\n    int *b = (int *)malloc(n * sizeof(int));\n    int *totals = (int *)malloc((n/10 + 1) * sizeof(int));\n    int *totals_comparison = (int *)malloc((n/10 + 1) * sizeof(int));\n    int *temp_a = (int *)malloc(10 * sizeof(int));\n    int *temp_b = (int *)malloc(10 * sizeof(int));\n    int iterator;\n    int iterator2;\n    int init;\n\n    for (int x = 0; x < n; ++x){\n        for (int y = 0; y < 8; ++y){\n            if (rand()/(real_t)(RAND_MAX) < .933){ //.933 gets close to a 50/50 distribution for a collescence of 10 values\n                a[x] += 1<<y;\n            }\n        }\n    }\n    for (int x = 0; x < n/10 + 1; ++x){\n        for (int y = 0; y < 8; ++y){\n            totals[x] +=  1<<y;\n            totals_comparison[x] += 1<<y;\n        }\n    }\n    for (int x = 0; x < n; ++x){\n        b[x] = 0;\n    }\n    #pragma acc data copyin(a[0:n]) copy(totals[0:n/10 + 1]) copyout(b[0:n])\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                #pragma acc atomic update capture\n                    {\n                        b[x] = totals[x/10];\n                        totals[x/10] |= a[x];\n                    }\n            }\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        totals_comparison[x/10] |= a[x];\n    }\n    for (int x = 0; x < (n/10 + 1); ++x){\n        if (totals_comparison[x] != totals[x]){\n            err += 1;\n            break;\n        }\n    }\n    for (int x = 0; x < 8; ++x){\n        init += 1<<x;\n    }\n    int y;\n    for (int x = 0; x < n; x = x + 10){\n        y = x;\n        for (; y < x + 10 && y < n; y++){\n            temp_a[y - x] = a[y];\n            temp_b[y - x] = b[y];\n        }\n        if (!is_possible(temp_a, temp_b, (y - x) - 1, init)){\n            err += 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "atomic",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_structured_assign_bitxor_equals.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:atomic,construct-independent,V:2.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    int *a = (int *)malloc(n * sizeof(int));\n    int *b = (int *)malloc(n * sizeof(int));\n    int *totals = (int *)malloc((n/10 + 1) * sizeof(int));\n    int *totals_comparison = (int *)malloc((n/10 + 1) * sizeof(int));\n    int *temp_a = (int *)malloc(10 * sizeof(int));\n    int *temp_b = (int *)malloc(10 * sizeof(int));\n    int iterator;\n    int iterator2;\n    int init;\n\n    for (int x = 0; x < n; ++x){\n        for (int y = 0; y < 8; ++y){\n            if (rand()/(real_t)(RAND_MAX) < .933){ //.933 gets close to a 50/50 distribution for a collescence of 10 values\n                a[x] += 1<<y;\n            }\n        }\n    }\n    for (int x = 0; x < n/10 + 1; ++x){\n        for (int y = 0; y < 8; ++y){\n            totals[x] +=  1<<y;\n            totals_comparison[x] += 1<<y;\n        }\n    }\n    for (int x = 0; x < n; ++x){\n        b[x] = 0;\n    }\n    #pragma acc data copyin(a[0:n]) copy(totals[0:n/10 + 1]) copyout(b[0:n])\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                #pragma acc atomic update capture\n                    {\n                        b[x] = totals[x/10];\n                        totals[x/10] ^= a[x];\n                    }\n            }\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        totals_comparison[x/10] ^= a[x];\n    }\n    for (int x = 0; x < (n/10 + 1); ++x){\n        if (totals_comparison[x] != totals[x]){\n            err += 1;\n            break;\n        }\n    }\n    for (int x = 0; x < 8; ++x){\n        init += 1<<x;\n    }\n    int y;\n    for (int x = 0; x < n; x = x + 10){\n        y = x;\n        for (; y < x + 10 && y < n; y++){\n            temp_a[y - x] = a[y];\n            temp_b[y - x] = b[y];\n        }\n        if (!is_possible(temp_a, temp_b, (y - x) - 1, init)){\n            err += 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "atomic",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_structured_assign_divided_equals.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:atomic,construct-independent,V:2.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t *a = (real_t *)malloc(n * sizeof(real_t));\n    real_t *b = (real_t *)malloc(n * sizeof(real_t));\n    real_t *c = (real_t *)malloc(n * sizeof(real_t));\n    real_t *totals = (real_t *)malloc((n/10 + 1) * sizeof(real_t));\n    real_t *totals_comparison = (real_t *)malloc((n/10 + 1) * sizeof(real_t));\n    real_t *temp_a = (real_t *)malloc(10 * sizeof(real_t));\n    real_t *temp_b = (real_t *)malloc(10 * sizeof(real_t));\n    real_t *temp_c = (real_t *)malloc(10 * sizeof(real_t));\n    int temp_iterator;\n    int ab_iterator;\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n        c[x] = 0;\n    }\n    for (int x = 0; x < n/10 + 1; ++x){\n        totals[x] = 1;\n        totals_comparison[x] = 1;\n    }\n\n    #pragma acc data copyin(a[0:n], b[0:n]) copy(totals[0:n/10 + 1]) copyout(c[0:n])\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                #pragma acc atomic update capture\n                {\n                    c[x] = totals[x/10];\n                    totals[x/10] /= (a[x] + b[x]);\n                }\n            }\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        totals_comparison[x/10] /= a[x] + b[x];\n    }\n    for (int x = 0; x < 10; ++x){\n        if (fabs(totals_comparison[x] - totals[x]) > PRECISION){\n            err += 1;\n            break;\n        }\n    }\n\n    for (int x = 0; x < n; x = x + 10){\n        temp_iterator = 0;\n        for (ab_iterator = x; ab_iterator < n && ab_iterator < x + 10;  ab_iterator+= 1){\n            temp_a[temp_iterator] = a[ab_iterator];\n            temp_b[temp_iterator] = b[ab_iterator];\n            temp_c[temp_iterator] = c[ab_iterator];\n            temp_iterator++;\n        }\n        if (!(is_possible(temp_a, temp_b, temp_c, temp_iterator, 1))){\n            err++;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "atomic",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_structured_assign_expr_bitand_x.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:atomic,construct-independent,V:2.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    int *a = (int *)malloc(n * sizeof(int));\n    int *b = (int *)malloc(n * sizeof(int));\n    int *totals = (int *)malloc((n/10 + 1) * sizeof(int));\n    int *totals_comparison = (int *)malloc((n/10 + 1) * sizeof(int));\n    int *temp_a = (int *)malloc(10 * sizeof(int));\n    int *temp_b = (int *)malloc(10 * sizeof(int));\n    int iterator;\n    int iterator2;\n    int init;\n\n    for (int x = 0; x < n; ++x){\n        for (int y = 0; y < 8; ++y){\n            if (rand()/(real_t)(RAND_MAX) < .933){ //.933 gets close to a 50/50 distribution for a collescence of 10 values\n                a[x] += 1<<y;\n            }\n        }\n    }\n    for (int x = 0; x < n/10 + 1; ++x){\n        for (int y = 0; y < 8; ++y){\n            totals[x] +=  1<<y;\n            totals_comparison[x] += 1<<y;\n        }\n    }\n    for (int x = 0; x < n; ++x){\n        b[x] = 0;\n    }\n    #pragma acc data copyin(a[0:n]) copy(totals[0:n/10 + 1]) copyout(b[0:n])\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                #pragma acc atomic update capture\n                    {\n                        b[x] = totals[x/10];\n                        totals[x/10] = a[x] & totals[x/10];\n                    }\n            }\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        totals_comparison[x/10] &= a[x];\n    }\n    for (int x = 0; x < (n/10 + 1); ++x){\n        if (totals_comparison[x] != totals[x]){\n            err += 1;\n            break;\n        }\n    }\n    for (int x = 0; x < 8; ++x){\n        init += 1<<x;\n    }\n\n    for (int x = 0; x < n; x = x + 10){\n        int y = x;\n        for (; y < x + 10 && y < n; y++){\n            temp_a[y - x] = a[y];\n            temp_b[y - x] = b[y];\n        }\n        if (!is_possible(temp_a, temp_b, y - x, init)){\n            err += 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "atomic",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_structured_assign_expr_bitor_x.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:atomic,construct-independent,V:2.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    int *a = (int *)malloc(n * sizeof(int));\n    int *b = (int *)malloc(n * sizeof(int));\n    int *totals = (int *)malloc((n/10 + 1) * sizeof(int));\n    int *totals_comparison = (int *)malloc((n/10 + 1) * sizeof(int));\n    int *temp_a = (int *)malloc(10 * sizeof(int));\n    int *temp_b = (int *)malloc(10 * sizeof(int));\n    int iterator;\n    int iterator2;\n    int init;\n\n    for (int x = 0; x < n; ++x){\n        for (int y = 0; y < 8; ++y){\n            if (rand()/(real_t)(RAND_MAX) < .933){ //.933 gets close to a 50/50 distribution for a collescence of 10 values\n                a[x] += 1<<y;\n            }\n        }\n    }\n    for (int x = 0; x < n/10 + 1; ++x){\n        for (int y = 0; y < 8; ++y){\n            totals[x] +=  1<<y;\n            totals_comparison[x] += 1<<y;\n        }\n    }\n    for (int x = 0; x < n; ++x){\n        b[x] = 0;\n    }\n    #pragma acc data copyin(a[0:n]) copy(totals[0:n/10 + 1]) copyout(b[0:n])\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                #pragma acc atomic update capture\n                    {\n                        b[x] = totals[x/10];\n                        totals[x/10] = a[x] | totals[x/10];\n                    }\n            }\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        totals_comparison[x/10] |= a[x];\n    }\n    for (int x = 0; x < (n/10 + 1); ++x){\n        if (totals_comparison[x] != totals[x]){\n            err += 1;\n            break;\n        }\n    }\n    for (int x = 0; x < 8; ++x){\n        init += 1<<x;\n    }\n    int y;\n    for (int x = 0; x < n; x = x + 10){\n        y = x;\n        for (; y < x + 10 && y < n; y++){\n            temp_a[y - x] = a[y];\n            temp_b[y - x] = b[y];\n        }\n        if (!is_possible(temp_a, temp_b, (y - x) - 1, init)){\n            err += 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "atomic",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_structured_assign_expr_bitxor_x.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:atomic,construct-independent,V:2.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    int *a = (int *)malloc(n * sizeof(int));\n    int *b = (int *)malloc(n * sizeof(int));\n    int *totals = (int *)malloc((n/10 + 1) * sizeof(int));\n    int *totals_comparison = (int *)malloc((n/10 + 1) * sizeof(int));\n    int *temp_a = (int *)malloc(10 * sizeof(int));\n    int *temp_b = (int *)malloc(10 * sizeof(int));\n    int iterator;\n    int iterator2;\n    int init;\n\n    for (int x = 0; x < n; ++x){\n        for (int y = 0; y < 8; ++y){\n            if (rand()/(real_t)(RAND_MAX) < .933){ //.933 gets close to a 50/50 distribution for a collescence of 10 values\n                a[x] += 1<<y;\n            }\n        }\n    }\n    for (int x = 0; x < n/10 + 1; ++x){\n        for (int y = 0; y < 8; ++y){\n            totals[x] +=  1<<y;\n            totals_comparison[x] += 1<<y;\n        }\n    }\n    for (int x = 0; x < n; ++x){\n        b[x] = 0;\n    }\n    #pragma acc data copyin(a[0:n]) copy(totals[0:n/10 + 1]) copyout(b[0:n])\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                #pragma acc atomic update capture\n                    {\n                        b[x] = totals[x/10];\n                        totals[x/10] = a[x] ^ totals[x/10];\n                    }\n            }\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        totals_comparison[x/10] ^= a[x];\n    }\n    for (int x = 0; x < (n/10 + 1); ++x){\n        if (totals_comparison[x] != totals[x]){\n            err += 1;\n            break;\n        }\n    }\n    for (int x = 0; x < 8; ++x){\n        init += 1<<x;\n    }\n    int y;\n    for (int x = 0; x < n; x = x + 10){\n        y = x;\n        for (; y < x + 10 && y < n; y++){\n            temp_a[y - x] = a[y];\n            temp_b[y - x] = b[y];\n        }\n        if (!is_possible(temp_a, temp_b, (y - x) - 1, init)){\n            err += 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "atomic",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_structured_assign_expr_divided_x.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:atomic,construct-independent,V:2.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t *a = (real_t *)malloc(n * sizeof(real_t));\n    real_t *b = (real_t *)malloc(n * sizeof(real_t));\n    real_t *c = (real_t *)malloc(n * sizeof(real_t));\n    real_t *totals = (real_t *)malloc((n/10 + 1) * sizeof(real_t));\n    real_t* passed_a = (real_t *)malloc(10 * sizeof(real_t));\n    real_t* passed_b = (real_t *)malloc(10 * sizeof(real_t));\n    real_t *temp_a = (real_t *)malloc(10 * sizeof(real_t));\n    real_t *temp_b = (real_t *)malloc(10 * sizeof(real_t));\n    real_t *temp_c = (real_t *)malloc(10 * sizeof(real_t));\n    int temp_iterator;\n    int ab_iterator;\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n        c[x] = 0;\n    }\n    for (int x = 0; x < n/10 + 1; ++x){\n        totals[x] = 1;\n    }\n\n    #pragma acc data copyin(a[0:n], b[0:n]) copy(totals[0:n/10 + 1]) copyout(c[0:n])\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                #pragma acc atomic update capture\n                {\n                    c[x] = totals[x/10];\n                    totals[x/10] = (a[x] + b[x]) / totals[x/10];\n                }\n            }\n        }\n    }\n\n    for (int x = 0; x < n; x = x + 10){\n        for (int y = 0; y < 10 && (x + y) < n; ++y){\n            passed_a[y] = a[x + y];\n            passed_b[y] = b[x + y];\n        }\n        if (!(is_possible_2(passed_a, passed_b, 10, 1, totals[x/10]))){\n            err += 1;\n            break;\n        }\n    }\n\n    for (int x = 0; x < n; x = x + 10){\n        temp_iterator = 0;\n        for (ab_iterator = x; ab_iterator < n && ab_iterator < x + 10;  ab_iterator+= 1){\n            temp_a[temp_iterator] = a[ab_iterator];\n            temp_b[temp_iterator] = b[ab_iterator];\n            temp_c[temp_iterator] = c[ab_iterator];\n            temp_iterator++;\n        }\n        if (!(is_possible(temp_a, temp_b, temp_c, temp_iterator, 1))){\n            err++;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "atomic",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_structured_assign_expr_multiply_x.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:atomic,construct-independent,V:2.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t *a = (real_t *)malloc(n * sizeof(real_t));\n    real_t *b = (real_t *)malloc(n * sizeof(real_t));\n    real_t *c = (real_t *)malloc(n * sizeof(real_t));\n    real_t *totals = (real_t *)malloc((n/10 + 1) * sizeof(real_t));\n    real_t *totals_comparison = (real_t *)malloc((n/10 + 1) * sizeof(real_t));\n    real_t * passed_ab = (real_t *)malloc(10 * sizeof(real_t));\n    real_t * passed_c = (real_t *)malloc(10 * sizeof(real_t));\n    int passed_indexer;\n    int absolute_indexer;\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n    }\n    for (int x = 0; x < n/10 + 1; ++x){\n        totals[x] = 1;\n        totals_comparison[x] = 1;\n    }\n\n    #pragma acc data copyin(a[0:n], b[0:n]) copy(totals[0:n/10 + 1]) copyout(c[0:n])\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                #pragma acc atomic update capture\n                {\n                    c[x] = totals[x%(n/10 + 1)];\n                    totals[x%(n/10 + 1)] = (a[x] + b[x]) * totals[x%(n/10 + 1)];\n                }\n            }\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        totals_comparison[x%(n/10 + 1)] *= a[x] + b[x];\n    }\n    for (int x = 0; x < 10; ++x){\n        if (fabs(totals_comparison[x] - totals[x]) > PRECISION * totals_comparison[x]){\n            err += 1;\n            break;\n        }\n    }\n\n    for (int x = 0; x < n/10 + 1; ++x){\n        for (passed_indexer = 0, absolute_indexer = x; absolute_indexer < n; passed_indexer++, absolute_indexer += n/10 + 1){\n            passed_ab[passed_indexer] = a[absolute_indexer] + b[absolute_indexer];\n            passed_c[passed_indexer] = c[absolute_indexer];\n        }\n        if (!is_possible(passed_ab, passed_c, passed_indexer - 1, 1)){\n            err++;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "atomic",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_structured_assign_expr_plus_x.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:atomic,construct-independent,V:2.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t *a = (real_t *)malloc(n * sizeof(real_t));\n    real_t *b = (real_t *)malloc(n * sizeof(real_t));\n    real_t *c = (real_t *)malloc(n * sizeof(real_t));\n    real_t *totals = (real_t *)malloc((n/10 + 1) * sizeof(real_t));\n    real_t *totals_comparison = (real_t *)malloc((n/10 + 1) * sizeof(real_t));\n    real_t *passed_ab = (real_t *)malloc(10 * sizeof(real_t));\n    real_t *passed_c = (real_t *)malloc(10 * sizeof(real_t));\n    int passed_indexer;\n    int absolute_indexer;\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n    }\n    for (int x = 0; x < n/10 + 1; ++x){\n        totals[x] = 0;\n        totals_comparison[x] = 0;\n    }\n\n    #pragma acc data copyin(a[0:n], b[0:n]) copy(totals[0:n/10 + 1]) copyout(c[0:n])\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                #pragma acc atomic update capture\n                {\n                    c[x] = totals[x%(n/10 + 1)];\n                    totals[x%(n/10 + 1)] = (a[x] * b[x]) + totals[x%(n/10 + 1)];\n                }\n            }\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        totals_comparison[x%(n/10 + 1)] += a[x] * b[x];\n    }\n    for (int x = 0; x < n/10 + 1; ++x){\n        if (fabs(totals_comparison[x] - totals[x]) > PRECISION){\n            err += 1;\n            break;\n        }\n    }\n\n    for (int x = 0; x < n/10 + 1; ++x){\n        for (passed_indexer = 0, absolute_indexer = x; absolute_indexer < n; passed_indexer++, absolute_indexer+= (n/10 + 1)){\n            passed_ab[passed_indexer] = a[absolute_indexer] * b[absolute_indexer];\n            passed_c[passed_indexer] = c[absolute_indexer];\n        }\n        if (!is_possible(passed_ab, passed_c, passed_indexer - 1, 0)){\n            err++;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "atomic",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_structured_assign_lshift_equals.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:atomic,construct-independent,V:2.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    unsigned int *a = (unsigned int *)malloc(n * sizeof(int));\n    unsigned int *b = (unsigned int *)malloc(n * sizeof(int));\n    unsigned int *c = (unsigned int *)malloc(7 * n * sizeof(int));\n    unsigned int passed = 1;\n\n    for (int x = 0; x < n; ++x){\n        a[x] = 1;\n        for (int y = 0; y < 7; ++y){\n            if ((rand()/(real_t) (RAND_MAX)) > .5){\n                b[x] += 1<<y;\n            }\n        }\n    }\n\n    #pragma acc data copyin(b[0:n]) copy(a[0:n]) copyout(c[0:7*n])\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                #pragma acc loop\n                for (int y = 0; y < 7; ++y){\n                    c[x * 7 + y] = a[x];\n                    if ((b[x]>>y)%2 == 1){\n                        #pragma acc atomic update capture\n                        {\n                            c[x * 7 + y] = a[x];\n                            a[x] <<= 1;\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        for (int y = 0; y < 7; ++y){\n            if ((b[x]>>y)%2 == 1){\n                a[x] >>= 1;\n            }\n        }\n        if (a[x] != 1){\n            err += 1;\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        if (!is_possible(b[x], &(c[x * 7]), 7, passed)){\n            err++;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "atomic",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_structured_assign_minus_equals.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:atomic,construct-independent,V:2.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t *a = (real_t *)malloc(n * sizeof(real_t));\n    real_t *b = (real_t *)malloc(n * sizeof(real_t));\n    real_t *c = (real_t *)malloc(n * sizeof(real_t));\n    real_t *totals = (real_t *)malloc(10 * sizeof(real_t));\n    real_t *totals_host = (real_t *)malloc(10 * sizeof(real_t));\n    real_t * passed_ab = (real_t *)malloc((n/10 + 1) * sizeof(real_t));\n    real_t * passed_c = (real_t *)malloc((n/10 + 1) * sizeof(real_t));\n    int passed_indexer;\n    int absolute_indexer;\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n    }\n    for (int x = 0; x < 10; ++x){\n        totals[x] = 0;\n    }\n\n    #pragma acc data copyin(a[0:n], b[0:n]) copy(totals[0:10])\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                #pragma acc atomic update capture\n                {\n                    c[x] = totals[x%10];\n                    totals[x%10] -= (a[x] + b[x]);\n                }\n            }\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        totals_host[x%10] = totals_host[x%10] - (a[x] + b[x]);\n    }\n    for (int x = 0; x < 10; ++x){\n        if (fabs(totals_host[x] - totals[x]) > PRECISION){\n            err += 1;\n        }\n    }\n\n    for (int x = 0; x < 10; ++x){\n        for (passed_indexer = 0, absolute_indexer = x; absolute_indexer < n; passed_indexer++, absolute_indexer+= 10){\n            passed_ab[passed_indexer] = a[absolute_indexer] + b[absolute_indexer];\n            passed_c[passed_indexer] = c[absolute_indexer];\n        }\n        if (!is_possible(passed_ab, passed_c, passed_indexer - 1, 0)){\n            err++;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "atomic",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_structured_assign_multiply_equals.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:atomic,construct-independent,V:2.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t *a = (real_t *)malloc(n * sizeof(real_t));\n    real_t *b = (real_t *)malloc(n * sizeof(real_t));\n    real_t *c = (real_t *)malloc(n * sizeof(real_t));\n    real_t *totals = (real_t *)malloc((n/10 + 1) * sizeof(real_t));\n    real_t *totals_comparison = (real_t *)malloc((n/10 + 1) * sizeof(real_t));\n    real_t * passed_ab = (real_t *)malloc(10 * sizeof(real_t));\n    real_t * passed_c = (real_t *)malloc(10 * sizeof(real_t));\n    int passed_indexer;\n    int absolute_indexer;\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n    }\n    for (int x = 0; x < n/10 + 1; ++x){\n        totals[x] = 1;\n        totals_comparison[x] = 1;\n    }\n\n    #pragma acc data copyin(a[0:n], b[0:n]) copy(totals[0:n/10 + 1]) copyout(c[0:n])\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                #pragma acc atomic update capture\n                {\n                    c[x] = totals[x%(n/10 + 1)];\n                    totals[x%(n/10 + 1)] *= a[x] + b[x];\n                }\n            }\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        totals_comparison[x%(n/10 + 1)] *= a[x] + b[x];\n    }\n    for (int x = 0; x < 10; ++x){\n        if (fabs(totals_comparison[x] - totals[x]) > PRECISION * totals_comparison[x]){\n            err += 1;\n            break;\n        }\n    }\n\n    for (int x = 0; x < n/10 + 1; ++x){\n        for (passed_indexer = 0, absolute_indexer = x; absolute_indexer < n; passed_indexer++, absolute_indexer += n/10 + 1){\n            passed_ab[passed_indexer] = a[absolute_indexer] + b[absolute_indexer];\n            passed_c[passed_indexer] = c[absolute_indexer];\n        }\n        if (!is_possible(passed_ab, passed_c, passed_indexer - 1, 1)){\n            err++;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "atomic",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_structured_assign_plus_equals.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:atomic,construct-independent,V:2.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t *a = (real_t *)malloc(n * sizeof(real_t));\n    real_t *b = (real_t *)malloc(n * sizeof(real_t));\n    real_t *c = (real_t *)malloc(n * sizeof(real_t));\n    real_t *totals = (real_t *)malloc((n/10 + 1) * sizeof(real_t));\n    real_t *totals_comparison = (real_t *)malloc((n/10 + 1) * sizeof(real_t));\n    real_t *passed_ab = (real_t *)malloc(10 * sizeof(real_t));\n    real_t *passed_c = (real_t *)malloc(10 * sizeof(real_t));\n    int passed_indexer;\n    int absolute_indexer;\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n    }\n    for (int x = 0; x < n/10 + 1; ++x){\n        totals[x] = 0;\n        totals_comparison[x] = 0;\n    }\n\n    #pragma acc data copyin(a[0:n], b[0:n]) copy(totals[0:n/10 + 1]) copyout(c[0:n])\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                #pragma acc atomic update capture\n                {\n                    c[x] = totals[x%(n/10 + 1)];\n                    totals[x%(n/10 + 1)] += a[x] * b[x];\n                }\n            }\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        totals_comparison[x%(n/10 + 1)] += a[x] * b[x];\n    }\n    for (int x = 0; x < n/10 + 1; ++x){\n        if (fabs(totals_comparison[x] - totals[x]) > PRECISION){\n            err += 1;\n            break;\n        }\n    }\n\n    for (int x = 0; x < n/10 + 1; ++x){\n        for (passed_indexer = 0, absolute_indexer = x; absolute_indexer < n; passed_indexer++, absolute_indexer+= (n/10 + 1)){\n            passed_ab[passed_indexer] = a[absolute_indexer] * b[absolute_indexer];\n            passed_c[passed_indexer] = c[absolute_indexer];\n        }\n        if (!is_possible(passed_ab, passed_c, passed_indexer - 1, 0)){\n            err++;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "atomic",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_structured_assign_postdecrement.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:atomic,construct-independent,V:2.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t *a = (real_t *)malloc(n * sizeof(real_t));\n    real_t *b = (real_t *)malloc(n * sizeof(real_t));\n    int *c = (int *)malloc(n * sizeof(int));\n    int *distribution = (int *)malloc(10 * sizeof(int));\n    int *distribution_comparison = (int *)malloc(10 * sizeof(int));\n    bool found = false;\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n    }\n    for (int x = 0; x < 10; ++x){\n        distribution[x] = 0;\n        distribution_comparison[x] = 0;\n    }\n\n    #pragma acc data copyin(a[0:n], b[0:n]) copy(distribution[0:10]) copyout(c[0:n])\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                #pragma acc atomic update capture\n                {\n                    c[x] = distribution[(int) (a[x]*b[x]/10)];\n                    (distribution[(int) (a[x]*b[x]/10)])--;\n                }\n            }\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        distribution_comparison[(int) (a[x]*b[x]/10)]--;\n    }\n    for (int x = 0; x < 10; ++x){\n        if (distribution_comparison[x] != distribution[x]){\n            err += 1;\n            break;\n        }\n    }\n\n    for (int x = 0; x < 10; ++x){\n        for (int y = 0; y > -distribution_comparison[x]; --y){\n            for (int z = 0; z < n; ++z){\n                if (y == c[z] && x == (int) (a[x] * b[x] / 10)){\n                    found = true;\n                    break;\n                }\n            }\n            if (!found){\n                err++;\n            }\n            found = false;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "atomic",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_structured_assign_postincrement.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:atomic,construct-independent,V:2.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t *a = (real_t *)malloc(n * sizeof(real_t));\n    real_t *b = (real_t *)malloc(n * sizeof(real_t));\n    int *c = (int *)malloc(n * sizeof(int));\n    int *distribution = (int *)malloc(10 * sizeof(int));\n    int *distribution_comparison = (int *)malloc(10 * sizeof(int));\n    bool found = false;\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n    }\n    for (int x = 0; x < 10; ++x){\n        distribution[x] = 0;\n        distribution_comparison[x] = 0;\n    }\n\n    #pragma acc data copyin(a[0:n], b[0:n]) copy(distribution[0:10]) copyout(c[0:n])\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                #pragma acc atomic update capture\n                {\n                    c[x] = distribution[(int) (a[x]*b[x]/10)];\n                    distribution[(int) (a[x]*b[x]/10)]++;\n                }\n            }\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        distribution_comparison[(int) (a[x]*b[x]/10)]++;\n    }\n    for (int x = 0; x < 10; ++x){\n        if (distribution_comparison[x] != distribution[x]){\n            err += 1;\n            break;\n        }\n    }\n\n    for (int x = 0; x < 10; ++x){\n        for (int y = 0; y < distribution_comparison[x]; ++y){\n            for (int z = 0; z < n; ++z){\n                if (c[z] == y && (int) (a[z]*b[z]/10) == x){\n                    found = true;\n                    break;\n                }\n            }\n            if (!found){\n                err++;\n            }\n            found = false;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "atomic",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_structured_assign_predecrement.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:atomic,construct-independent,V:2.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t *a = (real_t *)malloc(n * sizeof(real_t));\n    real_t *b = (real_t *)malloc(n * sizeof(real_t));\n    int *c = (int *)malloc(n * sizeof(int));\n    int *distribution = (int *)malloc(10 * sizeof(int));\n    int *distribution_comparison = (int *)malloc(10 * sizeof(int));\n    bool found = false;\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n    }\n    for (int x = 0; x < 10; ++x){\n        distribution[x] = 0;\n        distribution_comparison[x] = 0;\n    }\n\n    #pragma acc data copyin(a[0:n], b[0:n]) copy(distribution[0:10]) copyout(c[0:n])\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                #pragma acc atomic update capture\n                {\n                    c[x] = distribution[(int) (a[x]*b[x]/10)];\n                    --distribution[(int) (a[x]*b[x]/10)];\n                }\n            }\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        distribution_comparison[(int) (a[x]*b[x]/10)]--;\n    }\n    for (int x = 0; x < 10; ++x){\n        if (distribution_comparison[x] != distribution[x]){\n            err += 1;\n            break;\n        }\n    }\n\n    for (int x = 0; x < 10; ++x){\n        for (int y = 0; y > distribution[x]; --y){\n            for (int z = 0; z < n; ++z){\n                if (c[z] == y && x == (int) (a[z] * b[z] / 10)){\n                    found = true;\n                    break;\n                }\n            }\n            if (!found){\n                err++;\n            }\n            found = false;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "atomic",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_structured_assign_preincrement.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:atomic,construct-independent,V:2.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t *a = (real_t *)malloc(n * sizeof(real_t));\n    real_t *b = (real_t *)malloc(n * sizeof(real_t));\n    int *c = (int *)malloc(n * sizeof(int));\n    int *distribution = (int *)malloc(10 * sizeof(int));\n    int *distribution_comparison = (int *)malloc(10 * sizeof(int));\n    bool found = false;\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n    }\n    for (int x = 0; x < 10; ++x){\n        distribution[x] = 0;\n        distribution_comparison[x] = 0;\n    }\n\n    #pragma acc data copyin(a[0:n], b[0:n]) copy(distribution[0:10]) copyout(c[0:n])\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                #pragma acc atomic update capture\n                {\n                    c[x] = distribution[(int) (a[x]*b[x]/10)];\n                    ++distribution[(int) (a[x]*b[x]/10)];\n                }\n            }\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        distribution_comparison[(int) (a[x]*b[x]/10)]++;\n    }\n    for (int x = 0; x < 10; ++x){\n        if (distribution_comparison[x] != distribution[x]){\n            err += 1;\n            break;\n        }\n    }\n\n    for (int x = 0; x < 10; ++x){\n        for (int y = 0; y < distribution[x]; ++y){\n            for (int z = 0; z < n; ++z){\n                if (c[z] == y && x == (int) (a[z] * b[z] / 10)){\n                    found = true;\n                    break;\n                }\n            }\n            if (!found){\n                err++;\n            }\n            found = false;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "atomic",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_structured_assign_rshift_equals.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:atomic,construct-independent,V:2.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    unsigned int *a = (unsigned int *)malloc(n * sizeof(int));\n    unsigned int *b = (unsigned int *)malloc(n * sizeof(int));\n    unsigned int *c = (unsigned int *)malloc(7 * n * sizeof(int));\n    unsigned int passed = 1<<8;\n\n    for (int x = 0; x < n; ++x){\n        a[x] = 1<<8;\n        for (int y = 0; y < 7; ++y){\n            if ((rand()/(real_t) (RAND_MAX)) > .5){\n                b[x] += 1<<y;\n            }\n        }\n    }\n\n    #pragma acc data copyin(b[0:n]) copy(a[0:n]) copyout(c[0:7*n])\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                #pragma acc loop\n                for (int y = 0; y < 7; ++y){\n                    c[x * 7 + y] = a[x];\n                    if ((b[x]>>y)%2 == 1){\n                        #pragma acc atomic update capture\n                        {\n                            c[x * 7 + y] = a[x];\n                            a[x] >>= 1;\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        for (int y = 0; y < 7; ++y){\n            if ((b[x]>>y)%2 == 1){\n                a[x] <<= 1;\n            }\n        }\n        if (a[x] != 1<<8){\n            err += 1;\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        if (!is_possible(b[x], &(c[x * 7]), 7, passed)){\n            err++;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "atomic",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_structured_assign_x_bitand_expr.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:atomic,construct-independent,V:2.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    int *a = (int *)malloc(n * sizeof(int));\n    int *b = (int *)malloc(n * sizeof(int));\n    int *totals = (int *)malloc((n/10 + 1) * sizeof(int));\n    int *totals_comparison = (int *)malloc((n/10 + 1) * sizeof(int));\n    int *temp_a = (int *)malloc(10 * sizeof(int));\n    int *temp_b = (int *)malloc(10 * sizeof(int));\n    int iterator;\n    int iterator2;\n    int init;\n\n    for (int x = 0; x < n; ++x){\n        for (int y = 0; y < 8; ++y){\n            if (rand()/(real_t)(RAND_MAX) < .933){ //.933 gets close to a 50/50 distribution for a collescence of 10 values\n                a[x] += 1<<y;\n            }\n        }\n    }\n    for (int x = 0; x < n/10 + 1; ++x){\n        for (int y = 0; y < 8; ++y){\n            totals[x] +=  1<<y;\n            totals_comparison[x] += 1<<y;\n        }\n    }\n    for (int x = 0; x < n; ++x){\n        b[x] = 0;\n    }\n    #pragma acc data copyin(a[0:n]) copy(totals[0:n/10 + 1]) copyout(b[0:n])\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                #pragma acc atomic update capture\n                    {\n                        b[x] = totals[x/10];\n                        totals[x/10] = totals[x/10] & a[x];\n                    }\n            }\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        totals_comparison[x/10] &= a[x];\n    }\n    for (int x = 0; x < (n/10 + 1); ++x){\n        if (totals_comparison[x] != totals[x]){\n            err += 1;\n            break;\n        }\n    }\n    for (int x = 0; x < 8; ++x){\n        init += 1<<x;\n    }\n\n    for (int x = 0; x < n; x = x + 10){\n        int y = x;\n        for (; y < x + 10 && y < n; y++){\n            temp_a[y - x] = a[y];\n            temp_b[y - x] = b[y];\n        }\n        if (!is_possible(temp_a, temp_b, y - x, init)){\n            err += 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "atomic",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_structured_assign_x_bitor_expr.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:atomic,construct-independent,V:2.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    int *a = (int *)malloc(n * sizeof(int));\n    int *b = (int *)malloc(n * sizeof(int));\n    int *totals = (int *)malloc((n/10 + 1) * sizeof(int));\n    int *totals_comparison = (int *)malloc((n/10 + 1) * sizeof(int));\n    int *temp_a = (int *)malloc(10 * sizeof(int));\n    int *temp_b = (int *)malloc(10 * sizeof(int));\n    int iterator;\n    int iterator2;\n    int init;\n    int y;\n\n    for (int x = 0; x < n; ++x){\n        for (int y = 0; y < 8; ++y){\n            if (rand()/(real_t)(RAND_MAX) < .933){ //.933 gets close to a 50/50 distribution for a collescence of 10 values\n                a[x] += 1<<y;\n            }\n        }\n    }\n    for (int x = 0; x < n/10 + 1; ++x){\n        for (int y = 0; y < 8; ++y){\n            totals[x] +=  1<<y;\n            totals_comparison[x] += 1<<y;\n        }\n    }\n    for (int x = 0; x < n; ++x){\n        b[x] = 0;\n    }\n    #pragma acc data copyin(a[0:n]) copy(totals[0:n/10 + 1]) copyout(b[0:n])\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                #pragma acc atomic update capture\n                    {\n                        b[x] = totals[x/10];\n                        totals[x/10] = totals[x/10] | a[x];\n                    }\n            }\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        totals_comparison[x/10] |= a[x];\n    }\n    for (int x = 0; x < (n/10 + 1); ++x){\n        if (totals_comparison[x] != totals[x]){\n            err += 1;\n            break;\n        }\n    }\n    for (int x = 0; x < 8; ++x){\n        init += 1<<x;\n    }\n    for (int x = 0; x < n; x = x + 10){\n        y = x;\n        for (; y < x + 10 && y < n; y++){\n            temp_a[y - x] = a[y];\n            temp_b[y - x] = b[y];\n        }\n        if (!is_possible(temp_a, temp_b, (y - x) - 1, init)){\n            err += 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "atomic",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_structured_assign_x_bitxor_expr.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:atomic,construct-independent,V:2.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    int *a = (int *)malloc(n * sizeof(int));\n    int *b = (int *)malloc(n * sizeof(int));\n    int *totals = (int *)malloc((n/10 + 1) * sizeof(int));\n    int *totals_comparison = (int *)malloc((n/10 + 1) * sizeof(int));\n    int *temp_a = (int *)malloc(10 * sizeof(int));\n    int *temp_b = (int *)malloc(10 * sizeof(int));\n    int iterator;\n    int iterator2;\n    int init;\n    int y;\n\n    for (int x = 0; x < n; ++x){\n        for (int y = 0; y < 8; ++y){\n            if (rand()/(real_t)(RAND_MAX) < .933){ //.933 gets close to a 50/50 distribution for a collescence of 10 values\n                a[x] += 1<<y;\n            }\n        }\n    }\n    for (int x = 0; x < n/10 + 1; ++x){\n        for (int y = 0; y < 8; ++y){\n            totals[x] +=  1<<y;\n            totals_comparison[x] += 1<<y;\n        }\n    }\n    for (int x = 0; x < n; ++x){\n        b[x] = 0;\n    }\n    #pragma acc data copyin(a[0:n]) copy(totals[0:n/10 + 1]) copyout(b[0:n])\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                #pragma acc atomic update capture\n                    {\n                        b[x] = totals[x/10];\n                        totals[x/10] = totals[x/10] ^ a[x];\n                    }\n            }\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        totals_comparison[x/10] ^= a[x];\n    }\n    for (int x = 0; x < (n/10 + 1); ++x){\n        if (totals_comparison[x] != totals[x]){\n            err += 1;\n            break;\n        }\n    }\n    for (int x = 0; x < 8; ++x){\n        init += 1<<x;\n    }\n    for (int x = 0; x < n; x = x + 10){\n        y = x;\n        for (; y < x + 10 && y < n; y++){\n            temp_a[y - x] = a[y];\n            temp_b[y - x] = b[y];\n        }\n        if (!is_possible(temp_a, temp_b, (y - x) - 1, init)){\n            err += 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "atomic",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_structured_assign_x_divided_expr.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:atomic,construct-independent,V:2.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t *a = (real_t *)malloc(n * sizeof(real_t));\n    real_t *b = (real_t *)malloc(n * sizeof(real_t));\n    real_t *c = (real_t *)malloc(n * sizeof(real_t));\n    real_t *totals = (real_t *)malloc((n/10 + 1) * sizeof(real_t));\n    real_t *totals_comparison = (real_t *)malloc((n/10 + 1) * sizeof(real_t));\n    real_t *temp_a = (real_t *)malloc(10 * sizeof(real_t));\n    real_t *temp_b = (real_t *)malloc(10 * sizeof(real_t));\n    real_t *temp_c = (real_t *)malloc(10 * sizeof(real_t));\n    int temp_iterator;\n    int ab_iterator;\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n        c[x] = 0;\n    }\n    for (int x = 0; x < n/10 + 1; ++x){\n        totals[x] = 1;\n        totals_comparison[x] = 1;\n    }\n\n    #pragma acc data copyin(a[0:n], b[0:n]) copy(totals[0:n/10 + 1]) copyout(c[0:n])\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                #pragma acc atomic update capture\n                {\n                    c[x] = totals[x/10];\n                    totals[x/10] = totals[x/10] / (a[x] + b[x]);\n                }\n            }\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        totals_comparison[x/10] /= a[x] + b[x];\n    }\n    for (int x = 0; x < 10; ++x){\n        if (fabs(totals_comparison[x] - totals[x]) > PRECISION){\n            err += 1;\n            break;\n        }\n    }\n\n    for (int x = 0; x < n; x = x + 10){\n        temp_iterator = 0;\n        for (ab_iterator = x; ab_iterator < n && ab_iterator < x + 10;  ab_iterator+= 1){\n            temp_a[temp_iterator] = a[ab_iterator];\n            temp_b[temp_iterator] = b[ab_iterator];\n            temp_c[temp_iterator] = c[ab_iterator];\n            temp_iterator++;\n        }\n        if (!(is_possible(temp_a, temp_b, temp_c, temp_iterator, 1))){\n            err++;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "atomic",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_structured_assign_x_lshift_expr.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:atomic,construct-independent,V:2.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    unsigned int *a = (unsigned int *)malloc(n * sizeof(int));\n    unsigned int *b = (unsigned int *)malloc(n * sizeof(int));\n    unsigned int *c = (unsigned int *)malloc(7 * n * sizeof(int));\n    unsigned int passed = 1;\n\n    for (int x = 0; x < n; ++x){\n        a[x] = 1;\n        for (int y = 0; y < 7; ++y){\n            if ((rand()/(real_t) (RAND_MAX)) > .5){\n                b[x] += 1<<y;\n            }\n        }\n    }\n\n    #pragma acc data copyin(b[0:n]) copy(a[0:n]) copyout(c[0:7*n])\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                #pragma acc loop\n                for (int y = 0; y < 7; ++y){\n                    c[x * 7 + y] = a[x];\n                    if ((b[x]>>y)%2 == 1){\n                        #pragma acc atomic update capture\n                        {\n                            c[x * 7 + y] = a[x];\n                            a[x] = a[x] << 1;\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        for (int y = 0; y < 7; ++y){\n            if ((b[x]>>y)%2 == 1){\n                a[x] >>= 1;\n            }\n        }\n        if (a[x] != 1){\n            err += 1;\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        if (!is_possible(b[x], &(c[x * 7]), 7, passed)){\n            err++;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "atomic",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_structured_assign_x_minus_expr.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:atomic,construct-independent,V:2.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t *a = (real_t *)malloc(n * sizeof(real_t));\n    real_t *b = (real_t *)malloc(n * sizeof(real_t));\n    real_t *c = (real_t *)malloc(n * sizeof(real_t));\n    real_t *totals = (real_t *)malloc(10 * sizeof(real_t));\n    real_t *totals_host = (real_t *)malloc(10 * sizeof(real_t));\n    real_t * passed_ab = (real_t *)malloc((n/10 + 1) * sizeof(real_t));\n    real_t * passed_c = (real_t *)malloc((n/10 + 1) * sizeof(real_t));\n    int passed_indexer;\n    int absolute_indexer;\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n    }\n    for (int x = 0; x < 10; ++x){\n        totals[x] = 0;\n    }\n\n    #pragma acc data copyin(a[0:n], b[0:n]) copy(totals[0:10])\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                #pragma acc atomic update capture\n                {\n                    c[x] = totals[x%10];\n                    totals[x%10] = totals[x%10] - (a[x] + b[x]);\n                }\n            }\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        totals_host[x%10] = totals_host[x%10] - (a[x] + b[x]);\n    }\n    for (int x = 0; x < 10; ++x){\n        if (fabs(totals_host[x] - totals[x]) > PRECISION){\n            err += 1;\n        }\n    }\n\n    for (int x = 0; x < 10; ++x){\n        for (passed_indexer = 0, absolute_indexer = x; absolute_indexer < n; passed_indexer++, absolute_indexer+= 10){\n            passed_ab[passed_indexer] = a[absolute_indexer] + b[absolute_indexer];\n            passed_c[passed_indexer] = c[absolute_indexer];\n        }\n        if (!is_possible(passed_ab, passed_c, passed_indexer - 1, 0)){\n            err++;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "atomic",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_structured_assign_x_multiply_expr.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:atomic,construct-independent,V:2.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t *a = (real_t *)malloc(n * sizeof(real_t));\n    real_t *b = (real_t *)malloc(n * sizeof(real_t));\n    real_t *c = (real_t *)malloc(n * sizeof(real_t));\n    real_t *totals = (real_t *)malloc((n/10 + 1) * sizeof(real_t));\n    real_t *totals_comparison = (real_t *)malloc((n/10 + 1) * sizeof(real_t));\n    real_t * passed_ab = (real_t *)malloc(10 * sizeof(real_t));\n    real_t * passed_c = (real_t *)malloc(10 * sizeof(real_t));\n    int passed_indexer;\n    int absolute_indexer;\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n    }\n    for (int x = 0; x < n/10 + 1; ++x){\n        totals[x] = 1;\n        totals_comparison[x] = 1;\n    }\n\n    #pragma acc data copyin(a[0:n], b[0:n]) copy(totals[0:n/10 + 1]) copyout(c[0:n])\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                #pragma acc atomic update capture\n                {\n                    c[x] = totals[x%(n/10 + 1)];\n                    totals[x%(n/10 + 1)] = totals[x%(n/10 + 1)] * (a[x] + b[x]);\n                }\n            }\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        totals_comparison[x%(n/10 + 1)] *= a[x] + b[x];\n    }\n    for (int x = 0; x < 10; ++x){\n        if (fabs(totals_comparison[x] - totals[x]) > PRECISION * totals_comparison[x]){\n            err += 1;\n            break;\n        }\n    }\n\n    for (int x = 0; x < n/10 + 1; ++x){\n        for (passed_indexer = 0, absolute_indexer = x; absolute_indexer < n; passed_indexer++, absolute_indexer += n/10 + 1){\n            passed_ab[passed_indexer] = a[absolute_indexer] + b[absolute_indexer];\n            passed_c[passed_indexer] = c[absolute_indexer];\n        }\n        if (!is_possible(passed_ab, passed_c, passed_indexer - 1, 1)){\n            err++;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "atomic",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_structured_assign_x_plus_expr.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:atomic,construct-independent,V:2.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t *a = (real_t *)malloc(n * sizeof(real_t));\n    real_t *b = (real_t *)malloc(n * sizeof(real_t));\n    real_t *c = (real_t *)malloc(n * sizeof(real_t));\n    real_t *totals = (real_t *)malloc((n/10 + 1) * sizeof(real_t));\n    real_t *totals_comparison = (real_t *)malloc((n/10 + 1) * sizeof(real_t));\n    real_t *passed_ab = (real_t *)malloc(10 * sizeof(real_t));\n    real_t *passed_c = (real_t *)malloc(10 * sizeof(real_t));\n    int passed_indexer;\n    int absolute_indexer;\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n    }\n    for (int x = 0; x < n/10 + 1; ++x){\n        totals[x] = 0;\n        totals_comparison[x] = 0;\n    }\n\n    #pragma acc data copyin(a[0:n], b[0:n]) copy(totals[0:n/10 + 1]) copyout(c[0:n])\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                #pragma acc atomic update capture\n                {\n                    c[x] = totals[x%(n/10 + 1)];\n                    totals[x%(n/10 + 1)] = totals[x%(n/10 + 1)] + (a[x] * b[x]);\n                }\n            }\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        totals_comparison[x%(n/10 + 1)] += a[x] * b[x];\n    }\n    for (int x = 0; x < n/10 + 1; ++x){\n        if (fabs(totals_comparison[x] - totals[x]) > PRECISION){\n            err += 1;\n            break;\n        }\n    }\n\n    for (int x = 0; x < n/10 + 1; ++x){\n        for (passed_indexer = 0, absolute_indexer = x; absolute_indexer < n; passed_indexer++, absolute_indexer+= (n/10 + 1)){\n            passed_ab[passed_indexer] = a[absolute_indexer] * b[absolute_indexer];\n            passed_c[passed_indexer] = c[absolute_indexer];\n        }\n        if (!is_possible(passed_ab, passed_c, passed_indexer - 1, 0)){\n            err++;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "atomic",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_structured_assign_x_rshift_expr.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:atomic,construct-independent,V:2.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    unsigned int *a = (unsigned int *)malloc(n * sizeof(int));\n    unsigned int *b = (unsigned int *)malloc(n * sizeof(int));\n    unsigned int *c = (unsigned int *)malloc(7 * n * sizeof(int));\n    unsigned int passed = 1<<8;\n\n    for (int x = 0; x < n; ++x){\n        a[x] = 1<<8;\n        for (int y = 0; y < 7; ++y){\n            if ((rand()/(real_t) (RAND_MAX)) > .5){\n                b[x] += 1<<y;\n            }\n        }\n    }\n\n    #pragma acc data copyin(b[0:n]) copy(a[0:n]) copyout(c[0:7*n])\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                #pragma acc loop\n                for (int y = 0; y < 7; ++y){\n                    c[x * 7 + y] = a[x];\n                    if ((b[x]>>y)%2 == 1){\n                        #pragma acc atomic update capture\n                        {\n                            c[x * 7 + y] = a[x];\n                            a[x] = a[x] >> 1;\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        for (int y = 0; y < 7; ++y){\n            if ((b[x]>>y)%2 == 1){\n                a[x] <<= 1;\n            }\n        }\n        if (a[x] != 1<<8){\n            err += 1;\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        if (!is_possible(b[x], &(c[x * 7]), 7, passed)){\n            err++;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "atomic",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_structured_bitand_equals_assign.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:atomic,construct-independent,V:2.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    int *a = (int *)malloc(n * sizeof(int));\n    int *b = (int *)malloc(n * sizeof(int));\n    int *totals = (int *)malloc((n/10 + 1) * sizeof(int));\n    int *totals_comparison = (int *)malloc((n/10 + 1) * sizeof(int));\n    int *temp_a = (int *)malloc(10 * sizeof(int));\n    int *temp_b = (int *)malloc(10 * sizeof(int));\n    int iterator;\n    int iterator2;\n    int init;\n\n    for (int x = 0; x < n; ++x){\n        for (int y = 0; y < 8; ++y){\n            if (rand()/(real_t)(RAND_MAX) < .933){ //.933 gets close to a 50/50 distribution for a collescence of 10 values\n                a[x] += 1<<y;\n            }\n        }\n    }\n    for (int x = 0; x < n/10 + 1; ++x){\n        for (int y = 0; y < 8; ++y){\n            totals[x] +=  1<<y;\n            totals_comparison[x] += 1<<y;\n        }\n    }\n    for (int x = 0; x < n; ++x){\n        b[x] = 0;\n    }\n    #pragma acc data copyin(a[0:n]) copy(totals[0:n/10 + 1]) copyout(b[0:n])\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                #pragma acc atomic update capture\n                    {\n                        totals[x/10] &= a[x];\n                        b[x] = totals[x/10];\n                    }\n            }\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        totals_comparison[x/10] &= a[x];\n    }\n    for (int x = 0; x < (n/10 + 1); ++x){\n        if (totals_comparison[x] != totals[x]){\n            err += 1;\n            break;\n        }\n    }\n    for (int x = 0; x < 8; ++x){\n        init += 1<<x;\n    }\n\n    for (int x = 0; x < n; x = x + 10){\n        int y = x;\n        for (; y < x + 10 && y < n; y++){\n            temp_a[y - x] = a[y];\n            temp_b[y - x] = b[y];\n        }\n        if (!is_possible(temp_a, temp_b, y - x, init)){\n            err += 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "atomic",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_structured_bitor_equals_assign.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:atomic,construct-independent,V:2.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    int *a = (int *)malloc(n * sizeof(int));\n    int *b = (int *)malloc(n * sizeof(int));\n    int *totals = (int *)malloc((n/10 + 1) * sizeof(int));\n    int *totals_comparison = (int *)malloc((n/10 + 1) * sizeof(int));\n    int *temp_a = (int *)malloc(10 * sizeof(int));\n    int *temp_b = (int *)malloc(10 * sizeof(int));\n    int iterator;\n    int iterator2;\n    int init;\n\n    for (int x = 0; x < n; ++x){\n        for (int y = 0; y < 8; ++y){\n            if (rand()/(real_t)(RAND_MAX) < .933){ //.933 gets close to a 50/50 distribution for a collescence of 10 values\n                a[x] += 1<<y;\n            }\n        }\n    }\n    for (int x = 0; x < n/10 + 1; ++x){\n        for (int y = 0; y < 8; ++y){\n            totals[x] +=  1<<y;\n            totals_comparison[x] += 1<<y;\n        }\n    }\n    for (int x = 0; x < n; ++x){\n        b[x] = 0;\n    }\n    #pragma acc data copyin(a[0:n]) copy(totals[0:n/10 + 1]) copyout(b[0:n])\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                #pragma acc atomic update capture\n                    {\n                        totals[x/10] |= a[x];\n                        b[x] = totals[x/10];\n                    }\n            }\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        totals_comparison[x/10] |= a[x];\n    }\n    for (int x = 0; x < (n/10 + 1); ++x){\n        if (totals_comparison[x] != totals[x]){\n            err += 1;\n            break;\n        }\n    }\n    for (int x = 0; x < 8; ++x){\n        init += 1<<x;\n    }\n    int y;\n    for (int x = 0; x < n; x = x + 10){\n        y = x;\n        for (; y < x + 10 && y < n; y++){\n            temp_a[y - x] = a[y];\n            temp_b[y - x] = b[y];\n        }\n        if (!is_possible(temp_a, temp_b, (y - x) - 1, init)){\n            err += 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "atomic",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_structured_bitxor_equals_assign.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:atomic,construct-independent,V:2.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    int *a = (int *)malloc(n * sizeof(int));\n    int *b = (int *)malloc(n * sizeof(int));\n    int *totals = (int *)malloc((n/10 + 1) * sizeof(int));\n    int *totals_comparison = (int *)malloc((n/10 + 1) * sizeof(int));\n    int *temp_a = (int *)malloc(10 * sizeof(int));\n    int *temp_b = (int *)malloc(10 * sizeof(int));\n    int iterator;\n    int iterator2;\n    int init;\n\n    for (int x = 0; x < n; ++x){\n        for (int y = 0; y < 8; ++y){\n            if (rand()/(real_t)(RAND_MAX) < .933){ //.933 gets close to a 50/50 distribution for a collescence of 10 values\n                a[x] += 1<<y;\n            }\n        }\n    }\n    for (int x = 0; x < n/10 + 1; ++x){\n        for (int y = 0; y < 8; ++y){\n            totals[x] +=  1<<y;\n            totals_comparison[x] += 1<<y;\n        }\n    }\n    for (int x = 0; x < n; ++x){\n        b[x] = 0;\n    }\n    #pragma acc data copyin(a[0:n]) copy(totals[0:n/10 + 1]) copyout(b[0:n])\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                #pragma acc atomic update capture\n                    {\n                        totals[x/10] ^= a[x];\n                        b[x] = totals[x/10];\n                    }\n            }\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        totals_comparison[x/10] ^= a[x];\n    }\n    for (int x = 0; x < (n/10 + 1); ++x){\n        if (totals_comparison[x] != totals[x]){\n            err += 1;\n            break;\n        }\n    }\n    for (int x = 0; x < 8; ++x){\n        init += 1<<x;\n    }\n    int y;\n    for (int x = 0; x < n; x = x + 10){\n        y = x;\n        for (; y < x + 10 && y < n; y++){\n            temp_a[y - x] = a[y];\n            temp_b[y - x] = b[y];\n        }\n        if (!is_possible(temp_a, temp_b, (y - x) - 1, init)){\n            err += 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "atomic",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_structured_divided_equals_assign.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:atomic,construct-independent,V:2.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t *a = (real_t *)malloc(n * sizeof(real_t));\n    real_t *b = (real_t *)malloc(n * sizeof(real_t));\n    real_t *c = (real_t *)malloc(n * sizeof(real_t));\n    real_t *totals = (real_t *)malloc((n/10 + 1) * sizeof(real_t));\n    real_t *totals_comparison = (real_t *)malloc((n/10 + 1) * sizeof(real_t));\n    real_t *temp_a = (real_t *)malloc(10 * sizeof(real_t));\n    real_t *temp_b = (real_t *)malloc(10 * sizeof(real_t));\n    real_t *temp_c = (real_t *)malloc(10 * sizeof(real_t));\n    int temp_iterator;\n    int ab_iterator;\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n        c[x] = 0;\n    }\n    for (int x = 0; x < n/10 + 1; ++x){\n        totals[x] = 1;\n        totals_comparison[x] = 1;\n    }\n\n    #pragma acc data copyin(a[0:n], b[0:n]) copy(totals[0:n/10 + 1]) copyout(c[0:n])\n    {\n      #pragma acc parallel\n      {\n          #pragma acc loop\n          for (int x = 0; x < n; ++x){\n              #pragma acc atomic update capture\n              {\n                  totals[x/10] /= (a[x] + b[x]);\n                  c[x] = totals[x/10];\n              }\n          }\n      }\n    }\n\n    for (int x = 0; x < n; ++x){\n        totals_comparison[x/10] /= a[x] + b[x];\n    }\n    for (int x = 0; x < 10; ++x){\n        if (fabs(totals_comparison[x] - totals[x]) > PRECISION){\n            err += 1;\n            break;\n        }\n    }\n\n    for (int x = 0; x < n; x = x + 10){\n        temp_iterator = 0;\n        for (ab_iterator = x; ab_iterator < n && ab_iterator < x + 10;  ab_iterator+= 1){\n            temp_a[temp_iterator] = a[ab_iterator];\n            temp_b[temp_iterator] = b[ab_iterator];\n            temp_c[temp_iterator] = c[ab_iterator];\n            temp_iterator++;\n        }\n        if (!(is_possible(temp_a, temp_b, temp_c, temp_iterator, 1))){\n            err++;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "atomic",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_structured_expr_bitand_x_assign.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:atomic,construct-independent,V:2.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    int *a = (int *)malloc(n * sizeof(int));\n    int *b = (int *)malloc(n * sizeof(int));\n    int *totals = (int *)malloc((n/10 + 1) * sizeof(int));\n    int *totals_comparison = (int *)malloc((n/10 + 1) * sizeof(int));\n    int *temp_a = (int *)malloc(10 * sizeof(int));\n    int *temp_b = (int *)malloc(10 * sizeof(int));\n    int iterator;\n    int iterator2;\n    int init;\n\n    for (int x = 0; x < n; ++x){\n        for (int y = 0; y < 8; ++y){\n            if (rand()/(real_t)(RAND_MAX) < .933){ //.933 gets close to a 50/50 distribution for a collescence of 10 values\n                a[x] += 1<<y;\n            }\n        }\n    }\n    for (int x = 0; x < n/10 + 1; ++x){\n        for (int y = 0; y < 8; ++y){\n            totals[x] +=  1<<y;\n            totals_comparison[x] += 1<<y;\n        }\n    }\n    for (int x = 0; x < n; ++x){\n        b[x] = 0;\n    }\n    #pragma acc data copyin(a[0:n]) copy(totals[0:n/10 + 1]) copyout(b[0:n])\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                #pragma acc atomic update capture\n                    {\n                        totals[x/10] = a[x] & totals[x/10];\n                        b[x] = totals[x/10];\n                    }\n            }\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        totals_comparison[x/10] &= a[x];\n    }\n    for (int x = 0; x < (n/10 + 1); ++x){\n        if (totals_comparison[x] != totals[x]){\n            err += 1;\n            break;\n        }\n    }\n    for (int x = 0; x < 8; ++x){\n        init += 1<<x;\n    }\n\n    for (int x = 0; x < n; x = x + 10){\n        int y = x;\n        for (; y < x + 10 && y < n; y++){\n            temp_a[y - x] = a[y];\n            temp_b[y - x] = b[y];\n        }\n        if (!is_possible(temp_a, temp_b, y - x, init)){\n            err += 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "atomic",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_structured_expr_bitor_x_assign.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:atomic,construct-independent,V:2.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    int *a = (int *)malloc(n * sizeof(int));\n    int *b = (int *)malloc(n * sizeof(int));\n    int *totals = (int *)malloc((n/10 + 1) * sizeof(int));\n    int *totals_comparison = (int *)malloc((n/10 + 1) * sizeof(int));\n    int *temp_a = (int *)malloc(10 * sizeof(int));\n    int *temp_b = (int *)malloc(10 * sizeof(int));\n    int iterator;\n    int iterator2;\n    int init;\n\n    for (int x = 0; x < n; ++x){\n        for (int y = 0; y < 8; ++y){\n            if (rand()/(real_t)(RAND_MAX) < .933){ //.933 gets close to a 50/50 distribution for a collescence of 10 values\n                a[x] += 1<<y;\n            }\n        }\n    }\n    for (int x = 0; x < n/10 + 1; ++x){\n        for (int y = 0; y < 8; ++y){\n            totals[x] +=  1<<y;\n            totals_comparison[x] += 1<<y;\n        }\n    }\n    for (int x = 0; x < n; ++x){\n        b[x] = 0;\n    }\n    #pragma acc data copyin(a[0:n]) copy(totals[0:n/10 + 1]) copyout(b[0:n])\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                #pragma acc atomic update capture\n                    {\n                        totals[x/10] = a[x] | totals[x/10];\n                        b[x] = totals[x/10];\n                    }\n            }\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        totals_comparison[x/10] |= a[x];\n    }\n    for (int x = 0; x < (n/10 + 1); ++x){\n        if (totals_comparison[x] != totals[x]){\n            err += 1;\n            break;\n        }\n    }\n    for (int x = 0; x < 8; ++x){\n        init += 1<<x;\n    }\n    int y;\n    for (int x = 0; x < n; x = x + 10){\n        y = x;\n        for (; y < x + 10 && y < n; y++){\n            temp_a[y - x] = a[y];\n            temp_b[y - x] = b[y];\n        }\n        if (!is_possible(temp_a, temp_b, (y - x) - 1, init)){\n            err += 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "atomic",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_structured_expr_bitxor_x_assign.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:atomic,construct-independent,V:2.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    int *a = (int *)malloc(n * sizeof(int));\n    int *b = (int *)malloc(n * sizeof(int));\n    int *totals = (int *)malloc((n/10 + 1) * sizeof(int));\n    int *totals_comparison = (int *)malloc((n/10 + 1) * sizeof(int));\n    int *temp_a = (int *)malloc(10 * sizeof(int));\n    int *temp_b = (int *)malloc(10 * sizeof(int));\n    int iterator;\n    int iterator2;\n    int init;\n    int y;\n\n    for (int x = 0; x < n; ++x){\n        for (int y = 0; y < 8; ++y){\n            if (rand()/(real_t)(RAND_MAX) < .933){ //.933 gets close to a 50/50 distribution for a collescence of 10 values\n                a[x] += 1<<y;\n            }\n        }\n    }\n    for (int x = 0; x < n/10 + 1; ++x){\n        for (int y = 0; y < 8; ++y){\n            totals[x] +=  1<<y;\n            totals_comparison[x] += 1<<y;\n        }\n    }\n    for (int x = 0; x < n; ++x){\n        b[x] = 0;\n    }\n    #pragma acc data copyin(a[0:n]) copy(totals[0:n/10 + 1]) copyout(b[0:n])\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                #pragma acc atomic update capture\n                    {\n                        totals[x/10] = a[x] ^ totals[x/10];\n                        b[x] = totals[x/10];\n                    }\n            }\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        totals_comparison[x/10] ^= a[x];\n    }\n    for (int x = 0; x < (n/10 + 1); ++x){\n        if (totals_comparison[x] != totals[x]){\n            err += 1;\n            break;\n        }\n    }\n    for (int x = 0; x < 8; ++x){\n        init += 1<<x;\n    }\n    for (int x = 0; x < n; x = x + 10){\n        y = x;\n        for (; y < x + 10 && y < n; y++){\n            temp_a[y - x] = a[y];\n            temp_b[y - x] = b[y];\n        }\n        if (!is_possible(temp_a, temp_b, (y - x) - 1, init)){\n            err += 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "atomic",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_structured_expr_multiply_x_assign.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:atomic,construct-independent,V:2.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t *a = (real_t *)malloc(n * sizeof(real_t));\n    real_t *b = (real_t *)malloc(n * sizeof(real_t));\n    real_t *c = (real_t *)malloc(n * sizeof(real_t));\n    real_t *totals = (real_t *)malloc((n/10 + 1) * sizeof(real_t));\n    real_t *totals_comparison = (real_t *)malloc((n/10 + 1) * sizeof(real_t));\n    real_t * passed_ab = (real_t *)malloc(10 * sizeof(real_t));\n    real_t * passed_c = (real_t *)malloc(10 * sizeof(real_t));\n    int passed_indexer;\n    int absolute_indexer;\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n    }\n    for (int x = 0; x < n/10 + 1; ++x){\n        totals[x] = 1;\n        totals_comparison[x] = 1;\n    }\n\n    #pragma acc data copyin(a[0:n], b[0:n]) copy(totals[0:n/10 + 1]) copyout(c[0:n])\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                #pragma acc atomic update capture\n                {\n                    totals[x%(n/10 + 1)] = (a[x] + b[x]) * totals[x%(n/10 + 1)];\n                    c[x] = totals[x%(n/10 + 1)];\n                }\n            }\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        totals_comparison[x%(n/10 + 1)] *= a[x] + b[x];\n    }\n    for (int x = 0; x < 10; ++x){\n        if (fabs(totals_comparison[x] - totals[x]) > PRECISION * totals_comparison[x]){\n            err += 1;\n            break;\n        }\n    }\n\n    for (int x = 0; x < n/10 + 1; ++x){\n        for (passed_indexer = 0, absolute_indexer = x; absolute_indexer < n; passed_indexer++, absolute_indexer += n/10 + 1){\n            passed_ab[passed_indexer] = a[absolute_indexer] + b[absolute_indexer];\n            passed_c[passed_indexer] = c[absolute_indexer];\n        }\n        if (!is_possible(passed_ab, passed_c, passed_indexer - 1, 1)){\n            err++;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "atomic",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_structured_expr_plus_x_assign.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:atomic,construct-independent,V:2.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t *a = (real_t *)malloc(n * sizeof(real_t));\n    real_t *b = (real_t *)malloc(n * sizeof(real_t));\n    real_t *c = (real_t *)malloc(n * sizeof(real_t));\n    real_t *totals = (real_t *)malloc((n/10 + 1) * sizeof(real_t));\n    real_t *totals_comparison = (real_t *)malloc((n/10 + 1) * sizeof(real_t));\n    real_t *passed_ab = (real_t *)malloc(10 * sizeof(real_t));\n    real_t *passed_c = (real_t *)malloc(10 * sizeof(real_t));\n    int passed_indexer;\n    int absolute_indexer;\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n    }\n    for (int x = 0; x < n/10 + 1; ++x){\n        totals[x] = 0;\n        totals_comparison[x] = 0;\n    }\n\n    #pragma acc data copyin(a[0:n], b[0:n]) copy(totals[0:n/10 + 1]) copyout(c[0:n])\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                #pragma acc atomic update capture\n                {\n                    totals[x%(n/10 + 1)] = (a[x] * b[x]) + totals[x%(n/10 + 1)];\n                    c[x] = totals[x%(n/10 + 1)];\n                }\n            }\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        totals_comparison[x%(n/10 + 1)] += a[x] * b[x];\n    }\n    for (int x = 0; x < n/10 + 1; ++x){\n        if (fabs(totals_comparison[x] - totals[x]) > PRECISION){\n            err += 1;\n            break;\n        }\n    }\n\n    for (int x = 0; x < n/10 + 1; ++x){\n        for (passed_indexer = 0, absolute_indexer = x; absolute_indexer < n; passed_indexer++, absolute_indexer+= (n/10 + 1)){\n            passed_ab[passed_indexer] = a[absolute_indexer] * b[absolute_indexer];\n            passed_c[passed_indexer] = c[absolute_indexer];\n        }\n        if (!is_possible(passed_ab, passed_c, passed_indexer - 1, 0)){\n            err++;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "atomic",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_structured_lshift_equals_assign.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:atomic,construct-independent,V:2.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    unsigned int *a = (unsigned int *)malloc(n * sizeof(int));\n    unsigned int *b = (unsigned int *)malloc(n * sizeof(int));\n    unsigned int *c = (unsigned int *)malloc(7 * n * sizeof(int));\n    unsigned int passed = 1;\n\n    for (int x = 0; x < n; ++x){\n        a[x] = 1;\n        for (int y = 0; y < 7; ++y){\n            if ((rand()/(real_t) (RAND_MAX)) > .5){\n                b[x] += 1<<y;\n            }\n        }\n    }\n\n    #pragma acc data copyin(b[0:n]) copy(a[0:n]) copyout(c[0:7*n])\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                #pragma acc loop\n                for (int y = 0; y < 7; ++y){\n                    c[x * 7 + y] = a[x];\n                    if ((b[x]>>y)%2 == 1){\n                        #pragma acc atomic update capture\n                        {\n                            a[x] <<= 1;\n                            c[x * 7 + y] = a[x];\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        for (int y = 0; y < 7; ++y){\n            if ((b[x]>>y)%2 == 1){\n                a[x] >>= 1;\n            }\n        }\n        if (a[x] != 1){\n            err += 1;\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        if (!is_possible(b[x], &(c[x * 7]), 7, passed)){\n            err++;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "atomic",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_structured_minus_equals_assign.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:atomic,construct-independent,V:2.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t *a = (real_t *)malloc(n * sizeof(real_t));\n    real_t *b = (real_t *)malloc(n * sizeof(real_t));\n    real_t *c = (real_t *)malloc(n * sizeof(real_t));\n    real_t *totals = (real_t *)malloc(10 * sizeof(real_t));\n    real_t *totals_host = (real_t *)malloc(10 * sizeof(real_t));\n    real_t * passed_ab = (real_t *)malloc((n/10 + 1) * sizeof(real_t));\n    real_t * passed_c = (real_t *)malloc((n/10 + 1) * sizeof(real_t));\n    int passed_indexer;\n    int absolute_indexer;\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n    }\n    for (int x = 0; x < 10; ++x){\n        totals[x] = 0;\n    }\n\n    #pragma acc data copyin(a[0:n], b[0:n]) copy(totals[0:10])\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                #pragma acc atomic update capture\n                {\n                    totals[x%10] -= (a[x] + b[x]);\n                    c[x] = totals[x%10];\n                }\n            }\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        totals_host[x%10] = totals_host[x%10] - (a[x] + b[x]);\n    }\n    for (int x = 0; x < 10; ++x){\n        if (fabs(totals_host[x] - totals[x]) > PRECISION){\n            err += 1;\n        }\n    }\n\n    for (int x = 0; x < 10; ++x){\n        for (passed_indexer = 0, absolute_indexer = x; absolute_indexer < n; passed_indexer++, absolute_indexer+= 10){\n            passed_ab[passed_indexer] = a[absolute_indexer] + b[absolute_indexer];\n            passed_c[passed_indexer] = c[absolute_indexer];\n        }\n        if (!is_possible(passed_ab, passed_c, passed_indexer - 1, 0)){\n            err++;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "atomic",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_structured_multiply_equals_assign.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:atomic,construct-independent,V:2.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t *a = (real_t *)malloc(n * sizeof(real_t));\n    real_t *b = (real_t *)malloc(n * sizeof(real_t));\n    real_t *c = (real_t *)malloc(n * sizeof(real_t));\n    real_t *totals = (real_t *)malloc((n/10 + 1) * sizeof(real_t));\n    real_t *totals_comparison = (real_t *)malloc((n/10 + 1) * sizeof(real_t));\n    real_t * passed_ab = (real_t *)malloc(10 * sizeof(real_t));\n    real_t * passed_c = (real_t *)malloc(10 * sizeof(real_t));\n    int passed_indexer;\n    int absolute_indexer;\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n    }\n    for (int x = 0; x < n/10 + 1; ++x){\n        totals[x] = 1;\n        totals_comparison[x] = 1;\n    }\n\n    #pragma acc data copyin(a[0:n], b[0:n]) copy(totals[0:n/10 + 1]) copyout(c[0:n])\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                #pragma acc atomic update capture\n                {\n                    totals[x%(n/10 + 1)] *= a[x] + b[x];\n                    c[x] = totals[x%(n/10 + 1)];\n                }\n            }\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        totals_comparison[x%(n/10 + 1)] *= a[x] + b[x];\n    }\n    for (int x = 0; x < 10; ++x){\n        if (fabs(totals_comparison[x] - totals[x]) > PRECISION * totals_comparison[x]){\n            err += 1;\n            break;\n        }\n    }\n\n    for (int x = 0; x < n/10 + 1; ++x){\n        for (passed_indexer = 0, absolute_indexer = x; absolute_indexer < n; passed_indexer++, absolute_indexer += n/10 + 1){\n            passed_ab[passed_indexer] = a[absolute_indexer] + b[absolute_indexer];\n            passed_c[passed_indexer] = c[absolute_indexer];\n        }\n        if (!is_possible(passed_ab, passed_c, passed_indexer - 1, 1)){\n            err++;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "atomic",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_structured_plus_equals_assign.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:atomic,construct-independent,V:2.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t *a = (real_t *)malloc(n * sizeof(real_t));\n    real_t *b = (real_t *)malloc(n * sizeof(real_t));\n    real_t *c = (real_t *)malloc(n * sizeof(real_t));\n    real_t *totals = (real_t *)malloc((n/10 + 1) * sizeof(real_t));\n    real_t *totals_comparison = (real_t *)malloc((n/10 + 1) * sizeof(real_t));\n    real_t *passed_ab = (real_t *)malloc(10 * sizeof(real_t));\n    real_t *passed_c = (real_t *)malloc(10 * sizeof(real_t));\n    int passed_indexer;\n    int absolute_indexer;\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n    }\n    for (int x = 0; x < n/10 + 1; ++x){\n        totals[x] = 0;\n        totals_comparison[x] = 0;\n    }\n\n    #pragma acc data copyin(a[0:n], b[0:n]) copy(totals[0:n/10 + 1]) copyout(c[0:n])\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                #pragma acc atomic update capture\n                {\n                    totals[x%(n/10 + 1)] += a[x] * b[x];\n                    c[x] = totals[x%(n/10 + 1)];\n                }\n            }\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        totals_comparison[x%(n/10 + 1)] += a[x] * b[x];\n    }\n    for (int x = 0; x < n/10 + 1; ++x){\n        if (fabs(totals_comparison[x] - totals[x]) > PRECISION){\n            err += 1;\n            break;\n        }\n    }\n\n    for (int x = 0; x < n/10 + 1; ++x){\n        for (passed_indexer = 0, absolute_indexer = x; absolute_indexer < n; passed_indexer++, absolute_indexer+= (n/10 + 1)){\n            passed_ab[passed_indexer] = a[absolute_indexer] * b[absolute_indexer];\n            passed_c[passed_indexer] = c[absolute_indexer];\n        }\n        if (!is_possible(passed_ab, passed_c, passed_indexer - 1, 0)){\n            err++;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "atomic",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_structured_postdecrement_assign.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:atomic,construct-independent,V:2.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t *a = (real_t *)malloc(n * sizeof(real_t));\n    real_t *b = (real_t *)malloc(n * sizeof(real_t));\n    int *c = (int *)malloc(n * sizeof(int));\n    int *distribution = (int *)malloc(10 * sizeof(int));\n    int *distribution_comparison = (int *)malloc(10 * sizeof(int));\n    bool found = false;\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n    }\n    for (int x = 0; x < 10; ++x){\n        distribution[x] = 0;\n        distribution_comparison[x] = 0;\n    }\n\n    #pragma acc data copyin(a[0:n], b[0:n]) copy(distribution[0:10]) copyout(c[0:n])\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                #pragma acc atomic update capture\n                {\n                    (distribution[(int) (a[x]*b[x]/10)])--;\n                    c[x] = distribution[(int) (a[x]*b[x]/10)];\n                }\n            }\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        distribution_comparison[(int) (a[x]*b[x]/10)]--;\n    }\n    for (int x = 0; x < 10; ++x){\n        if (distribution_comparison[x] != distribution[x]){\n            err += 1;\n            break;\n        }\n    }\n\n    for (int x = 0; x < 10; ++x){\n        for (int y = 0; y > -distribution_comparison[x]; --y){\n            for (int z = 0; z < n; ++z){\n                if (y - 1 == c[z] && x == (int) (a[x] * b[x] / 10)){\n                    found = true;\n                    break;\n                }\n            }\n            if (!found){\n                err++;\n            }\n            found = false;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "atomic",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_structured_postincrement_assign.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:atomic,construct-independent,V:2.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t *a = (real_t *)malloc(n * sizeof(real_t));\n    real_t *b = (real_t *)malloc(n * sizeof(real_t));\n    int *c = (int *)malloc(n * sizeof(int));\n    int *distribution = (int *)malloc(10 * sizeof(int));\n    int *distribution_comparison = (int *)malloc(10 * sizeof(int));\n    bool found = false;\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n    }\n    for (int x = 0; x < 10; ++x){\n        distribution[x] = 0;\n        distribution_comparison[x] = 0;\n    }\n\n    #pragma acc data copyin(a[0:n], b[0:n]) copy(distribution[0:10]) copyout(c[0:n])\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                #pragma acc atomic update capture\n                {\n                    distribution[(int) (a[x]*b[x]/10)]++;\n                    c[x] = distribution[(int) (a[x]*b[x]/10)];\n                }\n            }\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        distribution_comparison[(int) (a[x]*b[x]/10)]++;\n    }\n    for (int x = 0; x < 10; ++x){\n        if (distribution_comparison[x] != distribution[x]){\n            err += 1;\n            break;\n        }\n    }\n\n    for (int x = 0; x < 10; ++x){\n        for (int y = 0; y < distribution_comparison[x]; ++y){\n            for (int z = 0; z < n; ++z){\n                if (c[z] == y + 1 && (int) (a[z]*b[z]/10) == x){\n                    found = true;\n                    break;\n                }\n            }\n            if (!found){\n                err++;\n            }\n            found = false;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "atomic",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_structured_predecrement_assign.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:atomic,construct-independent,V:2.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t *a = (real_t *)malloc(n * sizeof(real_t));\n    real_t *b = (real_t *)malloc(n * sizeof(real_t));\n    int *c = (int *)malloc(n * sizeof(int));\n    int *distribution = (int *)malloc(10 * sizeof(int));\n    int *distribution_comparison = (int *)malloc(10 * sizeof(int));\n    bool found = false;\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n    }\n    for (int x = 0; x < 10; ++x){\n        distribution[x] = 0;\n        distribution_comparison[x] = 0;\n    }\n\n    #pragma acc data copyin(a[0:n], b[0:n]) copy(distribution[0:10]) copyout(c[0:n])\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                #pragma acc atomic update capture\n                {\n                    --distribution[(int) (a[x]*b[x]/10)];\n                    c[x] = distribution[(int) (a[x]*b[x]/10)];\n                }\n            }\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        distribution_comparison[(int) (a[x]*b[x]/10)]--;\n    }\n    for (int x = 0; x < 10; ++x){\n        if (distribution_comparison[x] != distribution[x]){\n            err += 1;\n            break;\n        }\n    }\n\n    for (int x = 0; x < 10; ++x){\n        for (int y = 0; y > distribution[x]; --y){\n            for (int z = 0; z < n; ++z){\n                if (c[z] == y - 1 && x == (int) (a[z] * b[z] / 10)){\n                    found = true;\n                    break;\n                }\n            }\n            if (!found){\n                err++;\n            }\n            found = false;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "atomic",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_structured_preincrement_assign.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:atomic,construct-independent,V:2.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t *a = (real_t *)malloc(n * sizeof(real_t));\n    real_t *b = (real_t *)malloc(n * sizeof(real_t));\n    int *c = (int *)malloc(n * sizeof(int));\n    int *distribution = (int *)malloc(10 * sizeof(int));\n    int *distribution_comparison = (int *)malloc(10 * sizeof(int));\n    bool found = false;\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n    }\n    for (int x = 0; x < 10; ++x){\n        distribution[x] = 0;\n        distribution_comparison[x] = 0;\n    }\n\n    #pragma acc data copyin(a[0:n], b[0:n]) copy(distribution[0:10]) copyout(c[0:n])\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                #pragma acc atomic update capture\n                {\n                    ++distribution[(int) (a[x]*b[x]/10)];\n                    c[x] = distribution[(int) (a[x]*b[x]/10)];\n                }\n            }\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        distribution_comparison[(int) (a[x]*b[x]/10)]++;\n    }\n    for (int x = 0; x < 10; ++x){\n        if (distribution_comparison[x] != distribution[x]){\n            err += 1;\n            break;\n        }\n    }\n\n    for (int x = 0; x < 10; ++x){\n        for (int y = 0; y < distribution[x]; ++y){\n            for (int z = 0; z < n; ++z){\n                if (c[z] == y + 1 && x == (int) (a[z] * b[z] / 10)){\n                    found = true;\n                    break;\n                }\n            }\n            if (!found){\n                err++;\n            }\n            found = false;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "atomic",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_structured_rshift_equals_assign.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:atomic,construct-independent,V:2.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    unsigned int *a = (unsigned int *)malloc(n * sizeof(int));\n    unsigned int *b = (unsigned int *)malloc(n * sizeof(int));\n    unsigned int *c = (unsigned int *)malloc(7 * n * sizeof(int));\n    unsigned int passed = 1<<8;\n\n    for (int x = 0; x < n; ++x){\n        a[x] = 1<<8;\n        for (int y = 0; y < 7; ++y){\n            if ((rand()/(real_t) (RAND_MAX)) > .5){\n                b[x] += 1<<y;\n            }\n        }\n    }\n\n    #pragma acc data copyin(b[0:n]) copy(a[0:n]) copyout(c[0:7*n])\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                #pragma acc loop\n                for (int y = 0; y < 7; ++y){\n                    c[x * 7 + y] = a[x];\n                    if ((b[x]>>y)%2 == 1){\n                        #pragma acc atomic update capture\n                        {\n                            a[x] >>= 1;\n                            c[x * 7 + y] = a[x];\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        for (int y = 0; y < 7; ++y){\n            if ((b[x]>>y)%2 == 1){\n                a[x] <<= 1;\n            }\n        }\n        if (a[x] != 1<<8){\n            err += 1;\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        if (!is_possible(b[x], &(c[x * 7]), 7, passed)){\n            err++;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "atomic",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_structured_x_bitand_expr_assign.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:atomic,construct-independent,V:2.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    int *a = (int *)malloc(n * sizeof(int));\n    int *b = (int *)malloc(n * sizeof(int));\n    int *totals = (int *)malloc((n/10 + 1) * sizeof(int));\n    int *totals_comparison = (int *)malloc((n/10 + 1) * sizeof(int));\n    int *temp_a = (int *)malloc(10 * sizeof(int));\n    int *temp_b = (int *)malloc(10 * sizeof(int));\n    int iterator;\n    int iterator2;\n    int init;\n\n    for (int x = 0; x < n; ++x){\n        for (int y = 0; y < 8; ++y){\n            if (rand()/(real_t)(RAND_MAX) < .933){ //.933 gets close to a 50/50 distribution for a collescence of 10 values\n                a[x] += 1<<y;\n            }\n        }\n    }\n    for (int x = 0; x < n/10 + 1; ++x){\n        for (int y = 0; y < 8; ++y){\n            totals[x] +=  1<<y;\n            totals_comparison[x] += 1<<y;\n        }\n    }\n    for (int x = 0; x < n; ++x){\n        b[x] = 0;\n    }\n    #pragma acc data copyin(a[0:n]) copy(totals[0:n/10 + 1]) copyout(b[0:n])\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                #pragma acc atomic update capture\n                    {\n                        totals[x/10] = totals[x/10] & a[x];\n                        b[x] = totals[x/10];\n                    }\n            }\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        totals_comparison[x/10] &= a[x];\n    }\n    for (int x = 0; x < (n/10 + 1); ++x){\n        if (totals_comparison[x] != totals[x]){\n            err += 1;\n            break;\n        }\n    }\n    for (int x = 0; x < 8; ++x){\n        init += 1<<x;\n    }\n\n    for (int x = 0; x < n; x = x + 10){\n        int y = x;\n        for (; y < x + 10 && y < n; y++){\n            temp_a[y - x] = a[y];\n            temp_b[y - x] = b[y];\n        }\n        if (!is_possible(temp_a, temp_b, y - x, init)){\n            err += 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "atomic",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_structured_x_bitor_expr_assign.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:atomic,construct-independent,V:2.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    int *a = (int *)malloc(n * sizeof(int));\n    int *b = (int *)malloc(n * sizeof(int));\n    int *totals = (int *)malloc((n/10 + 1) * sizeof(int));\n    int *totals_comparison = (int *)malloc((n/10 + 1) * sizeof(int));\n    int *temp_a = (int *)malloc(10 * sizeof(int));\n    int *temp_b = (int *)malloc(10 * sizeof(int));\n    int iterator;\n    int iterator2;\n    int init;\n\n    for (int x = 0; x < n; ++x){\n        for (int y = 0; y < 8; ++y){\n            if (rand()/(real_t)(RAND_MAX) < .933){ //.933 gets close to a 50/50 distribution for a collescence of 10 values\n                a[x] += 1<<y;\n            }\n        }\n    }\n    for (int x = 0; x < n/10 + 1; ++x){\n        for (int y = 0; y < 8; ++y){\n            totals[x] +=  1<<y;\n            totals_comparison[x] += 1<<y;\n        }\n    }\n    for (int x = 0; x < n; ++x){\n        b[x] = 0;\n    }\n    #pragma acc data copyin(a[0:n]) copy(totals[0:n/10 + 1]) copyout(b[0:n])\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                #pragma acc atomic update capture\n                    {\n                        totals[x/10] = totals[x/10] | a[x];\n                        b[x] = totals[x/10];\n                    }\n            }\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        totals_comparison[x/10] |= a[x];\n    }\n    for (int x = 0; x < (n/10 + 1); ++x){\n        if (totals_comparison[x] != totals[x]){\n            err += 1;\n            break;\n        }\n    }\n    for (int x = 0; x < 8; ++x){\n        init += 1<<x;\n    }\n    int y;\n    for (int x = 0; x < n; x = x + 10){\n        y = x;\n        for (; y < x + 10 && y < n; y++){\n            temp_a[y - x] = a[y];\n            temp_b[y - x] = b[y];\n        }\n        if (!is_possible(temp_a, temp_b, (y - x) - 1, init)){\n            err += 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "atomic",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_structured_x_bitxor_expr_assign.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:atomic,construct-independent,V:2.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    int *a = (int *)malloc(n * sizeof(int));\n    int *b = (int *)malloc(n * sizeof(int));\n    int *totals = (int *)malloc((n/10 + 1) * sizeof(int));\n    int *totals_comparison = (int *)malloc((n/10 + 1) * sizeof(int));\n    int *temp_a = (int *)malloc(10 * sizeof(int));\n    int *temp_b = (int *)malloc(10 * sizeof(int));\n    int iterator;\n    int iterator2;\n    int init;\n\n    for (int x = 0; x < n; ++x){\n        for (int y = 0; y < 8; ++y){\n            if (rand()/(real_t)(RAND_MAX) < .933){ //.933 gets close to a 50/50 distribution for a collescence of 10 values\n                a[x] += 1<<y;\n            }\n        }\n    }\n    for (int x = 0; x < n/10 + 1; ++x){\n        for (int y = 0; y < 8; ++y){\n            totals[x] +=  1<<y;\n            totals_comparison[x] += 1<<y;\n        }\n    }\n    for (int x = 0; x < n; ++x){\n        b[x] = 0;\n    }\n    #pragma acc data copyin(a[0:n]) copy(totals[0:n/10 + 1]) copyout(b[0:n])\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                #pragma acc atomic update capture\n                    {\n                        totals[x/10] = totals[x/10] ^ a[x];\n                        b[x] = totals[x/10];\n                    }\n            }\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        totals_comparison[x/10] ^= a[x];\n    }\n    for (int x = 0; x < (n/10 + 1); ++x){\n        if (totals_comparison[x] != totals[x]){\n            err += 1;\n            break;\n        }\n    }\n    for (int x = 0; x < 8; ++x){\n        init += 1<<x;\n    }\n    int y;\n    for (int x = 0; x < n; x = x + 10){\n        y = x;\n        for (; y < x + 10 && y < n; y++){\n            temp_a[y - x] = a[y];\n            temp_b[y - x] = b[y];\n        }\n        if (!is_possible(temp_a, temp_b, (y - x) - 1, init)){\n            err += 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "atomic",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_structured_x_divided_expr_assign.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:atomic,construct-independent,V:2.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t *a = (real_t *)malloc(n * sizeof(real_t));\n    real_t *b = (real_t *)malloc(n * sizeof(real_t));\n    real_t *c = (real_t *)malloc(n * sizeof(real_t));\n    real_t *totals = (real_t *)malloc((n/10 + 1) * sizeof(real_t));\n    real_t *totals_comparison = (real_t *)malloc((n/10 + 1) * sizeof(real_t));\n    real_t *temp_a = (real_t *)malloc(10 * sizeof(real_t));\n    real_t *temp_b = (real_t *)malloc(10 * sizeof(real_t));\n    real_t *temp_c = (real_t *)malloc(10 * sizeof(real_t));\n    int temp_iterator;\n    int ab_iterator;\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n        c[x] = 0;\n    }\n    for (int x = 0; x < n/10 + 1; ++x){\n        totals[x] = 1;\n        totals_comparison[x] = 1;\n    }\n\n    #pragma acc data copyin(a[0:n], b[0:n]) copy(totals[0:n/10 + 1]) copyout(c[0:n])\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                #pragma acc atomic update capture\n                {\n                    totals[x/10] = totals[x/10] / (a[x] + b[x]);\n                    c[x] = totals[x/10];\n                }\n            }\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        totals_comparison[x/10] /= a[x] + b[x];\n    }\n    for (int x = 0; x < 10; ++x){\n        if (fabs(totals_comparison[x] - totals[x]) > PRECISION){\n            err += 1;\n            break;\n        }\n    }\n\n    for (int x = 0; x < n; x = x + 10){\n        temp_iterator = 0;\n        for (ab_iterator = x; ab_iterator < n && ab_iterator < x + 10;  ab_iterator+= 1){\n            temp_a[temp_iterator] = a[ab_iterator];\n            temp_b[temp_iterator] = b[ab_iterator];\n            temp_c[temp_iterator] = c[ab_iterator];\n            temp_iterator++;\n        }\n        if (!(is_possible(temp_a, temp_b, temp_c, temp_iterator, 1))){\n            err++;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "atomic",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_structured_x_lshift_expr_assign.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:atomic,construct-independent,V:2.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    unsigned int *a = (unsigned int *)malloc(n * sizeof(int));\n    unsigned int *b = (unsigned int *)malloc(n * sizeof(int));\n    unsigned int *c = (unsigned int *)malloc(7 * n * sizeof(int));\n    unsigned int passed = 1;\n\n    for (int x = 0; x < n; ++x){\n        a[x] = 1;\n        for (int y = 0; y < 7; ++y){\n            if ((rand()/(real_t) (RAND_MAX)) > .5){\n                b[x] += 1<<y;\n            }\n        }\n    }\n\n    #pragma acc data copyin(b[0:n]) copy(a[0:n]) copyout(c[0:7*n])\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                #pragma acc loop\n                for (int y = 0; y < 7; ++y){\n                    c[x * 7 + y] = a[x];\n                    if ((b[x]>>y)%2 == 1){\n                        #pragma acc atomic update capture\n                        {\n                            a[x] = a[x] << 1;\n                            c[x * 7 + y] = a[x];\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        for (int y = 0; y < 7; ++y){\n            if ((b[x]>>y)%2 == 1){\n                a[x] >>= 1;\n            }\n        }\n        if (a[x] != 1){\n            err += 1;\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        if (!is_possible(b[x], &(c[x * 7]), 7, passed)){\n            err++;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "atomic",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_structured_x_minus_expr_assign.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:atomic,construct-independent,V:2.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t *a = (real_t *)malloc(n * sizeof(real_t));\n    real_t *b = (real_t *)malloc(n * sizeof(real_t));\n    real_t *c = (real_t *)malloc(n * sizeof(real_t));\n    real_t *totals = (real_t *)malloc(10 * sizeof(real_t));\n    real_t *totals_host = (real_t *)malloc(10 * sizeof(real_t));\n    real_t * passed_ab = (real_t *)malloc((n/10 + 1) * sizeof(real_t));\n    real_t * passed_c = (real_t *)malloc((n/10 + 1) * sizeof(real_t));\n    int passed_indexer;\n    int absolute_indexer;\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n    }\n    for (int x = 0; x < 10; ++x){\n        totals[x] = 0;\n    }\n\n    #pragma acc data copyin(a[0:n], b[0:n]) copy(totals[0:10])\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                #pragma acc atomic update capture\n                {\n                    totals[x%10] = totals[x%10] - (a[x] + b[x]);\n                    c[x] = totals[x%10];\n                }\n            }\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        totals_host[x%10] = totals_host[x%10] - (a[x] + b[x]);\n    }\n    for (int x = 0; x < 10; ++x){\n        if (fabs(totals_host[x] - totals[x]) > PRECISION){\n            err += 1;\n        }\n    }\n\n    for (int x = 0; x < 10; ++x){\n        for (passed_indexer = 0, absolute_indexer = x; absolute_indexer < n; passed_indexer++, absolute_indexer+= 10){\n            passed_ab[passed_indexer] = a[absolute_indexer] + b[absolute_indexer];\n            passed_c[passed_indexer] = c[absolute_indexer];\n        }\n        if (!is_possible(passed_ab, passed_c, passed_indexer - 1, 0)){\n            err++;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "atomic",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_structured_x_multiply_expr_assign.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:atomic,construct-independent,V:2.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t *a = (real_t *)malloc(n * sizeof(real_t));\n    real_t *b = (real_t *)malloc(n * sizeof(real_t));\n    real_t *c = (real_t *)malloc(n * sizeof(real_t));\n    real_t *totals = (real_t *)malloc((n/10 + 1) * sizeof(real_t));\n    real_t *totals_comparison = (real_t *)malloc((n/10 + 1) * sizeof(real_t));\n    real_t * passed_ab = (real_t *)malloc(10 * sizeof(real_t));\n    real_t * passed_c = (real_t *)malloc(10 * sizeof(real_t));\n    int passed_indexer;\n    int absolute_indexer;\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n    }\n    for (int x = 0; x < n/10 + 1; ++x){\n        totals[x] = 1;\n        totals_comparison[x] = 1;\n    }\n\n    #pragma acc data copyin(a[0:n], b[0:n]) copy(totals[0:n/10 + 1]) copyout(c[0:n])\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                #pragma acc atomic update capture\n                {\n                    totals[x%(n/10 + 1)] = totals[x%(n/10 + 1)] * (a[x] + b[x]);\n                    c[x] = totals[x%(n/10 + 1)];\n                }\n            }\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        totals_comparison[x%(n/10 + 1)] *= a[x] + b[x];\n    }\n    for (int x = 0; x < 10; ++x){\n        if (fabs(totals_comparison[x] - totals[x]) > PRECISION * totals_comparison[x]){\n            err += 1;\n            break;\n        }\n    }\n\n    for (int x = 0; x < n/10 + 1; ++x){\n        for (passed_indexer = 0, absolute_indexer = x; absolute_indexer < n; passed_indexer++, absolute_indexer += n/10 + 1){\n            passed_ab[passed_indexer] = a[absolute_indexer] + b[absolute_indexer];\n            passed_c[passed_indexer] = c[absolute_indexer];\n        }\n        if (!is_possible(passed_ab, passed_c, passed_indexer - 1, 1)){\n            err++;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "atomic",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_structured_x_plus_expr_assign.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:atomic,construct-independent,V:2.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t *a = (real_t *)malloc(n * sizeof(real_t));\n    real_t *b = (real_t *)malloc(n * sizeof(real_t));\n    real_t *c = (real_t *)malloc(n * sizeof(real_t));\n    real_t *totals = (real_t *)malloc((n/10 + 1) * sizeof(real_t));\n    real_t *totals_comparison = (real_t *)malloc((n/10 + 1) * sizeof(real_t));\n    real_t *passed_ab = (real_t *)malloc(10 * sizeof(real_t));\n    real_t *passed_c = (real_t *)malloc(10 * sizeof(real_t));\n    int passed_indexer;\n    int absolute_indexer;\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n    }\n    for (int x = 0; x < n/10 + 1; ++x){\n        totals[x] = 0;\n        totals_comparison[x] = 0;\n    }\n\n    #pragma acc data copyin(a[0:n], b[0:n]) copy(totals[0:n/10 + 1]) copyout(c[0:n])\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                #pragma acc atomic update capture\n                {\n                    totals[x%(n/10 + 1)] = totals[x%(n/10 + 1)] + (a[x] * b[x]);\n                    c[x] = totals[x%(n/10 + 1)];\n                }\n            }\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        totals_comparison[x%(n/10 + 1)] += a[x] * b[x];\n    }\n    for (int x = 0; x < n/10 + 1; ++x){\n        if (fabs(totals_comparison[x] - totals[x]) > PRECISION){\n            err += 1;\n            break;\n        }\n    }\n\n    for (int x = 0; x < n/10 + 1; ++x){\n        for (passed_indexer = 0, absolute_indexer = x; absolute_indexer < n; passed_indexer++, absolute_indexer+= (n/10 + 1)){\n            passed_ab[passed_indexer] = a[absolute_indexer] * b[absolute_indexer];\n            passed_c[passed_indexer] = c[absolute_indexer];\n        }\n        if (!is_possible(passed_ab, passed_c, passed_indexer - 1, 0)){\n            err++;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "atomic",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_structured_x_rshift_expr_assign.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:atomic,construct-independent,V:2.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    unsigned int *a = (unsigned int *)malloc(n * sizeof(int));\n    unsigned int *b = (unsigned int *)malloc(n * sizeof(int));\n    unsigned int *c = (unsigned int *)malloc(7 * n * sizeof(int));\n    unsigned int passed = 1<<8;\n\n    for (int x = 0; x < n; ++x){\n        a[x] = 1<<8;\n        for (int y = 0; y < 7; ++y){\n            if ((rand()/(real_t) (RAND_MAX)) > .5){\n                b[x] += 1<<y;\n            }\n        }\n    }\n\n    #pragma acc data copyin(b[0:n]) copy(a[0:n]) copyout(c[0:7*n])\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                #pragma acc loop\n                for (int y = 0; y < 7; ++y){\n                    c[x * 7 + y] = a[x];\n                    if ((b[x]>>y)%2 == 1){\n                        #pragma acc atomic update capture\n                        {\n                            a[x] = a[x] >> 1;\n                            c[x * 7 + y] = a[x];\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        for (int y = 0; y < 7; ++y){\n            if ((b[x]>>y)%2 == 1){\n                a[x] <<= 1;\n            }\n        }\n        if (a[x] != 1<<8){\n            err += 1;\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        if (!is_possible(b[x], &(c[x * 7]), 7, passed)){\n            err++;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "atomic",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_update_bitand_equals.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:atomic,construct-independent,V:2.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    int  *a = (int *)malloc(n * sizeof(int));\n    int *totals = (int *)malloc((n/10 + 1) * sizeof(int));\n    int *totals_comparison = (int *)malloc((n/10 + 1) * sizeof(int));\n\n    for (int x = 0; x < n; ++x){\n        for (int y = 0; y < 8; ++y){\n            if (rand()/(real_t)(RAND_MAX) < .933){ //.933 gets close to a 50/50 distribution for a collescence of 10 values\n                a[x] += 1<<y;\n            }\n        }\n    }\n    for (int x = 0; x < n/10 + 1; ++x){\n        for (int y = 0; y < 8; ++y){\n            totals[x] +=  1<<y;\n            totals_comparison[x] += 1<<y;\n        }\n\n    }\n\n    #pragma acc data copyin(a[0:n]) copy(totals[0:n/10 + 1])\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                #pragma acc atomic update\n                    totals[x%(n/10 + 1)] &= a[x];\n            }\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        totals_comparison[x%(n/10 + 1)] &= a[x];\n    }\n    for (int x = 0; x < 10; ++x){\n        if (fabs(totals_comparison[x] - totals[x]) > PRECISION){\n            err += 1;\n            break;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "atomic",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_update_bitor_equals.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:atomic,construct-independent,V:2.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    int  *a = (int *)malloc(n * sizeof(int));\n    int *totals = (int *)malloc((n/10 + 1) * sizeof(int));\n    int *totals_comparison = (int *)malloc((n/10 + 1) * sizeof(int));\n\n    for (int x = 0; x < n; ++x){\n        for (int y = 0; y < 8; ++y){\n            if (rand()/(real_t)(RAND_MAX) > .933){ //.933 gets close to a 50/50 distribution for a collescence of 10 values\n                a[x] += 1<<y;\n            }\n        }\n    }\n    for (int x = 0; x < n/10 + 1; ++x){\n        totals[x] = 0;\n\n    }\n\n    #pragma acc data copyin(a[0:n]) copy(totals[0:n/10 + 1])\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                #pragma acc atomic update\n                    totals[x%(n/10 + 1)] |= a[x];\n            }\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        totals_comparison[x%(n/10 + 1)] |= a[x];\n    }\n    for (int x = 0; x < 10; ++x){\n        if (fabs(totals_comparison[x] - totals[x]) > PRECISION){\n            err += 1;\n            break;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "atomic",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_update_bitxor_equals.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:atomic,construct-independent,V:2.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    int  *a = (int *)malloc(n * sizeof(int));\n    int *totals = (int *)malloc((n/10 + 1) * sizeof(int));\n    int *totals_comparison = (int *)malloc((n/10 + 1) * sizeof(int));\n\n    for (int x = 0; x < n; ++x){\n        for (int y = 0; y < 8; ++y){\n            if (rand()/(real_t)(RAND_MAX) > .5){\n                a[x] += 1<<y;\n            }\n        }\n    }\n    for (int x = 0; x < n/10 + 1; ++x){\n        totals[x] = 0;\n        totals_comparison[x] = 0;\n    }\n\n    #pragma acc data copyin(a[0:n]) copy(totals[0:n/10 + 1])\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                #pragma acc atomic update\n                    totals[x%(n/10 + 1)] ^= a[x];\n            }\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        totals_comparison[x%(n/10 + 1)] ^= a[x];\n    }\n    for (int x = 0; x < 10; ++x){\n        if (fabs(totals_comparison[x] - totals[x]) > PRECISION){\n            err += 1;\n            break;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "atomic",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_update_divided_equals.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:atomic,construct-independent,V:2.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t *a = (real_t *)malloc(n * sizeof(real_t));\n    real_t *b = (real_t *)malloc(n * sizeof(real_t));\n    real_t *totals = (real_t *)malloc((n/10 + 1) * sizeof(real_t));\n    real_t *totals_comparison = (real_t *)malloc((n/10 + 1) * sizeof(real_t));\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n    }\n    for (int x = 0; x < n/10 + 1; ++x){\n        totals[x] = 1;\n        totals_comparison[x] = 1;\n    }\n\n    #pragma acc data copyin(a[0:n], b[0:n]) copy(totals[0:n/10 + 1])\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                #pragma acc atomic update\n                    totals[x%(n/10 + 1)] /= (a[x] + b[x]);\n            }\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        totals_comparison[x%(n/10 + 1)] /= a[x] + b[x];\n    }\n    for (int x = 0; x < 10; ++x){\n        if (fabs(totals_comparison[x] - totals[x]) > PRECISION){\n            err += 1;\n            break;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "atomic",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_update_expr_and_x.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:construct-independent,atomic,V:2.0-2.7\n      LOGICAL FUNCTION test1()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x, y !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT, 10):: randoms\n        LOGICAL,DIMENSION(LOOPCOUNT, 10):: a !Data\n        LOGICAL,DIMENSION(LOOPCOUNT):: totals, totals_comparison\n        INTEGER :: errors = 0\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(randoms)\n        DO x = 1, LOOPCOUNT\n          DO y = 1, 10\n            IF (randoms(x, y) < .933) THEN\n              a(x, y) = .TRUE.\n            ELSE\n              a(x, y) = .FALSE.\n            END IF\n          END DO\n        END DO\n\n        totals = .FALSE.\n        totals_comparison = .FALSE.\n\n        !$acc data copyin(a(1:LOOPCOUNT,1:10)) copy(totals(1:LOOPCOUNT))\n          !$acc parallel\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              DO y = 1, 10\n                !$acc atomic update\n                  totals(x) = a(x, y) .AND. totals(x)\n              END DO\n            END DO\n          !$acc end parallel\n        !$acc end data\n\n        DO x = 1, LOOPCOUNT\n          DO y = 1, 10\n            totals_comparison(x) = totals_comparison(x) .AND. a(x, y)\n          END DO\n        END DO\n\n        DO x = 1, LOOPCOUNT\n          IF (totals_comparison(x) .NEQV. totals(x)) THEN\n            errors = errors + 1\n            WRITE(*, *) totals_comparison(x)\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "construct-independent",
                            "atomic"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_update_expr_and_x_end.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:construct-independent,atomic,V:2.0-2.7\n      LOGICAL FUNCTION test1()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x, y !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT, 10):: randoms\n        LOGICAL,DIMENSION(LOOPCOUNT, 10):: a !Data\n        LOGICAL,DIMENSION(LOOPCOUNT):: totals, totals_comparison\n        INTEGER :: errors = 0\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(randoms)\n        DO x = 1, LOOPCOUNT\n          DO y = 1, 10\n            IF (randoms(x, y) < .933) THEN\n              a(x, y) = .TRUE.\n            ELSE\n              a(x, y) = .FALSE.\n            END IF\n          END DO\n        END DO\n\n        totals = .FALSE.\n        totals_comparison = .FALSE.\n\n        !$acc data copyin(a(1:LOOPCOUNT,1:10)) copy(totals(1:LOOPCOUNT))\n          !$acc parallel\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              DO y = 1, 10\n                !$acc atomic update\n                  totals(x) = a(x, y) .AND. totals(x)\n                !$acc end atomic\n              END DO\n            END DO\n          !$acc end parallel\n        !$acc end data\n\n        DO x = 1, LOOPCOUNT\n          DO y = 1, 10\n            totals_comparison(x) = totals_comparison(x) .AND. a(x, y)\n          END DO\n        END DO\n\n        DO x = 1, LOOPCOUNT\n          IF (totals_comparison(x) .NEQV. totals(x)) THEN\n            errors = errors + 1\n            WRITE(*, *) totals_comparison(x)\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "construct-independent",
                            "atomic"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_update_expr_bitand_x.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:atomic,construct-independent,V:2.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    int  *a = (int *)malloc(n * sizeof(int));\n    int *totals = (int *)malloc((n/10 + 1) * sizeof(int));\n    int *totals_comparison = (int *)malloc((n/10 + 1) * sizeof(int));\n\n    for (int x = 0; x < n; ++x){\n        for (int y = 0; y < 8; ++y){\n            if (rand()/(real_t)(RAND_MAX) < .933){ //.933 gets close to a 50/50 distribution for a collescence of 10 values\n                a[x] += 1<<y;\n            }\n        }\n    }\n    for (int x = 0; x < n/10 + 1; ++x){\n        for (int y = 0; y < 8; ++y){\n            totals[x] +=  1<<y;\n            totals_comparison[x] += 1<<y;\n        }\n\n    }\n\n    #pragma acc data copyin(a[0:n]) copy(totals[0:n/10 + 1])\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                #pragma acc atomic update\n                    totals[x%(n/10 + 1)] = a[x] & totals[x%(n/10 + 1)];\n            }\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        totals_comparison[x%(n/10 + 1)] &= a[x];\n    }\n    for (int x = 0; x < 10; ++x){\n        if (fabs(totals_comparison[x] - totals[x]) > PRECISION){\n            err += 1;\n            break;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "atomic",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_update_expr_bitor_x.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:atomic,construct-independent,V:2.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    int  *a = (int *)malloc(n * sizeof(int));\n    int *totals = (int *)malloc((n/10 + 1) * sizeof(int));\n    int *totals_comparison = (int *)malloc((n/10 + 1) * sizeof(int));\n\n    for (int x = 0; x < n; ++x){\n        for (int y = 0; y < 8; ++y){\n            if (rand()/(real_t)(RAND_MAX) > .933){ //.933 gets close to a 50/50 distribution for a collescence of 10 values\n                a[x] += 1<<y;\n            }\n        }\n    }\n    for (int x = 0; x < n/10 + 1; ++x){\n        totals[x] = 0;\n\n    }\n\n    #pragma acc data copyin(a[0:n]) copy(totals[0:n/10 + 1])\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                #pragma acc atomic update\n                    totals[x%(n/10 + 1)] = totals[x%(n/10 + 1)] | a[x];\n            }\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        totals_comparison[x%(n/10 + 1)] |= a[x];\n    }\n    for (int x = 0; x < 10; ++x){\n        if (fabs(totals_comparison[x] - totals[x]) > PRECISION){\n            err += 1;\n            break;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "atomic",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_update_expr_bitxor_x.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:atomic,construct-independent,V:2.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    int  *a = (int *)malloc(n * sizeof(int));\n    int *totals = (int *)malloc((n/10 + 1) * sizeof(int));\n    int *totals_comparison = (int *)malloc((n/10 + 1) * sizeof(int));\n\n    for (int x = 0; x < n; ++x){\n        for (int y = 0; y < 8; ++y){\n            if (rand()/(real_t)(RAND_MAX) > .5){\n                a[x] += 1<<y;\n            }\n        }\n    }\n    for (int x = 0; x < n/10 + 1; ++x){\n        totals[x] = 0;\n        totals_comparison[x] = 0;\n    }\n\n    #pragma acc data copyin(a[0:n]) copy(totals[0:n/10 + 1])\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                #pragma acc atomic update\n                    totals[x%(n/10 + 1)] = a[x] ^ totals[x%(n/10 + 1)];\n            }\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        totals_comparison[x%(n/10 + 1)] ^= a[x];\n    }\n    for (int x = 0; x < 10; ++x){\n        if (fabs(totals_comparison[x] - totals[x]) > PRECISION){\n            err += 1;\n            break;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "atomic",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_update_expr_divided_x.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:construct-independent,atomic,V:2.0-2.7\n      LOGICAL FUNCTION test1()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x, y !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT, 10):: a !Data\n        REAL(8),DIMENSION(LOOPCOUNT):: totals\n        REAL(8),DIMENSION(10):: passed\n        INTEGER :: errors = 0\n        LOGICAL IS_POSSIBLE\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(a)\n\n        totals = 1\n\n        !$acc data copyin(a(1:LOOPCOUNT, 1:10)) copy(totals(1:LOOPCOUNT))\n          !$acc parallel\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              DO y = 1, 10\n                !$acc atomic update\n                  totals(x) = a(x, y) / totals(x)\n              END DO\n            END DO\n          !$acc end parallel\n        !$acc end data\n\n\n        DO x = 1, LOOPCOUNT\n          DO y = 1, 10\n            passed(y) = a(x, y)\n          END DO\n          IF (IS_POSSIBLE(passed, totals(x), 10, 1) .eqv. .FALSE.) THEN\n            errors = errors + 1\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "construct-independent",
                            "atomic"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_update_expr_divided_x.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:atomic,construct-independent,V:2.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t *a = (real_t *)malloc(n * sizeof(real_t));\n    real_t *b = (real_t *)malloc(n * sizeof(real_t));\n    real_t *totals = (real_t *)malloc((n/10 + 1) * sizeof(real_t));\n    real_t * passed = (real_t *)malloc(10 * sizeof(real_t));\n    int indexer;\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n    }\n    for (int x = 0; x < n/10 + 1; ++x){\n        totals[x] = 1;\n    }\n\n    #pragma acc data copyin(a[0:n], b[0:n]) copy(totals[0:n/10 + 1])\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                #pragma acc atomic update\n                    totals[x%(n/10 + 1)] = (a[x] + b[x]) / totals[x%(n/10 + 1)];\n            }\n        }\n    }\n\n\n    for (int x = 0; x < (n/10 + 1); ++x){\n        indexer = x;\n        while (indexer < n){\n            passed[indexer/(n/10 + 1)] = (a[x] + b[x]);\n            indexer += (n/10 + 1);\n        }\n        if (!(possible_result(passed, 10, 1, totals[x]))){\n            err += 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "atomic",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_update_expr_divided_x_end.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:construct-independent,atomic,V:2.0-2.7\n      LOGICAL FUNCTION test1()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x, y !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT, 10):: a !Data\n        REAL(8),DIMENSION(LOOPCOUNT):: totals\n        REAL(8),DIMENSION(10):: passed\n        INTEGER :: errors = 0\n        LOGICAL IS_POSSIBLE\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(a)\n\n        totals = 1\n\n        !$acc data copyin(a(1:LOOPCOUNT, 1:10)) copy(totals(1:LOOPCOUNT))\n          !$acc parallel\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              DO y = 1, 10\n                !$acc atomic update\n                  totals(x) = a(x, y) / totals(x)\n                !$acc end atomic\n              END DO\n            END DO\n          !$acc end parallel\n        !$acc end data\n\n\n        DO x = 1, LOOPCOUNT\n          DO y = 1, 10\n            passed(y) = a(x, y)\n          END DO\n          IF (IS_POSSIBLE(passed, totals(x), 10, 1) .eqv. .FALSE.) THEN\n            errors = errors + 1\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "construct-independent",
                            "atomic"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_update_expr_eqv_x.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:construct-independent,atomic,V:2.0-2.7\n      LOGICAL FUNCTION test1()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x, y !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT, 10):: randoms\n        LOGICAL,DIMENSION(LOOPCOUNT, 10):: a !Data\n        LOGICAL,DIMENSION(LOOPCOUNT):: totals, totals_comparison\n        INTEGER :: errors = 0\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(randoms)\n        DO x = 1, LOOPCOUNT\n          DO y = 1, 10\n            IF (randoms(x, y) > .5) THEN\n              a(x, y) = .TRUE.\n            ELSE\n              a(x, y) = .FALSE.\n            END IF\n          END DO\n        END DO\n\n        totals = .FALSE.\n        totals_comparison = .FALSE.\n\n        !$acc data copyin(a(1:LOOPCOUNT,1:10)) copy(totals(1:LOOPCOUNT))\n          !$acc parallel\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              DO y = 1, 10\n                !$acc atomic update\n                  totals(x) = a(x, y) .EQV. totals(x)\n              END DO\n            END DO\n          !$acc end parallel\n        !$acc end data\n\n        DO x = 1, LOOPCOUNT\n          DO y = 1, 10\n            totals_comparison(x) = totals_comparison(x) .EQV. a(x, y)\n          END DO\n        END DO\n\n        DO x = 1, LOOPCOUNT\n          IF (totals_comparison(x) .NEQV. totals(x)) THEN\n            errors = errors + 1\n            WRITE(*, *) totals_comparison(x)\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "construct-independent",
                            "atomic"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_update_expr_eqv_x_end.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:construct-independent,atomic,V:2.0-2.7\n      LOGICAL FUNCTION test1()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x, y !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT, 10):: randoms\n        LOGICAL,DIMENSION(LOOPCOUNT, 10):: a !Data\n        LOGICAL,DIMENSION(LOOPCOUNT):: totals, totals_comparison\n        INTEGER :: errors = 0\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(randoms)\n        DO x = 1, LOOPCOUNT\n          DO y = 1, 10\n            IF (randoms(x, y) > .5) THEN\n              a(x, y) = .TRUE.\n            ELSE\n              a(x, y) = .FALSE.\n            END IF\n          END DO\n        END DO\n\n        totals = .FALSE.\n        totals_comparison = .FALSE.\n\n        !$acc data copyin(a(1:LOOPCOUNT,1:10)) copy(totals(1:LOOPCOUNT))\n          !$acc parallel\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              DO y = 1, 10\n                !$acc atomic update\n                  totals(x) = a(x, y) .EQV. totals(x)\n                !$acc end atomic\n              END DO\n            END DO\n          !$acc end parallel\n        !$acc end data\n\n        DO x = 1, LOOPCOUNT\n          DO y = 1, 10\n            totals_comparison(x) = totals_comparison(x) .EQV. a(x, y)\n          END DO\n        END DO\n\n        DO x = 1, LOOPCOUNT\n          IF (totals_comparison(x) .NEQV. totals(x)) THEN\n            errors = errors + 1\n            WRITE(*, *) totals_comparison(x)\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "construct-independent",
                            "atomic"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_update_expr_lshift_x.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:atomic,construct-independent,V:2.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    unsigned int *a = (unsigned int *)malloc(3 * n * sizeof(int));\n    unsigned int *b = (unsigned int *)malloc(n * sizeof(int));\n    int orders[18] = {1, 2, 0, 1, 0, 2, 2, 1, 0, 2, 0, 1, 0, 1, 2, 0, 2, 1};\n    int result;\n\n    for (int x = 0; x < n; ++x){\n        for (int y = 0; y < 3; ++y){\n            a[x * 3 + y] = (int) (rand() / (unsigned int) (RAND_MAX / 4));\n        }\n        b[x] = 0;\n    }\n\n    #pragma acc data copyin(a[0:3 * n]) copy(b[0:n])\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                #pragma acc loop\n                for (int y = 0; y < 3; ++y){\n                    #pragma acc atomic update\n                        b[x] = a[x * 3 + y] << b[x];\n                }\n            }\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        for (int y = 0; y < 6; ++y){\n            result = 0;\n            for (int z = 0; z < 3; ++z){\n                result = a[x * 3 + orders[y * 3 + z]] << result;\n            }\n            if (result == b[x]){\n                break;\n            }\n        }\n        if (result != b[x]){\n            err += 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "atomic",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_update_expr_minus_x.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:construct-independent,atomic,V:2.0-2.7\n      LOGICAL FUNCTION test1()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x, y !Iterators\n        LOGICAL IS_POSSIBLE\n        REAL(8),DIMENSION(LOOPCOUNT, 10):: a !Data\n        REAL(8),DIMENSION(LOOPCOUNT):: totals\n        INTEGER :: errors = 0\n        REAL(8),DIMENSION(10):: passed\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(a)\n\n        totals = 0\n\n        !$acc data copyin(a(1:LOOPCOUNT, 1:10)) copy(totals(1:LOOPCOUNT))\n          !$acc parallel\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              DO y = 1, 10\n                !$acc atomic update\n                  totals(x) = a(x, y) - totals(x)\n              END DO\n            END DO\n          !$acc end parallel\n        !$acc end data\n\n        DO x = 1, LOOPCOUNT\n          DO y = 1, 10\n            passed(y) = a(x, y)\n          END DO\n          IF (IS_POSSIBLE(passed, totals(x), 10, 0) .eqv. .FALSE.) THEN\n            errors = errors + 1\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "construct-independent",
                            "atomic"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_update_expr_minus_x.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:atomic,construct-independent,V:2.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t *a = (real_t *)malloc(n * sizeof(real_t));\n    real_t *totals = (real_t *)malloc(((n/10) + 1) * sizeof(real_t));\n    int indexer = 0;\n    real_t * passed = (real_t *)malloc(10 * sizeof(real_t));\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n    }\n    for (int x = 0; x < (n/10) + 1; ++x){\n        totals[x] = 0;\n    }\n\n    #pragma acc data copyin(a[0:n]) copy(totals[0:(n/10) + 1])\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                #pragma acc atomic update\n                    totals[x%((int) (n/10) + 1)] = a[x] - totals[x%((int) (n/10) + 1)];\n            }\n        }\n    }\n    for (int x = 0; x < (n/10) + 1; ++x){\n        indexer = x;\n        while (indexer < n){\n            passed[indexer/((int) (n/10) + 1)] = a[indexer];\n            indexer += (n/10) + 1;\n        }\n        if (!(possible_result(passed, 10, 0, totals[x]))){\n            err += 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "atomic",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_update_expr_minus_x_end.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:construct-independent,atomic,V:2.0-2.7\n      LOGICAL FUNCTION test1()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x, y !Iterators\n        LOGICAL IS_POSSIBLE\n        REAL(8),DIMENSION(LOOPCOUNT, 10):: a !Data\n        REAL(8),DIMENSION(LOOPCOUNT):: totals\n        INTEGER :: errors = 0\n        REAL(8),DIMENSION(10):: passed\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(a)\n\n        totals = 0\n\n        !$acc data copyin(a(1:LOOPCOUNT, 1:10)) copy(totals(1:LOOPCOUNT))\n          !$acc parallel\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              DO y = 1, 10\n                !$acc atomic update\n                  totals(x) = a(x, y) - totals(x)\n                !$acc end atomic\n              END DO\n            END DO\n          !$acc end parallel\n        !$acc end data\n\n        DO x = 1, LOOPCOUNT\n          DO y = 1, 10\n            passed(y) = a(x, y)\n          END DO\n          IF (IS_POSSIBLE(passed, totals(x), 10, 0) .eqv. .FALSE.) THEN\n            errors = errors + 1\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "construct-independent",
                            "atomic"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_update_expr_multiply_x.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:atomic,construct-independent,V:2.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t *a = (real_t *)malloc(n * sizeof(real_t));\n    real_t *b = (real_t *)malloc(n * sizeof(real_t));\n    real_t *totals = (real_t *)malloc((n/10 + 1) * sizeof(real_t));\n    real_t *totals_comparison = (real_t *)malloc((n/10 + 1) * sizeof(real_t));\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n    }\n    for (int x = 0; x < n/10 + 1; ++x){\n        totals[x] = 1;\n        totals_comparison[x] = 1;\n    }\n\n    #pragma acc data copyin(a[0:n], b[0:n]) copy(totals[0:n/10 + 1])\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                #pragma acc atomic update\n                    totals[x%(n/10 + 1)] = (a[x] + b[x]) * totals[x%(n/10 + 1)];\n            }\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        totals_comparison[x%(n/10 + 1)] *= a[x] + b[x];\n    }\n    for (int x = 0; x < 10; ++x){\n        if (fabs(totals_comparison[x] - totals[x]) > PRECISION * totals_comparison[x]){\n            err += 1;\n            break;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "atomic",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_update_expr_neqv_x.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:construct-independent,atomic,V:2.0-2.7\n      LOGICAL FUNCTION test1()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x, y !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT, 10):: randoms\n        LOGICAL,DIMENSION(LOOPCOUNT, 10):: a !Data\n        LOGICAL,DIMENSION(LOOPCOUNT):: totals, totals_comparison\n        INTEGER :: errors = 0\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(randoms)\n        DO x = 1, LOOPCOUNT\n          DO y = 1, 10\n            IF (randoms(x, y) > .5) THEN\n              a(x, y) = .TRUE.\n            ELSE\n              a(x, y) = .FALSE.\n            END IF\n          END DO\n        END DO\n\n        totals = .FALSE.\n        totals_comparison = .FALSE.\n\n        !$acc data copyin(a(1:LOOPCOUNT,1:10)) copy(totals(1:LOOPCOUNT))\n          !$acc parallel\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              DO y = 1, 10\n                !$acc atomic update\n                  totals(x) = a(x, y) .NEQV. totals(x)\n              END DO\n            END DO\n          !$acc end parallel\n        !$acc end data\n\n        DO x = 1, LOOPCOUNT\n          DO y = 1, 10\n            totals_comparison(x) = totals_comparison(x) .NEQV. a(x, y)\n          END DO\n        END DO\n\n        DO x = 1, LOOPCOUNT\n          IF (totals_comparison(x) .NEQV. totals(x)) THEN\n            errors = errors + 1\n            WRITE(*, *) totals_comparison(x)\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "construct-independent",
                            "atomic"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_update_expr_neqv_x_end.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:construct-independent,atomic,V:2.0-2.7\n      LOGICAL FUNCTION test1()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x, y !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT, 10):: randoms\n        LOGICAL,DIMENSION(LOOPCOUNT, 10):: a !Data\n        LOGICAL,DIMENSION(LOOPCOUNT):: totals, totals_comparison\n        INTEGER :: errors = 0\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(randoms)\n        DO x = 1, LOOPCOUNT\n          DO y = 1, 10\n            IF (randoms(x, y) > .5) THEN\n              a(x, y) = .TRUE.\n            ELSE\n              a(x, y) = .FALSE.\n            END IF\n          END DO\n        END DO\n\n        totals = .FALSE.\n        totals_comparison = .FALSE.\n\n        !$acc data copyin(a(1:LOOPCOUNT,1:10)) copy(totals(1:LOOPCOUNT))\n          !$acc parallel\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              DO y = 1, 10\n                !$acc atomic update\n                  totals(x) = a(x, y) .NEQV. totals(x)\n                !$acc end atomic\n              END DO\n            END DO\n          !$acc end parallel\n        !$acc end data\n\n        DO x = 1, LOOPCOUNT\n          DO y = 1, 10\n            totals_comparison(x) = totals_comparison(x) .NEQV. a(x, y)\n          END DO\n        END DO\n\n        DO x = 1, LOOPCOUNT\n          IF (totals_comparison(x) .NEQV. totals(x)) THEN\n            errors = errors + 1\n            WRITE(*, *) totals_comparison(x)\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "construct-independent",
                            "atomic"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_update_expr_or_x.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:construct-independent,atomic,V:2.0-2.7\n      LOGICAL FUNCTION test1()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x, y !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT, 10):: randoms\n        LOGICAL,DIMENSION(LOOPCOUNT, 10):: a !Data\n        LOGICAL,DIMENSION(LOOPCOUNT):: totals, totals_comparison\n        INTEGER :: errors = 0\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(randoms)\n        DO x = 1, LOOPCOUNT\n          DO y = 1, 10\n            IF (randoms(x, y) > .933) THEN\n              a(x, y) = .TRUE.\n            ELSE\n              a(x, y) = .FALSE.\n            END IF\n          END DO\n        END DO\n\n        totals = .FALSE.\n        totals_comparison = .FALSE.\n\n        !$acc data copyin(a(1:LOOPCOUNT,1:10)) copy(totals(1:LOOPCOUNT))\n          !$acc parallel\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              DO y = 1, 10\n                !$acc atomic update\n                  totals(x) = a(x, y) .OR. totals(x)\n              END DO\n            END DO\n          !$acc end parallel\n        !$acc end data\n\n        DO x = 1, LOOPCOUNT\n          DO y = 1, 10\n            totals_comparison(x) = totals_comparison(x) .OR. a(x, y)\n          END DO\n        END DO\n\n        DO x = 1, LOOPCOUNT\n          IF (totals_comparison(x) .NEQV. totals(x)) THEN\n            errors = errors + 1\n            WRITE(*, *) totals_comparison(x)\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "construct-independent",
                            "atomic"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_update_expr_or_x_end.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:construct-independent,atomic,V:2.0-2.7\n      LOGICAL FUNCTION test1()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x, y !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT, 10):: randoms\n        LOGICAL,DIMENSION(LOOPCOUNT, 10):: a !Data\n        LOGICAL,DIMENSION(LOOPCOUNT):: totals, totals_comparison\n        INTEGER :: errors = 0\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(randoms)\n        DO x = 1, LOOPCOUNT\n          DO y = 1, 10\n            IF (randoms(x, y) > .933) THEN\n              a(x, y) = .TRUE.\n            ELSE\n              a(x, y) = .FALSE.\n            END IF\n          END DO\n        END DO\n\n        totals = .FALSE.\n        totals_comparison = .FALSE.\n\n        !$acc data copyin(a(1:LOOPCOUNT,1:10)) copy(totals(1:LOOPCOUNT))\n          !$acc parallel\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              DO y = 1, 10\n                !$acc atomic update\n                  totals(x) = a(x, y) .OR. totals(x)\n                !$acc end atomic\n              END DO\n            END DO\n          !$acc end parallel\n        !$acc end data\n\n        DO x = 1, LOOPCOUNT\n          DO y = 1, 10\n            totals_comparison(x) = totals_comparison(x) .OR. a(x, y)\n          END DO\n        END DO\n\n        DO x = 1, LOOPCOUNT\n          IF (totals_comparison(x) .NEQV. totals(x)) THEN\n            errors = errors + 1\n            WRITE(*, *) totals_comparison(x)\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "construct-independent",
                            "atomic"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_update_expr_plus_x.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:construct-independent,atomic,V:2.0-2.7\n      LOGICAL FUNCTION test1()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x, y !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT, 10):: a !Data\n        REAL(8),DIMENSION(LOOPCOUNT):: totals, totals_comparison\n        INTEGER :: errors = 0\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(a)\n\n        totals = 0\n        totals_comparison = 0\n\n        !$acc data copyin(a(1:LOOPCOUNT, 1:10)) copy(totals(1:LOOPCOUNT))\n          !$acc parallel\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              DO y = 1, 10\n                !$acc atomic update\n                  totals(x) = a(x, y) + totals(x)\n              END DO\n            END DO\n          !$acc end parallel\n        !$acc end data\n        DO x = 1, LOOPCOUNT\n          DO y = 1, 10\n            totals_comparison(x) = totals_comparison(x) + a(x, y)\n          END DO\n        END DO\n\n        DO x = 1, LOOPCOUNT\n          IF (totals_comparison(x) .NE. totals(x)) THEN\n            errors = errors + 1\n            WRITE(*, *) totals_comparison(x)\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "construct-independent",
                            "atomic"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_update_expr_plus_x.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:atomic,construct-independent,V:2.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t *a = (real_t *)malloc(n * sizeof(real_t));\n    real_t *b = (real_t *)malloc(n * sizeof(real_t));\n    real_t *totals = (real_t *)malloc(10 * sizeof(real_t));\n    real_t *totals_comparison = (real_t *)malloc(10 * sizeof(real_t));\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n    }\n    for (int x = 0; x < 10; ++x){\n        totals[x] = 0;\n        totals_comparison[x] = 0;\n    }\n\n    #pragma acc data copyin(a[0:n], b[0:n]) copy(totals[0:10])\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                #pragma acc loop\n                for (int y = 0; y < n; ++y){\n                    #pragma acc atomic update\n                        totals[(int) ((a[x] + b[x])/2)] = a[x] * b[x] + totals[(int) ((a[x] + b[x])/2)];\n                }\n            }\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        for (int y = 0; y < n; ++y){\n            totals_comparison[(int) ((a[x] + b[x])/2)] += a[x] * b[x];\n        }\n    }\n    for (int x = 0; x < 10; ++x){\n        if (fabs(totals_comparison[x] - totals[x]) > 10 * PRECISION){\n            err += 1;\n            break;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "atomic",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_update_expr_plus_x_end.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:construct-independent,atomic,V:2.0-2.7\n      LOGICAL FUNCTION test1()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x, y !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT, 10):: a !Data\n        REAL(8),DIMENSION(LOOPCOUNT):: totals, totals_comparison\n        INTEGER :: errors = 0\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(a)\n\n        totals = 0\n        totals_comparison = 0\n\n        !$acc data copyin(a(1:LOOPCOUNT, 1:10)) copy(totals(1:LOOPCOUNT))\n          !$acc parallel\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              DO y = 1, 10\n                !$acc atomic update\n                  totals(x) = a(x, y) + totals(x)\n                !$acc end atomic\n              END DO\n            END DO\n          !$acc end parallel\n        !$acc end data\n        DO x = 1, LOOPCOUNT\n          DO y = 1, 10\n            totals_comparison(x) = totals_comparison(x) + a(x, y)\n          END DO\n        END DO\n\n        DO x = 1, LOOPCOUNT\n          IF (totals_comparison(x) .NE. totals(x)) THEN\n            errors = errors + 1\n            WRITE(*, *) totals_comparison(x)\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "construct-independent",
                            "atomic"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_update_expr_rshift_x.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:atomic,construct-independent,V:2.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    unsigned int *a = (unsigned int *)malloc(3 * n * sizeof(int));\n    unsigned int *b = (unsigned int *)malloc(n * sizeof(int));\n    int orders[18] = {1, 2, 0, 1, 0, 2, 2, 1, 0, 2, 0, 1, 0, 1, 2, 0, 2, 1};\n    int result;\n\n    for (int x = 0; x < n; ++x){\n        for (int y = 0; y < 3; ++y){\n            a[x * 3 + y] = (int) (rand() / (unsigned int) (RAND_MAX / 4));\n        }\n        b[x] = 0;\n    }\n\n    #pragma acc data copyin(a[0:3 * n]) copy(b[0:n])\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                #pragma acc loop independent\n                for (int y = 0; y < 3; ++y){\n                    #pragma acc atomic update\n                        b[x] = a[x * 3 + y] >> b[x];\n                }\n            }\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        for (int y = 0; y < 6; ++y){\n            result = 0;\n            for (int z = 0; z < 3; ++z){\n                result = a[x * 3 + orders[y * 3 + z]] >> result;\n            }\n            if (result == b[x]){\n                break;\n            }\n        }\n        if (result != b[x]){\n            err += 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "atomic",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_update_expr_times_x.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:construct-independent,atomic,V:2.0-2.7\n      LOGICAL FUNCTION test1()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x, y !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT, 10):: a !Data\n        REAL(8),DIMENSION(LOOPCOUNT):: totals, totals_comparison\n        INTEGER :: errors = 0\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(a)\n\n        totals = 1\n        totals_comparison = 1\n\n        !$acc data copyin(a(1:LOOPCOUNT, 1:10)) copy(totals(1:LOOPCOUNT))\n          !$acc parallel\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              DO y = 1, 10\n                !$acc atomic update\n                  totals(x) = a(x, y) * totals(x)\n              END DO\n            END DO\n          !$acc end parallel\n        !$acc end data\n        DO x = 1, LOOPCOUNT\n          DO y = 1, 10\n            totals_comparison(x) = totals_comparison(x) * a(x, y)\n          END DO\n        END DO\n\n        DO x = 1, LOOPCOUNT\n          IF (totals_comparison(x) .NE. totals(x)) THEN\n            errors = errors + 1\n            WRITE(*, *) totals_comparison(x)\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "construct-independent",
                            "atomic"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_update_expr_times_x_end.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:construct-independent,atomic,V:2.0-2.7\n      LOGICAL FUNCTION test1()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x, y !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT, 10):: a !Data\n        REAL(8),DIMENSION(LOOPCOUNT):: totals, totals_comparison\n        INTEGER :: errors = 0\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(a)\n\n        totals = 1\n        totals_comparison = 1\n\n        !$acc data copyin(a(1:LOOPCOUNT, 1:10)) copy(totals(1:LOOPCOUNT))\n          !$acc parallel\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              DO y = 1, 10\n                !$acc atomic update\n                  totals(x) = a(x, y) * totals(x)\n                !$acc end atomic\n              END DO\n            END DO\n          !$acc end parallel\n        !$acc end data\n        DO x = 1, LOOPCOUNT\n          DO y = 1, 10\n            totals_comparison(x) = totals_comparison(x) * a(x, y)\n          END DO\n        END DO\n\n        DO x = 1, LOOPCOUNT\n          IF (totals_comparison(x) .NE. totals(x)) THEN\n            errors = errors + 1\n            WRITE(*, *) totals_comparison(x)\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "construct-independent",
                            "atomic"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_update_iand_expr_x.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:construct-independent,atomic,V:2.0-2.7\n      LOGICAL FUNCTION test1()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x, y !Iterators\n        INTEGER,DIMENSION(LOOPCOUNT):: a !Data\n        REAL(8),DIMENSION(LOOPCOUNT, 8):: randoms\n        INTEGER,DIMENSION(LOOPCOUNT/10 + 1):: totals, totals_comparison\n        INTEGER :: errors = 0\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(randoms)\n        a = 0\n        DO x = 1, LOOPCOUNT\n          DO y = 1, 8\n            IF (randoms(x, y) .gt. .933) THEN\n              a(x) = a(x) + ISHFT(1, y - 1)\n            END IF\n          END DO\n        END DO\n        totals = 0\n        totals_comparison = 0\n        DO x = 1, LOOPCOUNT/10 + 1\n          DO y = 0, 7\n            totals(x) = totals(x) + ISHFT(1, y)\n            totals_comparison(x) = totals_comparison(x) + ISHFT(1, y)\n          END DO\n        END DO\n\n        !$acc data copyin(a(1:LOOPCOUNT)) copy(totals(1:(LOOPCOUNT/10 + 1)))\n          !$acc parallel\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              !$acc atomic update\n                totals(MOD(x, LOOPCOUNT/10 + 1) + 1) = iand(a(x), totals(MOD(x, LOOPCOUNT/10 + 1) + 1))\n            END DO\n          !$acc end parallel\n        !$acc end data\n        DO x = 1, LOOPCOUNT\n          totals_comparison(MOD(x, LOOPCOUNT/10 + 1) + 1) = iand(totals_comparison(MOD(x, LOOPCOUNT/10 + 1) + 1), a(x))\n        END DO\n        DO x = 1, LOOPCOUNT/10 + 1\n          IF (totals_comparison(x) .NE. totals(x)) THEN\n            errors = errors + 1\n            WRITE(*, *) totals_comparison(x)\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "construct-independent",
                            "atomic"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_update_iand_expr_x_end.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:construct-independent,atomic,V:2.0-2.7\n      LOGICAL FUNCTION test1()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x, y !Iterators\n        INTEGER,DIMENSION(LOOPCOUNT):: a !Data\n        REAL(8),DIMENSION(LOOPCOUNT, 8):: randoms\n        INTEGER,DIMENSION(LOOPCOUNT/10 + 1):: totals, totals_comparison\n        INTEGER :: errors = 0\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(randoms)\n        a = 0\n        DO x = 1, LOOPCOUNT\n          DO y = 1, 8\n            IF (randoms(x, y) .gt. .933) THEN\n              a(x) = a(x) + ISHFT(1, y - 1)\n            END IF\n          END DO\n        END DO\n        totals = 0\n        totals_comparison = 0\n        DO x = 1, LOOPCOUNT/10 + 1\n          DO y = 0, 7\n            totals(x) = totals(x) + ISHFT(1, y)\n            totals_comparison(x) = totals_comparison(x) + ISHFT(1, y)\n          END DO\n        END DO\n\n        !$acc data copyin(a(1:LOOPCOUNT)) copy(totals(1:(LOOPCOUNT/10 + 1)))\n          !$acc parallel\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              !$acc atomic update\n                totals(MOD(x, LOOPCOUNT/10 + 1) + 1) = iand(a(x), totals(MOD(x, LOOPCOUNT/10 + 1) + 1))\n              !$acc end atomic\n            END DO\n          !$acc end parallel\n        !$acc end data\n        DO x = 1, LOOPCOUNT\n          totals_comparison(MOD(x, LOOPCOUNT/10 + 1) + 1) = iand(totals_comparison(MOD(x, LOOPCOUNT/10 + 1) + 1), a(x))\n        END DO\n        DO x = 1, LOOPCOUNT/10 + 1\n          IF (totals_comparison(x) .NE. totals(x)) THEN\n            errors = errors + 1\n            WRITE(*, *) totals_comparison(x)\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "construct-independent",
                            "atomic"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_update_iand_x_expr.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:construct-independent,atomic,V:2.0-2.7\n      LOGICAL FUNCTION test1()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x, y !Iterators\n        INTEGER,DIMENSION(LOOPCOUNT):: a !Data\n        REAL(8),DIMENSION(LOOPCOUNT, 8):: randoms\n        INTEGER,DIMENSION(LOOPCOUNT/10 + 1):: totals, totals_comparison\n        INTEGER :: errors = 0\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(randoms)\n        a = 0\n        DO x = 1, LOOPCOUNT\n          DO y = 1, 8\n            IF (randoms(x, y) .gt. .933) THEN\n              a(x) = a(x) + ISHFT(1, y - 1)\n            END IF\n          END DO\n        END DO\n        totals = 0\n        totals_comparison = 0\n        DO x = 1, LOOPCOUNT/10 + 1\n          DO y = 0, 7\n            totals(x) = totals(x) + ISHFT(1, y)\n            totals_comparison(x) = totals_comparison(x) + ISHFT(1, y)\n          END DO\n        END DO\n\n        !$acc data copyin(a(1:LOOPCOUNT)) copy(totals(1:(LOOPCOUNT/10 + 1)))\n          !$acc parallel\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              !$acc atomic update\n                totals(MOD(x, LOOPCOUNT/10 + 1) + 1) = iand(totals(MOD(x, LOOPCOUNT/10 + 1) + 1), a(x))\n            END DO\n          !$acc end parallel\n        !$acc end data\n        DO x = 1, LOOPCOUNT\n          totals_comparison(MOD(x, LOOPCOUNT/10 + 1) + 1) = iand(totals_comparison(MOD(x, LOOPCOUNT/10 + 1) + 1), a(x))\n        END DO\n        DO x = 1, LOOPCOUNT/10 + 1\n          IF (totals_comparison(x) .NE. totals(x)) THEN\n            errors = errors + 1\n            WRITE(*, *) totals_comparison(x)\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "construct-independent",
                            "atomic"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_update_iand_x_expr_end.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:construct-independent,atomic,V:2.0-2.7\n      LOGICAL FUNCTION test1()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x, y !Iterators\n        INTEGER,DIMENSION(LOOPCOUNT):: a !Data\n        REAL(8),DIMENSION(LOOPCOUNT, 8):: randoms\n        INTEGER,DIMENSION(LOOPCOUNT/10 + 1):: totals, totals_comparison\n        INTEGER :: errors = 0\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(randoms)\n        a = 0\n        DO x = 1, LOOPCOUNT\n          DO y = 1, 8\n            IF (randoms(x, y) .gt. .933) THEN\n              a(x) = a(x) + ISHFT(1, y - 1)\n            END IF\n          END DO\n        END DO\n        totals = 0\n        totals_comparison = 0\n        DO x = 1, LOOPCOUNT/10 + 1\n          DO y = 0, 7\n            totals(x) = totals(x) + ISHFT(1, y)\n            totals_comparison(x) = totals_comparison(x) + ISHFT(1, y)\n          END DO\n        END DO\n\n        !$acc data copyin(a(1:LOOPCOUNT)) copy(totals(1:(LOOPCOUNT/10 + 1)))\n          !$acc parallel\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              !$acc atomic update\n                totals(MOD(x, LOOPCOUNT/10 + 1) + 1) = iand(totals(MOD(x, LOOPCOUNT/10 + 1) + 1), a(x))\n              !$acc end atomic\n            END DO\n          !$acc end parallel\n        !$acc end data\n        DO x = 1, LOOPCOUNT\n          totals_comparison(MOD(x, LOOPCOUNT/10 + 1) + 1) = iand(totals_comparison(MOD(x, LOOPCOUNT/10 + 1) + 1), a(x))\n        END DO\n        DO x = 1, LOOPCOUNT/10 + 1\n          IF (totals_comparison(x) .NE. totals(x)) THEN\n            errors = errors + 1\n            WRITE(*, *) totals_comparison(x)\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "construct-independent",
                            "atomic"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_update_ior_expr_x.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:construct-independent,atomic,V:2.0-2.7\n      LOGICAL FUNCTION test1()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x, y !Iterators\n        INTEGER,DIMENSION(LOOPCOUNT):: a !Data\n        REAL(8),DIMENSION(LOOPCOUNT, 8):: randoms\n        INTEGER,DIMENSION(LOOPCOUNT/10 + 1):: totals, totals_comparison\n        INTEGER :: errors = 0\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(randoms)\n        a = 0\n        DO x = 1, LOOPCOUNT\n          DO y = 1, 8\n            IF (randoms(x, y) .lt. .933) THEN\n              a(x) = a(x) + ISHFT(1, y - 1)\n            END IF\n          END DO\n        END DO\n        totals = 0\n        totals_comparison = 0\n        DO x = 1, LOOPCOUNT/10 + 1\n          totals(x) = 0\n          totals_comparison(x) = 0\n        END DO\n\n        !$acc data copyin(a(1:LOOPCOUNT)) copy(totals(1:(LOOPCOUNT/10 + 1)))\n          !$acc parallel\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              !$acc atomic update\n                totals(MOD(x, LOOPCOUNT/10 + 1) + 1) = ior(a(x), totals(MOD(x, LOOPCOUNT/10 + 1) + 1))\n            END DO\n          !$acc end parallel\n        !$acc end data\n        DO x = 1, LOOPCOUNT\n          totals_comparison(MOD(x, LOOPCOUNT/10 + 1) + 1) = ior(totals_comparison(MOD(x, LOOPCOUNT/10 + 1) + 1), a(x))\n        END DO\n        DO x = 1, LOOPCOUNT/10 + 1\n          IF (totals_comparison(x) .NE. totals(x)) THEN\n            errors = errors + 1\n            WRITE(*, *) totals_comparison(x)\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "construct-independent",
                            "atomic"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_update_ior_expr_x_end.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:construct-independent,atomic,V:2.0-2.7\n      LOGICAL FUNCTION test1()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x, y !Iterators\n        INTEGER,DIMENSION(LOOPCOUNT):: a !Data\n        REAL(8),DIMENSION(LOOPCOUNT, 8):: randoms\n        INTEGER,DIMENSION(LOOPCOUNT/10 + 1):: totals, totals_comparison\n        INTEGER :: errors = 0\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(randoms)\n        a = 0\n        DO x = 1, LOOPCOUNT\n          DO y = 1, 8\n            IF (randoms(x, y) .lt. .933) THEN\n              a(x) = a(x) + ISHFT(1, y - 1)\n            END IF\n          END DO\n        END DO\n        totals = 0\n        totals_comparison = 0\n        DO x = 1, LOOPCOUNT/10 + 1\n          totals(x) = 0\n          totals_comparison(x) = 0\n        END DO\n\n        !$acc data copyin(a(1:LOOPCOUNT)) copy(totals(1:(LOOPCOUNT/10 + 1)))\n          !$acc parallel\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              !$acc atomic update\n                totals(MOD(x, LOOPCOUNT/10 + 1) + 1) = ior(a(x), totals(MOD(x, LOOPCOUNT/10 + 1) + 1))\n              !$acc end atomic\n            END DO\n          !$acc end parallel\n        !$acc end data\n        DO x = 1, LOOPCOUNT\n          totals_comparison(MOD(x, LOOPCOUNT/10 + 1) + 1) = ior(totals_comparison(MOD(x, LOOPCOUNT/10 + 1) + 1), a(x))\n        END DO\n        DO x = 1, LOOPCOUNT/10 + 1\n          IF (totals_comparison(x) .NE. totals(x)) THEN\n            errors = errors + 1\n            WRITE(*, *) totals_comparison(x)\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "construct-independent",
                            "atomic"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_update_ior_x_expr.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:construct-independent,atomic,V:2.0-2.7\n      LOGICAL FUNCTION test1()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x, y !Iterators\n        INTEGER,DIMENSION(LOOPCOUNT):: a !Data\n        REAL(8),DIMENSION(LOOPCOUNT, 8):: randoms\n        INTEGER,DIMENSION(LOOPCOUNT/10 + 1):: totals, totals_comparison\n        INTEGER :: errors = 0\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(randoms)\n        a = 0\n        DO x = 1, LOOPCOUNT\n          DO y = 1, 8\n            IF (randoms(x, y) .lt. .933) THEN\n              a(x) = a(x) + ISHFT(1, y - 1)\n            END IF\n          END DO\n        END DO\n        totals = 0\n        totals_comparison = 0\n        DO x = 1, LOOPCOUNT/10 + 1\n          totals(x) = 0\n          totals_comparison(x) = 0\n        END DO\n\n        !$acc data copyin(a(1:LOOPCOUNT)) copy(totals(1:(LOOPCOUNT/10 + 1)))\n          !$acc parallel\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              !$acc atomic update\n                totals(MOD(x, LOOPCOUNT/10 + 1) + 1) = ior(totals(MOD(x, LOOPCOUNT/10 + 1) + 1), a(x))\n            END DO\n          !$acc end parallel\n        !$acc end data\n        DO x = 1, LOOPCOUNT\n          totals_comparison(MOD(x, LOOPCOUNT/10 + 1) + 1) = ior(totals_comparison(MOD(x, LOOPCOUNT/10 + 1) + 1), a(x))\n        END DO\n        DO x = 1, LOOPCOUNT/10 + 1\n          IF (totals_comparison(x) .NE. totals(x)) THEN\n            errors = errors + 1\n            WRITE(*, *) totals_comparison(x)\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "construct-independent",
                            "atomic"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_update_ior_x_expr_end.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:construct-independent,atomic,V:2.0-2.7\n      LOGICAL FUNCTION test1()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x, y !Iterators\n        INTEGER,DIMENSION(LOOPCOUNT):: a !Data\n        REAL(8),DIMENSION(LOOPCOUNT, 8):: randoms\n        INTEGER,DIMENSION(LOOPCOUNT/10 + 1):: totals, totals_comparison\n        INTEGER :: errors = 0\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(randoms)\n        a = 0\n        DO x = 1, LOOPCOUNT\n          DO y = 1, 8\n            IF (randoms(x, y) .lt. .933) THEN\n              a(x) = a(x) + ISHFT(1, y - 1)\n            END IF\n          END DO\n        END DO\n        totals = 0\n        totals_comparison = 0\n        DO x = 1, LOOPCOUNT/10 + 1\n          totals(x) = 0\n          totals_comparison(x) = 0\n        END DO\n\n        !$acc data copyin(a(1:LOOPCOUNT)) copy(totals(1:(LOOPCOUNT/10 + 1)))\n          !$acc parallel\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              !$acc atomic update\n                totals(MOD(x, LOOPCOUNT/10 + 1) + 1) = ior(totals(MOD(x, LOOPCOUNT/10 + 1) + 1), a(x))\n              !$acc end atomic\n            END DO\n          !$acc end parallel\n        !$acc end data\n        DO x = 1, LOOPCOUNT\n          totals_comparison(MOD(x, LOOPCOUNT/10 + 1) + 1) = ior(totals_comparison(MOD(x, LOOPCOUNT/10 + 1) + 1), a(x))\n        END DO\n        DO x = 1, LOOPCOUNT/10 + 1\n          IF (totals_comparison(x) .NE. totals(x)) THEN\n            errors = errors + 1\n            WRITE(*, *) totals_comparison(x)\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "construct-independent",
                            "atomic"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_update_ixor_expr_x.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:construct-independent,atomic,V:2.0-2.7\n      LOGICAL FUNCTION test1()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x, y !Iterators\n        INTEGER,DIMENSION(LOOPCOUNT):: a !Data\n        REAL(8),DIMENSION(LOOPCOUNT, 8):: randoms\n        INTEGER,DIMENSION(LOOPCOUNT/10 + 1):: totals, totals_comparison\n        INTEGER :: errors = 0\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(randoms)\n        a = 0\n        DO x = 1, LOOPCOUNT\n          DO y = 1, 8\n            IF (randoms(x, y) .lt. .5) THEN\n              a(x) = a(x) + ISHFT(1, y - 1)\n            END IF\n          END DO\n        END DO\n        totals = 0\n        totals_comparison = 0\n        DO x = 1, LOOPCOUNT/10 + 1\n          totals(x) = 0\n          totals_comparison(x) = 0\n        END DO\n\n        !$acc data copyin(a(1:LOOPCOUNT)) copy(totals(1:(LOOPCOUNT/10 + 1)))\n          !$acc parallel\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              !$acc atomic update\n                totals(MOD(x, LOOPCOUNT/10 + 1) + 1) = ieor(a(x), totals(MOD(x, LOOPCOUNT/10 + 1) + 1))\n            END DO\n          !$acc end parallel\n        !$acc end data\n        DO x = 1, LOOPCOUNT\n          totals_comparison(MOD(x, LOOPCOUNT/10 + 1) + 1) = ieor(totals_comparison(MOD(x, LOOPCOUNT/10 + 1) + 1), a(x))\n        END DO\n        DO x = 1, LOOPCOUNT/10 + 1\n          IF (totals_comparison(x) .NE. totals(x)) THEN\n            errors = errors + 1\n            WRITE(*, *) totals_comparison(x)\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "construct-independent",
                            "atomic"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_update_ixor_expr_x_end.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:construct-independent,atomic,V:2.0-2.7\n      LOGICAL FUNCTION test1()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x, y !Iterators\n        INTEGER,DIMENSION(LOOPCOUNT):: a !Data\n        REAL(8),DIMENSION(LOOPCOUNT, 8):: randoms\n        INTEGER,DIMENSION(LOOPCOUNT/10 + 1):: totals, totals_comparison\n        INTEGER :: errors = 0\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(randoms)\n        a = 0\n        DO x = 1, LOOPCOUNT\n          DO y = 1, 8\n            IF (randoms(x, y) .lt. .5) THEN\n              a(x) = a(x) + ISHFT(1, y - 1)\n            END IF\n          END DO\n        END DO\n        totals = 0\n        totals_comparison = 0\n        DO x = 1, LOOPCOUNT/10 + 1\n          totals(x) = 0\n          totals_comparison(x) = 0\n        END DO\n\n        !$acc data copyin(a(1:LOOPCOUNT)) copy(totals(1:(LOOPCOUNT/10 + 1)))\n          !$acc parallel\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              !$acc atomic update\n                totals(MOD(x, LOOPCOUNT/10 + 1) + 1) = ieor(a(x), totals(MOD(x, LOOPCOUNT/10 + 1) + 1))\n              !$acc end atomic\n            END DO\n          !$acc end parallel\n        !$acc end data\n        DO x = 1, LOOPCOUNT\n          totals_comparison(MOD(x, LOOPCOUNT/10 + 1) + 1) = ieor(totals_comparison(MOD(x, LOOPCOUNT/10 + 1) + 1), a(x))\n        END DO\n        DO x = 1, LOOPCOUNT/10 + 1\n          IF (totals_comparison(x) .NE. totals(x)) THEN\n            errors = errors + 1\n            WRITE(*, *) totals_comparison(x)\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "construct-independent",
                            "atomic"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_update_ixor_x_expr.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:construct-independent,atomic,V:2.0-2.7\n      LOGICAL FUNCTION test1()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x, y !Iterators\n        INTEGER,DIMENSION(LOOPCOUNT):: a !Data\n        REAL(8),DIMENSION(LOOPCOUNT, 8):: randoms\n        INTEGER,DIMENSION(LOOPCOUNT/10 + 1):: totals, totals_comparison\n        INTEGER :: errors = 0\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(randoms)\n        a = 0\n        DO x = 1, LOOPCOUNT\n          DO y = 1, 8\n            IF (randoms(x, y) .lt. .5) THEN\n              a(x) = a(x) + ISHFT(1, y - 1)\n            END IF\n          END DO\n        END DO\n        totals = 0\n        totals_comparison = 0\n        DO x = 1, LOOPCOUNT/10 + 1\n          totals(x) = 0\n          totals_comparison(x) = 0\n        END DO\n\n        !$acc data copyin(a(1:LOOPCOUNT)) copy(totals(1:(LOOPCOUNT/10 + 1)))\n          !$acc parallel\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              !$acc atomic update\n                totals(MOD(x, LOOPCOUNT/10 + 1) + 1) = ieor(totals(MOD(x, LOOPCOUNT/10 + 1) + 1), a(x))\n            END DO\n          !$acc end parallel\n        !$acc end data\n        DO x = 1, LOOPCOUNT\n          totals_comparison(MOD(x, LOOPCOUNT/10 + 1) + 1) = ieor(totals_comparison(MOD(x, LOOPCOUNT/10 + 1) + 1), a(x))\n        END DO\n        DO x = 1, LOOPCOUNT/10 + 1\n          IF (totals_comparison(x) .NE. totals(x)) THEN\n            errors = errors + 1\n            WRITE(*, *) totals_comparison(x)\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "construct-independent",
                            "atomic"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_update_ixor_x_expr_end.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:construct-independent,atomic,V:2.0-2.7\n      LOGICAL FUNCTION test1()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x, y !Iterators\n        INTEGER,DIMENSION(LOOPCOUNT):: a !Data\n        REAL(8),DIMENSION(LOOPCOUNT, 8):: randoms\n        INTEGER,DIMENSION(LOOPCOUNT/10 + 1):: totals, totals_comparison\n        INTEGER :: errors = 0\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(randoms)\n        a = 0\n        DO x = 1, LOOPCOUNT\n          DO y = 1, 8\n            IF (randoms(x, y) .lt. .5) THEN\n              a(x) = a(x) + ISHFT(1, y - 1)\n            END IF\n          END DO\n        END DO\n        totals = 0\n        totals_comparison = 0\n        DO x = 1, LOOPCOUNT/10 + 1\n          totals(x) = 0\n          totals_comparison(x) = 0\n        END DO\n\n        !$acc data copyin(a(1:LOOPCOUNT)) copy(totals(1:(LOOPCOUNT/10 + 1)))\n          !$acc parallel\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              !$acc atomic update\n                totals(MOD(x, LOOPCOUNT/10 + 1) + 1) = ieor(totals(MOD(x, LOOPCOUNT/10 + 1) + 1), a(x))\n              !$acc end atomic\n            END DO\n          !$acc end parallel\n        !$acc end data\n        DO x = 1, LOOPCOUNT\n          totals_comparison(MOD(x, LOOPCOUNT/10 + 1) + 1) = ieor(totals_comparison(MOD(x, LOOPCOUNT/10 + 1) + 1), a(x))\n        END DO\n        DO x = 1, LOOPCOUNT/10 + 1\n          IF (totals_comparison(x) .NE. totals(x)) THEN\n            errors = errors + 1\n            WRITE(*, *) totals_comparison(x)\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "construct-independent",
                            "atomic"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_update_lshift_equals.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:atomic,construct-independent,V:2.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    unsigned int *a = (unsigned int *)malloc(n * sizeof(int));\n    unsigned int *b = (unsigned int *)malloc(n * sizeof(int));\n\n    for (int x = 0; x < n; ++x){\n        a[x] = 1;\n        for (int y = 0; y < 7; ++y){\n            if ((rand()/(unsigned int) (RAND_MAX)) > .5){\n                b[x] += 1<<y;\n            }\n        }\n    }\n\n    #pragma acc data copyin(b[0:n]) copy(a[0:n])\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                #pragma acc loop\n                for (int y = 0; y < 7; ++y){\n                    if ((b[x]>>y)%2 == 1){\n                        #pragma acc atomic update\n                            a[x] <<= 1;\n                    }\n                }\n            }\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        for (int y = 0; y < 7; ++y){\n            if ((b[x]>>y)%2 == 1){\n                a[x] >>= 1;\n            }\n        }\n        if (a[x] != 1){\n            err += 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "atomic",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_update_max_expr_list_x.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:construct-independent,atomic,V:2.0-2.7\n      LOGICAL FUNCTION test1()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x, y !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT):: a, b !Data\n        REAL(8),DIMENSION(LOOPCOUNT/10 + 1):: totals, totals_comparison\n        INTEGER :: errors = 0\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(a)\n        CALL RANDOM_NUMBER(b)\n\n        totals = 0\n        totals_comparison = 0\n\n        !$acc data copyin(a(1:LOOPCOUNT), b(1:LOOPCOUNT)) copy(totals(1:(LOOPCOUNT/10 + 1)))\n          !$acc parallel\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              !$acc atomic update\n                totals(MOD(x, LOOPCOUNT/10 + 1) + 1) = max(a(x), b(x), totals(MOD(x, LOOPCOUNT/10 + 1) + 1))\n            END DO\n          !$acc end parallel\n        !$acc end data\n        DO x = 1, LOOPCOUNT\n          totals_comparison(MOD(x, LOOPCOUNT/10 + 1) + 1) = max(totals_comparison(MOD(x, LOOPCOUNT/10 + 1) + 1), a(x), b(x))\n        END DO\n        DO x = 1, LOOPCOUNT/10 + 1\n          IF (totals_comparison(x) .NE. totals(x)) THEN\n            errors = errors + 1\n            WRITE(*, *) totals_comparison(x)\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "construct-independent",
                            "atomic"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_update_max_expr_list_x_end.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:construct-independent,atomic,V:2.0-2.7\n      LOGICAL FUNCTION test1()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x, y !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT):: a, b !Data\n        REAL(8),DIMENSION(LOOPCOUNT/10 + 1):: totals, totals_comparison\n        INTEGER :: errors = 0\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(a)\n        CALL RANDOM_NUMBER(b)\n\n        totals = 0\n        totals_comparison = 0\n\n        !$acc data copyin(a(1:LOOPCOUNT), b(1:LOOPCOUNT)) copy(totals(1:(LOOPCOUNT/10 + 1)))\n          !$acc parallel\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              !$acc atomic update\n                totals(MOD(x, LOOPCOUNT/10 + 1) + 1) = max(a(x), b(x), totals(MOD(x, LOOPCOUNT/10 + 1) + 1))\n              !$acc end atomic\n            END DO\n          !$acc end parallel\n        !$acc end data\n        DO x = 1, LOOPCOUNT\n          totals_comparison(MOD(x, LOOPCOUNT/10 + 1) + 1) = max(totals_comparison(MOD(x, LOOPCOUNT/10 + 1) + 1), a(x), b(x))\n        END DO\n        DO x = 1, LOOPCOUNT/10 + 1\n          IF (totals_comparison(x) .NE. totals(x)) THEN\n            errors = errors + 1\n            WRITE(*, *) totals_comparison(x)\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "construct-independent",
                            "atomic"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_update_max_expr_x.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:construct-independent,atomic,V:2.0-2.7\n      LOGICAL FUNCTION test1()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x, y !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT):: a !Data\n        REAL(8),DIMENSION(LOOPCOUNT/10 + 1):: totals, totals_comparison\n        INTEGER :: errors = 0\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(a)\n\n        totals = 0\n        totals_comparison = 0\n\n        !$acc data copyin(a(1:LOOPCOUNT)) copy(totals(1:(LOOPCOUNT/10 + 1)))\n          !$acc parallel\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              !$acc atomic update\n                totals(MOD(x, LOOPCOUNT/10 + 1) + 1) = max(a(x), totals(MOD(x, LOOPCOUNT/10 + 1) + 1))\n            END DO\n          !$acc end parallel\n        !$acc end data\n        DO x = 1, LOOPCOUNT\n          totals_comparison(MOD(x, LOOPCOUNT/10 + 1) + 1) = max(totals_comparison(MOD(x, LOOPCOUNT/10 + 1) + 1), a(x))\n        END DO\n        DO x = 1, LOOPCOUNT/10 + 1\n          IF (totals_comparison(x) .NE. totals(x)) THEN\n            errors = errors + 1\n            WRITE(*, *) totals_comparison(x)\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "construct-independent",
                            "atomic"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_update_max_expr_x_end.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:construct-independent,atomic,V:2.0-2.7\n      LOGICAL FUNCTION test1()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x, y !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT):: a !Data\n        REAL(8),DIMENSION(LOOPCOUNT/10 + 1):: totals, totals_comparison\n        INTEGER :: errors = 0\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(a)\n\n        totals = 0\n        totals_comparison = 0\n\n        !$acc data copyin(a(1:LOOPCOUNT)) copy(totals(1:(LOOPCOUNT/10 + 1)))\n          !$acc parallel\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              !$acc atomic update\n                totals(MOD(x, LOOPCOUNT/10 + 1) + 1) = max(a(x), totals(MOD(x, LOOPCOUNT/10 + 1) + 1))\n              !$acc end atomic\n            END DO\n          !$acc end parallel\n        !$acc end data\n        DO x = 1, LOOPCOUNT\n          totals_comparison(MOD(x, LOOPCOUNT/10 + 1) + 1) = max(totals_comparison(MOD(x, LOOPCOUNT/10 + 1) + 1), a(x))\n        END DO\n        DO x = 1, LOOPCOUNT/10 + 1\n          IF (totals_comparison(x) .NE. totals(x)) THEN\n            errors = errors + 1\n            WRITE(*, *) totals_comparison(x)\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "construct-independent",
                            "atomic"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_update_max_x_expr.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:construct-independent,atomic,V:2.0-2.7\n      LOGICAL FUNCTION test1()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x, y !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT):: a !Data\n        REAL(8),DIMENSION(LOOPCOUNT/10 + 1):: totals, totals_comparison\n        INTEGER :: errors = 0\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(a)\n\n        totals = 0\n        totals_comparison = 0\n\n        !$acc data copyin(a(1:LOOPCOUNT)) copy(totals(1:(LOOPCOUNT/10 + 1)))\n          !$acc parallel\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              !$acc atomic update\n                totals(MOD(x, LOOPCOUNT/10 + 1) + 1) = max(totals(MOD(x, LOOPCOUNT/10 + 1) + 1), a(x))\n            END DO\n          !$acc end parallel\n        !$acc end data\n        DO x = 1, LOOPCOUNT\n          totals_comparison(MOD(x, LOOPCOUNT/10 + 1) + 1) = max(totals_comparison(MOD(x, LOOPCOUNT/10 + 1) + 1), a(x))\n        END DO\n        DO x = 1, LOOPCOUNT/10 + 1\n          IF (totals_comparison(x) .NE. totals(x)) THEN\n            errors = errors + 1\n            WRITE(*, *) totals_comparison(x)\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "construct-independent",
                            "atomic"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_update_max_x_expr_end.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:construct-independent,atomic,V:2.0-2.7\n      LOGICAL FUNCTION test1()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x, y !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT):: a !Data\n        REAL(8),DIMENSION(LOOPCOUNT/10 + 1):: totals, totals_comparison\n        INTEGER :: errors = 0\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(a)\n\n        totals = 0\n        totals_comparison = 0\n\n        !$acc data copyin(a(1:LOOPCOUNT)) copy(totals(1:(LOOPCOUNT/10 + 1)))\n          !$acc parallel\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              !$acc atomic update\n                totals(MOD(x, LOOPCOUNT/10 + 1) + 1) = max(totals(MOD(x, LOOPCOUNT/10 + 1) + 1), a(x))\n              !$acc end atomic\n            END DO\n          !$acc end parallel\n        !$acc end data\n        DO x = 1, LOOPCOUNT\n          totals_comparison(MOD(x, LOOPCOUNT/10 + 1) + 1) = max(totals_comparison(MOD(x, LOOPCOUNT/10 + 1) + 1), a(x))\n        END DO\n        DO x = 1, LOOPCOUNT/10 + 1\n          IF (totals_comparison(x) .NE. totals(x)) THEN\n            errors = errors + 1\n            WRITE(*, *) totals_comparison(x)\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "construct-independent",
                            "atomic"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_update_max_x_expr_list.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:construct-independent,atomic,V:2.0-2.7\n      LOGICAL FUNCTION test1()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x, y !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT):: a, b !Data\n        REAL(8),DIMENSION(LOOPCOUNT/10 + 1):: totals, totals_comparison\n        INTEGER :: errors = 0\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(a)\n        CALL RANDOM_NUMBER(b)\n\n        totals = 0\n        totals_comparison = 0\n\n        !$acc data copyin(a(1:LOOPCOUNT), b(1:LOOPCOUNT)) copy(totals(1:(LOOPCOUNT/10 + 1)))\n          !$acc parallel\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              !$acc atomic update\n                totals(MOD(x, LOOPCOUNT/10 + 1) + 1) = max(totals(MOD(x, LOOPCOUNT/10 + 1) + 1), a(x), b(x))\n            END DO\n          !$acc end parallel\n        !$acc end data\n        DO x = 1, LOOPCOUNT\n          totals_comparison(MOD(x, LOOPCOUNT/10 + 1) + 1) = max(totals_comparison(MOD(x, LOOPCOUNT/10 + 1) + 1), a(x), b(x))\n        END DO\n        DO x = 1, LOOPCOUNT/10 + 1\n          IF (totals_comparison(x) .NE. totals(x)) THEN\n            errors = errors + 1\n            WRITE(*, *) totals_comparison(x)\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "construct-independent",
                            "atomic"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_update_max_x_expr_list_end.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:construct-independent,atomic,V:2.0-2.7\n      LOGICAL FUNCTION test1()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x, y !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT):: a, b !Data\n        REAL(8),DIMENSION(LOOPCOUNT/10 + 1):: totals, totals_comparison\n        INTEGER :: errors = 0\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(a)\n        CALL RANDOM_NUMBER(b)\n\n        totals = 0\n        totals_comparison = 0\n\n        !$acc data copyin(a(1:LOOPCOUNT), b(1:LOOPCOUNT)) copy(totals(1:(LOOPCOUNT/10 + 1)))\n          !$acc parallel\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              !$acc atomic update\n                totals(MOD(x, LOOPCOUNT/10 + 1) + 1) = max(totals(MOD(x, LOOPCOUNT/10 + 1) + 1), a(x), b(x))\n              !$acc end atomic\n            END DO\n          !$acc end parallel\n        !$acc end data\n        DO x = 1, LOOPCOUNT\n          totals_comparison(MOD(x, LOOPCOUNT/10 + 1) + 1) = max(totals_comparison(MOD(x, LOOPCOUNT/10 + 1) + 1), a(x), b(x))\n        END DO\n        DO x = 1, LOOPCOUNT/10 + 1\n          IF (totals_comparison(x) .NE. totals(x)) THEN\n            errors = errors + 1\n            WRITE(*, *) totals_comparison(x)\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "construct-independent",
                            "atomic"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_update_min_expr_list_x.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:construct-independent,atomic,V:2.0-2.7\n      LOGICAL FUNCTION test1()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x, y !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT):: a, b !Data\n        REAL(8),DIMENSION(LOOPCOUNT/10 + 1):: totals, totals_comparison\n        INTEGER :: errors = 0\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(a)\n        CALL RANDOM_NUMBER(b)\n\n        totals = 1\n        totals_comparison = 1\n\n        !$acc data copyin(a(1:LOOPCOUNT), b(1:LOOPCOUNT)) copy(totals(1:(LOOPCOUNT/10 + 1)))\n          !$acc parallel\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              !$acc atomic update\n                totals(MOD(x, LOOPCOUNT/10 + 1) + 1) = min(a(x), b(x), totals(MOD(x, LOOPCOUNT/10 + 1) + 1))\n            END DO\n          !$acc end parallel\n        !$acc end data\n        DO x = 1, LOOPCOUNT\n          totals_comparison(MOD(x, LOOPCOUNT/10 + 1) + 1) = min(totals_comparison(MOD(x, LOOPCOUNT/10 + 1) + 1), a(x), b(x))\n        END DO\n        DO x = 1, LOOPCOUNT/10 + 1\n          IF (totals_comparison(x) .NE. totals(x)) THEN\n            errors = errors + 1\n            WRITE(*, *) totals_comparison(x)\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "construct-independent",
                            "atomic"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_update_min_expr_list_x_end.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:construct-independent,atomic,V:2.0-2.7\n      LOGICAL FUNCTION test1()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x, y !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT):: a, b !Data\n        REAL(8),DIMENSION(LOOPCOUNT/10 + 1):: totals, totals_comparison\n        INTEGER :: errors = 0\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(a)\n        CALL RANDOM_NUMBER(b)\n\n        totals = 1\n        totals_comparison = 1\n\n        !$acc data copyin(a(1:LOOPCOUNT), b(1:LOOPCOUNT)) copy(totals(1:(LOOPCOUNT/10 + 1)))\n          !$acc parallel\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              !$acc atomic update\n                totals(MOD(x, LOOPCOUNT/10 + 1) + 1) = min(a(x), b(x), totals(MOD(x, LOOPCOUNT/10 + 1) + 1))\n              !$acc end atomic\n            END DO\n          !$acc end parallel\n        !$acc end data\n        DO x = 1, LOOPCOUNT\n          totals_comparison(MOD(x, LOOPCOUNT/10 + 1) + 1) = min(totals_comparison(MOD(x, LOOPCOUNT/10 + 1) + 1), a(x), b(x))\n        END DO\n        DO x = 1, LOOPCOUNT/10 + 1\n          IF (totals_comparison(x) .NE. totals(x)) THEN\n            errors = errors + 1\n            WRITE(*, *) totals_comparison(x)\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "construct-independent",
                            "atomic"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_update_min_expr_x.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:construct-independent,atomic,V:2.0-2.7\n      LOGICAL FUNCTION test1()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x, y !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT):: a !Data\n        REAL(8),DIMENSION(LOOPCOUNT/10 + 1):: totals, totals_comparison\n        INTEGER :: errors = 0\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(a)\n\n        totals = 1\n        totals_comparison = 1\n\n        !$acc data copyin(a(1:LOOPCOUNT)) copy(totals(1:(LOOPCOUNT/10 + 1)))\n          !$acc parallel\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              !$acc atomic update\n                totals(MOD(x, LOOPCOUNT/10 + 1) + 1) = min(a(x), totals(MOD(x, LOOPCOUNT/10 + 1) + 1))\n            END DO\n          !$acc end parallel\n        !$acc end data\n        DO x = 1, LOOPCOUNT\n          totals_comparison(MOD(x, LOOPCOUNT/10 + 1) + 1) = min(totals_comparison(MOD(x, LOOPCOUNT/10 + 1) + 1), a(x))\n        END DO\n        DO x = 1, LOOPCOUNT/10 + 1\n          IF (totals_comparison(x) .NE. totals(x)) THEN\n            errors = errors + 1\n            WRITE(*, *) totals_comparison(x)\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "construct-independent",
                            "atomic"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_update_min_expr_x_end.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:construct-independent,atomic,V:2.0-2.7\n      LOGICAL FUNCTION test1()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x, y !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT):: a !Data\n        REAL(8),DIMENSION(LOOPCOUNT/10 + 1):: totals, totals_comparison\n        INTEGER :: errors = 0\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(a)\n\n        totals = 1\n        totals_comparison = 1\n\n        !$acc data copyin(a(1:LOOPCOUNT)) copy(totals(1:(LOOPCOUNT/10 + 1)))\n          !$acc parallel\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              !$acc atomic update\n                totals(MOD(x, LOOPCOUNT/10 + 1) + 1) = min(a(x), totals(MOD(x, LOOPCOUNT/10 + 1) + 1))\n              !$acc end atomic\n            END DO\n          !$acc end parallel\n        !$acc end data\n        DO x = 1, LOOPCOUNT\n          totals_comparison(MOD(x, LOOPCOUNT/10 + 1) + 1) = min(totals_comparison(MOD(x, LOOPCOUNT/10 + 1) + 1), a(x))\n        END DO\n        DO x = 1, LOOPCOUNT/10 + 1\n          IF (totals_comparison(x) .NE. totals(x)) THEN\n            errors = errors + 1\n            WRITE(*, *) totals_comparison(x)\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "construct-independent",
                            "atomic"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_update_min_x_expr.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:construct-independent,atomic,V:2.0-2.7\n      LOGICAL FUNCTION test1()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x, y !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT):: a !Data\n        REAL(8),DIMENSION(LOOPCOUNT/10 + 1):: totals, totals_comparison\n        INTEGER :: errors = 0\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(a)\n\n        totals = 0\n        totals_comparison = 0\n\n        !$acc data copyin(a(1:LOOPCOUNT)) copy(totals(1:(LOOPCOUNT/10 + 1)))\n          !$acc parallel\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              !$acc atomic update\n                totals(MOD(x, LOOPCOUNT/10 + 1) + 1) = min(totals(MOD(x, LOOPCOUNT/10 + 1) + 1), a(x))\n            END DO\n          !$acc end parallel\n        !$acc end data\n        DO x = 1, LOOPCOUNT\n          totals_comparison(MOD(x, LOOPCOUNT/10 + 1) + 1) = min(totals_comparison(MOD(x, LOOPCOUNT/10 + 1) + 1), a(x))\n        END DO\n        DO x = 1, LOOPCOUNT/10 + 1\n          IF (totals_comparison(x) .NE. totals(x)) THEN\n            errors = errors + 1\n            WRITE(*, *) totals_comparison(x)\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "construct-independent",
                            "atomic"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_update_min_x_expr_end.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:construct-independent,atomic,V:2.0-2.7\n      LOGICAL FUNCTION test1()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x, y !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT):: a !Data\n        REAL(8),DIMENSION(LOOPCOUNT/10 + 1):: totals, totals_comparison\n        INTEGER :: errors = 0\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(a)\n\n        totals = 0\n        totals_comparison = 0\n\n        !$acc data copyin(a(1:LOOPCOUNT)) copy(totals(1:(LOOPCOUNT/10 + 1)))\n          !$acc parallel\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              !$acc atomic update\n                totals(MOD(x, LOOPCOUNT/10 + 1) + 1) = min(totals(MOD(x, LOOPCOUNT/10 + 1) + 1), a(x))\n              !$acc end atomic\n            END DO\n          !$acc end parallel\n        !$acc end data\n        DO x = 1, LOOPCOUNT\n          totals_comparison(MOD(x, LOOPCOUNT/10 + 1) + 1) = min(totals_comparison(MOD(x, LOOPCOUNT/10 + 1) + 1), a(x))\n        END DO\n        DO x = 1, LOOPCOUNT/10 + 1\n          IF (totals_comparison(x) .NE. totals(x)) THEN\n            errors = errors + 1\n            WRITE(*, *) totals_comparison(x)\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "construct-independent",
                            "atomic"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_update_min_x_expr_list.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:construct-independent,atomic,V:2.0-2.7\n      LOGICAL FUNCTION test1()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x, y !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT):: a, b !Data\n        REAL(8),DIMENSION(LOOPCOUNT/10 + 1):: totals, totals_comparison\n        INTEGER :: errors = 0\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(a)\n        CALL RANDOM_NUMBER(b)\n\n        totals = 1\n        totals_comparison = 1\n\n        !$acc data copyin(a(1:LOOPCOUNT), b(1:LOOPCOUNT)) copy(totals(1:(LOOPCOUNT/10 + 1)))\n          !$acc parallel\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              !$acc atomic update\n                totals(MOD(x, LOOPCOUNT/10 + 1) + 1) = min(totals(MOD(x, LOOPCOUNT/10 + 1) + 1), a(x), b(x))\n            END DO\n          !$acc end parallel\n        !$acc end data\n        DO x = 1, LOOPCOUNT\n          totals_comparison(MOD(x, LOOPCOUNT/10 + 1) + 1) = min(totals_comparison(MOD(x, LOOPCOUNT/10 + 1) + 1), a(x), b(x))\n        END DO\n        DO x = 1, LOOPCOUNT/10 + 1\n          IF (totals_comparison(x) .NE. totals(x)) THEN\n            errors = errors + 1\n            WRITE(*, *) totals_comparison(x)\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "construct-independent",
                            "atomic"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_update_min_x_expr_list_end.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:construct-independent,atomic,V:2.0-2.7\n      LOGICAL FUNCTION test1()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x, y !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT):: a, b !Data\n        REAL(8),DIMENSION(LOOPCOUNT/10 + 1):: totals, totals_comparison\n        INTEGER :: errors = 0\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(a)\n        CALL RANDOM_NUMBER(b)\n\n        totals = 1\n        totals_comparison = 1\n\n        !$acc data copyin(a(1:LOOPCOUNT), b(1:LOOPCOUNT)) copy(totals(1:(LOOPCOUNT/10 + 1)))\n          !$acc parallel\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              !$acc atomic update\n                totals(MOD(x, LOOPCOUNT/10 + 1) + 1) = min(totals(MOD(x, LOOPCOUNT/10 + 1) + 1), a(x), b(x))\n              !$acc end atomic\n            END DO\n          !$acc end parallel\n        !$acc end data\n        DO x = 1, LOOPCOUNT\n          totals_comparison(MOD(x, LOOPCOUNT/10 + 1) + 1) = min(totals_comparison(MOD(x, LOOPCOUNT/10 + 1) + 1), a(x), b(x))\n        END DO\n        DO x = 1, LOOPCOUNT/10 + 1\n          IF (totals_comparison(x) .NE. totals(x)) THEN\n            errors = errors + 1\n            WRITE(*, *) totals_comparison(x)\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "construct-independent",
                            "atomic"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_update_minus_equals.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:atomic,construct-independent,V:2.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t *a = (real_t *)malloc(n * sizeof(real_t));\n    real_t *b = (real_t *)malloc(n * sizeof(real_t));\n    real_t *totals = (real_t *)malloc(10 * sizeof(real_t));\n    real_t *totals_host = (real_t *)malloc(10 * sizeof(real_t));\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n    }\n    for (int x = 0; x < 10; ++x){\n        totals[x] = 0;\n    }\n\n    #pragma acc data copyin(a[0:n], b[0:n]) copy(totals[0:10])\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                #pragma acc atomic update\n                    totals[x%10] -= (a[x] + b[x]);\n            }\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        totals_host[x%10] = totals_host[x%10] - (a[x] + b[x]);\n    }\n    for (int x = 0; x < 10; ++x){\n        if (fabs(totals_host[x] - totals[x]) > PRECISION){\n            err += 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "atomic",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_update_multiply_equals.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:atomic,construct-independent,V:2.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t *a = (real_t *)malloc(n * sizeof(real_t));\n    real_t *b = (real_t *)malloc(n * sizeof(real_t));\n    real_t *totals = (real_t *)malloc((n/10 + 1) * sizeof(real_t));\n    real_t *totals_comparison = (real_t *)malloc((n/10 + 1) * sizeof(real_t));\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n    }\n    for (int x = 0; x < n/10 + 1; ++x){\n        totals[x] = 1;\n        totals_comparison[x] = 1;\n    }\n\n    #pragma acc data copyin(a[0:n], b[0:n]) copy(totals[0:n/10 + 1])\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                #pragma acc atomic update\n                    totals[x%(n/10 + 1)] *= a[x] + b[x];\n            }\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        totals_comparison[x%(n/10 + 1)] *= a[x] + b[x];\n    }\n    for (int x = 0; x < 10; ++x){\n        if (fabs(totals_comparison[x] - totals[x]) > PRECISION * totals_comparison[x]){\n            err += 1;\n            break;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "atomic",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_update_plus_equals.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:atomic,construct-independent,V:2.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t *a = (real_t *)malloc(n * sizeof(real_t));\n    real_t *b = (real_t *)malloc(n * sizeof(real_t));\n    real_t *totals = (real_t *)malloc((n/10 + 1) * sizeof(real_t));\n    real_t *totals_comparison = (real_t *)malloc((n/10 + 1) * sizeof(real_t));\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n    }\n    for (int x = 0; x < n/10 + 1; ++x){\n        totals[x] = 0;\n        totals_comparison[x] = 0;\n    }\n\n    #pragma acc data copyin(a[0:n], b[0:n]) copy(totals[0:n/10 + 1])\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                #pragma acc atomic update\n                    totals[x%(n/10 + 1)] += a[x] * b[x];\n            }\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        totals_comparison[x%(n/10 + 1)] += a[x] * b[x];\n    }\n    for (int x = 0; x < n/10 + 1; ++x){\n        if (fabs(totals_comparison[x] - totals[x]) > (n/10 + 1) * PRECISION){\n            err += 1;\n            break;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "atomic",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_update_postdecrement.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:atomic,construct-independent,V:2.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t *a = (real_t *)malloc(n * sizeof(real_t));\n    real_t *b = (real_t *)malloc(n * sizeof(real_t));\n    int *distribution = (int *)malloc(10 * sizeof(int));\n    int *distribution_comparison = (int *)malloc(10 * sizeof(int));\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n    }\n    for (int x = 0; x < 10; ++x){\n        distribution[x] = 0;\n        distribution_comparison[x] = 0;\n    }\n\n    #pragma acc data copyin(a[0:n], b[0:n]) copy(distribution[0:10])\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                #pragma acc atomic update\n                    distribution[(int) (a[x] * b[x] / 10)]--;\n            }\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        distribution_comparison[(int) (a[x]*b[x]/10)]--;\n    }\n    for (int x = 0; x < 10; ++x){\n        if (distribution_comparison[x] != distribution[x]){\n            err += 1;\n            break;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "atomic",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_update_postincrement.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:atomic,construct-independent,V:2.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t *a = (real_t *)malloc(n * sizeof(real_t));\n    real_t *b = (real_t *)malloc(n * sizeof(real_t));\n    int *distribution = (int *)malloc(10 * sizeof(int));\n    int *distribution_comparison = (int *)malloc(10 * sizeof(int));\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n    }\n    for (int x = 0; x < 10; ++x){\n        distribution[x] = 0;\n        distribution_comparison[x] = 0;\n    }\n\n    #pragma acc data copyin(a[0:n], b[0:n]) copy(distribution[0:10])\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                #pragma acc loop\n                for (int y = 0; y < n; ++y){\n                    #pragma acc atomic update\n                        distribution[(int) (a[x]*b[y]/10)]++;\n                }\n            }\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        for (int y = 0; y < n; ++y){\n            distribution_comparison[(int) (a[x]*b[y]/10)]++;\n        }\n    }\n    for (int x = 0; x < 10; ++x){\n        if (distribution_comparison[x] != distribution[x]){\n            err += 1;\n            break;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "atomic",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_update_predecrement.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:atomic,construct-independent,V:2.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t *a = (real_t *)malloc(n * sizeof(real_t));\n    real_t *b = (real_t *)malloc(n * sizeof(real_t));\n    int *distribution = (int *)malloc(10 * sizeof(int));\n    int *distribution_comparison = (int *)malloc(10 * sizeof(int));\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n    }\n    for (int x = 0; x < 10; ++x){\n        distribution[x] = 0;\n        distribution_comparison[x] = 0;\n    }\n\n    #pragma acc data copyin(a[0:n], b[0:n]) copy(distribution[0:10])\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                #pragma acc loop\n                for (int y = 0; y < n; ++y){\n                    #pragma acc atomic update\n                        --distribution[(int) (a[x]*b[y]/10)];\n                }\n            }\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        for (int y = 0; y < n; ++y){\n            distribution_comparison[(int) (a[x]*b[y]/10)]--;\n        }\n    }\n    for (int x = 0; x < 10; ++x){\n        if (distribution_comparison[x] != distribution[x]){\n            err += 1;\n            break;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "atomic",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_update_preincrement.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:atomic,construct-independent,V:2.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t *a = (real_t *)malloc(n * sizeof(real_t));\n    real_t *b = (real_t *)malloc(n * sizeof(real_t));\n    int *distribution = (int *)malloc(10 * sizeof(int));\n    int *distribution_comparison = (int *)malloc(10 * sizeof(int));\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n    }\n    for (int x = 0; x < 10; ++x){\n        distribution[x] = 0;\n        distribution_comparison[x] = 0;\n    }\n\n    #pragma acc data copyin(a[0:n], b[0:n]) copy(distribution[0:10])\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                #pragma acc loop\n                for (int y = 0; y < n; ++y){\n                    #pragma acc atomic update\n                        ++distribution[(int) (a[x]*b[y]/10)];\n                }\n            }\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        for (int y = 0; y < n; ++y){\n            distribution_comparison[(int) (a[x]*b[y]/10)]++;\n        }\n    }\n    for (int x = 0; x < 10; ++x){\n        if (distribution_comparison[x] != distribution[x]){\n            err += 1;\n            break;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "atomic",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_update_rshift_equals.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:atomic,construct-independent,V:2.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    unsigned int *a = (unsigned int *)malloc(n * sizeof(int));\n    unsigned int *b = (unsigned int *)malloc(n * sizeof(int));\n\n    for (int x = 0; x < n; ++x){\n        a[x] = 1<<7;\n        for (int y = 0; y < 7; ++y){\n            if ((rand()/(unsigned int) (RAND_MAX)) > .5){\n                b[x] += 1<<y;\n            }\n        }\n    }\n\n    #pragma acc data copyin(b[0:n]) copy(a[0:n])\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                #pragma acc loop\n                for (int y = 0; y < 7; ++y){\n                    if ((b[x]>>y)%2 == 1){\n                        #pragma acc atomic update\n                            a[x] >>= 1;\n                    }\n                }\n            }\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        for (int y = 0; y < 7; ++y){\n            if ((b[x]>>y)%2 == 1){\n                a[x] <<= 1;\n            }\n        }\n        if (a[x] != 1<<7){\n            err += 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "atomic",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_update_x_and_expr.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:construct-independent,atomic,V:2.0-2.7\n      LOGICAL FUNCTION test1()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x, y !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT, 10):: randoms\n        LOGICAL,DIMENSION(LOOPCOUNT, 10):: a !Data\n        LOGICAL,DIMENSION(LOOPCOUNT):: totals, totals_comparison\n        INTEGER :: errors = 0\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(randoms)\n        DO x = 1, LOOPCOUNT\n          DO y = 1, 10\n            IF (randoms(x, y) < .933) THEN\n              a(x, y) = .TRUE.\n            ELSE\n              a(x, y) = .FALSE.\n            END IF\n          END DO\n        END DO\n\n        totals = .FALSE.\n        totals_comparison = .FALSE.\n\n        !$acc data copyin(a(1:LOOPCOUNT,1:10)) copy(totals(1:LOOPCOUNT))\n          !$acc parallel\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              DO y = 1, 10\n                !$acc atomic update\n                  totals(x) = totals(x) .AND. a(x, y)\n              END DO\n            END DO\n          !$acc end parallel\n        !$acc end data\n\n        DO x = 1, LOOPCOUNT\n          DO y = 1, 10\n            totals_comparison(x) = totals_comparison(x) .AND. a(x, y)\n          END DO\n        END DO\n\n        DO x = 1, LOOPCOUNT\n          IF (totals_comparison(x) .NEQV. totals(x)) THEN\n            errors = errors + 1\n            WRITE(*, *) totals_comparison(x)\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "construct-independent",
                            "atomic"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_update_x_and_expr_end.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:construct-independent,atomic,V:2.0-2.7\n      LOGICAL FUNCTION test1()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x, y !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT, 10):: randoms\n        LOGICAL,DIMENSION(LOOPCOUNT, 10):: a !Data\n        LOGICAL,DIMENSION(LOOPCOUNT):: totals, totals_comparison\n        INTEGER :: errors = 0\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(randoms)\n        DO x = 1, LOOPCOUNT\n          DO y = 1, 10\n            IF (randoms(x, y) < .933) THEN\n              a(x, y) = .TRUE.\n            ELSE\n              a(x, y) = .FALSE.\n            END IF\n          END DO\n        END DO\n\n        totals = .FALSE.\n        totals_comparison = .FALSE.\n\n        !$acc data copyin(a(1:LOOPCOUNT,1:10)) copy(totals(1:LOOPCOUNT))\n          !$acc parallel\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              DO y = 1, 10\n                !$acc atomic update\n                  totals(x) = totals(x) .AND. a(x, y)\n                !$acc end atomic\n              END DO\n            END DO\n          !$acc end parallel\n        !$acc end data\n\n        DO x = 1, LOOPCOUNT\n          DO y = 1, 10\n            totals_comparison(x) = totals_comparison(x) .AND. a(x, y)\n          END DO\n        END DO\n\n        DO x = 1, LOOPCOUNT\n          IF (totals_comparison(x) .NEQV. totals(x)) THEN\n            errors = errors + 1\n            WRITE(*, *) totals_comparison(x)\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "construct-independent",
                            "atomic"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_update_x_bitand_expr.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:atomic,construct-independent,V:2.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    int  *a = (int *)malloc(n * sizeof(int));\n    int *totals = (int *)malloc((n/10 + 1) * sizeof(int));\n    int *totals_comparison = (int *)malloc((n/10 + 1) * sizeof(int));\n\n    for (int x = 0; x < n; ++x){\n        for (int y = 0; y < 8; ++y){\n            if (rand()/(real_t)(RAND_MAX) < .933){ //.933 gets close to a 50/50 distribution for a collescence of 10 values\n                a[x] += 1<<y;\n            }\n        }\n    }\n    for (int x = 0; x < n/10 + 1; ++x){\n        for (int y = 0; y < 8; ++y){\n            totals[x] +=  1<<y;\n            totals_comparison[x] += 1<<y;\n        }\n    }\n\n    #pragma acc data copyin(a[0:n]) copy(totals[0:n/10 + 1])\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                #pragma acc atomic update\n                    totals[x%(n/10 + 1)] = totals[x%(n/10 + 1)] & a[x];\n            }\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        totals_comparison[x%(n/10 + 1)] &= a[x];\n    }\n    for (int x = 0; x < 10; ++x){\n        if (fabs(totals_comparison[x] - totals[x]) > PRECISION){\n            err += 1;\n            break;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "atomic",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_update_x_bitor_expr.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:atomic,construct-independent,V:2.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    int  *a = (int *)malloc(n * sizeof(int));\n    int *totals = (int *)malloc((n/10 + 1) * sizeof(int));\n    int *totals_comparison = (int *)malloc((n/10 + 1) * sizeof(int));\n\n    for (int x = 0; x < n; ++x){\n        for (int y = 0; y < 8; ++y){\n            if (rand()/(real_t)(RAND_MAX) > .933){ //.933 gets close to a 50/50 distribution for a collescence of 10 values\n                a[x] += 1<<y;\n            }\n        }\n    }\n    for (int x = 0; x < n/10 + 1; ++x){\n        totals[x] = 0;\n\n    }\n\n    #pragma acc data copyin(a[0:n]) copy(totals[0:n/10 + 1])\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                #pragma acc atomic update\n                    totals[x%(n/10 + 1)] = totals[x%(n/10 + 1)] | a[x];\n            }\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        totals_comparison[x%(n/10 + 1)] |= a[x];\n    }\n    for (int x = 0; x < 10; ++x){\n        if (fabs(totals_comparison[x] - totals[x]) > PRECISION){\n            err += 1;\n            break;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "atomic",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_update_x_bitxor_expr.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:atomic,construct-independent,V:2.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    int  *a = (int *)malloc(n * sizeof(int));\n    int *totals = (int *)malloc((n/10 + 1) * sizeof(int));\n    int *totals_comparison = (int *)malloc((n/10 + 1) * sizeof(int));\n\n    for (int x = 0; x < n; ++x){\n        for (int y = 0; y < 8; ++y){\n            if (rand()/(real_t)(RAND_MAX) > .5){\n                a[x] += 1<<y;\n            }\n        }\n    }\n    for (int x = 0; x < n/10 + 1; ++x){\n        totals[x] = 0;\n        totals_comparison[x] = 0;\n    }\n\n    #pragma acc data copyin(a[0:n]) copy(totals[0:n/10 + 1])\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                #pragma acc atomic update\n                    totals[x%(n/10 + 1)] =  totals[x%(n/10 + 1)] ^ a[x];\n            }\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        totals_comparison[x%(n/10 + 1)] ^= a[x];\n    }\n    for (int x = 0; x < n/10 + 1; ++x){\n        if (fabs(totals_comparison[x] - totals[x]) > PRECISION){\n            err += 1;\n            break;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "atomic",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_update_x_divided_expr.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:construct-independent,atomic,V:2.0-2.7\n      LOGICAL FUNCTION test1()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x, y !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT, 10):: a !Data\n        REAL(8),DIMENSION(LOOPCOUNT):: totals, totals_comparison\n        INTEGER :: errors = 0\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(a)\n\n        totals = 1\n        totals_comparison = 1\n\n        !$acc data copyin(a(1:LOOPCOUNT, 1:10)) copy(totals(1:LOOPCOUNT))\n          !$acc parallel\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              DO y = 1, 10\n                !$acc atomic update\n                  totals(x) = totals(x) / a(x, y)\n              END DO\n            END DO\n          !$acc end parallel\n        !$acc end data\n        DO x = 1, LOOPCOUNT\n          DO y = 1, 10\n            totals_comparison(x) = totals_comparison(x) / a(x, y)\n          END DO\n        END DO\n\n        DO x = 1, LOOPCOUNT\n          IF (totals_comparison(x) .NE. totals(x)) THEN\n            errors = errors + 1\n            WRITE(*, *) totals_comparison(x)\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "construct-independent",
                            "atomic"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_update_x_divided_expr.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:atomic,construct-independent,V:2.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t *a = (real_t *)malloc(n * sizeof(real_t));\n    real_t *b = (real_t *)malloc(n * sizeof(real_t));\n    real_t *totals = (real_t *)malloc((n/10 + 1) * sizeof(real_t));\n    real_t *totals_comparison = (real_t *)malloc((n/10 + 1) * sizeof(real_t));\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n    }\n    for (int x = 0; x < n/10 + 1; ++x){\n        totals[x] = 1;\n        totals_comparison[x] = 1;\n    }\n\n    #pragma acc data copyin(a[0:n], b[0:n]) copy(totals[0:n/10 + 1])\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                #pragma acc atomic update\n                    totals[x%(n/10 + 1)] = totals[x%(n/10 + 1)] / (a[x] + b[x]);\n            }\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        totals_comparison[x%(n/10 + 1)] /= a[x] + b[x];\n    }\n    for (int x = 0; x < 10; ++x){\n        if (fabs(totals_comparison[x] - totals[x]) > PRECISION){\n            err += 1;\n            break;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "atomic",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_update_x_divided_expr_end.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:construct-independent,atomic,V:2.0-2.7\n      LOGICAL FUNCTION test1()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x, y !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT, 10):: a !Data\n        REAL(8),DIMENSION(LOOPCOUNT):: totals, totals_comparison\n        INTEGER :: errors = 0\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(a)\n\n        totals = 1\n        totals_comparison = 1\n\n        !$acc data copyin(a(1:LOOPCOUNT, 1:10)) copy(totals(1:LOOPCOUNT))\n          !$acc parallel\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              DO y = 1, 10\n                !$acc atomic update\n                  totals(x) = totals(x) / a(x, y)\n                !$acc end atomic\n              END DO\n            END DO\n          !$acc end parallel\n        !$acc end data\n        DO x = 1, LOOPCOUNT\n          DO y = 1, 10\n            totals_comparison(x) = totals_comparison(x) / a(x, y)\n          END DO\n        END DO\n\n        DO x = 1, LOOPCOUNT\n          IF (totals_comparison(x) .NE. totals(x)) THEN\n            errors = errors + 1\n            WRITE(*, *) totals_comparison(x)\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "construct-independent",
                            "atomic"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_update_x_eqv_expr.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:construct-independent,atomic,V:2.0-2.7\n      LOGICAL FUNCTION test1()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x, y !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT, 10):: randoms\n        LOGICAL,DIMENSION(LOOPCOUNT, 10):: a !Data\n        LOGICAL,DIMENSION(LOOPCOUNT):: totals, totals_comparison\n        INTEGER :: errors = 0\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(randoms)\n        DO x = 1, LOOPCOUNT\n          DO y = 1, 10\n            IF (randoms(x, y) > .5) THEN\n              a(x, y) = .TRUE.\n            ELSE\n              a(x, y) = .FALSE.\n            END IF\n          END DO\n        END DO\n\n        totals = .FALSE.\n        totals_comparison = .FALSE.\n\n        !$acc data copyin(a(1:LOOPCOUNT,1:10)) copy(totals(1:LOOPCOUNT))\n          !$acc parallel\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              DO y = 1, 10\n                !$acc atomic update\n                  totals(x) = totals(x) .EQV. a(x, y)\n              END DO\n            END DO\n          !$acc end parallel\n        !$acc end data\n\n        DO x = 1, LOOPCOUNT\n          DO y = 1, 10\n            totals_comparison(x) = totals_comparison(x) .EQV. a(x, y)\n          END DO\n        END DO\n\n        DO x = 1, LOOPCOUNT\n          IF (totals_comparison(x) .NEQV. totals(x)) THEN\n            errors = errors + 1\n            WRITE(*, *) totals_comparison(x)\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "construct-independent",
                            "atomic"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_update_x_eqv_expr_end.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:construct-independent,atomic,V:2.0-2.7\n      LOGICAL FUNCTION test1()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x, y !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT, 10):: randoms\n        LOGICAL,DIMENSION(LOOPCOUNT, 10):: a !Data\n        LOGICAL,DIMENSION(LOOPCOUNT):: totals, totals_comparison\n        INTEGER :: errors = 0\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(randoms)\n        DO x = 1, LOOPCOUNT\n          DO y = 1, 10\n            IF (randoms(x, y) > .5) THEN\n              a(x, y) = .TRUE.\n            ELSE\n              a(x, y) = .FALSE.\n            END IF\n          END DO\n        END DO\n\n        totals = .FALSE.\n        totals_comparison = .FALSE.\n\n        !$acc data copyin(a(1:LOOPCOUNT,1:10)) copy(totals(1:LOOPCOUNT))\n          !$acc parallel\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              DO y = 1, 10\n                !$acc atomic update\n                  totals(x) = totals(x) .EQV. a(x, y)\n                !$acc end atomic\n              END DO\n            END DO\n          !$acc end parallel\n        !$acc end data\n\n        DO x = 1, LOOPCOUNT\n          DO y = 1, 10\n            totals_comparison(x) = totals_comparison(x) .EQV. a(x, y)\n          END DO\n        END DO\n\n        DO x = 1, LOOPCOUNT\n          IF (totals_comparison(x) .NEQV. totals(x)) THEN\n            errors = errors + 1\n            WRITE(*, *) totals_comparison(x)\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "construct-independent",
                            "atomic"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_update_x_lshift_expr.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:atomic,construct-independent,V:2.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    unsigned int *a = (unsigned int *)malloc(n * sizeof(int));\n    unsigned int *b = (unsigned int *)malloc(n * sizeof(int));\n\n    for (int x = 0; x < n; ++x){\n        a[x] = 1;\n        for (int y = 0; y < 7; ++y){\n            if ((rand()/(unsigned int) (RAND_MAX)) > .5){\n                b[x] += 1<<y;\n            }\n        }\n    }\n\n    #pragma acc data copyin(b[0:n]) copy(a[0:n])\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                #pragma acc loop\n                for (int y = 0; y < 7; ++y){\n                    if ((b[x]>>y)%2 == 1){\n                        #pragma acc atomic update\n                            a[x] = a[x] << 1;\n                    }\n                }\n            }\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        for (int y = 0; y < 7; ++y){\n            if ((b[x]>>y)%2 == 1){\n                a[x] >>= 1;\n            }\n        }\n        if (a[x] != 1){\n            err += 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "atomic",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_update_x_minus_expr.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:construct-independent,atomic,V:2.0-2.7\n      LOGICAL FUNCTION test1()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x, y !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT, 10):: a !Data\n        REAL(8),DIMENSION(LOOPCOUNT):: totals, totals_comparison\n        INTEGER :: errors = 0\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(a)\n\n        totals = 0\n        totals_comparison = 0\n\n        !$acc data copyin(a(1:LOOPCOUNT, 1:10)) copy(totals(1:LOOPCOUNT))\n          !$acc parallel\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              DO y = 1, 10\n                !$acc atomic update\n                  totals(x) = totals(x) - a(x, y)\n              END DO\n            END DO\n          !$acc end parallel\n        !$acc end data\n        DO x = 1, LOOPCOUNT\n          DO y = 1, 10\n            totals_comparison(x) = totals_comparison(x) - a(x, y)\n          END DO\n        END DO\n\n        DO x = 1, LOOPCOUNT\n          IF (totals_comparison(x) .NE. totals(x)) THEN\n            errors = errors + 1\n            WRITE(*, *) totals_comparison(x)\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "construct-independent",
                            "atomic"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_update_x_minus_expr.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:atomic,construct-independent,V:2.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t *a = (real_t *)malloc(n * sizeof(real_t));\n    real_t *b = (real_t *)malloc(n * sizeof(real_t));\n    real_t *totals = (real_t *)malloc(10 * sizeof(real_t));\n    real_t *totals_host = (real_t *)malloc(10 * sizeof(real_t));\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n    }\n    for (int x = 0; x < 10; ++x){\n        totals[x] = 0;\n    }\n\n    #pragma acc data copyin(a[0:n], b[0:n]) copy(totals[0:10])\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                #pragma acc atomic update\n                    totals[x%10] = totals[x%10] - (a[x] + b[x]);\n            }\n        }\n    }\n\n\n    for (int x = 0; x < n; ++x){\n        totals_host[x%10] = totals_host[x%10] - (a[x] + b[x]);\n    }\n    for (int x = 0; x < 10; ++x){\n        if (fabs(totals_host[x] - totals[x]) > PRECISION){\n            err += 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "atomic",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_update_x_minus_expr_end.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:construct-independent,atomic,V:2.0-2.7\n      LOGICAL FUNCTION test1()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x, y !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT, 10):: a !Data\n        REAL(8),DIMENSION(LOOPCOUNT):: totals, totals_comparison\n        INTEGER :: errors = 0\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(a)\n\n        totals = 0\n        totals_comparison = 0\n\n        !$acc data copyin(a(1:LOOPCOUNT, 1:10)) copy(totals(1:LOOPCOUNT))\n          !$acc parallel\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              DO y = 1, 10\n                !$acc atomic update\n                  totals(x) = totals(x) - a(x, y)\n                !$acc end atomic\n              END DO\n            END DO\n          !$acc end parallel\n        !$acc end data\n        DO x = 1, LOOPCOUNT\n          DO y = 1, 10\n            totals_comparison(x) = totals_comparison(x) - a(x, y)\n          END DO\n        END DO\n\n        DO x = 1, LOOPCOUNT\n          IF (totals_comparison(x) .NE. totals(x)) THEN\n            errors = errors + 1\n            WRITE(*, *) totals_comparison(x)\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "construct-independent",
                            "atomic"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_update_x_multiply_expr.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:atomic,construct-independent,V:2.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t *a = (real_t *)malloc(n * sizeof(real_t));\n    real_t *b = (real_t *)malloc(n * sizeof(real_t));\n    real_t *totals = (real_t *)malloc((n/10 + 1) * sizeof(real_t));\n    real_t *totals_comparison = (real_t *)malloc((n/10 + 1) * sizeof(real_t));\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n    }\n    for (int x = 0; x < n/10 + 1; ++x){\n        totals[x] = 1;\n        totals_comparison[x] = 1;\n    }\n\n    #pragma acc data copyin(a[0:n], b[0:n]) copy(totals[0:n/10 + 1])\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                #pragma acc atomic update\n                    totals[x%(n/10 + 1)] = totals[x%(n/10 + 1)] * (a[x] + b[x]);\n            }\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        totals_comparison[x%(n/10 + 1)] *= a[x] + b[x];\n    }\n    for (int x = 0; x < 10; ++x){\n        if (fabs(totals_comparison[x] - totals[x]) > PRECISION * totals_comparison[x]){\n            err += 1;\n            break;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "atomic",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_update_x_neqv_expr.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:construct-independent,atomic,V:2.0-2.7\n      LOGICAL FUNCTION test1()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x, y !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT, 10):: randoms\n        LOGICAL,DIMENSION(LOOPCOUNT, 10):: a !Data\n        LOGICAL,DIMENSION(LOOPCOUNT):: totals, totals_comparison\n        INTEGER :: errors = 0\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(randoms)\n        DO x = 1, LOOPCOUNT\n          DO y = 1, 10\n            IF (randoms(x, y) > .5) THEN\n              a(x, y) = .TRUE.\n            ELSE\n              a(x, y) = .FALSE.\n            END IF\n          END DO\n        END DO\n\n        totals = .FALSE.\n        totals_comparison = .FALSE.\n\n        !$acc data copyin(a(1:LOOPCOUNT,1:10)) copy(totals(1:LOOPCOUNT))\n          !$acc parallel\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              DO y = 1, 10\n                !$acc atomic update\n                  totals(x) = totals(x) .NEQV. a(x, y)\n              END DO\n            END DO\n          !$acc end parallel\n        !$acc end data\n\n        DO x = 1, LOOPCOUNT\n          DO y = 1, 10\n            totals_comparison(x) = totals_comparison(x) .NEQV. a(x, y)\n          END DO\n        END DO\n\n        DO x = 1, LOOPCOUNT\n          IF (totals_comparison(x) .NEQV. totals(x)) THEN\n            errors = errors + 1\n            WRITE(*, *) totals_comparison(x)\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "construct-independent",
                            "atomic"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_update_x_neqv_expr_end.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:construct-independent,atomic,V:2.0-2.7\n      LOGICAL FUNCTION test1()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x, y !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT, 10):: randoms\n        LOGICAL,DIMENSION(LOOPCOUNT, 10):: a !Data\n        LOGICAL,DIMENSION(LOOPCOUNT):: totals, totals_comparison\n        INTEGER :: errors = 0\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(randoms)\n        DO x = 1, LOOPCOUNT\n          DO y = 1, 10\n            IF (randoms(x, y) > .5) THEN\n              a(x, y) = .TRUE.\n            ELSE\n              a(x, y) = .FALSE.\n            END IF\n          END DO\n        END DO\n\n        totals = .FALSE.\n        totals_comparison = .FALSE.\n\n        !$acc data copyin(a(1:LOOPCOUNT,1:10)) copy(totals(1:LOOPCOUNT))\n          !$acc parallel\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              DO y = 1, 10\n                !$acc atomic update\n                  totals(x) = totals(x) .NEQV. a(x, y)\n                !$acc end atomic\n              END DO\n            END DO\n          !$acc end parallel\n        !$acc end data\n\n        DO x = 1, LOOPCOUNT\n          DO y = 1, 10\n            totals_comparison(x) = totals_comparison(x) .NEQV. a(x, y)\n          END DO\n        END DO\n\n        DO x = 1, LOOPCOUNT\n          IF (totals_comparison(x) .NEQV. totals(x)) THEN\n            errors = errors + 1\n            WRITE(*, *) totals_comparison(x)\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "construct-independent",
                            "atomic"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_update_x_or_expr.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:construct-independent,atomic,V:2.0-2.7\n      LOGICAL FUNCTION test1()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x, y !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT, 10):: randoms\n        LOGICAL,DIMENSION(LOOPCOUNT, 10):: a !Data\n        LOGICAL,DIMENSION(LOOPCOUNT):: totals, totals_comparison\n        INTEGER :: errors = 0\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(randoms)\n        DO x = 1, LOOPCOUNT\n          DO y = 1, 10\n            IF (randoms(x, y) > .933) THEN\n              a(x, y) = .TRUE.\n            ELSE\n              a(x, y) = .FALSE.\n            END IF\n          END DO\n        END DO\n\n        totals = .FALSE.\n        totals_comparison = .FALSE.\n\n        !$acc data copyin(a(1:LOOPCOUNT,1:10)) copy(totals(1:LOOPCOUNT))\n          !$acc parallel\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              DO y = 1, 10\n                !$acc atomic update\n                  totals(x) = totals(x) .OR. a(x, y)\n              END DO\n            END DO\n          !$acc end parallel\n        !$acc end data\n\n        DO x = 1, LOOPCOUNT\n          DO y = 1, 10\n            totals_comparison(x) = totals_comparison(x) .OR. a(x, y)\n          END DO\n        END DO\n\n        DO x = 1, LOOPCOUNT\n          IF (totals_comparison(x) .NEQV. totals(x)) THEN\n            errors = errors + 1\n            WRITE(*, *) totals_comparison(x)\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "construct-independent",
                            "atomic"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_update_x_or_expr_end.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:construct-independent,atomic,V:2.0-2.7\n      LOGICAL FUNCTION test1()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x, y !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT, 10):: randoms\n        LOGICAL,DIMENSION(LOOPCOUNT, 10):: a !Data\n        LOGICAL,DIMENSION(LOOPCOUNT):: totals, totals_comparison\n        INTEGER :: errors = 0\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(randoms)\n        DO x = 1, LOOPCOUNT\n          DO y = 1, 10\n            IF (randoms(x, y) > .933) THEN\n              a(x, y) = .TRUE.\n            ELSE\n              a(x, y) = .FALSE.\n            END IF\n          END DO\n        END DO\n\n        totals = .FALSE.\n        totals_comparison = .FALSE.\n\n        !$acc data copyin(a(1:LOOPCOUNT,1:10)) copy(totals(1:LOOPCOUNT))\n          !$acc parallel\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              DO y = 1, 10\n                !$acc atomic update\n                  totals(x) = totals(x) .OR. a(x, y)\n                !$acc end atomic\n              END DO\n            END DO\n          !$acc end parallel\n        !$acc end data\n\n        DO x = 1, LOOPCOUNT\n          DO y = 1, 10\n            totals_comparison(x) = totals_comparison(x) .OR. a(x, y)\n          END DO\n        END DO\n\n        DO x = 1, LOOPCOUNT\n          IF (totals_comparison(x) .NEQV. totals(x)) THEN\n            errors = errors + 1\n            WRITE(*, *) totals_comparison(x)\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "construct-independent",
                            "atomic"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_update_x_plus_expr.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:construct-independent,atomic,V:2.0-2.7\n      LOGICAL FUNCTION test1()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x, y !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT, 10):: a !Data\n        REAL(8),DIMENSION(LOOPCOUNT):: totals, totals_comparison\n        INTEGER :: errors = 0\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(a)\n\n        totals = 0\n        totals_comparison = 0\n\n        !$acc data copyin(a(1:LOOPCOUNT, 1:10)) copy(totals(1:LOOPCOUNT))\n          !$acc parallel\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              DO y = 1, 10\n                !$acc atomic update\n                  totals(x) = totals(x) + a(x, y)\n              END DO\n            END DO\n          !$acc end parallel\n        !$acc end data\n        DO x = 1, LOOPCOUNT\n          DO y = 1, 10\n            totals_comparison(x) = totals_comparison(x) + a(x, y)\n          END DO\n        END DO\n\n        DO x = 1, LOOPCOUNT\n          IF (totals_comparison(x) .NE. totals(x)) THEN\n            errors = errors + 1\n            WRITE(*, *) totals_comparison(x)\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "construct-independent",
                            "atomic"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_update_x_plus_expr.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:atomic,construct-independent,V:2.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t *a = (real_t *)malloc(n * sizeof(real_t));\n    real_t *b = (real_t *)malloc(n * sizeof(real_t));\n    real_t *totals = (real_t *)malloc(10 * sizeof(real_t));\n    real_t *totals_comparison = (real_t *)malloc(10 * sizeof(real_t));\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n    }\n    for (int x = 0; x < 10; ++x){\n        totals[x] = 0;\n        totals_comparison[x] = 0;\n    }\n\n    #pragma acc data copyin(a[0:n], b[0:n]) copy(totals[0:10])\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                #pragma acc loop\n                for (int y = 0; y < n; ++y){\n                    #pragma acc atomic update\n                        totals[(int) ((a[x] + b[x])/2)] = totals[(int) ((a[x] + b[x])/2)] + a[x] * b[x];\n                }\n            }\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        for (int y = 0; y < n; ++y){\n            totals_comparison[(int) ((a[x] + b[x])/2)] += a[x] * b[x];\n        }\n    }\n    for (int x = 0; x < 10; ++x){\n        if (fabs(totals_comparison[x] - totals[x]) > PRECISION){\n            err += 1;\n            break;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "atomic",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_update_x_plus_expr_end.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:construct-independent,atomic,V:2.0-2.7\n      LOGICAL FUNCTION test1()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x, y !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT, 10):: a !Data\n        REAL(8),DIMENSION(LOOPCOUNT):: totals, totals_comparison\n        INTEGER :: errors = 0\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(a)\n\n        totals = 0\n        totals_comparison = 0\n\n        !$acc data copyin(a(1:LOOPCOUNT, 1:10)) copy(totals(1:LOOPCOUNT))\n          !$acc parallel\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              DO y = 1, 10\n                !$acc atomic update\n                  totals(x) = totals(x) + a(x, y)\n                !$acc end atomic\n              END DO\n            END DO\n          !$acc end parallel\n        !$acc end data\n        DO x = 1, LOOPCOUNT\n          DO y = 1, 10\n            totals_comparison(x) = totals_comparison(x) + a(x, y)\n          END DO\n        END DO\n\n        DO x = 1, LOOPCOUNT\n          IF (totals_comparison(x) .NE. totals(x)) THEN\n            errors = errors + 1\n            WRITE(*, *) totals_comparison(x)\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "construct-independent",
                            "atomic"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_update_x_rshift_expr.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:atomic,construct-independent,V:2.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    unsigned int *a = (unsigned int *)malloc(n * sizeof(int));\n    unsigned int *b = (unsigned int *)malloc(n * sizeof(int));\n\n    for (int x = 0; x < n; ++x){\n        a[x] = 1<<7;\n        for (int y = 0; y < 7; ++y){\n            if ((rand()/(unsigned int) (RAND_MAX)) > .5){\n                b[x] += 1<<y;\n            }\n        }\n    }\n\n    #pragma acc data copyin(b[0:n]) copy(a[0:n])\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                #pragma acc loop\n                for (int y = 0; y < 7; ++y){\n                    if ((b[x]>>y)%2 == 1){\n                        #pragma acc atomic update\n                            a[x] = a[x] >> 1;\n                    }\n                }\n            }\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        for (int y = 0; y < 7; ++y){\n            if ((b[x]>>y)%2 == 1){\n                a[x] <<= 1;\n            }\n        }\n        if (a[x] != 1<<7){\n            err += 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "atomic",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_update_x_times_expr.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:construct-independent,atomic,V:2.0-2.7\n      LOGICAL FUNCTION test1()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x, y !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT, 10):: a !Data\n        REAL(8),DIMENSION(LOOPCOUNT):: totals, totals_comparison\n        INTEGER :: errors = 0\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(a)\n\n        totals = 1\n        totals_comparison = 1\n\n        !$acc data copyin(a(1:LOOPCOUNT, 1:10)) copy(totals(1:LOOPCOUNT))\n          !$acc parallel\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              DO y = 1, 10\n                !$acc atomic update\n                  totals(x) = totals(x) * a(x, y)\n              END DO\n            END DO\n          !$acc end parallel\n        !$acc end data\n        DO x = 1, LOOPCOUNT\n          DO y = 1, 10\n            totals_comparison(x) = totals_comparison(x) * a(x, y)\n          END DO\n        END DO\n\n        DO x = 1, LOOPCOUNT\n          IF (totals_comparison(x) .NE. totals(x)) THEN\n            errors = errors + 1\n            WRITE(*, *) totals_comparison(x)\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "construct-independent",
                            "atomic"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_update_x_times_expr_end.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:construct-independent,atomic,V:2.0-2.7\n      LOGICAL FUNCTION test1()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x, y !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT, 10):: a !Data\n        REAL(8),DIMENSION(LOOPCOUNT):: totals, totals_comparison\n        INTEGER :: errors = 0\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(a)\n\n        totals = 1\n        totals_comparison = 1\n\n        !$acc data copyin(a(1:LOOPCOUNT, 1:10)) copy(totals(1:LOOPCOUNT))\n          !$acc parallel\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              DO y = 1, 10\n                !$acc atomic update\n                  totals(x) = totals(x) * a(x, y)\n                !$acc end atomic\n              END DO\n            END DO\n          !$acc end parallel\n        !$acc end data\n        DO x = 1, LOOPCOUNT\n          DO y = 1, 10\n            totals_comparison(x) = totals_comparison(x) * a(x, y)\n          END DO\n        END DO\n\n        DO x = 1, LOOPCOUNT\n          IF (totals_comparison(x) .NE. totals(x)) THEN\n            errors = errors + 1\n            WRITE(*, *) totals_comparison(x)\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "construct-independent",
                            "atomic"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_x_and_expr.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:construct-independent,atomic,V:2.0-2.7\n      LOGICAL FUNCTION test1()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x, y !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT, 10):: randoms\n        LOGICAL,DIMENSION(LOOPCOUNT, 10):: a !Data\n        LOGICAL,DIMENSION(LOOPCOUNT):: totals, totals_comparison\n        INTEGER :: errors = 0\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(randoms)\n        DO x = 1, LOOPCOUNT\n          DO y = 1, 10\n            IF (randoms(x, y) < .933) THEN\n              a(x, y) = .TRUE.\n            ELSE\n              a(x, y) = .FALSE.\n            END IF\n          END DO\n        END DO\n\n        totals = .FALSE.\n        totals_comparison = .FALSE.\n\n        !$acc data copyin(a(1:LOOPCOUNT,1:10)) copy(totals(1:LOOPCOUNT))\n          !$acc parallel\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              DO y = 1, 10\n                !$acc atomic\n                  totals(x) = totals(x) .AND. a(x, y)\n              END DO\n            END DO\n          !$acc end parallel\n        !$acc end data\n\n        DO x = 1, LOOPCOUNT\n          DO y = 1, 10\n            totals_comparison(x) = totals_comparison(x) .AND. a(x, y)\n          END DO\n        END DO\n\n        DO x = 1, LOOPCOUNT\n          IF (totals_comparison(x) .NEQV. totals(x)) THEN\n            errors = errors + 1\n            WRITE(*, *) totals_comparison(x)\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "construct-independent",
                            "atomic"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_x_and_expr_end.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:construct-independent,atomic,V:2.0-2.7\n      LOGICAL FUNCTION test1()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x, y !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT, 10):: randoms\n        LOGICAL,DIMENSION(LOOPCOUNT, 10):: a !Data\n        LOGICAL,DIMENSION(LOOPCOUNT):: totals, totals_comparison\n        INTEGER :: errors = 0\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(randoms)\n        DO x = 1, LOOPCOUNT\n          DO y = 1, 10\n            IF (randoms(x, y) < .933) THEN\n              a(x, y) = .TRUE.\n            ELSE\n              a(x, y) = .FALSE.\n            END IF\n          END DO\n        END DO\n\n        totals = .FALSE.\n        totals_comparison = .FALSE.\n\n        !$acc data copyin(a(1:LOOPCOUNT,1:10)) copy(totals(1:LOOPCOUNT))\n          !$acc parallel\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              DO y = 1, 10\n                !$acc atomic\n                  totals(x) = totals(x) .AND. a(x, y)\n                !$acc end atomic\n              END DO\n            END DO\n          !$acc end parallel\n        !$acc end data\n\n        DO x = 1, LOOPCOUNT\n          DO y = 1, 10\n            totals_comparison(x) = totals_comparison(x) .AND. a(x, y)\n          END DO\n        END DO\n\n        DO x = 1, LOOPCOUNT\n          IF (totals_comparison(x) .NEQV. totals(x)) THEN\n            errors = errors + 1\n            WRITE(*, *) totals_comparison(x)\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "construct-independent",
                            "atomic"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_x_bitand_expr.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:atomic,construct-independent,V:2.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    int  *a = (int *)malloc(n * sizeof(int));\n    int *totals = (int *)malloc((n/10 + 1) * sizeof(int));\n    int *totals_comparison = (int *)malloc((n/10 + 1) * sizeof(int));\n\n    for (int x = 0; x < n; ++x){\n        for (int y = 0; y < 8; ++y){\n            if (rand()/(real_t)(RAND_MAX) < .933){ //.933 gets close to a 50/50 distribution for a collescence of 10 values\n                a[x] += 1<<y;\n            }\n        }\n    }\n    for (int x = 0; x < n/10 + 1; ++x){\n        for (int y = 0; y < 8; ++y){\n            totals[x] +=  1<<y;\n            totals_comparison[x] += 1<<y;\n        }\n    }\n\n    #pragma acc data copyin(a[0:n]) copy(totals[0:n/10 + 1])\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                #pragma acc atomic\n                    totals[x%(n/10 + 1)] = totals[x%(n/10 + 1)] & a[x];\n            }\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        totals_comparison[x%(n/10 + 1)] &= a[x];\n    }\n    for (int x = 0; x < 10; ++x){\n        if (fabs(totals_comparison[x] - totals[x]) > PRECISION){\n            err += 1;\n            break;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "atomic",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_x_bitor_expr.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:atomic,construct-independent,V:2.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    int  *a = (int *)malloc(n * sizeof(int));\n    int *totals = (int *)malloc((n/10 + 1) * sizeof(int));\n    int *totals_comparison = (int *)malloc((n/10 + 1) * sizeof(int));\n\n    for (int x = 0; x < n; ++x){\n        for (int y = 0; y < 8; ++y){\n            if (rand()/(real_t)(RAND_MAX) > .933){ //.933 gets close to a 50/50 distribution for a collescence of 10 values\n                a[x] += 1<<y;\n            }\n        }\n    }\n    for (int x = 0; x < n/10 + 1; ++x){\n        totals[x] = 0;\n\n    }\n\n    #pragma acc data copyin(a[0:n]) copy(totals[0:n/10 + 1])\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                #pragma acc atomic\n                    totals[x%(n/10 + 1)] = totals[x%(n/10 + 1)] | a[x];\n            }\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        totals_comparison[x%(n/10 + 1)] |= a[x];\n    }\n    for (int x = 0; x < 10; ++x){\n        if (fabs(totals_comparison[x] - totals[x]) > PRECISION){\n            err += 1;\n            break;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "atomic",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_x_bitxor_expr.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:atomic,construct-independent,V:2.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    int  *a = (int *)malloc(n * sizeof(int));\n    int *totals = (int *)malloc((n/10 + 1) * sizeof(int));\n    int *totals_comparison = (int *)malloc((n/10 + 1) * sizeof(int));\n\n    for (int x = 0; x < n; ++x){\n        for (int y = 0; y < 8; ++y){\n            if (rand()/(real_t)(RAND_MAX) > .5){\n                a[x] += 1<<y;\n            }\n        }\n    }\n    for (int x = 0; x < n/10 + 1; ++x){\n        totals[x] = 0;\n        totals_comparison[x] = 0;\n    }\n\n    #pragma acc data copyin(a[0:n]) copy(totals[0:n/10 + 1])\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                #pragma acc atomic\n                    totals[x%(n/10 + 1)] =  totals[x%(n/10 + 1)] ^ a[x];\n            }\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        totals_comparison[x%(n/10 + 1)] ^= a[x];\n    }\n    for (int x = 0; x < n/10 + 1; ++x){\n        if (fabs(totals_comparison[x] - totals[x]) > PRECISION){\n            err += 1;\n            break;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "atomic",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_x_divided_expr.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:construct-independent,atomic,V:2.0-2.7\n      LOGICAL FUNCTION test1()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x, y !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT, 10):: a !Data\n        REAL(8),DIMENSION(LOOPCOUNT):: totals, totals_comparison\n        INTEGER :: errors = 0\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(a)\n\n        totals = 1\n        totals_comparison = 1\n\n        !$acc data copyin(a(1:LOOPCOUNT, 1:10)) copy(totals(1:LOOPCOUNT))\n          !$acc parallel\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              DO y = 1, 10\n                !$acc atomic\n                  totals(x) = totals(x) / a(x, y)\n              END DO\n            END DO\n          !$acc end parallel\n        !$acc end data\n        DO x = 1, LOOPCOUNT\n          DO y = 1, 10\n            totals_comparison(x) = totals_comparison(x) / a(x, y)\n          END DO\n        END DO\n\n        DO x = 1, LOOPCOUNT\n          IF (totals_comparison(x) .NE. totals(x)) THEN\n            errors = errors + 1\n            WRITE(*, *) totals_comparison(x)\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "construct-independent",
                            "atomic"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_x_divided_expr.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:atomic,construct-independent,V:2.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t *a = (real_t *)malloc(n * sizeof(real_t));\n    real_t *b = (real_t *)malloc(n * sizeof(real_t));\n    real_t *totals = (real_t *)malloc((n/10 + 1) * sizeof(real_t));\n    real_t *totals_comparison = (real_t *)malloc((n/10 + 1) * sizeof(real_t));\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n    }\n    for (int x = 0; x < n/10 + 1; ++x){\n        totals[x] = 1;\n        totals_comparison[x] = 1;\n    }\n\n    #pragma acc data copyin(a[0:n], b[0:n]) copy(totals[0:n/10 + 1])\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                #pragma acc atomic\n                    totals[x%(n/10 + 1)] = totals[x%(n/10 + 1)] / (a[x] + b[x]);\n            }\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        totals_comparison[x%(n/10 + 1)] /= a[x] + b[x];\n    }\n    for (int x = 0; x < 10; ++x){\n        if (fabs(totals_comparison[x] - totals[x]) > PRECISION){\n            err += 1;\n            break;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "atomic",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_x_divided_expr_end.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:construct-independent,atomic,V:2.0-2.7\n      LOGICAL FUNCTION test1()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x, y !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT, 10):: a !Data\n        REAL(8),DIMENSION(LOOPCOUNT):: totals, totals_comparison\n        INTEGER :: errors = 0\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(a)\n\n        totals = 1\n        totals_comparison = 1\n\n        !$acc data copyin(a(1:LOOPCOUNT, 1:10)) copy(totals(1:LOOPCOUNT))\n          !$acc parallel\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              DO y = 1, 10\n                !$acc atomic\n                  totals(x) = totals(x) / a(x, y)\n                !$acc end atomic\n              END DO\n            END DO\n          !$acc end parallel\n        !$acc end data\n        DO x = 1, LOOPCOUNT\n          DO y = 1, 10\n            totals_comparison(x) = totals_comparison(x) / a(x, y)\n          END DO\n        END DO\n\n        DO x = 1, LOOPCOUNT\n          IF (totals_comparison(x) .NE. totals(x)) THEN\n            errors = errors + 1\n            WRITE(*, *) totals_comparison(x)\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "construct-independent",
                            "atomic"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_x_eqv_expr.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:construct-independent,atomic,V:2.0-2.7\n      LOGICAL FUNCTION test1()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x, y !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT, 10):: randoms\n        LOGICAL,DIMENSION(LOOPCOUNT, 10):: a !Data\n        LOGICAL,DIMENSION(LOOPCOUNT):: totals, totals_comparison\n        INTEGER :: errors = 0\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(randoms)\n        DO x = 1, LOOPCOUNT\n          DO y = 1, 10\n            IF (randoms(x, y) > .5) THEN\n              a(x, y) = .TRUE.\n            ELSE\n              a(x, y) = .FALSE.\n            END IF\n          END DO\n        END DO\n\n        totals = .FALSE.\n        totals_comparison = .FALSE.\n\n        !$acc data copyin(a(1:LOOPCOUNT,1:10)) copy(totals(1:LOOPCOUNT))\n          !$acc parallel\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              DO y = 1, 10\n                !$acc atomic\n                  totals(x) = totals(x) .EQV. a(x, y)\n              END DO\n            END DO\n          !$acc end parallel\n        !$acc end data\n\n        DO x = 1, LOOPCOUNT\n          DO y = 1, 10\n            totals_comparison(x) = totals_comparison(x) .EQV. a(x, y)\n          END DO\n        END DO\n\n        DO x = 1, LOOPCOUNT\n          IF (totals_comparison(x) .NEQV. totals(x)) THEN\n            errors = errors + 1\n            WRITE(*, *) totals_comparison(x)\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "construct-independent",
                            "atomic"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_x_eqv_expr_end.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:construct-independent,atomic,V:2.0-2.7\n      LOGICAL FUNCTION test1()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x, y !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT, 10):: randoms\n        LOGICAL,DIMENSION(LOOPCOUNT, 10):: a !Data\n        LOGICAL,DIMENSION(LOOPCOUNT):: totals, totals_comparison\n        INTEGER :: errors = 0\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(randoms)\n        DO x = 1, LOOPCOUNT\n          DO y = 1, 10\n            IF (randoms(x, y) > .5) THEN\n              a(x, y) = .TRUE.\n            ELSE\n              a(x, y) = .FALSE.\n            END IF\n          END DO\n        END DO\n\n        totals = .FALSE.\n        totals_comparison = .FALSE.\n\n        !$acc data copyin(a(1:LOOPCOUNT,1:10)) copy(totals(1:LOOPCOUNT))\n          !$acc parallel\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              DO y = 1, 10\n                !$acc atomic\n                  totals(x) = totals(x) .EQV. a(x, y)\n                !$acc end atomic\n              END DO\n            END DO\n          !$acc end parallel\n        !$acc end data\n\n        DO x = 1, LOOPCOUNT\n          DO y = 1, 10\n            totals_comparison(x) = totals_comparison(x) .EQV. a(x, y)\n          END DO\n        END DO\n\n        DO x = 1, LOOPCOUNT\n          IF (totals_comparison(x) .NEQV. totals(x)) THEN\n            errors = errors + 1\n            WRITE(*, *) totals_comparison(x)\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "construct-independent",
                            "atomic"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_x_lshift_expr.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:atomic,construct-independent,V:2.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    unsigned int *a = (unsigned int *)malloc(n * sizeof(int));\n    unsigned int *b = (unsigned int *)malloc(n * sizeof(int));\n\n    for (int x = 0; x < n; ++x){\n        a[x] = 1;\n        for (int y = 0; y < 7; ++y){\n            if ((rand()/(unsigned int) (RAND_MAX)) > .5){\n                b[x] += 1<<y;\n            }\n        }\n    }\n\n    #pragma acc data copyin(b[0:n]) copy(a[0:n])\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                #pragma acc loop\n                for (int y = 0; y < 7; ++y){\n                    if ((b[x]>>y)%2 == 1){\n                        #pragma acc atomic\n                            a[x] = a[x] << 1;\n                    }\n                }\n            }\n        }\n    }\n    for (int x = 0; x < n; ++x){\n        for (int y = 0; y < 7; ++y){\n            if ((b[x]>>y)%2 == 1){\n                a[x] >>= 1;\n            }\n        }\n        if (a[x] != 1){\n            err += 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "atomic",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_x_minus_expr.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:construct-independent,atomic,V:2.0-2.7\n      LOGICAL FUNCTION test1()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x, y !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT, 10):: a !Data\n        REAL(8),DIMENSION(LOOPCOUNT):: totals, totals_comparison\n        INTEGER :: errors = 0\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(a)\n\n        totals = 0\n        totals_comparison = 0\n\n        !$acc data copyin(a(1:LOOPCOUNT, 1:10)) copy(totals(1:LOOPCOUNT))\n          !$acc parallel\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              DO y = 1, 10\n                !$acc atomic\n                  totals(x) = totals(x) - a(x, y)\n              END DO\n            END DO\n          !$acc end parallel\n        !$acc end data\n        DO x = 1, LOOPCOUNT\n          DO y = 1, 10\n            totals_comparison(x) = totals_comparison(x) - a(x, y)\n          END DO\n        END DO\n\n        DO x = 1, LOOPCOUNT\n          IF (totals_comparison(x) .NE. totals(x)) THEN\n            errors = errors + 1\n            WRITE(*, *) totals_comparison(x)\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "construct-independent",
                            "atomic"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_x_minus_expr.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:atomic,construct-independent,V:2.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t *a = (real_t *)malloc(n * sizeof(real_t));\n    real_t *b = (real_t *)malloc(n * sizeof(real_t));\n    real_t *totals = (real_t *)malloc(10 * sizeof(real_t));\n    real_t *totals_host = (real_t *)malloc(10 * sizeof(real_t));\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n    }\n    for (int x = 0; x < 10; ++x){\n        totals[x] = 0;\n    }\n\n    #pragma acc data copyin(a[0:n], b[0:n]) copy(totals[0:10])\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                #pragma acc atomic\n                    totals[x%10] = totals[x%10] - (a[x] + b[x]);\n            }\n        }\n    }\n\n\n    for (int x = 0; x < n; ++x){\n        totals_host[x%10] = totals_host[x%10] - (a[x] + b[x]);\n    }\n    for (int x = 0; x < 10; ++x){\n        if (fabs(totals_host[x] - totals[x]) > PRECISION){\n            err += 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "atomic",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_x_minus_expr_end.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:construct-independent,atomic,V:2.0-2.7\n      LOGICAL FUNCTION test1()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x, y !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT, 10):: a !Data\n        REAL(8),DIMENSION(LOOPCOUNT):: totals, totals_comparison\n        INTEGER :: errors = 0\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(a)\n\n        totals = 0\n        totals_comparison = 0\n\n        !$acc data copyin(a(1:LOOPCOUNT, 1:10)) copy(totals(1:LOOPCOUNT))\n          !$acc parallel\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              DO y = 1, 10\n                !$acc atomic\n                  totals(x) = totals(x) - a(x, y)\n                !$acc end atomic\n              END DO\n            END DO\n          !$acc end parallel\n        !$acc end data\n        DO x = 1, LOOPCOUNT\n          DO y = 1, 10\n            totals_comparison(x) = totals_comparison(x) - a(x, y)\n          END DO\n        END DO\n\n        DO x = 1, LOOPCOUNT\n          IF (totals_comparison(x) .NE. totals(x)) THEN\n            errors = errors + 1\n            WRITE(*, *) totals_comparison(x)\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "construct-independent",
                            "atomic"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_x_multiply_expr.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:atomic,construct-independent,V:2.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t *a = (real_t *)malloc(n * sizeof(real_t));\n    real_t *b = (real_t *)malloc(n * sizeof(real_t));\n    real_t *totals = (real_t *)malloc((n/10 + 1) * sizeof(real_t));\n    real_t *totals_comparison = (real_t *)malloc((n/10 + 1) * sizeof(real_t));\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n    }\n    for (int x = 0; x < n/10 + 1; ++x){\n        totals[x] = 1;\n        totals_comparison[x] = 1;\n    }\n\n    #pragma acc data copyin(a[0:n], b[0:n]) copy(totals[0:n/10 + 1])\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                #pragma acc atomic\n                    totals[x%(n/10 + 1)] = totals[x%(n/10 + 1)] * (a[x] + b[x]);\n            }\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        totals_comparison[x%(n/10 + 1)] *= a[x] + b[x];\n    }\n    for (int x = 0; x < 10; ++x){\n        if (fabs(totals_comparison[x] - totals[x]) > PRECISION * totals_comparison[x]){\n            err += 1;\n            break;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "atomic",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_x_neqv_expr.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:construct-independent,atomic,V:2.0-2.7\n      LOGICAL FUNCTION test1()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x, y !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT, 10):: randoms\n        LOGICAL,DIMENSION(LOOPCOUNT, 10):: a !Data\n        LOGICAL,DIMENSION(LOOPCOUNT):: totals, totals_comparison\n        INTEGER :: errors = 0\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(randoms)\n        DO x = 1, LOOPCOUNT\n          DO y = 1, 10\n            IF (randoms(x, y) > .5) THEN\n              a(x, y) = .TRUE.\n            ELSE\n              a(x, y) = .FALSE.\n            END IF\n          END DO\n        END DO\n\n        totals = .FALSE.\n        totals_comparison = .FALSE.\n\n        !$acc data copyin(a(1:LOOPCOUNT,1:10)) copy(totals(1:LOOPCOUNT))\n          !$acc parallel\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              DO y = 1, 10\n                !$acc atomic\n                  totals(x) = totals(x) .NEQV. a(x, y)\n              END DO\n            END DO\n          !$acc end parallel\n        !$acc end data\n\n        DO x = 1, LOOPCOUNT\n          DO y = 1, 10\n            totals_comparison(x) = totals_comparison(x) .NEQV. a(x, y)\n          END DO\n        END DO\n\n        DO x = 1, LOOPCOUNT\n          IF (totals_comparison(x) .NEQV. totals(x)) THEN\n            errors = errors + 1\n            WRITE(*, *) totals_comparison(x)\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "construct-independent",
                            "atomic"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_x_neqv_expr_end.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:construct-independent,atomic,V:2.0-2.7\n      LOGICAL FUNCTION test1()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x, y !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT, 10):: randoms\n        LOGICAL,DIMENSION(LOOPCOUNT, 10):: a !Data\n        LOGICAL,DIMENSION(LOOPCOUNT):: totals, totals_comparison\n        INTEGER :: errors = 0\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(randoms)\n        DO x = 1, LOOPCOUNT\n          DO y = 1, 10\n            IF (randoms(x, y) > .5) THEN\n              a(x, y) = .TRUE.\n            ELSE\n              a(x, y) = .FALSE.\n            END IF\n          END DO\n        END DO\n\n        totals = .FALSE.\n        totals_comparison = .FALSE.\n\n        !$acc data copyin(a(1:LOOPCOUNT,1:10)) copy(totals(1:LOOPCOUNT))\n          !$acc parallel\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              DO y = 1, 10\n                !$acc atomic\n                  totals(x) = totals(x) .NEQV. a(x, y)\n                !$acc end atomic\n              END DO\n            END DO\n          !$acc end parallel\n        !$acc end data\n\n        DO x = 1, LOOPCOUNT\n          DO y = 1, 10\n            totals_comparison(x) = totals_comparison(x) .NEQV. a(x, y)\n          END DO\n        END DO\n\n        DO x = 1, LOOPCOUNT\n          IF (totals_comparison(x) .NEQV. totals(x)) THEN\n            errors = errors + 1\n            WRITE(*, *) totals_comparison(x)\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "construct-independent",
                            "atomic"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_x_or_expr.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:construct-independent,atomic,V:2.0-2.7\n      LOGICAL FUNCTION test1()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x, y !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT, 10):: randoms\n        LOGICAL,DIMENSION(LOOPCOUNT, 10):: a !Data\n        LOGICAL,DIMENSION(LOOPCOUNT):: totals, totals_comparison\n        INTEGER :: errors = 0\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(randoms)\n        DO x = 1, LOOPCOUNT\n          DO y = 1, 10\n            IF (randoms(x, y) > .933) THEN\n              a(x, y) = .TRUE.\n            ELSE\n              a(x, y) = .FALSE.\n            END IF\n          END DO\n        END DO\n\n        totals = .FALSE.\n        totals_comparison = .FALSE.\n\n        !$acc data copyin(a(1:LOOPCOUNT,1:10)) copy(totals(1:LOOPCOUNT))\n          !$acc parallel\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              DO y = 1, 10\n                !$acc atomic\n                  totals(x) = totals(x) .OR. a(x, y)\n              END DO\n            END DO\n          !$acc end parallel\n        !$acc end data\n\n        DO x = 1, LOOPCOUNT\n          DO y = 1, 10\n            totals_comparison(x) = totals_comparison(x) .OR. a(x, y)\n          END DO\n        END DO\n\n        DO x = 1, LOOPCOUNT\n          IF (totals_comparison(x) .NEQV. totals(x)) THEN\n            errors = errors + 1\n            WRITE(*, *) totals_comparison(x)\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "construct-independent",
                            "atomic"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_x_or_expr_end.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:construct-independent,atomic,V:2.0-2.7\n      LOGICAL FUNCTION test1()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x, y !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT, 10):: randoms\n        LOGICAL,DIMENSION(LOOPCOUNT, 10):: a !Data\n        LOGICAL,DIMENSION(LOOPCOUNT):: totals, totals_comparison\n        INTEGER :: errors = 0\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(randoms)\n        DO x = 1, LOOPCOUNT\n          DO y = 1, 10\n            IF (randoms(x, y) > .933) THEN\n              a(x, y) = .TRUE.\n            ELSE\n              a(x, y) = .FALSE.\n            END IF\n          END DO\n        END DO\n\n        totals = .FALSE.\n        totals_comparison = .FALSE.\n\n        !$acc data copyin(a(1:LOOPCOUNT,1:10)) copy(totals(1:LOOPCOUNT))\n          !$acc parallel\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              DO y = 1, 10\n                !$acc atomic\n                  totals(x) = totals(x) .OR. a(x, y)\n                !$acc end atomic\n              END DO\n            END DO\n          !$acc end parallel\n        !$acc end data\n\n        DO x = 1, LOOPCOUNT\n          DO y = 1, 10\n            totals_comparison(x) = totals_comparison(x) .OR. a(x, y)\n          END DO\n        END DO\n\n        DO x = 1, LOOPCOUNT\n          IF (totals_comparison(x) .NEQV. totals(x)) THEN\n            errors = errors + 1\n            WRITE(*, *) totals_comparison(x)\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "construct-independent",
                            "atomic"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_x_plus_expr.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:construct-independent,atomic,V:2.0-2.7\n      LOGICAL FUNCTION test1()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x, y !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT, 10):: a !Data\n        REAL(8),DIMENSION(LOOPCOUNT):: totals, totals_comparison\n        INTEGER :: errors = 0\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(a)\n\n        totals = 0\n        totals_comparison = 0\n\n        !$acc data copyin(a(1:LOOPCOUNT, 1:10)) copy(totals(1:LOOPCOUNT))\n          !$acc parallel\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              DO y = 1, 10\n                !$acc atomic\n                  totals(x) = totals(x) + a(x, y)\n              END DO\n            END DO\n          !$acc end parallel\n        !$acc end data\n        DO x = 1, LOOPCOUNT\n          DO y = 1, 10\n            totals_comparison(x) = totals_comparison(x) + a(x, y)\n          END DO\n        END DO\n\n        DO x = 1, LOOPCOUNT\n          IF (totals_comparison(x) .NE. totals(x)) THEN\n            errors = errors + 1\n            WRITE(*, *) totals_comparison(x)\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "construct-independent",
                            "atomic"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_x_plus_expr.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:atomic,construct-independent,V:2.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t *a = (real_t *)malloc(n * sizeof(real_t));\n    real_t *b = (real_t *)malloc(n * sizeof(real_t));\n    real_t *totals = (real_t *)malloc(10 * sizeof(real_t));\n    real_t *totals_comparison = (real_t *)malloc(10 * sizeof(real_t));\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n    }\n    for (int x = 0; x < 10; ++x){\n        totals[x] = 0;\n        totals_comparison[x] = 0;\n    }\n\n    #pragma acc data copyin(a[0:n], b[0:n]) copy(totals[0:10])\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                #pragma acc loop\n                for (int y = 0; y < n; ++y){\n                    #pragma acc atomic\n                        totals[(int) ((a[x] + b[x])/2)] = totals[(int) ((a[x] + b[x])/2)] + a[x] * b[x];\n                }\n            }\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        for (int y = 0; y < n; ++y){\n            totals_comparison[(int) ((a[x] + b[x])/2)] += a[x] * b[x];\n        }\n    }\n    for (int x = 0; x < 10; ++x){\n        if (fabs(totals_comparison[x] - totals[x]) > PRECISION){\n            err += 1;\n            break;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "atomic",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_x_plus_expr_end.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:construct-independent,atomic,V:2.0-2.7\n      LOGICAL FUNCTION test1()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x, y !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT, 10):: a !Data\n        REAL(8),DIMENSION(LOOPCOUNT):: totals, totals_comparison\n        INTEGER :: errors = 0\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(a)\n\n        totals = 0\n        totals_comparison = 0\n\n        !$acc data copyin(a(1:LOOPCOUNT, 1:10)) copy(totals(1:LOOPCOUNT))\n          !$acc parallel\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              DO y = 1, 10\n                !$acc atomic\n                  totals(x) = totals(x) + a(x, y)\n                !$acc end atomic\n              END DO\n            END DO\n          !$acc end parallel\n        !$acc end data\n        DO x = 1, LOOPCOUNT\n          DO y = 1, 10\n            totals_comparison(x) = totals_comparison(x) + a(x, y)\n          END DO\n        END DO\n\n        DO x = 1, LOOPCOUNT\n          IF (totals_comparison(x) .NE. totals(x)) THEN\n            errors = errors + 1\n            WRITE(*, *) totals_comparison(x)\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "construct-independent",
                            "atomic"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_x_rshift_expr.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:atomic,construct-independent,V:2.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    unsigned int *a = (unsigned int *)malloc(n * sizeof(int));\n    unsigned int *b = (unsigned int *)malloc(n * sizeof(int));\n\n    for (int x = 0; x < n; ++x){\n        a[x] = 1<<7;\n        for (int y = 0; y < 7; ++y){\n            if ((rand()/(unsigned int) (RAND_MAX)) > .5){\n                b[x] += 1<<y;\n            }\n        }\n    }\n\n    #pragma acc data copyin(b[0:n]) copy(a[0:n])\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                #pragma acc loop\n                for (int y = 0; y < 7; ++y){\n                    if ((b[x]>>y)%2 == 1){\n                        #pragma acc atomic\n                            a[x] = a[x] >> 1;\n                    }\n                }\n            }\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        for (int y = 0; y < 7; ++y){\n            if ((b[x]>>y)%2 == 1){\n                a[x] <<= 1;\n            }\n        }\n        if (a[x] != 1<<7){\n            err += 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "atomic",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_x_times_expr.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:construct-independent,atomic,V:2.0-2.7\n      LOGICAL FUNCTION test1()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x, y !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT, 10):: a !Data\n        REAL(8),DIMENSION(LOOPCOUNT):: totals, totals_comparison\n        INTEGER :: errors = 0\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(a)\n\n        totals = 1\n        totals_comparison = 1\n\n        !$acc data copyin(a(1:LOOPCOUNT, 1:10)) copy(totals(1:LOOPCOUNT))\n          !$acc parallel\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              DO y = 1, 10\n                !$acc atomic\n                  totals(x) = totals(x) * a(x, y)\n              END DO\n            END DO\n          !$acc end parallel\n        !$acc end data\n        DO x = 1, LOOPCOUNT\n          DO y = 1, 10\n            totals_comparison(x) = totals_comparison(x) * a(x, y)\n          END DO\n        END DO\n\n        DO x = 1, LOOPCOUNT\n          IF (totals_comparison(x) .NE. totals(x)) THEN\n            errors = errors + 1\n            WRITE(*, *) totals_comparison(x)\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "construct-independent",
                            "atomic"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_x_times_expr_end.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:construct-independent,atomic,V:2.0-2.7\n      LOGICAL FUNCTION test1()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x, y !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT, 10):: a !Data\n        REAL(8),DIMENSION(LOOPCOUNT):: totals, totals_comparison\n        INTEGER :: errors = 0\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(a)\n\n        totals = 1\n        totals_comparison = 1\n\n        !$acc data copyin(a(1:LOOPCOUNT, 1:10)) copy(totals(1:LOOPCOUNT))\n          !$acc parallel\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              DO y = 1, 10\n                !$acc atomic\n                  totals(x) = totals(x) * a(x, y)\n                !$acc end atomic\n              END DO\n            END DO\n          !$acc end parallel\n        !$acc end data\n        DO x = 1, LOOPCOUNT\n          DO y = 1, 10\n            totals_comparison(x) = totals_comparison(x) * a(x, y)\n          END DO\n        END DO\n\n        DO x = 1, LOOPCOUNT\n          IF (totals_comparison(x) .NE. totals(x)) THEN\n            errors = errors + 1\n            WRITE(*, *) totals_comparison(x)\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "construct-independent",
                            "atomic"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "data_copy_no_lower_bound.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:data,data_region,construct-independent,V:1.0-2.7\n      LOGICAL FUNCTION test1()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT):: a, b, c !Data\n        INTEGER :: errors = 0\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(a)\n        CALL RANDOM_NUMBER(b)\n        c = 0\n\n        !$acc data copyin(a(1:LOOPCOUNT), b(1:LOOPCOUNT)) copy(c(:LOOPCOUNT))\n          !$acc parallel\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              c(x) = c(x) + a(x) + b(x)\n            END DO\n          !$acc end parallel\n        !$acc end data\n        DO x = 1, LOOPCOUNT\n          IF (abs(c(x) - (a(x) + b(x))) .gt. PRECISION) THEN\n            errors = errors + 1\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "data",
                            "data_region",
                            "construct-independent"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "data_copy_no_lower_bound.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:data,data-region,construct-independent,V:1.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n    real_t * c = (real_t *)malloc(n * sizeof(real_t));\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n        c[x] = 0.0;\n    }\n\n    #pragma acc data copyin(a[0:n], b[0:n]) copy(c[:n])\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                c[x] += a[x] + b[x];\n            }\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        if (fabs(c[x] - (a[x] + b[x])) > PRECISION){\n            err += 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "data",
                            "data-region",
                            "construct-independent"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "data_copyin_no_lower_bound.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:data,data_region,construct-independent,V:1.0-2.7\n      LOGICAL FUNCTION test1()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT):: a, b, c !Data\n        INTEGER :: errors = 0\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(a)\n        CALL RANDOM_NUMBER(b)\n        c = 0\n\n        !$acc data copyin(a(:LOOPCOUNT), b(:LOOPCOUNT)) copyout(c(1:LOOPCOUNT))\n          !$acc parallel\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              c(x) = a(x) + b(x)\n            END DO\n          !$acc end parallel\n        !$acc end data\n\n        DO x = 1, LOOPCOUNT\n          IF (abs(c(x) - (a(x) + b(x))) .gt. PRECISION) THEN\n            errors = errors + 1\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "data",
                            "data_region",
                            "construct-independent"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "data_copyin_no_lower_bound.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:data,data-region,construct-independent,V:1.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n    real_t * c = (real_t *)malloc(n * sizeof(real_t));\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n        c[x] = 0.0;\n    }\n\n    #pragma acc data copyin(a[:n], b[:n]) copyout(c[0:n])\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                c[x] = a[x] + b[x];\n            }\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        if (fabs(c[x] - (a[x] + b[x])) > PRECISION){\n            err += 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "data",
                            "data-region",
                            "construct-independent"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "data_copyout_no_lower_bound.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:data,data_region,construct-independent,V:1.0-2.7\n      LOGICAL FUNCTION test1()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT):: a, b, c !Data\n        INTEGER :: errors = 0\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(a)\n        CALL RANDOM_NUMBER(b)\n        c = 0\n\n        !$acc data copyin(a(1:LOOPCOUNT), b(1:LOOPCOUNT)) copyout(c(:LOOPCOUNT))\n          !$acc parallel\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              c(x) = a(x) + b(x)\n            END DO\n          !$acc end parallel\n        !$acc end data\n        DO x = 1, LOOPCOUNT\n          IF (abs(c(x) - (a(x) + b(x))) .gt. PRECISION) THEN\n            errors = errors + 1\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "data",
                            "data_region",
                            "construct-independent"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "data_copyout_no_lower_bound.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:data,data-region,construct-independent,V:1.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n    real_t * c = (real_t *)malloc(n * sizeof(real_t));\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n        c[x] = 0.0;\n    }\n\n    #pragma acc data copyin(a[0:n], b[0:n]) copyout(c[:n])\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                c[x] = a[x] + b[x];\n            }\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        if (fabs(c[x] - (a[x] + b[x])) > PRECISION){\n            err += 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "data",
                            "data-region",
                            "construct-independent"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "data_copyout_reference_counts.F90": {
                "num tests": 3,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:data,data_region,devonly,construct-independent,V:2.0-2.7\n      LOGICAL FUNCTION test1()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT):: a, b, c !Data\n        INTEGER :: errors = 0\n        INTEGER,DIMENSION(1)::devtest\n\n        devtest(1) = 1\n        !$acc enter data copyin(devtest(1:1))\n        !$acc parallel present(devtest(1:1))\n          devtest(1) = 0\n        !$acc end parallel\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        IF (devtest(1) .eq. 1) THEN\n          CALL RANDOM_NUMBER(a)\n          CALL RANDOM_NUMBER(b)\n          c = 0\n          !$acc data copyin(c(1:LOOPCOUNT))\n            !$acc data copyin(a(1:LOOPCOUNT), b(1:LOOPCOUNT)) copyout(c(1:LOOPCOUNT))\n              !$acc parallel\n                !$acc loop\n                DO x = 1, LOOPCOUNT\n                  c(x) = c(x) + a(x) + b(x)\n                END DO\n              !$acc end parallel\n            !$acc end data\n          !$acc end data\n\n          DO x = 1, LOOPCOUNT\n            IF (abs(c(x)) .gt. PRECISION) THEN\n              errors = errors + 1\n              EXIT\n            END IF\n          END DO\n        END IF\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "data",
                            "data_region",
                            "devonly",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "2": {
                        "content": "#ifndef T2\n!T2:data,data_region,devonly,construct-independent,V:2.0-2.7\n      LOGICAL FUNCTION test2()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT):: a, b, c !Data\n        INTEGER :: errors = 0\n        INTEGER,DIMENSION(1)::devtest\n\n        devtest(1) = 1\n        !$acc enter data copyin(devtest(1:1))\n        !$acc parallel present(devtest(1:1))\n          devtest(1) = 0\n        !$acc end parallel\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(a)\n        CALL RANDOM_NUMBER(b)\n        c = 0\n\n        !$acc enter data copyin(c(1:LOOPCOUNT))\n        !$acc data copyin(a(1:LOOPCOUNT), b(1:LOOPCOUNT)) copyout(c(1:LOOPCOUNT))\n          !$acc parallel\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              c(x) = c(x) + a(x) + b(x)\n            END DO\n          !$acc end parallel\n        !$acc end data\n        IF (devtest(1) .eq. 1) THEN\n          DO x = 1, LOOPCOUNT\n            IF (abs(c(x)) .gt. PRECISION) THEN\n              errors = errors + 2\n              EXIT\n            END IF\n          END DO\n        END IF\n        !$acc exit data copyout(c(1:LOOPCOUNT))\n        DO x = 1, LOOPCOUNT\n          IF (abs(c(x) - (a(x) + b(x))) .gt. PRECISION) THEN\n            errors = errors + 4\n            EXIT\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test2 = .FALSE.\n        ELSE\n          test2 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T2\n        LOGICAL :: test2\n#endif\n#ifndef T2\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test2()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 1\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "data",
                            "data_region",
                            "devonly",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "3": {
                        "content": "#ifndef T3\n!T3:data,data_region,devonly,construct-independent,V:2.0-2.7\n      LOGICAL FUNCTION test3()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT):: a, b, c !Data\n        INTEGER :: errors = 0\n        INTEGER,DIMENSION(1)::devtest\n\n        devtest(1) = 1\n        !$acc enter data copyin(devtest(1:1))\n        !$acc parallel present(devtest(1:1))\n          devtest(1) = 0\n        !$acc end parallel\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(a)\n        CALL RANDOM_NUMBER(b)\n        c = 0\n\n        !$acc enter data copyin(c(1:LOOPCOUNT))\n        !$acc data copyin(a(1:LOOPCOUNT), b(1:LOOPCOUNT)) copyout(c(1:LOOPCOUNT))\n          !$acc parallel\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              c(x) = c(x) + a(x) + b(x)\n            END DO\n          !$acc end parallel\n          !$acc exit data delete(c(1:LOOPCOUNT))\n        !$acc end data\n\n        DO x = 1, LOOPCOUNT\n          IF (abs(c(x) - (a(x) + b(x))) .gt. PRECISION) THEN\n            errors = errors + 8\n            EXIT\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test3 = .FALSE.\n        ELSE\n          test3 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T3\n        LOGICAL :: test3\n#endif\n#ifndef T3\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test3()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 2\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "data",
                            "data_region",
                            "devonly",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "data_copyout_reference_counts.c": {
                "num tests": 3,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:data,data-region,reference-counting,devonly,construct-independent,V:2.5-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n    real_t * c = (real_t *)malloc(n * sizeof(real_t));\n    int * devtest = (int *)malloc(sizeof(int));\n    devtest[0] = 1;\n    #pragma acc enter data copyin(devtest[0:1])\n    #pragma acc parallel present(devtest[0:1])\n    {\n      devtest[0] = 0;\n    }\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n        c[x] = 0.0;\n    }\n\n\n    if (devtest[0] == 1) {\n        #pragma acc data copyin(c[0:n])\n        {\n            #pragma acc data copyin(a[0:n], b[0:n]) copyout(c[0:n])\n            {\n                #pragma acc parallel\n                {\n                    #pragma acc loop\n                    for (int x = 0; x < n; ++x){\n                        c[x] += a[x] + b[x];\n                    }\n                }\n            }\n            for (int x = 0; x < n; ++x){\n                if (fabs(c[x]) > PRECISION){\n                    err += 1;\n                    break;\n                }\n            }\n        }\n        for (int x = 0; x < n; ++x){\n            if (fabs(c[x]) > PRECISION){\n                err += 1;\n                break;\n            }\n        }\n\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "data",
                            "data-region",
                            "reference-counting",
                            "devonly",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "2": {
                        "content": "#ifndef T2\n//T2:data,data-region,reference-counting,construct-independent,V:2.5-2.7\nint test2(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n    real_t * c = (real_t *)malloc(n * sizeof(real_t));\n    int * devtest = (int *)malloc(sizeof(int));\n    devtest[0] = 1;\n    #pragma acc enter data copyin(devtest[0:1])\n    #pragma acc parallel present(devtest[0:1])\n    {\n      devtest[0] = 0;\n    }\n\n    for (int x = 0; x < n; ++x){\n      a[x] = rand() / (real_t)(RAND_MAX / 10);\n      b[x] = rand() / (real_t)(RAND_MAX / 10);\n      c[x] = 0.0;\n    }\n\n    #pragma acc enter data copyin(c[0:n])\n    #pragma acc data copyin(a[0:n], b[0:n]) copyout(c[0:n])\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                c[x] += a[x] + b[x];\n            }\n        }\n    }\n    if (devtest[0] == 1){\n        for (int x = 0; x < n; ++x){\n            if (fabs(c[x]) > PRECISION){\n                err += 1;\n                break;\n            }\n        }\n    }\n    #pragma acc exit data copyout(c[0:n])\n    for (int x = 0; x < n; ++x){\n        if (fabs(c[x] - (a[x] + b[x])) > PRECISION){\n            err += 1;\n            break;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T2\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test2();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 1);\n    }\n#endif\n",
                        "tags": [
                            "data",
                            "data-region",
                            "reference-counting",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "3": {
                        "content": "#ifndef T3\n//T3:data,data-region,construct-independent,V:2.5-2.7\nint test3(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n    real_t * c = (real_t *)malloc(n * sizeof(real_t));\n    int * devtest = (int *)malloc(sizeof(int));\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n        c[x] = 0.0;\n    }\n\n    #pragma acc enter data copyin(c[0:n])\n    #pragma acc data copyin(a[0:n], b[0:n]) copyout(c[0:n])\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                c[x] += a[x] + b[x];\n            }\n        }\n        #pragma acc exit data delete(c[0:n])\n    }\n    for (int x = 0; x < n; ++x){\n        if (fabs(c[x] - (a[x] + b[x])) > PRECISION){\n            err += 1;\n            break;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T3\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test3();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 2);\n    }\n#endif\n",
                        "tags": [
                            "data",
                            "data-region",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "data_create.F90": {
                "num tests": 3,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:data,data_region,construct-independent,V:1.0-2.7\n      LOGICAL FUNCTION test1()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT):: a, b, c !Data\n        INTEGER :: errors = 0\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(a)\n        b = 0\n        c = 0 \n\n        !$acc data create(b(1:LOOPCOUNT))\n          !$acc data copyin(a(1:LOOPCOUNT))\n            !$acc parallel\n              !$acc loop\n              DO x = 1, LOOPCOUNT\n                b(x) = a(x)\n              END DO\n            !$acc end parallel\n          !$acc end data\n          !$acc data copyout(c(1:LOOPCOUNT))\n            !$acc parallel\n              !$acc loop\n              DO x = 1, LOOPCOUNT\n                c(x) = b(x)\n              END DO\n            !$acc end parallel\n          !$acc end data\n        !$acc end data\n\n        DO x = 1, LOOPCOUNT\n          IF (abs(a(x) - c(x)) .gt. PRECISION) THEN\n            errors = errors + 1\n            EXIT\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "data",
                            "data_region",
                            "construct-independent"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "2": {
                        "content": "#ifndef T2\n!T2:data,data_region,construct-independent,V:1.0-2.7\n      LOGICAL FUNCTION test2()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT):: a, b, c !Data\n        INTEGER :: errors = 0\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(a)\n        b = 0\n        c = 0\n \n        !$acc data present_or_create(b(1:LOOPCOUNT))\n          !$acc data copyin(a(1:LOOPCOUNT))\n            !$acc parallel\n              !$acc loop\n              DO x = 1, LOOPCOUNT\n                b(x) = a(x)\n              END DO\n            !$acc end parallel\n          !$acc end data\n          !$acc data copyout(c(1:LOOPCOUNT))\n            !$acc parallel\n              !$acc loop\n              DO x = 1, LOOPCOUNT\n                c(x) = b(x)\n              END DO\n            !$acc end parallel\n          !$acc end data\n        !$acc end data\n \n        DO x = 1, LOOPCOUNT\n          IF (abs(a(x) - c(x)) .gt. PRECISION) THEN\n            errors = errors + 2\n            EXIT\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test2 = .FALSE.\n        ELSE\n          test2 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T2\n        LOGICAL :: test2\n#endif\n#ifndef T2\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test2()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 1\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "data",
                            "data_region",
                            "construct-independent"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "3": {
                        "content": "#ifndef T3\n!T3:data,data_region,construct-independent,V:1.0-2.7\n      LOGICAL FUNCTION test3()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT):: a, b, c !Data\n        INTEGER :: errors = 0\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(a)\n        b = 0\n        c = 0\n \n        !$acc data pcreate(b(1:LOOPCOUNT))\n          !$acc data copyin(a(1:LOOPCOUNT))\n            !$acc parallel\n              !$acc loop\n              DO x = 1, LOOPCOUNT\n                b(x) = a(x)\n              END DO\n            !$acc end parallel\n          !$acc end data\n          !$acc data copyout(c(1:LOOPCOUNT))\n            !$acc parallel\n              !$acc loop\n              DO x = 1, LOOPCOUNT\n                c(x) = b(x)\n              END DO\n            !$acc end parallel\n          !$acc end data\n        !$acc end data\n     \n        DO x = 1, LOOPCOUNT\n          IF (abs(a(x) - c(x)) .gt. PRECISION) THEN\n            errors = errors + 4\n            EXIT\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test3 = .FALSE.\n        ELSE\n          test3 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T3\n        LOGICAL :: test3\n#endif\n#ifndef T3\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test3()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 2\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "data",
                            "data_region",
                            "construct-independent"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "data_create.c": {
                "num tests": 3,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:data,data-region,construct-independent,V:1.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n    real_t * c = (real_t *)malloc(n * sizeof(real_t));\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = 0.0;\n        c[x] = 0.0;\n    }\n\n    #pragma acc data create(b[0:n])\n    {\n        #pragma acc data copyin(a[0:n])\n        {\n            #pragma acc parallel\n            {\n                #pragma acc loop\n                for (int x = 0; x < n; ++x){\n                    b[x] = a[x];\n                }\n            }\n        }\n        #pragma acc data copyout(c[0:n])\n        {\n            #pragma acc parallel\n            {\n                #pragma acc loop\n                for (int x = 0; x < n; ++x){\n                    c[x] = b[x];\n                }\n            }\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        if (fabs(c[x] - a[x]) > PRECISION) {\n            err += 1;\n            break;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "data",
                            "data-region",
                            "construct-independent"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "2": {
                        "content": "#ifndef T2\n//T2:data,data-region,construct-independent,compatibility-features,V:1.0-2.7\nint test2(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n    real_t * c = (real_t *)malloc(n * sizeof(real_t));\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = 0.0;\n        c[x] = 0.0;\n    }\n\n    #pragma acc data present_or_create(b[0:n])\n    {\n        #pragma acc data copyin(a[0:n])\n        {\n            #pragma acc parallel\n            {\n                #pragma acc loop\n                for (int x = 0; x < n; ++x){\n                    b[x] = a[x];\n                }\n            }\n        }\n        #pragma acc data copyout(c[0:n])\n        {\n            #pragma acc parallel\n            {\n                #pragma acc loop\n                for (int x = 0; x < n; ++x){\n                    c[x] = a[x];\n                }\n            }\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        if (fabs(c[x] - a[x]) > PRECISION) {\n            err += 2;\n            break;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T2\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test2();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 1);\n    }\n#endif\n",
                        "tags": [
                            "data",
                            "data-region",
                            "construct-independent",
                            "compatibility-features"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "3": {
                        "content": "#ifndef T3\n//T3:data,data-region,construct-independent,compatibility-features,V:1.0-2.7\nint test3(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n    real_t * c = (real_t *)malloc(n * sizeof(real_t));\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = 0.0;\n        c[x] = 0.0;\n    }\n\n    #pragma acc data pcreate(b[0:n])\n    {\n        #pragma acc data copyin(a[0:n])\n        {\n            #pragma acc parallel\n            {\n                #pragma acc loop\n                for (int x = 0; x < n; ++x){\n                    b[x] = a[x];\n                }\n            }\n        }\n        #pragma acc data copyout(c[0:n])\n        {\n            #pragma acc parallel\n            {\n                #pragma acc loop\n                for (int x = 0; x < n; ++x){\n                    c[x] = b[x];\n                }\n            }\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        if (fabs(c[x] - a[x]) > PRECISION){\n            err += 4;\n            break;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T3\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test3();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 2);\n    }\n#endif\n",
                        "tags": [
                            "data",
                            "data-region",
                            "construct-independent",
                            "compatibility-features"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "data_create_no_lower_bound.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:data,data_region,construct-independent,V:1.0-2.7\n      LOGICAL FUNCTION test1()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT):: a, b, c, d, e !Data\n        INTEGER :: errors = 0\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(a)\n        CALL RANDOM_NUMBER(b)\n        c = 0\n        CALL RANDOM_NUMBER(d)\n        e = 0\n\n        !$acc data copyin(a(1:LOOPCOUNT), b(1:LOOPCOUNT), d(1:LOOPCOUNT)) create(c(:LOOPCOUNT)) copyout(e(1:LOOPCOUNT))\n          !$acc parallel\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              c(x) = a(x) + b(x)\n            END DO\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              e(x) = c(x) + d(x)\n            END DO\n          !$acc end parallel\n        !$acc end data\n        DO x = 1, LOOPCOUNT\n          IF (abs(e(x) - (a(x) + b(x) + d(x))) .gt. PRECISION) THEN\n            errors = errors + 1\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "data",
                            "data_region",
                            "construct-independent"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "data_create_no_lower_bound.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:data,data-region,construct-independent,V:1.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n    real_t * c = (real_t *)malloc(n * sizeof(real_t));\n    real_t * d = (real_t *)malloc(n * sizeof(real_t));\n    real_t * e = (real_t *)malloc(n * sizeof(real_t));\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n        c[x] = 0.0;\n        d[x] = rand() / (real_t)(RAND_MAX / 10);\n        e[x] = 0.0;\n    }\n\n    #pragma acc data copyin(a[0:n], b[0:n], d[0:n]) create(c[:n]) copyout(e[0:n])\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                c[x] = a[x] + b[x];\n            }\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                e[x] = c[x] + d[x];\n            }\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        if (fabs(e[x] - (a[x] + b[x] + d[x])) > PRECISION){\n            err += 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "data",
                            "data-region",
                            "construct-independent"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "data_present_no_lower_bound.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:data,data_region,construct-independent,present,V:2.0-2.7\n      LOGICAL FUNCTION test1()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT):: a, b, c !Data\n        INTEGER :: errors = 0\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(a)\n        CALL RANDOM_NUMBER(b)\n        c = 0\n \n        !$acc enter data copyin(c(1:LOOPCOUNT))\n        !$acc data copyin(a(1:LOOPCOUNT), b(1:LOOPCOUNT)) present(c(:LOOPCOUNT))\n          !$acc parallel\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              c(x) = a(x) + b(x)\n            END DO\n          !$acc end parallel\n        !$acc end data\n        !$acc exit data copyout(c(1:LOOPCOUNT))\n        DO x = 1, LOOPCOUNT\n          IF (abs(c(x) - (a(x) + b(x))) .gt. PRECISION) THEN\n            errors = errors + 1\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "data",
                            "data_region",
                            "construct-independent",
                            "present"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "data_present_no_lower_bound.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:data,data-region,construct-independent,V:1.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n    real_t * c = (real_t *)malloc(n * sizeof(real_t));\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n        c[x] = 0.0;\n    }\n\n    #pragma acc enter data copyin(c[0:n])\n    #pragma acc data copyin(a[0:n], b[0:n]) present(c[:n])\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                c[x] += a[x] + b[x];\n            }\n        }\n    }\n    #pragma acc exit data copyout(c[0:n])\n\n    for (int x = 0; x < n; ++x){\n        if (fabs(c[x] - (a[x] + b[x])) > PRECISION){\n            err += 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "data",
                            "data-region",
                            "construct-independent"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "data_with_changing_subscript.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:data,data_region,construct-independent,V:1.0-2.7\n      LOGICAL FUNCTION test1()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x, indexer !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT):: a, b, c !Data\n        INTEGER :: errors = 0\n\n        indexer = LOOPCOUNT\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(a)\n        CALL RANDOM_NUMBER(b)\n        c = 0\n\n        !$acc data copyin(a(1:indexer), b(1:indexer)) copyout(c(1:indexer))\n          !$acc parallel\n            !$acc loop\n            DO x = 1, indexer\n              c(x) = a(x) + b(x)\n            END DO\n            indexer = 1\n          !$acc end parallel\n        !$acc end data\n        DO x = 1, LOOPCOUNT\n          IF (abs(c(x) - (a(x) + b(x))) .gt. PRECISION) THEN\n            errors = errors + 1\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "data",
                            "data_region",
                            "construct-independent"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "data_with_changing_subscript.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:data,data-region,construct-independent,V:2.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    int length = n;\n    real_t * a = (real_t *)malloc(n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n    real_t * c = (real_t *)malloc(n * sizeof(real_t));\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n        c[x] = 0.0;\n    }\n\n    #pragma acc data copyin(a[0:length], b[0:length]) copyout(c[0:length])\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < length; ++x){\n                c[x] = a[x] + b[x];\n            }\n        }\n        length = 1;\n    }\n\n    for (int x = 0; x < n; ++x){\n        if (fabs(c[x] - (a[x] + b[x])) > PRECISION){\n            err += 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "data",
                            "data-region",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "data_with_derived_type.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:data,data_region,construct-independent,V:1.0-2.7\n      LOGICAL FUNCTION test1()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        TYPE multi_item\n          REAL(8) :: a\n          REAL(8) :: b\n          REAL(8) :: c\n        END TYPE multi_item\n        INTEGER :: x !Iterators\n        TYPE (multi_item),DIMENSION(LOOPCOUNT):: a !Data\n        INTEGER :: errors = 0\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        DO x = 1, LOOPCOUNT\n          CALL RANDOM_NUMBER(a(x)%a)\n          CALL RANDOM_NUMBER(a(x)%b)\n          a(x)%c = 0.0\n        END DO\n\n        !$acc data copy(a(1:LOOPCOUNT))\n          !$acc parallel\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              a(x)%c = a(x)%a + a(x)%b\n            END DO\n          !$acc end parallel\n        !$acc end data\n        DO x = 1, LOOPCOUNT\n          IF (abs(a(x)%c - (a(x)%a + a(x)%b)) .gt. PRECISION) THEN\n            errors = errors + 1\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "data",
                            "data_region",
                            "construct-independent"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "data_with_structs.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:data,data-region,construct-independent,V:1.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    multi_item * a = (multi_item *)malloc(n * sizeof(multi_item));\n\n    for (int x = 0; x < n; ++x){\n        a[x].a = rand() / (real_t)(RAND_MAX / 10);\n        a[x].b = rand() / (real_t)(RAND_MAX / 10);\n        a[x].c = rand() / (real_t)(RAND_MAX / 10);\n    }\n\n    #pragma acc data copy(a[0:n])\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                a[x].c = a[x].a + a[x].b;\n            }\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        if (fabs(a[x].c - (a[x].a + a[x].b)) > PRECISION){\n            err += 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "data",
                            "data-region",
                            "construct-independent"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "declare_copyin.F90": {
                "num tests": 4,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:construct-independent,declare,V:2.0-2.7\n      LOGICAL FUNCTION test1()\n  USE OPENACC\n  USE DECLARE_COPYIN_MOD\n  IMPLICIT NONE\n  INCLUDE \"acc_testsuite.Fh\"\n  INTEGER :: errors = 0\n  INTEGER :: mult = 2\n  INTEGER :: x\n  REAL(8),DIMENSION(LOOPCOUNT) :: a, b\n\n  SEEDDIM(1) = 1\n# ifdef SEED\n  SEEDDIM(1) = SEED\n# endif\n  CALL RANDOM_SEED(PUT=SEEDDIM)\n\n  CALL RANDOM_NUMBER(a)\n  b = 0\n\n  !$acc data copyin(a(1:LOOPCOUNT)) copyout(b(1:LOOPCOUNT)) present(fixed_size_array)\n    !$acc parallel\n      !$acc loop\n      DO x = 1, LOOPCOUNT\n        b(x) = a(x) + fixed_size_array(MOD(x, 10))\n      END DO\n    !$acc end parallel\n  !$acc end data\n\n  DO x = 1, LOOPCOUNT\n    IF (abs(b(x) - (a(x) + fixed_size_array(MOD(x, 10)))) .gt. PRECISION) THEN\n      errors = errors + 1\n    END IF\n  END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "construct-independent",
                            "declare"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "2": {
                        "content": "#ifndef T2\n!T2:construct-independent,declare,V:1.0-2.7\n      LOGICAL FUNCTION test2()\n  USE OPENACC\n  USE DECLARE_COPYIN_MOD\n  IMPLICIT NONE\n  INCLUDE \"acc_testsuite.Fh\"\n  INTEGER :: errors = 0\n  INTEGER :: mult = 2\n  REAL(8),DIMENSION(LOOPCOUNT) :: a, b\n\n  SEEDDIM(1) = 1\n# ifdef SEED\n  SEEDDIM(1) = SEED\n# endif\n  CALL RANDOM_SEED(PUT=SEEDDIM)\n\n  CALL RANDOM_NUMBER(a)\n  b = 0\n\n  !$acc data copyin(a(1:LOOPCOUNT)) copyout(b(1:LOOPCOUNT)) present(scalar)\n    !$acc parallel\n      !$acc loop\n      DO x = 1, LOOPCOUNT\n        b(x) = a(x) + scalar\n      END DO\n    !$acc end parallel\n  !$acc end data\n\n  DO x = 1, LOOPCOUNT\n    IF (abs(b(x) - (a(x) + scalar)) .gt. PRECISION) THEN\n      errors = errors + 1\n    END IF\n  END DO\n\n        IF (errors .eq. 0) THEN\n          test2 = .FALSE.\n        ELSE\n          test2 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T2\n        LOGICAL :: test2\n#endif\n#ifndef T2\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test2()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 1\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "construct-independent",
                            "declare"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "3": {
                        "content": "#ifndef T3\n!T3:construct-independent,declare,V:1.0-2.7\n      LOGICAL FUNCTION test3()\n  USE OPENACC\n  USE DECLARE_COPYIN_MOD\n  IMPLICIT NONE\n  INCLUDE \"acc_testsuite.Fh\"\n  INTEGER :: errors = 0\n  INTEGER :: mult = 2\n  REAL(8),DIMENSION(LOOPCOUNT) :: a, b\n\n  SEEDDIM(1) = 1\n# ifdef SEED\n  SEEDDIM(1) = SEED\n# endif\n  CALL RANDOM_SEED(PUT=SEEDDIM)\n\n  CALL RANDOM_NUMBER(a)\n  b = a\n\n  !$acc data copy(a(1:LOOPCOUNT))\n    !$acc parallel\n      !$acc loop\n      DO x = 1, 1\n        CALL externMultiplyData(a, LOOPCOUNT)\n      END DO\n    !$acc end parallel\n  !$acc end data\n\n  DO x = 1, LOOPCOUNT\n    IF (abs(a(x) - (b(x) * 2)) .gt. PRECISION) THEN\n      errors = errors + 1\n    END IF\n  END DO\n\n        IF (errors .eq. 0) THEN\n          test3 = .FALSE.\n        ELSE\n          test3 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T3\n        LOGICAL :: test3\n#endif\n#ifndef T3\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test3()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 2\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "construct-independent",
                            "declare"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "4": {
                        "content": "#ifndef T4\n!T4:construct-independent,declare,V:1.0-2.7\n      LOGICAL FUNCTION test4()\n  USE OPENACC\n  USE DECLARE_COPYIN_MOD\n  IMPLICIT NONE\n  INCLUDE \"acc_testsuite.Fh\"\n  INTEGER :: errors = 0\n  INTEGER :: mult = 2\n  REAL(8),DIMENSION(LOOPCOUNT) :: a, b\n\n  SEEDDIM(1) = 1\n# ifdef SEED\n  SEEDDIM(1) = SEED\n# endif\n  CALL RANDOM_SEED(PUT=SEEDDIM)\n\n  CALL RANDOM_NUMBER(a)\n  b = a\n\n  !$acc data copy(a(1:LOOPCOUNT))\n    !$acc parallel\n      !$acc loop\n      DO x = 1, 1\n        CALL multiplyData(a)\n      END DO\n    !$acc end parallel\n  !$acc end data\n\n  DO x = 1, LOOPCOUNT\n    IF (abs(a(x) - (b(x) * 2)) .gt. PRECISION) THEN\n      errors = errors + 1\n    END IF\n  END DO\n\n        IF (errors .eq. 0) THEN\n          test4 = .FALSE.\n        ELSE\n          test4 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T4\n        LOGICAL :: test4\n#endif\n#ifndef T4\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test4()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 3\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "construct-independent",
                            "declare"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "declare_copyin.c": {
                "num tests": 5,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:declare,construct-independent,V:1.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n    int mult = 2;\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = 0;\n    }\n    #pragma acc data copyin(a[0:n]) copyout(b[0:n]) present(fixed_size_array)\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                b[x] = a[x] + fixed_size_array[x%10];\n            }\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        if (fabs(b[x] - (a[x] + fixed_size_array[x%10])) > PRECISION){\n            err += 1;\n            break;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "declare",
                            "construct-independent"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "2": {
                        "content": "#ifndef T2\n//T2:declare,construct-independent,V:1.0-2.7\nint test2(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n    int mult = 2;\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = 0;\n    }\n\n    #pragma acc data copyin(a[0:n]) copyout(b[0:n]) present(scalar)\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                b[x] = a[x] + scalar;\n            }\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        if (fabs(b[x] - (a[x] + scalar)) > PRECISION){\n            err += 1;\n            break;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T2\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test2();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 1);\n    }\n#endif\n",
                        "tags": [
                            "declare",
                            "construct-independent"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "3": {
                        "content": "#ifndef T3\n//T3:declare,construct-independent,V:2.0-2.7\nint test3(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n    int mult = 2;\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = a[x];\n    }\n\n    #pragma acc data copy(a[0:n])\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < 1; ++x){\n                extern_multiplyData_copyin(a, n);\n            }\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        if (fabs(a[x] - (b[x] * 2)) > PRECISION){\n            err += 1;\n            break;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T3\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test3();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 2);\n    }\n#endif\n",
                        "tags": [
                            "declare",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "4": {
                        "content": "#ifndef T4\n//T4:declare,construct-independent,V:2.0-2.7\nint test4(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n    int mult = 2;\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = a[x];\n    }\n\n    #pragma acc data copy(a[0:n])\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < 1; ++x){\n                multiplyData(a);\n            }\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        if (fabs(a[x] - (b[x] * 2)) > PRECISION){\n            err += 1;\n            break;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T4\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test4();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 3);\n    }\n#endif\n",
                        "tags": [
                            "declare",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "5": {
                        "content": "#ifndef T5\n//T5:declare,construct-independent,attach,V:2.6-2.7\nint test5(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n    int mult = 2;\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = a[x];\n    }\n\n    datapointer = a;\n    #pragma acc enter data copyin(a[0:n]) attach(datapointer)\n    #pragma acc data present(datapointer[0:n])\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                datapointer[x] = datapointer[x] * 2;\n            }\n        }\n    }\n    #pragma acc exit data copyout(a[0:n])\n\n    for (int x = 0; x < n; ++x){\n        if (fabs(a[x] - (b[x] * 2)) > PRECISION){\n            err += 1;\n            break;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T5\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test5();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 4);\n    }\n#endif\n",
                        "tags": [
                            "declare",
                            "construct-independent",
                            "attach"
                        ],
                        "versions": [
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "declare_copyin_mod.F90": {
                "num tests": 0,
                "tests": {}
            },
            "declare_create.F90": {
                "num tests": 4,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:construct-independent,declare,update,V:2.0-2.7\n      LOGICAL FUNCTION test1()\n  USE OPENACC\n  IMPLICIT NONE\n  INCLUDE \"acc_testsuite.Fh\"\n  INTEGER :: errors = 0\n  INTEGER :: mult = 2\n  REAL(8),DIMENSION(LOOPCOUNT) :: a, b\n\n  SEEDDIM(1) = 1\n# ifdef SEED\n  SEEDDIM(1) = SEED\n# endif\n  CALL RANDOM_SEED(PUT=SEEDDIM)\n\n  CALL RANDOM_NUMBER(a)\n  b = 0\n  !$acc update device(n)\n  !$acc data copyin(a(1:LOOPCOUNT)) copyout(b(1:LOOPCOUNT)) present(fixed_size_array)\n    !$acc parallel\n      !$acc loop\n      DO x = 1, 10\n        fixed_size_array(x) = x * x\n      END DO\n    !$acc end parallel\n    !$acc parallel\n      !$acc loop\n      DO x = 1, LOOPCOUNT\n        b(x) = a(x) + fixed_size_array(MOD(x, 10))\n      END DO\n    !$acc end parallel\n  !$acc end data\n\n  DO x = 1, LOOPCOUNT\n    IF (abs(b(x) - (a(x) + (MOD(x, 10) * MOD(x, 10)))) .gt. PRECISION) THEN\n      errors = errors + 1\n    END IF\n  END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "construct-independent",
                            "declare",
                            "update"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "2": {
                        "content": "#ifndef T2\n!T2:construct-independent,declare,update,V:2.0-2.7\n      LOGICAL FUNCTION test2()\n  USE OPENACC\n  IMPLICIT NONE\n  INCLUDE \"acc_testsuite.Fh\"\n  INTEGER :: errors = 0\n  INTEGER :: mult = 2\n  REAL(8),DIMENSION(LOOPCOUNT) :: a, b\n\n  SEEDDIM(1) = 1\n# ifdef SEED\n  SEEDDIM(1) = SEED\n# endif\n  CALL RANDOM_SEED(PUT=SEEDDIM)\n\n  CALL RANDOM_NUMBER(a)\n  b = 0\n  scalar = 10\n  !$acc update device(scalar)\n  !$acc data copyin(a(1:LOOPCOUNT)) copyout(b(1:LOOPCOUNT)) present(scalar)\n    !$acc parallel\n      !$acc loop\n      DO x = 1, LOOPCOUNT\n        b(x) = a(x) + scalar\n      END DO\n    !$acc end parallel\n  !$acc end data\n\n  DO x = 1, LOOPCOUNT\n    IF (abs(b(x) - (a(x) + scalar)) .gt. PRECISION) THEN\n      errors = errors + 1\n    END IF\n  END DO\n\n        IF (errors .eq. 0) THEN\n          test2 = .FALSE.\n        ELSE\n          test2 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T2\n        LOGICAL :: test2\n#endif\n#ifndef T2\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test2()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 1\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "construct-independent",
                            "declare",
                            "update"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "3": {
                        "content": "#ifndef T3\n!T3:construct-independent,declare,V:2.0-2.7\n      LOGICAL FUNCTION test3()\n  USE OPENACC\n  IMPLICIT NONE\n  INCLUDE \"acc_testsuite.Fh\"\n  INTEGER :: errors = 0\n  INTEGER :: mult = 2\n  REAL(8),DIMENSION(LOOPCOUNT) :: a, b\n\n  SEEDDIM(1) = 1\n# ifdef SEED\n  SEEDDIM(1) = SEED\n# endif\n  CALL RANDOM_SEED(PUT=SEEDDIM)\n\n  CALL RANDOM_NUMBER(a)\n  b = a\n  !$acc update\n  !$acc data copy(a(1:LOOPCOUNT))\n    !$acc parallel\n      !$acc loop\n      DO x = 1, 1\n        CALL externMultiplyData(a, LOOPCOUNT)\n      END DO\n    !$acc end parallel\n  !$acc end data\n\n  DO x = 1, LOOPCOUNT\n    IF (abs(a(x) - (b(x) * 2)) .gt. PRECISION) THEN\n      errors = errors + 1\n    END IF\n  END DO\n\n        IF (errors .eq. 0) THEN\n          test3 = .FALSE.\n        ELSE\n          test3 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T3\n        LOGICAL :: test3\n#endif\n#ifndef T3\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test3()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 2\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "construct-independent",
                            "declare"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "4": {
                        "content": "#ifndef T4\n!T4:construct-independent,declare,V:2.0-2.7\n      LOGICAL FUNCTION test4()\n  USE OPENACC\n  IMPLICIT NONE\n  INCLUDE \"acc_testsuite.Fh\"\n  INTEGER :: errors = 0\n  INTEGER :: mult = 2\n  REAL(8),DIMENSION(LOOPCOUNT) :: a, b\n\n  SEEDDIM(1) = 1\n# ifdef SEED\n  SEEDDIM(1) = SEED\n# endif\n  CALL RANDOM_SEED(PUT=SEEDDIM)\n\n  CALL RANDOM_NUMBER(a)\n  b = a\n\n  !$acc data copy(a(1:LOOPCOUNT))\n    !$acc parallel\n      !$acc loop\n      DO x = 1, 1\n        CALL multiplyData(a)\n      END DO\n    !$acc end parallel\n  !$acc end data\n\n  DO x = 1, LOOPCOUNT\n    IF (abs(a(x) - (b(x) * 2)) .gt. PRECISION) THEN\n      errors = errors + 1\n    END IF\n  END DO\n\n        IF (errors .eq. 0) THEN\n          test4 = .FALSE.\n        ELSE\n          test4 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T4\n        LOGICAL :: test4\n#endif\n#ifndef T4\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test4()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 3\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "construct-independent",
                            "declare"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "declare_create.c": {
                "num tests": 5,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:declare,construct-independent,V:1.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n    int mult = 2;\n    #pragma acc update device(n)\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = 0;\n    }\n\n    #pragma acc data copyin(a[0:n]) copyout(b[0:n]) present(fixed_size_array)\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < 10; ++x){\n                fixed_size_array[x] = x*x;\n            }\n        }\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                b[x] = a[x] + fixed_size_array[x%10];\n            }\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        if (fabs(b[x] - (a[x] + (x%10) * (x%10))) > PRECISION){\n            err += 1;\n            break;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "declare",
                            "construct-independent"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "2": {
                        "content": "#ifndef T2\n//T2:declare,construct-independent,V:1.0-2.7\nint test2(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n    int mult = 2;\n    #pragma acc update device(n)\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = 0;\n    }\n\n    scalar = 10;\n    #pragma acc update device(scalar)\n    #pragma acc data copyin(a[0:n]) copyout(b[0:n])\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                b[x] = a[x] + scalar;\n            }\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        if (fabs(b[x] - (a[x] + 10)) > PRECISION){\n            err += 1;\n            break;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T2\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test2();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 1);\n    }\n#endif\n",
                        "tags": [
                            "declare",
                            "construct-independent"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "3": {
                        "content": "#ifndef T3\n//T3:declare,construct-independent,V:1.0-2.7\nint test3(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n    int mult = 2;\n    #pragma acc update device(n)\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = a[x];\n    }\n\n    #pragma acc update device(mult_create)\n    #pragma acc data copy(a[0:n])\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < 1; ++x){\n                extern_multiplyData_create(a, n);\n            }\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        if (fabs(a[x] - (b[x] * 2)) > PRECISION){\n            err += 1;\n            break;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T3\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test3();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 2);\n    }\n#endif\n",
                        "tags": [
                            "declare",
                            "construct-independent"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "4": {
                        "content": "#ifndef T4\n//T4:declare,construct-independent,V:2.0-2.7\nint test4(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n    int mult = 2;\n    #pragma acc update device(n)\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = a[x];\n    }\n    #pragma acc data copy(a[0:n])\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < 1; ++x){\n                multiplyData(a);\n            }\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        if (fabs(a[x] - (b[x] * 2)) > PRECISION){\n            err += 1;\n            break;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T4\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test4();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 3);\n    }\n#endif\n",
                        "tags": [
                            "declare",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "5": {
                        "content": "#ifndef T5\n//T5:declare,construct-independent,V:2.6-2.7\nint test5(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n    int mult = 2;\n    #pragma acc update device(n)\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = a[x];\n    }\n    datapointer = a;\n\n    #pragma acc data copyin(a[0:n]) attach(datapointer)\n    {\n        #pragma acc parallel present(datapointer[0:n])\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                datapointer[x] = datapointer[x] * 2;\n            }\n        }\n    }\n\n    #pragma acc exit data copyout(a[0:n])\n    for (int x = 0; x < n; ++x){\n        if (fabs(a[x] - (b[x] * 2)) > PRECISION){\n            err += 1;\n            break;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T5\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test5();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 4);\n    }\n#endif\n",
                        "tags": [
                            "declare",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "declare_device_resident.c": {
                "num tests": 3,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:declare,construct-independent,V:1.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n    int mult = 2;\n\n    #pragma acc parallel\n    {\n      mult_device_resident = 2;\n      scalar = 10;\n      for (int x = 0; x < 10; ++x){\n        fixed_size_array[x] = x*x;\n      }\n    }\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = 0;\n    }\n\n    #pragma acc data copyin(a[0:n]) copyout(b[0:n]) present(fixed_size_array)\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < 10; ++x){\n                fixed_size_array[x] = x*x;\n            }\n        }\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                b[x] = a[x] + fixed_size_array[x%10];\n            }\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        if (fabs(b[x] - (a[x] + (x%10) * (x%10))) > PRECISION){\n            err += 1;\n            break;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "declare",
                            "construct-independent"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "2": {
                        "content": "#ifndef T2\n//T2:declare,construct-independent,V:1.0-2.7\nint test2(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n    int mult = 2;\n\n    #pragma acc parallel\n    {\n      mult_device_resident = 2;\n      scalar = 10;\n      for (int x = 0; x < 10; ++x){\n        fixed_size_array[x] = x*x;\n      }\n    }\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = 0;\n    }\n\n    #pragma acc data copyin(a[0:n]) copyout(b[0:n])\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                b[x] = a[x] + scalar;\n            }\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        if (fabs(b[x] - (a[x] + 10)) > PRECISION){\n            err += 1;\n            break;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T2\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test2();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 1);\n    }\n#endif\n",
                        "tags": [
                            "declare",
                            "construct-independent"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "3": {
                        "content": "#ifndef T3\n//T3:declare,construct-independent,V:2.0-2.7\nint test3(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n    int mult = 2;\n\n    #pragma acc parallel\n    {\n      mult_device_resident = 2;\n      scalar = 10;\n      for (int x = 0; x < 10; ++x){\n        fixed_size_array[x] = x*x;\n      }\n    }\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = a[x];\n    }\n\n    #pragma acc data copy(a[0:n])\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < 1; ++x){\n                extern_multiplyData_device_resident(a, n);\n            }\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        if (fabs(a[x] - (b[x] * 2)) > PRECISION){\n            err += 1;\n            break;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T3\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test3();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 2);\n    }\n#endif\n",
                        "tags": [
                            "declare",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "declare_function_scope_copy.F90": {
                "num tests": 4,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:devonly,construct-independent,declare,V:2.0-2.7\n      LOGICAL FUNCTION test1()\n  USE OPENACC\n  IMPLICIT NONE\n  INCLUDE \"acc_testsuite.Fh\"\n  INTEGER :: errors = 0\n  INTEGER :: mult = 2\n  REAL(8),DIMENSION(LOOPCOUNT, LOOPCOUNT) :: a, b, c\n  INTEGER,DIMENSION(1) :: devtest\n  INTEGER :: x, y\n\n  devtest(1) = 1\n  !$acc enter data copyin(devtest(1:1))\n  !$acc parallel present(devtest(1:1))\n    devtest(1) = 0\n  !$acc end parallel\n\n  SEEDDIM(1) = 1\n# ifdef SEED\n  SEEDDIM(1) = SEED\n# endif\n  CALL RANDOM_SEED(PUT=SEEDDIM)\n\n  CALL RANDOM_NUMBER(a)\n  CALL RANDOM_NUMBER(b)\n  c = 1\n  !$acc data copyin(a(1:LOOPCOUNT, 1:LOOPCOUNT), b(1:LOOPCOUNT, 1:LOOPCOUNT))\n    DO x = 1, LOOPCOUNT\n      CALL copyin_copyout_test(a(:,x), b(:,x), c(:,x), LOOPCOUNT)\n    END DO\n  !$acc end data\n  DO x = 1, LOOPCOUNT\n    DO y = 1, LOOPCOUNT\n      IF (abs(c(x, y) - (1 + a(x, y) + b(x, y))) .gt. PRECISION) THEN\n        errors = errors + 1\n      END IF\n    END DO\n  END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "devonly",
                            "construct-independent",
                            "declare"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "2": {
                        "content": "#ifndef T2\n!T2:devonly,construct-independent,declare,V:2.0-2.7\n      LOGICAL FUNCTION test2()\n  USE OPENACC\n  IMPLICIT NONE\n  INCLUDE \"acc_testsuite.Fh\"\n  INTEGER :: errors = 0\n  INTEGER :: mult = 2\n  REAL(8),DIMENSION(LOOPCOUNT, LOOPCOUNT) :: a, b, c\n  INTEGER,DIMENSION(1) :: devtest\n  INTEGER :: x, y\n\n  devtest(1) = 1\n  !$acc enter data copyin(devtest(1:1))\n  !$acc parallel present(devtest(1:1))\n    devtest(1) = 0\n  !$acc end parallel\n\n  SEEDDIM(1) = 1\n# ifdef SEED\n  SEEDDIM(1) = SEED\n# endif\n  CALL RANDOM_SEED(PUT=SEEDDIM)\n\n  CALL RANDOM_NUMBER(a)\n  CALL RANDOM_NUMBER(b)\n  c = 2\n\n  !$acc data copyin(a(1:LOOPCOUNT, 1:LOOPCOUNT), b(1:LOOPCOUNT, 1:LOOPCOUNT))\n    DO x = 1, LOOPCOUNT\n      !$acc data copy(c(1:LOOPCOUNT, x:x))\n        CALL copyin_copyout_test(a(:,x), b(:,x), c(:,x), LOOPCOUNT)\n      !$acc end data\n    END DO\n  !$acc end data\n\n  DO x = 1, LOOPCOUNT\n    DO y = 1, LOOPCOUNT\n      IF (abs(c(x, y) - (2 + a(x, y) + b(x, y))) .gt. PRECISION) THEN\n        errors = errors + 1\n      END IF\n    END DO\n  END DO\n\n        IF (errors .eq. 0) THEN\n          test2 = .FALSE.\n        ELSE\n          test2 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T2\n        LOGICAL :: test2\n#endif\n#ifndef T2\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test2()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 1\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "devonly",
                            "construct-independent",
                            "declare"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "3": {
                        "content": "#ifndef T3\n!T3:devonly,construct-independent,declare,V:2.0-2.7\n      LOGICAL FUNCTION test3()\n  USE OPENACC\n  IMPLICIT NONE\n  INCLUDE \"acc_testsuite.Fh\"\n  INTEGER :: errors = 0\n  INTEGER :: mult = 2\n  REAL(8),DIMENSION(LOOPCOUNT, LOOPCOUNT) :: a, b, c\n  INTEGER,DIMENSION(1) :: devtest\n  INTEGER :: x, y\n\n  devtest(1) = 1\n  !$acc enter data copyin(devtest(1:1))\n  !$acc parallel present(devtest(1:1))\n    devtest(1) = 0\n  !$acc end parallel\n\n  SEEDDIM(1) = 1\n# ifdef SEED\n  SEEDDIM(1) = SEED\n# endif\n  CALL RANDOM_SEED(PUT=SEEDDIM)\n\n  IF (devtest(1) .eq. 1) THEN\n    CALL RANDOM_NUMBER(a)\n    CALL RANDOM_NUMBER(b)\n    c = 3\n\n    !$acc data copyin(a(1:LOOPCOUNT, 1:LOOPCOUNT), b(1:LOOPCOUNT, 1:LOOPCOUNT))\n      DO x = 1, LOOPCOUNT\n        !$acc data copyin(c(1:LOOPCOUNT, x:x))\n          CALL copyin_copyout_test(a(:,x), b(:,x), c(:,x), LOOPCOUNT)\n          DO y = 1, LOOPCOUNT\n            IF (abs(c(y, x) - 3) .gt. PRECISION) THEN\n              errors = errors + 1\n            END IF\n          END DO\n        !$acc end data\n        DO y = 1, LOOPCOUNT\n          IF (abs(c(y, x) - 3) .gt. PRECISION) THEN\n            errors = errors + 1\n          END IF\n        END DO\n      END DO\n    !$acc end data\n  END IF\n\n        IF (errors .eq. 0) THEN\n          test3 = .FALSE.\n        ELSE\n          test3 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T3\n        LOGICAL :: test3\n#endif\n#ifndef T3\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test3()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 2\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "devonly",
                            "construct-independent",
                            "declare"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "4": {
                        "content": "#ifndef T4\n!T4:devonly,construct-independent,declare,V:2.0-2.7\n      LOGICAL FUNCTION test4()\n  USE OPENACC\n  IMPLICIT NONE\n  INCLUDE \"acc_testsuite.Fh\"\n  INTEGER :: errors = 0\n  INTEGER :: mult = 2\n  REAL(8),DIMENSION(LOOPCOUNT, LOOPCOUNT) :: a, b, c\n  INTEGER,DIMENSION(1) :: devtest\n  INTEGER :: x, y\n\n  devtest(1) = 1\n  !$acc enter data copyin(devtest(1:1))\n  !$acc parallel present(devtest(1:1))\n    devtest(1) = 0\n  !$acc end parallel\n\n  SEEDDIM(1) = 1\n# ifdef SEED\n  SEEDDIM(1) = SEED\n# endif\n  CALL RANDOM_SEED(PUT=SEEDDIM)\n\n  IF (devtest(1) .eq. 1) THEN\n    CALL RANDOM_NUMBER(a)\n    CALL RANDOM_NUMBER(b)\n    c = 4\n\n    !$acc data copyin(a(1:LOOPCOUNT, 1:LOOPCOUNT), b(1:LOOPCOUNT, 1:LOOPCOUNT))\n      DO x = 1, LOOPCOUNT\n        !$acc data copy(c(1:LOOPCOUNT, x:x))\n          CALL copyin_copyout_test(a(:,x), b(:,x), c(:,x), LOOPCOUNT)\n          DO y = 1, LOOPCOUNT\n            IF (abs(c(y, x) - 4) .gt. PRECISION) THEN\n              errors = errors + 1\n            END IF\n          END DO\n        !$acc end data\n        DO y = 1, LOOPCOUNT\n          IF (abs(c(y, x) - (4 + a(y, x) + b(y, x))) .gt. PRECISION) THEN\n            errors = errors + 1\n          END IF\n        END DO\n      END DO\n    !$acc end data\n  END IF\n\n        IF (errors .eq. 0) THEN\n          test4 = .FALSE.\n        ELSE\n          test4 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T4\n        LOGICAL :: test4\n#endif\n#ifndef T4\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test4()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 3\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "devonly",
                            "construct-independent",
                            "declare"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "declare_function_scope_copy.c": {
                "num tests": 4,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:declare,construct-independent,V:1.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t ** a = (real_t **)malloc(n * sizeof(real_t));\n    real_t ** b = (real_t **)malloc(n * sizeof(real_t));\n    real_t ** c = (real_t **)malloc(n * sizeof(real_t));\n\n    for (int x = 0; x < n; ++x){\n        a[x] = (real_t *)malloc(n * sizeof(real_t));\n        b[x] = (real_t *)malloc(n * sizeof(real_t));\n        c[x] = (real_t *)malloc(n * sizeof(real_t));\n        for (int y = 0; y < n; ++y){\n            a[x][y] = rand() / (real_t)(RAND_MAX / 10);\n            b[x][y] = rand() / (real_t)(RAND_MAX / 10);\n            c[x][y] = 1;\n        }\n    }\n    #pragma acc data copyin(a[0:n][0:n], b[0:n][0:n])\n    {\n        for (int x = 0; x < n; ++x){\n            copyin_copyout_test(a[x], b[x], c[x]);\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        for (int y = 0; y < n; ++y){\n            if (fabs(c[x][y] - (1 + a[x][y] + b[x][y])) > PRECISION){\n                err += 1;\n            }\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "declare",
                            "construct-independent"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "2": {
                        "content": "#ifndef T2\n//T2:declare,construct-independent,reference-counting,V:2.5-2.7\nint test2(){\n    int err = 0;\n    srand(SEED);\n    real_t ** a = (real_t **)malloc(n * sizeof(real_t));\n    real_t ** b = (real_t **)malloc(n * sizeof(real_t));\n    real_t ** c = (real_t **)malloc(n * sizeof(real_t));\n\n    for (int x = 0; x < n; ++x){\n        for (int y = 0; y < n; ++y){\n            a[x][y] = rand() / (real_t)(RAND_MAX / 10);\n            b[x][y] = rand() / (real_t)(RAND_MAX / 10);\n            c[x][y] = 2;\n        }\n    }\n\n    #pragma acc data copyin(a[0:n][0:n], b[0:n][0:n])\n    {\n        for (int x = 0; x < n; ++x){\n            #pragma acc data copy(c[x:1][0:n])\n            {\n                copyin_copyout_test(a[x], b[x], c[x]);\n            }\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        for (int y = 0; y < n; ++y){\n            if (fabs(c[x][y] - (2 + a[x][y] + b[x][y])) > PRECISION){\n                err += 1;\n            }\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T2\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test2();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 1);\n    }\n#endif\n",
                        "tags": [
                            "declare",
                            "construct-independent",
                            "reference-counting"
                        ],
                        "versions": [
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "3": {
                        "content": "#ifndef T3\n//T3:declare,construct-independent,devonly,reference-counting,V:2.5-2.7\nint test3(){\n    int err = 0;\n    srand(SEED);\n    real_t ** a = (real_t **)malloc(n * sizeof(real_t));\n    real_t ** b = (real_t **)malloc(n * sizeof(real_t));\n    real_t ** c = (real_t **)malloc(n * sizeof(real_t));\n    int *devtest = (int *)malloc(sizeof(int));\n\n    devtest[0] = 1;\n    #pragma acc enter data copyin(devtest[0:1])\n    #pragma acc parallel present(devtest[0:1])\n    {\n        devtest[0] = 0;\n    }\n\n    if (devtest[0] == 1){\n        for (int x = 0; x < n; ++x){\n            for (int y = 0; y < n; ++y){\n                a[x][y] = rand() / (real_t)(RAND_MAX / 10);\n                b[x][y] = rand() / (real_t)(RAND_MAX / 10);\n                c[x][y] = 3;\n            }\n        }\n\n        #pragma acc data copyin(a[0:n][0:n], b[0:n][0:n])\n        {\n            for (int x = 0; x < n; ++x){\n                #pragma acc data copyin(c[x:1][0:n])\n                {\n                    copyin_copyout_test(a[x], b[x], c[x]);\n                    for (int y = 0; y < n; ++y){\n                        if (fabs(c[x][y] - 3) > PRECISION){\n                            err += 1;\n                        }\n                    }\n                }\n                for (int y = 0; y < n; ++y){\n                    if (fabs(c[x][y] - 3) > PRECISION){\n                        err += 1;\n                    }\n                }\n            }\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T3\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test3();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 2);\n    }\n#endif\n",
                        "tags": [
                            "declare",
                            "construct-independent",
                            "devonly",
                            "reference-counting"
                        ],
                        "versions": [
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "4": {
                        "content": "#ifndef T4\n//T4:declare,construct-independent,devonly,reference-counting,V:2.5-2.7\nint test4(){\n    int err = 0;\n    srand(SEED);\n    real_t ** a = (real_t **)malloc(n * sizeof(real_t));\n    real_t ** b = (real_t **)malloc(n * sizeof(real_t));\n    real_t ** c = (real_t **)malloc(n * sizeof(real_t));\n    int *devtest = (int *)malloc(sizeof(int));\n\n    devtest[0] = 1;\n    #pragma acc enter data copyin(devtest[0:1])\n    #pragma acc parallel present(devtest[0:1])\n    {\n        devtest[0] = 0;\n    }\n\n    if (devtest[1] == 1){\n        for (int x = 0; x < n; ++x){\n            for (int y = 0; y < n; ++y){\n                a[x][y] = rand() / (real_t)(RAND_MAX / 10);\n                b[x][y] = rand() / (real_t)(RAND_MAX / 10);\n                c[x][y] = 4;\n            }\n        }\n\n        #pragma acc data copyin(a[0:n][0:n], b[0:n][0:n])\n        {\n            for (int x = 0; x < n; ++x){\n                #pragma acc data copy(c[x:1][0:n])\n                {\n                    copyin_copyout_test(a[x], b[x], c[x]);\n                    for (int y = 0; y < n; ++y){\n                        if (fabs(c[x][y] - 4) > PRECISION){\n                            err += 1;\n                        }\n                    }\n                }\n                for (int y = 0; y < n; ++y){\n                    if (fabs(c[x][y] - (4 + a[x][y] + b[x][y])) > PRECISION){\n                        err += 1;\n                    }\n                }\n            }\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T4\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test4();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 3);\n    }\n#endif\n",
                        "tags": [
                            "declare",
                            "construct-independent",
                            "devonly",
                            "reference-counting"
                        ],
                        "versions": [
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "declare_function_scope_copyin.F90": {
                "num tests": 3,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:devonly,construct-independent,declare,V:2.0-2.7\n      LOGICAL FUNCTION test1()\n  USE OPENACC\n  IMPLICIT NONE\n  INCLUDE \"acc_testsuite.Fh\"\n  INTEGER :: errors = 0\n  INTEGER :: mult = 2\n  REAL(8),DIMENSION(LOOPCOUNT, LOOPCOUNT) :: a, b, c, a_host, b_host\n  INTEGER,DIMENSION(1) :: devtest\n  INTEGER :: x, y\n\n  devtest(1) = 1\n  !$acc enter data copyin(devtest(1:1))\n  !$acc parallel present(devtest(1:1))\n    devtest(1) = 0\n  !$acc end parallel\n\n  SEEDDIM(1) = 1\n# ifdef SEED\n  SEEDDIM(1) = SEED\n# endif\n  CALL RANDOM_SEED(PUT=SEEDDIM)\n\n  CALL RANDOM_NUMBER(a)\n  CALL RANDOM_NUMBER(b)\n  c = 1\n\n  !$acc data copy(c(1:LOOPCOUNT, 1:LOOPCOUNT))\n    DO x = 1, LOOPCOUNT\n      CALL function_test(a(:,x), b(:,x), c(:,x), LOOPCOUNT)\n    END DO\n  !$acc end data\n\n  DO x = 1, LOOPCOUNT\n    DO y = 1, LOOPCOUNT\n      IF (abs(c(x, y) - (1 + a(x, y) + b(x, y))) .gt. PRECISION) THEN\n        errors = errors + 1\n        PRINT*, \"1\"\n      END IF\n    END DO\n  END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "devonly",
                            "construct-independent",
                            "declare"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "2": {
                        "content": "#ifndef T2\n!T2:devonly,construct-independent,declare,V:2.0-2.7\n      LOGICAL FUNCTION test2()\n  USE OPENACC\n  IMPLICIT NONE\n  INCLUDE \"acc_testsuite.Fh\"\n  INTEGER :: errors = 0\n  INTEGER :: mult = 2\n  REAL(8),DIMENSION(LOOPCOUNT, LOOPCOUNT) :: a, b, c, a_host, b_host\n  INTEGER,DIMENSION(1) :: devtest\n  INTEGER :: x, y\n\n  devtest(1) = 1\n  !$acc enter data copyin(devtest(1:1))\n  !$acc parallel present(devtest(1:1))\n    devtest(1) = 0\n  !$acc end parallel\n\n  SEEDDIM(1) = 1\n# ifdef SEED\n  SEEDDIM(1) = SEED\n# endif\n  CALL RANDOM_SEED(PUT=SEEDDIM)\n\n  IF (devtest(1) .eq. 1) THEN\n    CALL RANDOM_NUMBER(a)\n    CALL RANDOM_NUMBER(b)\n    c = 0\n    a_host = a\n    b_host = b\n\n    !$acc data copy(a(1:LOOPCOUNT, 1:LOOPCOUNT), b(1:LOOPCOUNT, 1:LOOPCOUNT), c(1:LOOPCOUNT, 1:LOOPCOUNT))\n      DO x = 1, LOOPCOUNT\n        CALL function_test_dev_only(a(:,x), b(:,x), c(:,x), LOOPCOUNT)\n      END DO\n    !$acc end data\n\n    DO x = 1, LOOPCOUNT\n      DO y = 1, LOOPCOUNT\n        IF (abs(a(x, y) + 1) .gt. PRECISION) THEN\n          errors = errors + 1\n          PRINT*, \"2\"\n        END IF\n        IF (abs(b(x, y) + 1) .gt. PRECISION) THEN\n          errors = errors + 1\n          PRINT*, \"3\"\n        END IF\n        IF (abs(c(x, y) - (a_host(x, y) + b_host(x, y))) .gt. PRECISION) THEN\n          errors = errors + 1\n          PRINT*, \"4\"\n        END IF\n      END DO\n    END DO\n  END IF\n\n        IF (errors .eq. 0) THEN\n          test2 = .FALSE.\n        ELSE\n          test2 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T2\n        LOGICAL :: test2\n#endif\n#ifndef T2\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test2()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 1\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "devonly",
                            "construct-independent",
                            "declare"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "3": {
                        "content": "#ifndef T3\n!T3:devonly,construct-independent,declare,V:2.0-2.7\n      LOGICAL FUNCTION test3()\n  USE OPENACC\n  IMPLICIT NONE\n  INCLUDE \"acc_testsuite.Fh\"\n  INTEGER :: errors = 0\n  INTEGER :: mult = 2\n  REAL(8),DIMENSION(LOOPCOUNT, LOOPCOUNT) :: a, b, c, a_host, b_host\n  INTEGER,DIMENSION(1) :: devtest\n  INTEGER :: x, y\n\n  devtest(1) = 1\n  !$acc enter data copyin(devtest(1:1))\n  !$acc parallel present(devtest(1:1))\n    devtest(1) = 0\n  !$acc end parallel\n\n  SEEDDIM(1) = 1\n# ifdef SEED\n  SEEDDIM(1) = SEED\n# endif\n  CALL RANDOM_SEED(PUT=SEEDDIM)\n\n  IF (devtest(1) .eq. 1) THEN\n    CALL RANDOM_NUMBER(a)\n    CALL RANDOM_NUMBER(b)\n    c = 1\n    a_host = a\n    b_host = b\n\n    !$acc data copy(c(1:LOOPCOUNT, 1:LOOPCOUNt))\n      DO x = 1, LOOPCOUNT\n        CALL function_test_dev_only(a(:,x), b(:,x), c(:,x), LOOPCOUNT)\n      END DO\n    !$acc end data\n\n    DO x = 1, LOOPCOUNT\n      DO y = 1, LOOPCOUNT\n        IF (abs(a(x, y) - a_host(x, y)) .gt. PRECISION) THEN\n          errors = errors + 1\n          PRINT*, \"5\"\n        END IF\n        IF (abs(b(x, y) - b_host(x, y)) .gt. PRECISION) THEN\n          errors = errors + 1\n          PRINT*, \"6\"\n        END IF\n        IF (abs(c(x, y) - (1 + a(x, y) + b(x, y))) .gt. PRECISION) THEN\n          errors = errors + 1\n          PRINT*, \"7\"\n        END IF\n      END DO\n    END DO\n  END IF\n\n        IF (errors .eq. 0) THEN\n          test3 = .FALSE.\n        ELSE\n          test3 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T3\n        LOGICAL :: test3\n#endif\n#ifndef T3\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test3()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 2\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "devonly",
                            "construct-independent",
                            "declare"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "declare_function_scope_copyin.c": {
                "num tests": 3,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:declare,construct-independent,V:1.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t ** a = (real_t **)malloc(n * sizeof(real_t));\n    real_t ** b = (real_t **)malloc(n * sizeof(real_t));\n    real_t ** c = (real_t **)malloc(n * sizeof(real_t));\n\n    for (int x = 0; x < n; ++x){\n        a[x] = (real_t *)malloc(n * sizeof(real_t));\n        b[x] = (real_t *)malloc(n * sizeof(real_t));\n        c[x] = (real_t *)malloc(n * sizeof(real_t));\n        for (int y = 0; y < n; ++y){\n            a[x][y] = rand() / (real_t)(RAND_MAX / 10);\n            b[x][y] = rand() / (real_t)(RAND_MAX / 10);\n            c[x][y] = 1;\n        }\n    }\n\n    #pragma acc data copy(c[0:n][0:n])\n    {\n        for (int x = 0; x < n; ++x){\n            function_test(a[x], b[x], c[x]);\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        for (int y = 0; y < n; ++y){\n            if (fabs(c[x][y] - (1 + a[x][y] + b[x][y])) > PRECISION){\n                err += 1;\n            }\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "declare",
                            "construct-independent"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "2": {
                        "content": "#ifndef T2\n//T2:declare,construct-independent,devonly,reference-counting,V:2.5-2.7\nint test2(){\n    int err = 0;\n    srand(SEED);\n    real_t ** a = (real_t **)malloc(n * sizeof(real_t));\n    real_t ** b = (real_t **)malloc(n * sizeof(real_t));\n    real_t ** c = (real_t **)malloc(n * sizeof(real_t));\n    int * devtest = (int *)malloc(sizeof(int));\n    real_t ** a_host = (real_t **)malloc(n * sizeof(real_t *));\n    real_t ** b_host = (real_t **)malloc(n * sizeof(real_t *));\n\n    devtest[0] = 1;\n    #pragma acc enter data copyin(devtest[0:1])\n    #pragma acc parallel present(devtest[0:1])\n    {\n        devtest[0] = 0;\n    }\n\n    if (devtest[0] == 1){\n        for (int x = 0; x < n; ++x){\n            a_host[x] = (real_t *)malloc(n * sizeof(real_t));\n            b_host[x] = (real_t *)malloc(n * sizeof(real_t));\n            for (int y = 0; y < n; ++y){\n                a[x][y] = rand() / (real_t)(RAND_MAX / 10);\n                a_host[x][y] = a[x][y];\n                b[x][y] = rand() / (real_t)(RAND_MAX / 10);\n                b_host[x][y] = b[x][y];\n                c[x][y] = 0;\n            }\n        }\n\n        #pragma acc data copy(a[0:n][0:n], b[0:n][0:n], c[0:n][0:n])\n        {\n            for (int x = 0; x < n; ++x){\n                function_test_dev_only(a[x], b[x], c[x]);\n            }\n        }\n\n        for (int x = 0; x < n; ++x){\n            for (int y = 0; y < n; ++y){\n                if (fabs(a[x][y] + 1) > PRECISION){\n                    err += 1;\n                }\n                if (fabs(b[x][y] + 1) > PRECISION){\n                    err += 1;\n                }\n                if (fabs(c[x][y] - (a_host[x][y] + b_host[x][y])) > PRECISION){\n                    err += 1;\n                }\n            }\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T2\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test2();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 1);\n    }\n#endif\n",
                        "tags": [
                            "declare",
                            "construct-independent",
                            "devonly",
                            "reference-counting"
                        ],
                        "versions": [
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "3": {
                        "content": "#ifndef T3\n//T3:declare,construct-independent,devonly,V:2.0-2.7\nint test3(){\n    int err = 0;\n    srand(SEED);\n    real_t ** a = (real_t **)malloc(n * sizeof(real_t));\n    real_t ** b = (real_t **)malloc(n * sizeof(real_t));\n    real_t ** c = (real_t **)malloc(n * sizeof(real_t));\n    int * devtest = (int *)malloc(sizeof(int));\n    real_t ** a_host = (real_t **)malloc(n * sizeof(real_t *));\n    real_t ** b_host = (real_t **)malloc(n * sizeof(real_t *));\n\n    devtest[0] = 1;\n    #pragma acc enter data copyin(devtest[0:1])\n    #pragma acc parallel present(devtest[0:1])\n    {\n        devtest[0] = 0;\n    }\n\n    if (devtest[0] == 1){\n        for (int x = 0; x < n; ++x){\n            for (int y = 0; y < n; ++y){\n                a[x][y] = rand() / (real_t)(RAND_MAX / 10);\n                a_host[x][y] = a[x][y];\n                b[x][y] = rand() / (real_t)(RAND_MAX / 10);\n                b_host[x][y] = b[x][y];\n                c[x][y] = 1;\n            }\n        }\n\n        #pragma acc data copy(c[0:n][0:n])\n        {\n            for (int x = 0; x < n; ++x){\n                function_test_dev_only(a[x], b[x], c[x]);\n            }\n        }\n\n        for (int x = 0; x < n; ++x){\n            for (int y = 0; y < n; ++y){\n                if (fabs(a[x][y] - a_host[x][y]) > PRECISION){\n                    err += 1;\n                }\n                if (fabs(b[x][y] - b_host[x][y]) > PRECISION){\n                    err += 1;\n                }\n                if (fabs(c[x][y] - (1 + a[x][y] + b[x][y])) > PRECISION){\n                    err += 1;\n                }\n            }\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T3\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test3();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 2);\n    }\n#endif\n",
                        "tags": [
                            "declare",
                            "construct-independent",
                            "devonly"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "declare_function_scope_copyout.F90": {
                "num tests": 3,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:devonly,construct-independent,declare,V:2.0-2.7\n      LOGICAL FUNCTION test1()\n  USE OPENACC\n  IMPLICIT NONE\n  INCLUDE \"acc_testsuite.Fh\"\n  INTEGER :: errors = 0\n  INTEGER :: mult = 2\n  REAL(8),DIMENSION(LOOPCOUNT, LOOPCOUNT) :: a, b, c\n  INTEGER,DIMENSION(1) :: devtest\n  INTEGER :: x, y\n\n  devtest(1) = 1\n  !$acc enter data copyin(devtest(1:1))\n  !$acc parallel present(devtest(1:1))\n    devtest(1) = 0\n  !$acc end parallel\n\n  SEEDDIM(1) = 1\n# ifdef SEED\n  SEEDDIM(1) = SEED\n# endif\n  CALL RANDOM_SEED(PUT=SEEDDIM)\n\n  CALL RANDOM_NUMBER(a)\n  CALL RANDOM_NUMBER(b)\n  c = 1\n\n  !$acc data copyin(a(1:LOOPCOUNT, 1:LOOPCOUNT), b(1:LOOPCOUNT, 1:LOOPCOUNT))\n    DO x = 1, LOOPCOUNT\n      CALL copyout_test(a(:,x), b(:,x), c(:,x), LOOPCOUNT)\n    END DO\n  !$acc end data\n\n  DO x = 1, LOOPCOUNT\n    DO y = 1, LOOPCOUNT\n      IF (abs(c(x, y) - (a(x, y) + b(x, y))) .gt. PRECISION) THEN\n        errors = errors + 1\n      END IF\n    END DO\n  END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "devonly",
                            "construct-independent",
                            "declare"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "2": {
                        "content": "#ifndef T2\n!T2:devonly,construct-independent,declare,V:2.0-2.7\n      LOGICAL FUNCTION test2()\n  USE OPENACC\n  IMPLICIT NONE\n  INCLUDE \"acc_testsuite.Fh\"\n  INTEGER :: errors = 0\n  INTEGER :: mult = 2\n  REAL(8),DIMENSION(LOOPCOUNT, LOOPCOUNT) :: a, b, c\n  INTEGER,DIMENSION(1) :: devtest\n  INTEGER :: x, y\n\n  devtest(1) = 1\n  !$acc enter data copyin(devtest(1:1))\n  !$acc parallel present(devtest(1:1))\n    devtest(1) = 0\n  !$acc end parallel\n\n  SEEDDIM(1) = 1\n# ifdef SEED\n  SEEDDIM(1) = SEED\n# endif\n  CALL RANDOM_SEED(PUT=SEEDDIM)\n\n  CALL RANDOM_NUMBER(a)\n  CALL RANDOM_NUMBER(b)\n  c = 2\n\n  !$acc data copyin(a(1:LOOPCOUNT, 1:LOOPCOUNT), b(1:LOOPCOUNT, 1:LOOPCOUNT))\n    DO x = 1, LOOPCOUNT\n      !$acc data copy(c(1:LOOPCOUNT, x:x))\n        CALL copyout_test(a(:,x), b(:,x), c(:,x), LOOPCOUNT)\n      !$acc end data\n    END DO\n  !$acc end data\n\n  DO x = 1, LOOPCOUNT\n    DO y = 1, LOOPCOUNT\n      IF (abs(c(x, y) - (a(x, y) + b(x, y))) .gt. PRECISION) THEN\n        errors = errors + 1\n      END IF\n    END DO\n  END DO\n\n        IF (errors .eq. 0) THEN\n          test2 = .FALSE.\n        ELSE\n          test2 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T2\n        LOGICAL :: test2\n#endif\n#ifndef T2\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test2()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 1\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "devonly",
                            "construct-independent",
                            "declare"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "3": {
                        "content": "#ifndef T3\n!T3:devonly,construct-independent,declare,V:2.0-2.7\n      LOGICAL FUNCTION test3()\n  USE OPENACC\n  IMPLICIT NONE\n  INCLUDE \"acc_testsuite.Fh\"\n  INTEGER :: errors = 0\n  INTEGER :: mult = 2\n  REAL(8),DIMENSION(LOOPCOUNT, LOOPCOUNT) :: a, b, c\n  INTEGER,DIMENSION(1) :: devtest\n  INTEGER :: x, y\n\n  devtest(1) = 1\n  !$acc enter data copyin(devtest(1:1))\n  !$acc parallel present(devtest(1:1))\n    devtest(1) = 0\n  !$acc end parallel\n\n  SEEDDIM(1) = 1\n# ifdef SEED\n  SEEDDIM(1) = SEED\n# endif\n  CALL RANDOM_SEED(PUT=SEEDDIM)\n\n  IF (devtest(1) .eq. 1) THEN\n    CALL RANDOM_NUMBER(a)\n    CALL RANDOM_NUMBER(b)\n    c = 3\n\n    !$acc data copyin(a(1:LOOPCOUNT, 1:LOOPCOUNT), b(1:LOOPCOUNT, 1:LOOPCOUNT))\n      DO x = 1, LOOPCOUNT\n        !$acc data copyin(c(1:LOOPCOUNT, x:x))\n          CALL copyout_test(a(:,x), b(:,x), c(:,x), LOOPCOUNT)\n        !$acc end data\n        DO y = 1, LOOPCOUNT\n          IF (abs(c(y, x) - 3) .gt. PRECISION) THEN\n            errors = errors + 1\n          END IF\n        END DO\n      END DO\n    !$acc end data\n  END IF\n\n        IF (errors .eq. 0) THEN\n          test3 = .FALSE.\n        ELSE\n          test3 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T3\n        LOGICAL :: test3\n#endif\n#ifndef T3\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test3()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 2\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "devonly",
                            "construct-independent",
                            "declare"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "declare_function_scope_copyout.c": {
                "num tests": 4,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:declare,construct-independent,V:1.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t ** a = (real_t **)malloc(n * sizeof(real_t));\n    real_t ** b = (real_t **)malloc(n * sizeof(real_t));\n    real_t ** c = (real_t **)malloc(n * sizeof(real_t));\n\n    for (int x = 0; x < n; ++x){\n        a[x] = (real_t *)malloc(n * sizeof(real_t));\n        b[x] = (real_t *)malloc(n * sizeof(real_t));\n        c[x] = (real_t *)malloc(n * sizeof(real_t));\n        for (int y = 0; y < n; ++y){\n            a[x][y] = rand() / (real_t)(RAND_MAX / 10);\n            b[x][y] = rand() / (real_t)(RAND_MAX / 10);\n            c[x][y] = 1;\n        }\n    }\n    #pragma acc data copyin(a[0:n][0:n], b[0:n][0:n])\n    {\n        for (int x = 0; x < n; ++x){\n            copyout_test(a[x], b[x], c[x]);\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        for (int y = 0; y < n; ++y){\n            if (fabs(c[x][y] - (a[x][y] + b[x][y])) > PRECISION){\n                err += 1;\n            }\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "declare",
                            "construct-independent"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "2": {
                        "content": "#ifndef T2\n//T2:declare,construct-independent,reference-counting,V:2.5-2.7\nint test2(){\n    int err = 0;\n    srand(SEED);\n    real_t ** a = (real_t **)malloc(n * sizeof(real_t));\n    real_t ** b = (real_t **)malloc(n * sizeof(real_t));\n    real_t ** c = (real_t **)malloc(n * sizeof(real_t));\n\n    for (int x = 0; x < n; ++x){\n        for (int y = 0; y < n; ++y){\n            a[x][y] = rand() / (real_t)(RAND_MAX / 10);\n            b[x][y] = rand() / (real_t)(RAND_MAX / 10);\n            c[x][y] = 2;\n        }\n    }\n\n    #pragma acc data copyin(a[0:n][0:n], b[0:n][0:n])\n    {\n        for (int x = 0; x < n; ++x){\n            #pragma acc data copy(c[x:1][0:n])\n            {\n                copyout_test(a[x], b[x], c[x]);\n            }\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        for (int y = 0; y < n; ++y){\n            if (fabs(c[x][y] - (a[x][y] + b[x][y])) > PRECISION){\n                err += 1;\n            }\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T2\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test2();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 1);\n    }\n#endif\n",
                        "tags": [
                            "declare",
                            "construct-independent",
                            "reference-counting"
                        ],
                        "versions": [
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "3": {
                        "content": "#ifndef T3\n//T3:declare,construct-independent,devonly,reference-counting,V:2.5-2.7\nint test3(){\n    int err = 0;\n    srand(SEED);\n    real_t ** a = (real_t **)malloc(n * sizeof(real_t));\n    real_t ** b = (real_t **)malloc(n * sizeof(real_t));\n    real_t ** c = (real_t **)malloc(n * sizeof(real_t));\n    int *devtest = (int *)malloc(sizeof(int));\n\n    devtest[0] = 1;\n    #pragma acc enter data copyin(devtest[0:1])\n    #pragma acc parallel present(devtest[0:1])\n    {\n        devtest[0] = 0;\n    }\n\n    if (devtest[0] == 1){\n        for (int x = 0; x < n; ++x){\n            for (int y = 0; y < n; ++y){\n                a[x][y] = rand() / (real_t)(RAND_MAX / 10);\n                b[x][y] = rand() / (real_t)(RAND_MAX / 10);\n                c[x][y] = 3;\n            }\n        }\n\n        #pragma acc data copyin(a[0:n][0:n], b[0:n][0:n])\n        {\n            for (int x = 0; x < n; ++x){\n                #pragma acc data copyin(c[x:1][0:n])\n                {\n                    copyout_test(a[x], b[x], c[x]);\n                    for (int y = 0; y < n; ++y){\n                        if (fabs(c[x][y] - 3) > PRECISION){\n                            err += 1;\n                        }\n                    }\n                }\n                for (int y = 0; y < n; ++y){\n                    if (fabs(c[x][y] - 3) > PRECISION){\n                        err += 1;\n                    }\n                }\n            }\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T3\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test3();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 2);\n    }\n#endif\n",
                        "tags": [
                            "declare",
                            "construct-independent",
                            "devonly",
                            "reference-counting"
                        ],
                        "versions": [
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "4": {
                        "content": "#ifndef T4\n//T4:declare,construct-independent,devonly,reference-counting,V:2.5-2.7\nint test4(){\n    int err = 0;\n    srand(SEED);\n    real_t ** a = (real_t **)malloc(n * sizeof(real_t));\n    real_t ** b = (real_t **)malloc(n * sizeof(real_t));\n    real_t ** c = (real_t **)malloc(n * sizeof(real_t));\n    int *devtest = (int *)malloc(sizeof(int));\n\n    devtest[0] = 1;\n    #pragma acc enter data copyin(devtest[0:1])\n    #pragma acc parallel present(devtest[0:1])\n    {\n        devtest[0] = 0;\n    }\n\n    if (devtest[0] == 1){\n        for (int x = 0; x < n; ++x){\n            for (int y = 0; y < n; ++y){\n                a[x][y] = rand() / (real_t)(RAND_MAX / 10);\n                b[x][y] = rand() / (real_t)(RAND_MAX / 10);\n                c[x][y] = 4;\n            }\n        }\n\n        #pragma acc data copyin(a[0:n][0:n], b[0:n][0:n])\n        {\n            for (int x = 0; x < n; ++x){\n                #pragma acc data copy(c[x:1][0:n])\n                {\n                    copyout_test(a[x], b[x], c[x]);\n                    for (int y = 0; y < n; ++y){\n                        if (fabs(c[x][y] - 4) > PRECISION){\n                            err += 1;\n                        }\n                    }\n                }\n                for (int y = 0; y < n; ++y){\n                    if (fabs(c[x][y] - (a[x][y] + b[x][y])) > PRECISION){\n                        err += 1;\n                    }\n                }\n            }\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T4\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test4();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 3);\n    }\n#endif\n",
                        "tags": [
                            "declare",
                            "construct-independent",
                            "devonly",
                            "reference-counting"
                        ],
                        "versions": [
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "declare_function_scope_create.F90": {
                "num tests": 3,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:devonly,construct-independent,declare,V:2.0-2.7\n      LOGICAL FUNCTION test1()\n  USE OPENACC\n  IMPLICIT NONE\n  INCLUDE \"acc_testsuite.Fh\"\n  INTEGER :: errors = 0\n  INTEGER :: mult = 2\n  REAL(8),DIMENSION(LOOPCOUNT, LOOPCOUNT) :: a, b, c, d\n  INTEGER,DIMENSION(1) :: devtest\n  INTEGER :: x, y\n\n  devtest(1) = 1\n  !$acc enter data copyin(devtest(1:1))\n  !$acc parallel present(devtest(1:1))\n    devtest(1) = 0\n  !$acc end parallel\n\n  SEEDDIM(1) = 1\n# ifdef SEED\n  SEEDDIM(1) = SEED\n# endif\n  CALL RANDOM_SEED(PUT=SEEDDIM)\n\n  CALL RANDOM_NUMBER(a)\n  CALL RANDOM_NUMBER(b)\n  c = 1\n  d = 0\n\n  !$acc data copyin(a(1:LOOPCOUNT, 1:LOOPCOUNT), b(1:LOOPCOUNT, 1:LOOPCOUNT)) copyout(d(1:LOOPCOUNT, 1:LOOPCOUNT))\n    DO x = 1, LOOPCOUNT\n      CALL create_test(a(x), b(x), c(x), d(x), LOOPCOUNT)\n    END DO\n  !$acc end data\n\n  DO x = 1, LOOPCOUNT\n    DO y = 1, LOOPCOUNT\n      IF (abs(d(x, y) - (a(x, y) * (a(x, y) + b(x, y)))) .gt. PRECISION) THEN\n        errors = errors + 1\n      END IF\n    END DO\n  END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "devonly",
                            "construct-independent",
                            "declare"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "2": {
                        "content": "#ifndef T2\n!T2:devonly,construct-independent,declare,V:2.0-2.7\n      LOGICAL FUNCTION test2()\n  USE OPENACC\n  IMPLICIT NONE\n  INCLUDE \"acc_testsuite.Fh\"\n  INTEGER :: errors = 0\n  INTEGER :: mult = 2\n  REAL(8),DIMENSION(LOOPCOUNT, LOOPCOUNT) :: a, b, c, d\n  INTEGER,DIMENSION(1) :: devtest\n  INTEGER :: x, y\n\n  devtest(1) = 1\n  !$acc enter data copyin(devtest(1:1))\n  !$acc parallel present(devtest(1:1))\n    devtest(1) = 0\n  !$acc end parallel\n\n  SEEDDIM(1) = 1\n# ifdef SEED\n  SEEDDIM(1) = SEED\n# endif\n  CALL RANDOM_SEED(PUT=SEEDDIM)\n\n  CALL RANDOM_NUMBER(a)\n  CALL RANDOM_NUMBER(b)\n  c = 2\n  d = 0\n\n  !$acc data copyin(a(1:LOOPCOUNT, 1:LOOPCOUNT), b(1:LOOPCOUNT, 1:LOOPCOUNT)) copy(c(1:LOOPCOUNT, 1:LOOPCOUNT)) copyout(d(1:LOOPCOUNT, 1:LOOPCOUNT))\n    DO x = 1, LOOPCOUNT\n      CALL create_as_present(a(x), b(x), c(x), d(x), LOOPCOUNT)\n    END DO\n  !$acc end data\n\n  DO x = 1, LOOPCOUNT\n    DO y = 1, LOOPCOUNT\n      IF (abs(c(x, y) - (2 + a(x, y) + b(x, y))) .gt. PRECISION) THEN\n        errors = errors + 1\n      END IF\n      IF (abs(d(x, y) - (a(x, y) * c(x, y))) .gt. PRECISION * 2) THEN\n        errors = errors + 1\n      END IF\n    END DO\n  END DO\n\n        IF (errors .eq. 0) THEN\n          test2 = .FALSE.\n        ELSE\n          test2 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T2\n        LOGICAL :: test2\n#endif\n#ifndef T2\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test2()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 1\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "devonly",
                            "construct-independent",
                            "declare"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "3": {
                        "content": "#ifndef T3\n!T3:devonly,construct-independent,declare,V:2.0-2.7\n      LOGICAL FUNCTION test3()\n  USE OPENACC\n  IMPLICIT NONE\n  INCLUDE \"acc_testsuite.Fh\"\n  INTEGER :: errors = 0\n  INTEGER :: mult = 2\n  REAL(8),DIMENSION(LOOPCOUNT, LOOPCOUNT) :: a, b, c, d\n  INTEGER,DIMENSION(1) :: devtest\n  INTEGER :: x, y\n\n  devtest(1) = 1\n  !$acc enter data copyin(devtest(1:1))\n  !$acc parallel present(devtest(1:1))\n    devtest(1) = 0\n  !$acc end parallel\n\n  SEEDDIM(1) = 1\n# ifdef SEED\n  SEEDDIM(1) = SEED\n# endif\n  CALL RANDOM_SEED(PUT=SEEDDIM)\n\n  IF (devtest(1) .eq. 1) THEN\n    CALL RANDOM_NUMBER(a)\n    CALL RANDOM_NUMBER(b)\n    c = 3\n\n    !$acc data copyin(a(1:LOOPCOUNT, 1:LOOPCOUNT), b(1:LOOPCOUNT, 1:LOOPCOUNT))\n      DO x = 1, LOOPCOUNT\n        !$acc data copyin(c(x:x, 1:LOOPCOUNT)) copyout(d(x:x, 1:LOOPCOUNT))\n          CALL create_as_present(a(x), b(x), c(x), d(x), LOOPCOUNT)\n        !$acc end data\n        DO y = 1, LOOPCOUNT\n          IF (abs(c(x, y) - 3) .gt. PRECISION) THEN\n            errors = errors + 1\n          END IF\n          IF (abs(d(x, y) - (a(x, y) * (3 + a(x, y) + b(x, y)))) .gt. PRECISION * 2) THEN\n            errors = errors + 1\n          END IF\n        END DO\n      END DO\n    !$acc end data\n  END IF\n\n        IF (errors .eq. 0) THEN\n          test3 = .FALSE.\n        ELSE\n          test3 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T3\n        LOGICAL :: test3\n#endif\n#ifndef T3\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test3()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 2\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "devonly",
                            "construct-independent",
                            "declare"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "declare_function_scope_create.c": {
                "num tests": 3,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:declare,construct-independent,V:2.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t ** a = (real_t **)malloc(n * sizeof(real_t));\n    real_t ** b = (real_t **)malloc(n * sizeof(real_t));\n    real_t ** c = (real_t **)malloc(n * sizeof(real_t));\n    real_t ** d = (real_t **)malloc(n * sizeof(real_t));\n\n    for (int x = 0; x < n; ++x){\n        a[x] = (real_t *)malloc(n * sizeof(real_t));\n        b[x] = (real_t *)malloc(n * sizeof(real_t));\n        c[x] = (real_t *)malloc(n * sizeof(real_t));\n        d[x] = (real_t *)malloc(n * sizeof(real_t));\n        for (int y = 0; y < n; ++y){\n            a[x][y] = rand() / (real_t)(RAND_MAX / 10);\n            b[x][y] = rand() / (real_t)(RAND_MAX / 10);\n            c[x][y] = 1;\n            d[x][y] = 0;\n        }\n    }\n    #pragma acc data copyin(a[0:n][0:n], b[0:n][0:n]) copyout(d[0:n][0:n])\n    {\n        for (int x = 0; x < n; ++x){\n            create_test(a[x], b[x], c[x], d[x]);\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        for (int y = 0; y < n; ++y){\n            if (fabs(d[x][y] - (a[x][y] * (a[x][y] + b[x][y]))) > PRECISION){\n                err += 1;\n            }\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "declare",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "2": {
                        "content": "#ifndef T2\n//T2:declare,construct-independent,V:2.0-2.7\nint test2(){\n    int err = 0;\n    srand(SEED);\n    real_t ** a = (real_t **)malloc(n * sizeof(real_t));\n    real_t ** b = (real_t **)malloc(n * sizeof(real_t));\n    real_t ** c = (real_t **)malloc(n * sizeof(real_t));\n    real_t ** d = (real_t **)malloc(n * sizeof(real_t));\n\n    for (int x = 0; x < n; ++x){\n        for (int y = 0; y < n; ++y){\n            a[x][y] = rand() / (real_t)(RAND_MAX / 10);\n            b[x][y] = rand() / (real_t)(RAND_MAX / 10);\n            c[x][y] = 2;\n            d[x][y] = 0;\n        }\n    }\n\n    #pragma acc data copyin(a[0:n][0:n], b[0:n][0:n]) copy(c[0:n][0:n]) copyout(d[0:n][0:n])\n    {\n        for (int x = 0; x < n; ++x){\n            create_as_present(a[x], b[x], c[x], d[x]);\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        for (int y = 0; y < n; ++y){\n            if (fabs(c[x][y] - (2 + a[x][y] + b[x][y])) > PRECISION){\n                err += 1;\n            }\n            if (fabs(d[x][y] - (a[x][y] * c[x][y])) > PRECISION * 2){\n                err += 1;\n            }\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T2\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test2();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 1);\n    }\n#endif\n",
                        "tags": [
                            "declare",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "3": {
                        "content": "#ifndef T3\n//T3:declare,construct-independent,devonly,V:2.0-2.7\nint test3(){\n    int err = 0;\n    srand(SEED);\n    real_t ** a = (real_t **)malloc(n * sizeof(real_t));\n    real_t ** b = (real_t **)malloc(n * sizeof(real_t));\n    real_t ** c = (real_t **)malloc(n * sizeof(real_t));\n    real_t ** d = (real_t **)malloc(n * sizeof(real_t));\n    int *devtest = (int *)malloc(sizeof(int));\n\n    devtest[0] = 1;\n    #pragma acc enter data copyin(devtest[0:1])\n    #pragma acc parallel present(devtest[0:1])\n    {\n        devtest[0] = 0;\n    }\n\n    if (devtest[0] == 1){\n        for (int x = 0; x < n; ++x){\n            for (int y = 0; y < n; ++y){\n                a[x][y] = rand() / (real_t)(RAND_MAX / 10);\n                b[x][y] = rand() / (real_t)(RAND_MAX / 10);\n                c[x][y] = 3;\n            }\n        }\n\n        #pragma acc data copyin(a[0:n][0:n], b[0:n][0:n])\n        {\n            for (int x = 0; x < n; ++x){\n                #pragma acc data copyin(c[x:1][0:n]) copyout(d[x:1][0:n])\n                {\n                    create_as_present(a[x], b[x], c[x], d[x]);\n                }\n                for (int y = 0; y < n; ++y){\n                    if (fabs(c[x][y] - 3) > PRECISION){\n                        err += 1;\n                    }\n                }\n                for (int y = 0; y < n; ++y){\n                    if (fabs(d[x][y] - (a[x][y] * (3 + a[x][y] + b[x][y]))) > PRECISION * 2){\n                        err += 1;\n                    }\n                }\n            }\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T3\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test3();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 2);\n    }\n#endif\n",
                        "tags": [
                            "declare",
                            "construct-independent",
                            "devonly"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "declare_function_scope_deviceptr.c": {
                "num tests": 2,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:declare,runtime,construct-independent,V:2.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t ** a = (real_t **)malloc(n * sizeof(real_t *));\n    real_t ** b = (real_t **)malloc(n * sizeof(real_t *));\n    real_t ** c = (real_t **)malloc(n * sizeof(real_t *));\n    real_t ** d = (real_t **)malloc(n * sizeof(real_t *));\n    real_t ** devpointer_c = (real_t **)malloc(n * sizeof(real_t *));\n    int *devtest = (int *)malloc(sizeof(int));\n\n    for (int x = 0; x < n; ++x){\n        a[x] = (real_t *)malloc(n * sizeof(real_t));\n        b[x] = (real_t *)malloc(n * sizeof(real_t));\n        c[x] = (real_t *)malloc(n * sizeof(real_t));\n        d[x] = (real_t *)malloc(n * sizeof(real_t));\n        for (int y = 0; y < n; ++y){\n            a[x][y] = rand() / (real_t)(RAND_MAX / 10);\n            b[x][y] = rand() / (real_t)(RAND_MAX / 10);\n            c[x][y] = 1;\n            d[x][y] = 0;\n        }\n    }\n\n    #pragma acc data copyin(a[0:n][0:n], b[0:n][0:n]) copy(c[0:n][0:n]) copyout(d[0:n][0:n])\n    {\n        for (int x = 0; x < n; ++x){\n            devpointer_c[x] = acc_deviceptr(c[x]);\n            declare_deviceptr(a[x], b[x], devpointer_c[x], d[x]);\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        for (int y = 0; y < n; ++y){\n            if (fabs(c[x][y] - (1 + a[x][y] + b[x][y])) > PRECISION){\n                err += 1;\n            }\n            if (fabs(d[x][y] - (a[x][y] * c[x][y])) > PRECISION * 2){\n                err += 1;\n            }\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "declare",
                            "runtime",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "2": {
                        "content": "#ifndef T2\n//T2:declare,runtime,construct-independent,devonly,V:2.0-2.7\nint test2(){\n    int err = 0;\n    srand(SEED);\n    real_t ** a = (real_t **)malloc(n * sizeof(real_t *));\n    real_t ** b = (real_t **)malloc(n * sizeof(real_t *));\n    real_t ** c = (real_t **)malloc(n * sizeof(real_t *));\n    real_t ** d = (real_t **)malloc(n * sizeof(real_t *));\n    real_t ** devpointer_c = (real_t **)malloc(n * sizeof(real_t *));\n    int *devtest = (int *)malloc(sizeof(int));\n\n    devtest[0] = 1;\n    #pragma acc enter data copyin(devtest[0:1])\n    #pragma acc parallel present(devtest[0:1])\n    {\n        devtest[0] = 0;\n    }\n\n    if (devtest[0] == 1){\n        for (int x = 0; x < n; ++x){\n            for (int y = 0; y < n; ++y){\n                a[x][y] = rand() / (real_t)(RAND_MAX / 10);\n                b[x][y] = rand() / (real_t)(RAND_MAX / 10);\n                c[x][y] = 3;\n            }\n        }\n\n        #pragma acc data copyin(a[0:n][0:n], b[0:n][0:n])\n        {\n            for (int x = 0; x < n; ++x){\n                #pragma acc data copyout(d[x:1][0:n])\n                {\n                    devpointer_c[x] = acc_copyin(c[x], n * sizeof(real_t));\n                    declare_deviceptr(a[x], b[x], devpointer_c[x], d[x]);\n                }\n                for (int y = 0; y < n; ++y){\n                    if (fabs(c[x][y] - 3) > PRECISION){\n                        err += 1;\n                    }\n                }\n                for (int y = 0; y < n; ++y){\n                    if (fabs(d[x][y] - (a[x][y] * (3 + a[x][y] + b[x][y]))) > PRECISION * 10){\n                        err += 1;\n                    }\n                }\n            }\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T2\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test2();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 1);\n    }\n#endif\n",
                        "tags": [
                            "declare",
                            "runtime",
                            "construct-independent",
                            "devonly"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "declare_function_scope_present.F90": {
                "num tests": 2,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:devonly,construct-independent,declare,V:2.0-2.7\n      LOGICAL FUNCTION test1()\n  USE OPENACC\n  IMPLICIT NONE\n  INCLUDE \"acc_testsuite.Fh\"\n  INTEGER :: errors = 0\n  INTEGER :: mult = 2\n  REAL(8),DIMENSION(LOOPCOUNT, LOOPCOUNT) :: a, b, c, d\n  INTEGER,DIMENSION(1) :: devtest\n  INTEGER :: x, y\n\n  devtest(1) = 1\n  !$acc enter data copyin(devtest(1:1))\n  !$acc parallel present(devtest(1:1))\n    devtest(1) = 0\n  !$acc end parallel\n\n  SEEDDIM(1) = 1\n# ifdef SEED\n  SEEDDIM(1) = SEED\n# endif\n  CALL RANDOM_SEED(PUT=SEEDDIM)\n\n  CALL RANDOM_NUMBER(a)\n  CALL RANDOM_NUMBER(b)\n  c = 1\n  d = 0\n\n  !$acc data copyin(a(1:LOOPCOUNT, 1:LOOPCOUNT), b(1:LOOPCOUNT, 1:LOOPCOUNT)) copyout(d(1:LOOPCOUNT, 1:LOOPCOUNT))\n    DO x = 1, LOOPCOUNT\n      !$acc data copy(c(x:x, 1:LOOPCOUNT))\n        CALL present(a(x), b(x), c(x), d(x), LOOPCOUNT)\n      !$acc end data\n    END DO\n  !$acc end data\n\n  DO x = 1, LOOPCOUNT\n    DO y = 1, LOOPCOUNT\n      IF (abs(c(x, y) - (1 + a(x, y) + b(x, y))) .gt. PRECISION) THEN\n        errors = errors + 1\n      END IF\n      IF (abs(d(x, y) - (a(x, y) * c(x, y))) .gt. PRECISION * 2) THEN\n        errors = errors + 1\n      END IF\n    END DO\n  END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "devonly",
                            "construct-independent",
                            "declare"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "2": {
                        "content": "#ifndef T2\n!T2:devonly,construct-independent,declare,V:2.0-2.7\n      LOGICAL FUNCTION test2()\n  USE OPENACC\n  IMPLICIT NONE\n  INCLUDE \"acc_testsuite.Fh\"\n  INTEGER :: errors = 0\n  INTEGER :: mult = 2\n  REAL(8),DIMENSION(LOOPCOUNT, LOOPCOUNT) :: a, b, c, d\n  INTEGER,DIMENSION(1) :: devtest\n  INTEGER :: x, y\n\n  devtest(1) = 1\n  !$acc enter data copyin(devtest(1:1))\n  !$acc parallel present(devtest(1:1))\n    devtest(1) = 0\n  !$acc end parallel\n\n  SEEDDIM(1) = 1\n# ifdef SEED\n  SEEDDIM(1) = SEED\n# endif\n  CALL RANDOM_SEED(PUT=SEEDDIM)\n\n  IF (devtest(1) .eq. 1) THEN\n    CALL RANDOM_NUMBER(a)\n    CALL RANDOM_NUMBER(b)\n    c = 3\n\n    !$acc data copyin(a(1:LOOPCOUNT, 1:LOOPCOUNT), b(1:LOOPCOUNT, 1:LOOPCOUNT))\n      DO x = 1, LOOPCOUNT\n        !$acc data copyin(c(x:x, 1:LOOPCOUNT)) copyout(d(x:x, 1:LOOPCOUNT))\n          CALL present(a(x), b(x), c(x), d(x), LOOPCOUNT)\n        !$acc end data\n        DO y = 1, LOOPCOUNT\n          IF (abs(c(x, y) - 3) .gt. PRECISION) THEN\n            errors = errors + 1\n          END IF\n          IF (abs(d(x, y) - (a(x, y) * (3 + a(x, y) + b(x, y)))) .gt. PRECISION * 2) THEN\n            errors = errors + 1\n          END IF\n        END DO\n      END DO\n    !$acc end data\n  END IF\n\n        IF (errors .eq. 0) THEN\n          test2 = .FALSE.\n        ELSE\n          test2 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T2\n        LOGICAL :: test2\n#endif\n#ifndef T2\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test2()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 1\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "devonly",
                            "construct-independent",
                            "declare"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "declare_function_scope_present.c": {
                "num tests": 2,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:declare,present,construct-independent,V:2.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t ** a = (real_t **)malloc(n * sizeof(real_t));\n    real_t ** b = (real_t **)malloc(n * sizeof(real_t));\n    real_t ** c = (real_t **)malloc(n * sizeof(real_t));\n    real_t ** d = (real_t **)malloc(n * sizeof(real_t));\n\n    for (int x = 0; x < n; ++x){\n        a[x] = (real_t *)malloc(n * sizeof(real_t));\n        b[x] = (real_t *)malloc(n * sizeof(real_t));\n        c[x] = (real_t *)malloc(n * sizeof(real_t));\n        d[x] = (real_t *)malloc(n * sizeof(real_t));\n        for (int y = 0; y < n; ++y){\n            a[x][y] = rand() / (real_t)(RAND_MAX / 10);\n            b[x][y] = rand() / (real_t)(RAND_MAX / 10);\n            c[x][y] = 1;\n            d[x][y] = 0;\n        }\n    }\n\n    #pragma acc data copyin(a[0:n][0:n], b[0:n][0:n]) copyout(d[0:n][0:n])\n    {\n        for (int x = 0; x < n; ++x){\n            #pragma acc data copy(c[x:1][0:n])\n            {\n                present(a[x], b[x], c[x], d[x]);\n            }\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        for (int y = 0; y < n; ++y){\n            if (fabs(c[x][y] - (1 + a[x][y] + b[x][y])) > PRECISION){\n                err += 1;\n            }\n            if (fabs(d[x][y] - (a[x][y] * c[x][y])) > PRECISION * 2){\n                err += 1;\n            }\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "declare",
                            "present",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "2": {
                        "content": "#ifndef T2\n//T2:declare,present,devonly,construct-independent,V:2.0-2.7\nint test2(){\n    int err = 0;\n    srand(SEED);\n    real_t ** a = (real_t **)malloc(n * sizeof(real_t));\n    real_t ** b = (real_t **)malloc(n * sizeof(real_t));\n    real_t ** c = (real_t **)malloc(n * sizeof(real_t));\n    real_t ** d = (real_t **)malloc(n * sizeof(real_t));\n    int *devtest = (int *)malloc(sizeof(int));\n\n    devtest[0] = 1;\n    #pragma acc enter data copyin(devtest[0:1])\n    #pragma acc parallel present(devtest[0:1])\n    {\n        devtest[0] = 0;\n    }\n\n    if (devtest[0] == 1){\n        for (int x = 0; x < n; ++x){\n            for (int y = 0; y < n; ++y){\n                a[x][y] = rand() / (real_t)(RAND_MAX / 10);\n                b[x][y] = rand() / (real_t)(RAND_MAX / 10);\n                c[x][y] = 3;\n            }\n        }\n\n        #pragma acc data copyin(a[0:n][0:n], b[0:n][0:n])\n        {\n            for (int x = 0; x < n; ++x){\n                #pragma acc data copyin(c[x:1][0:n]) copyout(d[x:1][0:n])\n                {\n                    present(a[x], b[x], c[x], d[x]);\n                }\n                for (int y = 0; y < n; ++y){\n                    if (fabs(c[x][y] - 3) > PRECISION){\n                        err += 1;\n                    }\n                }\n                for (int y = 0; y < n; ++y){\n                    if (fabs(d[x][y] - (a[x][y] * (3 + a[x][y] + b[x][y]))) > PRECISION * 2){\n                        err += 1;\n                    }\n                }\n            }\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T2\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test2();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 1);\n    }\n#endif\n",
                        "tags": [
                            "declare",
                            "present",
                            "devonly",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "enter_data_copyin_no_lower_bound.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:data,executable-data,construct-independent,V:2.0-2.7\n      LOGICAL FUNCTION test1()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT):: a, b, c !Data\n        INTEGER :: errors = 0\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(a)\n        CALL RANDOM_NUMBER(b)\n        c = 0\n\n        !$acc enter data copyin(a(:LOOPCOUNT), b(:LOOPCOUNT))\n        !$acc data copyout(c(1:LOOPCOUNT)) present(a(1:LOOPCOUNT), b(1:LOOPCOUNT))\n          !$acc parallel\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              c(x) = a(x) + b(x)\n            END DO\n          !$acc end parallel\n        !$acc end data\n        !$acc exit data delete(a(1:LOOPCOUNT), b(1:LOOPCOUNT))\n\n        DO x = 1, LOOPCOUNT\n          IF (abs(c(x) - (a(x) + b(x))) .gt. PRECISION) THEN\n            errors = errors + 1\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "data",
                            "executable-data",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "enter_data_copyin_no_lower_bound.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:data,executable-data,syntactic,V:2.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n    real_t * c = (real_t *)malloc(n * sizeof(real_t));\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n        c[x] = 0.0;\n    }\n\n    #pragma acc enter data copyin(a[:n], b[:n]) create(c[0:n])\n    #pragma acc parallel present(a[0:n], b[0:n], c[0:n])\n    {\n        #pragma acc loop\n        for (int x = 0; x < n; ++x){\n            c[x] = a[x] + b[x];\n        }\n    }\n    #pragma acc exit data copyout(c[0:n]) delete(a[0:n], b[0:n])\n\n    for (int x = 0; x < n; ++x){\n        if (fabs(c[x] - (a[x] + b[x])) > PRECISION) {\n            err += 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "data",
                            "executable-data",
                            "syntactic"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "enter_data_create.F90": {
                "num tests": 3,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:data,executable-data,construct-independent,V:2.0-2.7\n      LOGICAL FUNCTION test1()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT):: a, b, c !Data\n        INTEGER :: errors = 0\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(a)\n        b = 0\n        c = 0\n\n        !$acc enter data create(b(1:LOOPCOUNT))\n        !$acc data copyin(a(1:LOOPCOUNT))\n          !$acc parallel present(b(1:LOOPCOUNT))\n            !$acc loop \n            DO x = 1, LOOPCOUNT\n              b(x) = a(x)\n            END DO\n          !$acc end parallel\n        !$acc end data\n        !$acc data copyout(c(1:LOOPCOUNT))\n          !$acc parallel present(b(1:LOOPCOUNT))\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              c(x) = b(x)\n            END DO\n          !$acc end parallel\n        !$acc end data\n        !$acc exit data delete(b(1:LOOPCOUNT))\n\n        DO x = 1, LOOPCOUNT\n          IF (abs(a(x) - c(x)) .gt. PRECISION) THEN\n            errors = errors + 1\n            EXIT\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "data",
                            "executable-data",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "2": {
                        "content": "#ifndef T2\n!T2:data,executable-data,construct-independent,V:2.0-2.7\n      LOGICAL FUNCTION test2()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT):: a, b, c !Data\n        INTEGER :: errors = 0\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(a)\n        b = 0\n        c = 0\n        !$acc enter data present_or_create(b(1:LOOPCOUNT))\n        !$acc data copyin(a(1:LOOPCOUNT))\n          !$acc parallel present(b(1:LOOPCOUNT))\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              b(x) = a(x)\n            END DO\n          !$acc end parallel\n        !$acc end data\n        !$acc data copyout(c(1:LOOPCOUNT))\n          !$acc parallel present(b(1:LOOPCOUNT))\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              c(x) = b(x)\n            END DO\n          !$acc end parallel\n        !$acc end data\n        !$acc exit data delete(b(1:LOOPCOUNT))\n\n        DO x = 1, LOOPCOUNT\n          IF (abs(a(x) - c(x)) .gt. PRECISION) THEN\n            errors = errors + 2\n            EXIT\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test2 = .FALSE.\n        ELSE\n          test2 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T2\n        LOGICAL :: test2\n#endif\n#ifndef T2\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test2()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 1\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "data",
                            "executable-data",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "3": {
                        "content": "#ifndef T3\n!T3:data,executable-data,construct-independent,V:2.0-2.7\n      LOGICAL FUNCTION test3()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT):: a, b, c !Data\n        INTEGER :: errors = 0\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(a)\n        b = 0\n        c = 0\n \n        !$acc enter data pcreate(b(1:LOOPCOUNT))\n        !$acc data copyin(a(1:LOOPCOUNT))\n          !$acc parallel present(b(1:LOOPCOUNT))\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              b(x) = a(x)\n            END DO\n          !$acc end parallel\n        !$acc end data\n        !$acc data copyout(c(1:LOOPCOUNT))\n          !$acc parallel present(b(1:LOOPCOUNT))\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              c(x) = b(x)\n            END DO\n          !$acc end parallel\n        !$acc end data\n        !$acc exit data delete(b(1:LOOPCOUNT))\n\n        DO x = 1, LOOPCOUNT\n          IF (abs(a(x) - c(x)) .gt. PRECISION) THEN\n            errors = errors + 4\n            EXIT\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test3 = .FALSE.\n        ELSE\n          test3 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T3\n        LOGICAL :: test3\n#endif\n#ifndef T3\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test3()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 2\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "data",
                            "executable-data",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "enter_data_create.c": {
                "num tests": 3,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:data,executable-data,construct-independent,V:2.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n    real_t * c = (real_t *)malloc(n * sizeof(real_t));\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = 0.0;\n        c[x] = 0.0;\n    }\n\n    #pragma acc enter data create(b[0:n])\n    #pragma acc data copyin(a[0:n])\n    {\n        #pragma acc parallel present(b[0:n])\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                b[x] = a[x];\n            }\n        }\n    }\n    #pragma acc data copyout(c[0:n])\n    {\n        #pragma acc parallel present(b[0:n])\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                c[x] = b[x];\n            }\n        }\n    }\n    #pragma acc exit data delete(b[0:n])\n\n    for (int x = 0; x < n; ++x){\n        if (fabs(c[x] - a[x]) > PRECISION) {\n            err += 1;\n            break;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "data",
                            "executable-data",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "2": {
                        "content": "#ifndef T2\n//T2:data,executable-data,construct-independent,compatibility-features,V:2.0-2.7\nint test2(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n    real_t * c = (real_t *)malloc(n * sizeof(real_t));\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = 0.0;\n        c[x] = 0.0;\n    }\n\n    #pragma acc enter data present_or_create(b[0:n])\n    #pragma acc data copyin(a[0:n])\n    {\n        #pragma acc parallel present(b[0:n])\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                b[x] = a[x];\n            }\n        }\n    }\n    #pragma acc data copyout(c[0:n])\n    {\n        #pragma acc parallel present(b[0:n])\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                c[x] = b[x];\n            }\n        }\n    }\n    #pragma acc exit data delete(b[0:n])\n    for (int x = 0; x < n; ++x){\n        if (fabs(c[x] - a[x]) > PRECISION) {\n            err += 2;\n            break;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T2\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test2();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 1);\n    }\n#endif\n",
                        "tags": [
                            "data",
                            "executable-data",
                            "construct-independent",
                            "compatibility-features"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "3": {
                        "content": "#ifndef T3\n//T3:data,executable-data,construct-independent,compatibility-features,V:2.0-2.7\nint test3(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n    real_t * c = (real_t *)malloc(n * sizeof(real_t));\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = 0.0;\n        c[x] = 0.0;\n    }\n\n    #pragma acc enter data pcreate(b[0:n])\n    #pragma acc data copyin(a[0:n])\n    {\n        #pragma acc parallel present(b[0:n])\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                b[x] = a[x];\n            }\n        }\n    }\n    #pragma acc data copyout(c[0:n])\n    {\n        #pragma acc parallel present(b[0:n])\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                c[x] = b[x];\n            }\n        }\n    }\n    #pragma acc exit data delete(b[0:n])\n    for (int x = 0; x < n; ++x){\n        if (fabs(c[x] - a[x]) > PRECISION){\n            err += 4;\n            break;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T3\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test3();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 2);\n    }\n#endif\n",
                        "tags": [
                            "data",
                            "executable-data",
                            "construct-independent",
                            "compatibility-features"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "enter_data_create_no_lower_bound.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:data,executable-data,construct-independent,V:2.0-2.7\n      LOGICAL FUNCTION test1()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT):: a, b, c, d, e !Data\n        INTEGER :: errors = 0\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(a)\n        CALL RANDOM_NUMBER(b)\n        c = 0\n        CALL RANDOM_NUMBER(d)\n        e = 0\n\n        !$acc enter data create(c(:LOOPCOUNT))\n        !$acc data copyin(a(1:LOOPCOUNT), b(1:LOOPCOUNT), d(1:LOOPCOUNT)) copyout(e(1:LOOPCOUNT)) present(c(1:LOOPCOUNT))\n          !$acc parallel\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              c(x) = a(x) + b(x)\n            END DO\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              e(x) = c(x) + d(x)\n            END DO\n          !$acc end parallel\n        !$acc end data\n        DO x = 1, LOOPCOUNT\n          IF (abs(e(x) - (a(x) + b(x) + d(x))) .gt. PRECISION) THEN\n            errors = errors + 1\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "data",
                            "executable-data",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "enter_data_create_no_lower_bound.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:data,executable-data,syntactic,construct-independent,V:2.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n    real_t * c = (real_t *)malloc(n * sizeof(real_t));\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n        c[x] = 0.0;\n    }\n\n    #pragma acc enter data copyin(a[0:n], b[0:n]) create(c[:n])\n    #pragma acc parallel present(a[0:n], b[0:n], c[0:n])\n    {\n        #pragma acc loop\n        for (int x = 0; x < n; ++x){\n            c[x] = a[x] + b[x];\n        }\n    }\n    #pragma acc exit data delete(a[0:n], b[0:n]) copyout(c[0:n])\n\n    for (int x = 0; x < n; ++x){\n        if (fabs(c[x] - (a[x] + b[x])) > PRECISION){\n            err += 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "data",
                            "executable-data",
                            "syntactic",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "enter_data_if.F90": {
                "num tests": 5,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:data,executable-data,devonly,construct-independent,if,V:2.0-2.7\n      LOGICAL FUNCTION test1()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT):: a, a_copy, b, b_copy, c !Data\n        INTEGER :: errors = 0\n        INTEGER,DIMENSION(1):: devtest\n        LOGICAL :: dev = .TRUE.\n        LOGICAL :: cpu = .FALSE.\n        devtest(1) = 1\n\n        !$acc enter data copyin(devtest(1:1))\n        !$acc parallel\n          devtest(1) = 0\n        !$acc end parallel\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(a)\n        CALL RANDOM_NUMBER(b)\n        c = 0\n\n        !$acc enter data copyin(a(1:LOOPCOUNT), b(1:LOOPCOUNT)) if(dev)\n        !$acc data create(a(1:LOOPCOUNT), b(1:LOOPCOUNT)) copyout(c(1:LOOPCOUNT))\n          !$acc parallel\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              c(x) = a(x) + b(x)\n            END DO\n          !$acc end parallel\n        !$acc end data\n        !$acc exit data delete(a(1:LOOPCOUNT), b(1:LOOPCOUNT)) if(dev)\n        DO x = 1, LOOPCOUNT\n          IF (abs(c(x) - (a(x) + b(x))) .gt. PRECISION) THEN\n            errors = errors + 1\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "data",
                            "executable-data",
                            "devonly",
                            "construct-independent",
                            "if"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "2": {
                        "content": "#ifndef T2\n!T2:data,executable-data,devonly,construct-independent,if,V:2.0-2.7\n      LOGICAL FUNCTION test2()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT):: a, a_copy, b, b_copy, c !Data\n        INTEGER :: errors = 0\n        INTEGER,DIMENSION(1):: devtest\n        LOGICAL :: dev = .TRUE.\n        LOGICAL :: cpu = .FALSE.\n        devtest(1) = 1\n\n        !$acc enter data copyin(devtest(1:1))\n        !$acc parallel\n          devtest(1) = 0\n        !$acc end parallel\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(a)\n        CALL RANDOM_NUMBER(b)\n        c = 0\n\n        !$acc enter data create(a(1:LOOPCOUNT), b(1:LOOPCOUNT)) if(cpu)\n        !$acc data copyin(a(1:LOOPCOUNT), b(1:LOOPCOUNT)) copyout(c(1:LOOPCOUNT))\n          !$acc parallel\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              c(x) = a(x) + b(x)\n            END DO\n          !$acc end parallel\n        !$acc end data\n        !$acc exit data copyout(a(1:LOOPCOUNT), b(1:LOOPCOUNT)) if(cpu)\n\n        DO x = 1, LOOPCOUNT\n          IF (abs(c(x) - (a(x) + b(x))) .gt. PRECISION) THEN\n            errors = errors + 1\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test2 = .FALSE.\n        ELSE\n          test2 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T2\n        LOGICAL :: test2\n#endif\n#ifndef T2\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test2()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 1\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "data",
                            "executable-data",
                            "devonly",
                            "construct-independent",
                            "if"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "3": {
                        "content": "#ifndef T3\n!T3:data,executable-data,devonly,construct-independent,if,V:2.0-2.7\n      LOGICAL FUNCTION test3()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT):: a, a_copy, b, b_copy, c !Data\n        INTEGER :: errors = 0\n        INTEGER,DIMENSION(1):: devtest\n        LOGICAL :: dev = .TRUE.\n        LOGICAL :: cpu = .FALSE.\n        devtest(1) = 1\n\n        !$acc enter data copyin(devtest(1:1))\n        !$acc parallel\n          devtest(1) = 0\n        !$acc end parallel\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        IF (devtest(1) .eq. 1) THEN\n          CALL RANDOM_NUMBER(a)\n          a_copy = a\n          CALL RANDOM_NUMBER(b)\n          b_copy = b\n          c = 0\n\n          !$acc enter data copyin(a(1:LOOPCOUNT), b(1:LOOPCOUNT)) if(dev)\n\n          a = 0\n          b = 0\n\n          !$acc data copyin(a(1:LOOPCOUNT), b(1:LOOPCOUNT)) copyout(c(1:LOOPCOUNT))\n            !$acc parallel\n              !$acc loop\n              DO x = 1, LOOPCOUNT\n                c(x) = a(x) + b(x)\n              END DO\n            !$acc end parallel\n          !$acc end data\n          !$acc exit data delete(a(1:LOOPCOUNT), b(1:LOOPCOUNT)) if(dev)\n\n          DO x = 1, LOOPCOUNT\n            IF (abs(c(x) - (a_copy(x) + b_copy(x))) .gt. PRECISION) THEN\n              errors = errors + 1\n            END IF\n          END DO\n        END IF\n\n        IF (errors .eq. 0) THEN\n          test3 = .FALSE.\n        ELSE\n          test3 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T3\n        LOGICAL :: test3\n#endif\n#ifndef T3\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test3()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 2\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "data",
                            "executable-data",
                            "devonly",
                            "construct-independent",
                            "if"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "4": {
                        "content": "#ifndef T4\n!T4:data,executable-data,devonly,construct-independent,if,V:2.0-2.7\n      LOGICAL FUNCTION test4()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT):: a, a_copy, b, b_copy, c !Data\n        INTEGER :: errors = 0\n        INTEGER,DIMENSION(1):: devtest\n        LOGICAL :: dev = .TRUE.\n        LOGICAL :: cpu = .FALSE.\n        devtest(1) = 1\n\n        !$acc enter data copyin(devtest(1:1))\n        !$acc parallel\n          devtest(1) = 0\n        !$acc end parallel\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        IF (devtest(1) .eq. 1) THEN\n          CALL RANDOM_NUMBER(a)\n          CALL RANDOM_NUMBER(b)\n          c = 0\n\n          !$acc enter data copyin(a(1:LOOPCOUNT), b(1:LOOPCOUNT)) if(cpu)\n          CALL RANDOM_NUMBER(a)\n          a_copy = a\n          CALL RANDOM_NUMBER(b)\n          b_copy = b\n\n          !$acc data copyin(a(1:LOOPCOUNT), b(1:LOOPCOUNT)) copyout(c(1:LOOPCOUNT))\n            !$acc parallel\n              !$acc loop\n              DO x = 1, LOOPCOUNT\n                c(x) = a(x) + b(x)\n              END DO\n            !$acc end parallel\n          !$acc end data\n          !$acc exit data copyout(a(1:LOOPCOUNT), b(1:LOOPCOUNT)) if(cpu)\n\n          DO x = 1, LOOPCOUNT\n            IF (abs(c(x) - (a_copy(x) + b_copy(x))) .gt. PRECISION) THEN\n              errors = errors + 1\n            END IF\n          END DO\n        END IF\n\n        IF (errors .eq. 0) THEN\n          test4 = .FALSE.\n        ELSE\n          test4 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T4\n        LOGICAL :: test4\n#endif\n#ifndef T4\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test4()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 3\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "data",
                            "executable-data",
                            "devonly",
                            "construct-independent",
                            "if"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "5": {
                        "content": "#ifndef T5\n!T5:data,executable-data,devonly,construct-independent,if,V:2.0-2.7\n      LOGICAL FUNCTION test5()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT):: a, a_copy, b, b_copy, c !Data\n        INTEGER :: errors = 0\n        INTEGER,DIMENSION(1):: devtest\n        LOGICAL :: dev = .TRUE.\n        LOGICAL :: cpu = .FALSE.\n        devtest(1) = 1\n\n        !$acc enter data copyin(devtest(1:1))\n        !$acc parallel\n          devtest(1) = 0\n        !$acc end parallel\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        IF (devtest(1) .eq. 1) THEN\n          CALL RANDOM_NUMBER(a)\n          CALL RANDOM_NUMBER(b)\n          c = 0\n\n          !$acc enter data create(a(1:LOOPCOUNT), b(1:LOOPCOUNT)) if(cpu)\n          !$acc data copyin(a(1:LOOPCOUNT), b(1:LOOPCOUNT)) copyout(c(1:LOOPCOUNT))\n            !$acc parallel\n              !$acc loop\n              DO x = 1, LOOPCOUNT\n                c(x) = a(x) + b(x)\n              END DO\n            !$acc end parallel\n          !$acc end data\n\n          DO x = 1, LOOPCOUNT\n            IF (abs(c(x) - (a(x) + b(x))) .gt. PRECISION) THEN\n              errors = errors + 1\n            END IF\n          END DO\n        END IF\n\n        IF (errors .eq. 0) THEN\n          test5 = .FALSE.\n        ELSE\n          test5 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T5\n        LOGICAL :: test5\n#endif\n#ifndef T5\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test5()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 4\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "data",
                            "executable-data",
                            "devonly",
                            "construct-independent",
                            "if"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "enter_exit_data_if.c": {
                "num tests": 5,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:data,executable-data,construct-independent,if,reference-counting,V:2.5-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n    real_t * c = (real_t *)malloc(n * sizeof(real_t));\n    int dev = 1;\n    int host = 0;\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n        c[x] = 0.0;\n    }\n\n    #pragma acc enter data copyin(a[0:n], b[0:n]) if(dev)\n    #pragma acc data create(a[0:n], b[0:n]) copyout(c[0:n])\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                c[x] = a[x] + b[x];\n            }\n        }\n    }\n    #pragma acc exit data delete(a[0:n], b[0:n]) if(dev)\n\n    for (int x = 0; x < n; ++x){\n        if (fabs(c[x] - (a[x] + b[x])) > PRECISION){\n            err += 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "data",
                            "executable-data",
                            "construct-independent",
                            "if",
                            "reference-counting"
                        ],
                        "versions": [
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "2": {
                        "content": "#ifndef T2\n//T2:data,executable-data,construct-independent,if,V:2.0-2.7\nint test2(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n    real_t * c = (real_t *)malloc(n * sizeof(real_t));\n    int dev = 1;\n    int host = 0;\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n        c[x] = 0;\n    }\n\n    #pragma acc enter data create(a[0:n], b[0:n]) if(host)\n    #pragma acc data copyin(a[0:n], b[0:n]) copyout(c[0:n])\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                c[x] = a[x] + b[x];\n            }\n        }\n    }\n    #pragma acc exit data delete(a[0:n], b[0:n]) if(host)\n\n    for (int x = 0; x < n; ++x){\n        if (fabs(c[x] - (a[x] + b[x])) > PRECISION){\n            err += 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T2\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test2();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 1);\n    }\n#endif\n",
                        "tags": [
                            "data",
                            "executable-data",
                            "construct-independent",
                            "if"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "3": {
                        "content": "#ifndef T3\n//T3:data,executable-data,construct-independent,devonly,if,reference-counting,V:2.5-2.7\nint test3(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(n * sizeof(real_t));\n    real_t * a_copy = (real_t *)malloc(n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n    real_t * b_copy = (real_t *)malloc(n * sizeof(real_t));\n    real_t * c = (real_t *)malloc(n * sizeof(real_t));\n    int dev = 1;\n    int host = 0;\n    int * devtest = (int *)malloc(sizeof(int));\n\n    devtest[0] = 1;\n    #pragma acc enter data copyin(devtest[0:1])\n    #pragma acc parallel\n    {\n        devtest[0] = 0;\n    }\n\n    if (devtest[0] == 1){\n        for (int x = 0; x < n; ++x){\n            a[x] = rand() / (real_t)(RAND_MAX / 10);\n            a_copy[x] = a[x];\n            b[x] = rand() / (real_t)(RAND_MAX / 10);\n            b_copy[x] = b[x];\n            c[x] = 0.0;\n        }\n\n        #pragma acc enter data copyin(a[0:n], b[0:n]) if(dev)\n        for (int x = 0; x < n; ++x){\n            a[x] = 0;\n            b[x] = 0;\n        }\n        #pragma acc data create(a[0:n], b[0:n]) copyout(c[0:n])\n        {\n            #pragma acc parallel\n            {\n                #pragma acc loop\n                for (int x = 0; x < n; ++x){\n                    c[x] = a[x] + b[x];\n                }\n            }\n        }\n        #pragma acc exit data copyout(a[0:n], b[0:n]) if(dev)\n\n        for (int x = 0; x < n; ++x){\n            if (fabs(c[x] - (a_copy[x] + b_copy[x])) > PRECISION){\n                err += 1;\n            }\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T3\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test3();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 2);\n    }\n#endif\n",
                        "tags": [
                            "data",
                            "executable-data",
                            "construct-independent",
                            "devonly",
                            "if",
                            "reference-counting"
                        ],
                        "versions": [
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "4": {
                        "content": "#ifndef T4\n//T4:data,executable-data,if,construct-independent,devonly,V:2.0-2.7\nint test4(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(n * sizeof(real_t));\n    real_t * a_copy = (real_t *)malloc(n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n    real_t * b_copy = (real_t *)malloc(n * sizeof(real_t));\n    real_t * c = (real_t *)malloc(n * sizeof(real_t));\n    int dev = 1;\n    int host = 0;\n    int * devtest = (int *)malloc(sizeof(int));\n\n    devtest[0] = 1;\n    #pragma acc enter data copyin(devtest[0:1])\n    #pragma acc parallel\n    {\n        devtest[0] = 0;\n    }\n\n    if (devtest[0] == 1){\n        for (int x = 0; x < n; ++x){\n            a[x] = rand() / (real_t)(RAND_MAX / 10);\n            b[x] = rand() / (real_t)(RAND_MAX / 10);\n            c[x] = 0.0;\n        }\n\n        #pragma acc enter data copyin(a[0:n], b[0:n]) if(host)\n        for (int x = 0; x < n; ++x){\n            a[x] = rand() / (real_t)(RAND_MAX / 10);\n            a_copy[x] = a[x];\n            b[x] = rand() / (real_t)(RAND_MAX / 10);\n            b_copy[x] = b[x];\n        }\n        #pragma acc data copyin(a[0:n], b[0:n]) copyout(c[0:n])\n        {\n            #pragma acc parallel\n            {\n                #pragma acc loop\n                for (int x = 0; x < n; ++x){\n                    c[x] = a[x] + b[x];\n                }\n            }\n        }\n        #pragma acc exit data copyout(a[0:n], b[0:n]) if(host)\n\n        for (int x = 0; x < n; ++x){\n            if (fabs(c[x] - (a_copy[x] + b_copy[x])) > PRECISION){\n                err += 1;\n            }\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T4\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test4();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 3);\n    }\n#endif\n",
                        "tags": [
                            "data",
                            "executable-data",
                            "if",
                            "construct-independent",
                            "devonly"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "5": {
                        "content": "#ifndef T5\n//T5:data,executable-data,if,construct-independent,devonly,V:2.0-2.7\nint test5(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(n * sizeof(real_t));\n    real_t * a_copy = (real_t *)malloc(n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n    real_t * b_copy = (real_t *)malloc(n * sizeof(real_t));\n    real_t * c = (real_t *)malloc(n * sizeof(real_t));\n    int dev = 1;\n    int host = 0;\n    int * devtest = (int *)malloc(sizeof(int));\n\n    devtest[0] = 1;\n    #pragma acc enter data copyin(devtest[0:1])\n    #pragma acc parallel\n    {\n        devtest[0] = 0;\n    }\n\n    if (devtest[0] == 1){\n        for (int x = 0; x < n; ++x){\n            a[x] = rand() / (real_t)(RAND_MAX / 10);\n            b[x] = rand() / (real_t)(RAND_MAX / 10);\n            c[x] = 0.0;\n        }\n\n        #pragma acc enter data create(a[0:n], b[0:n]) if(host)\n        #pragma acc data copyin(a[0:n], b[0:n]) copyout(c[0:n])\n        {\n            #pragma acc parallel\n            {\n                #pragma acc loop\n                for (int x = 0; x < n; ++x){\n                    c[x] = a[x] + b[x];\n                }\n            }\n        }\n        #pragma acc exit data copyout(a[0:n], b[0:n]) if(host)\n\n        for (int x = 0; x < n; ++x){\n            if (fabs(c[x] - (a[x] + b[x])) > PRECISION){\n                err += 1;\n            }\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T5\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test5();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 4);\n    }\n#endif\n",
                        "tags": [
                            "data",
                            "executable-data",
                            "if",
                            "construct-independent",
                            "devonly"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "exit_data.F90": {
                "num tests": 2,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:data,executable-data,devonly,construct-independent,V:2.0-2.7\n      LOGICAL FUNCTION test1()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT):: a, a_copy !Data\n        INTEGER :: errors = 0\n        INTEGER,DIMENSION(1):: devtest\n        devtest(1) = 1\n        !$acc enter data copyin(devtest(1:1))\n        !$acc parallel\n          devtest(1) = 0\n        !$acc end parallel\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(a)\n        a_copy = a\n\n        IF (devtest(1) .eq. 1) THEN\n          !$acc enter data copyin(a(1:LOOPCOUNT))\n          !$acc parallel present(a(1:LOOPCOUNT))\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              a(x) = a(x) + 1\n            END DO\n          !$acc end parallel\n          !$acc exit data delete(a(1:LOOPCOUNT))\n\n          DO x = 1, LOOPCOUNT\n            IF (abs(a(x) - a_copy(x)) .gt. PRECISION) THEN\n              errors = errors + 1\n            END IF\n          END DO\n        END IF\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "data",
                            "executable-data",
                            "devonly",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "2": {
                        "content": "#ifndef T2\n!T2:data,executable-data,devonly,construct-independent,V:2.0-2.7\n      LOGICAL FUNCTION test2()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT):: a, a_copy !Data\n        INTEGER :: errors = 0\n        INTEGER,DIMENSION(1):: devtest\n        devtest(1) = 1\n        !$acc enter data copyin(devtest(1:1))\n        !$acc parallel\n          devtest(1) = 0\n        !$acc end parallel\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(a)\n        a_copy = a\n        !$acc enter data copyin(a(1:LOOPCOUNT))\n        !$acc parallel present(a(1:LOOPCOUNT))\n          !$acc loop\n          DO x = 1, LOOPCOUNT\n            a(x) = a(x) + 1\n          END DO\n        !$acc end parallel\n        !$acc exit data copyout(a(1:LOOPCOUNT))\n\n        DO x = 1, LOOPCOUNT\n          IF (abs(a(x) - (a_copy(x) + 1)) .gt. PRECISION) THEN\n            errors = errors + 1\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test2 = .FALSE.\n        ELSE\n          test2 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T2\n        LOGICAL :: test2\n#endif\n#ifndef T2\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test2()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 1\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "data",
                            "executable-data",
                            "devonly",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "exit_data.c": {
                "num tests": 2,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:data,executable-data,devonly,construct-independent,V:2.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(n * sizeof(real_t));\n    real_t * a_copy = (real_t *)malloc(n * sizeof(real_t));\n    int * devtest = (int *)malloc(sizeof(int));\n\n    devtest[0] = 1;\n    #pragma acc enter data copyin(devtest[0:1])\n    #pragma acc parallel present(devtest[0:1])\n    {\n        devtest[0] = 0;\n    }\n\n    if (devtest[0] == 1){\n        for (int x = 0; x < n; ++x){\n            a[x] = rand() / (real_t)(RAND_MAX / 10);\n            a_copy[x] = a[x];\n        }\n\n        #pragma acc enter data copyin(a[0:n])\n        #pragma acc parallel present(a[0:n])\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                a[x] = a[x] + 1;\n            }\n        }\n        #pragma acc exit data delete(a[0:n])\n\n        for (int x = 0; x < n; ++x){\n            if (fabs(a[x] - a_copy[x]) > PRECISION){\n                err += 1;\n            }\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "data",
                            "executable-data",
                            "devonly",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "2": {
                        "content": "#ifndef T2\n//T2:data,executable-data,V:2.0-2.7\nint test2(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(n * sizeof(real_t));\n    real_t * a_copy = (real_t *)malloc(n * sizeof(real_t));\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        a_copy[x] = a[x];\n    }\n\n    #pragma acc enter data copyin(a[0:n])\n    #pragma acc parallel present(a[0:n])\n    {\n        #pragma acc loop\n        for (int x = 0; x < n; ++x){\n            a[x] = a[x] + 1;\n        }\n    }\n    #pragma acc exit data copyout(a[0:n])\n\n    for (int x = 0; x < n; ++x){\n        if (fabs(a[x] - (a_copy[x] + 1)) > PRECISION){\n            err += 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T2\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test2();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 1);\n    }\n#endif\n",
                        "tags": [
                            "data",
                            "executable-data"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "exit_data_copyout_no_lower_bound.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:data,executable-data,construct-independent,V:2.0-2.7\n      LOGICAL FUNCTION test1()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT):: a, b, c !Data\n        INTEGER :: errors = 0\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(a)\n        CALL RANDOM_NUMBER(b)\n        c = 0\n        !$acc enter data create(c(1:LOOPCOUNT))\n        !$acc data copyin(a(1:LOOPCOUNT), b(1:LOOPCOUNT)) present(c(1:LOOPCOUNT))\n          !$acc parallel\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              c(x) = a(x) + b(x)\n            END DO\n          !$acc end parallel\n        !$acc end data\n        !$acc exit data copyout(c(:LOOPCOUNT))\n        DO x = 1, LOOPCOUNT\n          IF (abs(c(x) - (a(x) + b(x))) .gt. PRECISION) THEN\n            errors = errors + 1\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "data",
                            "executable-data",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "exit_data_copyout_no_lower_bound.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:data,executable-data,syntactic,construct-independent,V:2.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n    real_t * c = (real_t *)malloc(n * sizeof(real_t));\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n        c[x] = 0.0;\n    }\n\n    #pragma acc enter data copyin(a[0:n], b[0:n]) create(c[0:n])\n    #pragma acc parallel present(a[0:n], b[0:n], c[0:n])\n    {\n        #pragma acc loop\n        for (int x = 0; x < n; ++x){\n            c[x] = a[x] + b[x];\n        }\n    }\n    #pragma acc exit data delete(a[0:n], b[0:n]) copyout(c[:n])\n\n    for (int x = 0; x < n; ++x){\n        if (fabs(c[x] - (a[x] + b[x])) > PRECISION) {\n            err += 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "data",
                            "executable-data",
                            "syntactic",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "exit_data_copyout_reference_counts.F90": {
                "num tests": 3,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:data,executable-data,devonly,construct-independent,V:2.0-2.7\n      LOGICAL FUNCTION test1()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT):: a, b, c !Data\n        INTEGER :: errors = 0\n        INTEGER,DIMENSION(1):: devtest\n\n        devtest(1) = 1\n        !$acc enter data copyin(devtest(1:1))\n        !$acc parallel present(devtest(1:1))\n          devtest(1) = 0\n        !$acc end parallel\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(a)\n        CALL RANDOM_NUMBER(b)\n        c = 0\n\n        IF (devtest(1) .eq. 1) THEN\n          !$acc enter data copyin(a(1:LOOPCOUNT), b(1:LOOPCOUNT), c(1:LOOPCOUNT))\n          !$acc data copyin(c(1:LOOPCOUNT))\n            !$acc parallel\n              !$acc loop\n              DO x = 1, LOOPCOUNT\n                c(x) = c(x) + a(x) + b(x)\n              END DO\n            !$acc end parallel\n            !$acc exit data delete(a(1:LOOPCOUNT), b(1:LOOPCOUNT)) copyout(c(1:LOOPCOUNT))\n          !$acc end data\n\n          DO x = 1, LOOPCOUNT\n            IF (abs(c(x)) .gt. PRECISION) THEN\n              errors = errors + 1\n              EXIT\n            END IF\n          END DO \n        END IF\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "data",
                            "executable-data",
                            "devonly",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "2": {
                        "content": "#ifndef T2\n!T2:data,executable-data,devonly,construct-independent,V:2.0-2.7\n      LOGICAL FUNCTION test2()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT):: a, b, c !Data\n        INTEGER :: errors = 0\n        INTEGER,DIMENSION(1):: devtest\n\n        devtest(1) = 1\n        !$acc enter data copyin(devtest(1:1))\n        !$acc parallel present(devtest(1:1))\n          devtest(1) = 0\n        !$acc end parallel\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(a)\n        CALL RANDOM_NUMBER(b)\n        c = 0\n        !$acc enter data copyin(a(1:LOOPCOUNT), b(1:LOOPCOUNT), c(1:LOOPCOUNT))\n        !$acc data copyin(c(1:LOOPCOUNT))\n          !$acc parallel\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              c(x) = c(x) + a(x) + b(x)\n            END DO\n          !$acc end parallel\n        !$acc end data\n        !$acc exit data copyout(c(1:LOOPCOUNT)) delete(a(1:LOOPCOUNT), b(1:LOOPCOUNT))\n\n        DO x = 1, LOOPCOUNT\n          IF (abs(c(x) - (a(x) + b(x))) .gt. PRECISION) THEN\n            errors = errors + 2\n            EXIT\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test2 = .FALSE.\n        ELSE\n          test2 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T2\n        LOGICAL :: test2\n#endif\n#ifndef T2\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test2()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 1\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "data",
                            "executable-data",
                            "devonly",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "3": {
                        "content": "#ifndef T3\n!T3:data,executable-data,devonly,construct-independent,V:2.0-2.7\n      LOGICAL FUNCTION test3()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT):: a, b, c !Data\n        INTEGER :: errors = 0\n        INTEGER,DIMENSION(1):: devtest\n\n        devtest(1) = 1\n        !$acc enter data copyin(devtest(1:1))\n        !$acc parallel present(devtest(1:1))\n          devtest(1) = 0\n        !$acc end parallel\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(a)\n        CALL RANDOM_NUMBER(b)\n        c = 0\n\n        !$acc enter data copyin(a(1:LOOPCOUNT), b(1:LOOPCOUNT), c(1:LOOPCOUNT))\n        !$acc enter data copyin(c(1:LOOPCOUNT))\n        !$acc parallel\n          !$acc loop\n          DO x = 1, LOOPCOUNT\n            c(x) = c(x) + a(x) + b(x)\n          END DO\n        !$acc end parallel\n        !$acc exit data delete(c(1:LOOPCOUNT))\n        !$acc exit data delete(a(1:LOOPCOUNT), b(1:LOOPCOUNT)) copyout(c(1:LOOPCOUNT))\n\n        DO x = 1, LOOPCOUNT\n          IF (abs(c(x) - (a(x) + b(x))) .gt. PRECISION) THEN\n            errors = errors + 4\n            EXIT\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test3 = .FALSE.\n        ELSE\n          test3 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T3\n        LOGICAL :: test3\n#endif\n#ifndef T3\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test3()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 2\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "data",
                            "executable-data",
                            "devonly",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "exit_data_copyout_reference_counts.c": {
                "num tests": 3,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:data,executable-data,devonly,construct-independent,reference-counting,V:2.5-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n    real_t * c = (real_t *)malloc(n * sizeof(real_t));\n    int * devtest = (int *)malloc(sizeof(int));\n\n    devtest[0] = 1;\n    #pragma acc enter data copyin(devtest[0:1])\n    #pragma acc parallel present(devtest[0:1])\n    {\n        devtest[0] = 0;\n    }\n\n    if (devtest[0] == 1){\n        for (int x = 0; x < n; ++x){\n          a[x] = rand() / (real_t)(RAND_MAX / 10);\n          b[x] = rand() / (real_t)(RAND_MAX / 10);\n          c[x] = 0.0;\n        }\n\n        #pragma acc enter data copyin(a[0:n], b[0:n], c[0:n])\n        #pragma acc data copyin(c[0:n])\n        {\n            #pragma acc parallel\n            {\n                #pragma acc loop\n                for (int x = 0; x < n; ++x){\n                    c[x] += a[x] + b[x];\n                }\n            }\n            #pragma acc exit data copyout(c[0:n]) delete(a[0:n], b[0:n])\n        }\n        for (int x = 0; x < n; ++x){\n            if (fabs(c[x]) > PRECISION){\n                err += 1;\n            }\n        }\n\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "data",
                            "executable-data",
                            "devonly",
                            "construct-independent",
                            "reference-counting"
                        ],
                        "versions": [
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "2": {
                        "content": "#ifndef T2\n//T2:data,executable-data,reference-counting,construct-independent,V:2.5-2.7\nint test2(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n    real_t * c = (real_t *)malloc(n * sizeof(real_t));\n\n    for (int x = 0; x < n; ++x){\n      a[x] = rand() / (real_t)(RAND_MAX / 10);\n      b[x] = rand() / (real_t)(RAND_MAX / 10);\n      c[x] = 0.0;\n    }\n\n    #pragma acc enter data copyin(a[0:n], b[0:n], c[0:n])\n    #pragma acc data copyin(c[0:n])\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                c[x] += a[x] + b[x];\n            }\n        }\n    }\n    #pragma acc exit data copyout(c[0:n]) delete(a[0:n], b[0:n])\n\n    for (int x = 0; x < n; ++x){\n        if (fabs(c[x] - (a[x] + b[x])) > PRECISION){\n            err += 2;\n            break;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T2\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test2();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 1);\n    }\n#endif\n",
                        "tags": [
                            "data",
                            "executable-data",
                            "reference-counting",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "3": {
                        "content": "#ifndef T3\n//T3:data,executable-data,reference-counting,construct-independent,V:2.5-2.7\nint test3(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n    real_t * c = (real_t *)malloc(n * sizeof(real_t));\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n        c[x] = 0.0;\n    }\n\n    #pragma acc enter data copyin(a[0:n], b[0:n], c[0:n])\n    #pragma acc enter data create(c[0:n])\n    #pragma acc parallel\n    {\n        #pragma acc loop\n        for (int x = 0; x < n; ++x){\n            c[x] += a[x] + b[x];\n        }\n    }\n    #pragma acc exit data delete(c[0:n])\n    #pragma acc exit data delete(a[0:n], b[0:n]) copyout(c[0:n])\n\n    for (int x = 0; x < n; ++x){\n        if (fabs(c[x] - (a[x] + b[x])) > PRECISION){\n            err += 4;\n            break;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T3\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test3();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 2);\n    }\n#endif\n",
                        "tags": [
                            "data",
                            "executable-data",
                            "reference-counting",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "exit_data_delete_no_lower_bound.F90": {
                "num tests": 2,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:data,executable-data,construct-independent,V:2.0-2.7\n      LOGICAL FUNCTION test1()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT):: a, b, c !Data\n        INTEGER :: errors = 0\n        LOGICAL,DIMENSION(1):: has_device\n\n        has_device(1) = .TRUE.\n        !$acc enter data copyin(has_device(1:1))\n        !$acc parallel present(has_device(1:1))\n          has_device(1) = .FALSE.\n        !$acc end parallel\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(a)\n        CALL RANDOM_NUMBER(b)\n        c = 0\n\n        !$acc enter data copyin(a(1:LOOPCOUNT), b(1:LOOPCOUNT))\n        !$acc data copyout(c(1:LOOPCOUNT)) present(a(1:LOOPCOUNT), b(1:LOOPCOUNT))\n          !$acc parallel\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              c(x) = a(x) + b(x)\n            END DO\n          !$acc end parallel\n        !$acc end data\n        !$acc exit data delete(a(:LOOPCOUNT), b(:LOOPCOUNT))\n        DO x = 1, LOOPCOUNT\n          IF (abs(c(x) - (a(x) + b(x))) .gt. PRECISION) THEN\n            errors = errors + 1\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "data",
                            "executable-data",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "2": {
                        "content": "#ifndef T2\n!T2:data,executable-data,construct-independent,V:2.0-2.7\n      LOGICAL FUNCTION test2()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT):: a, b, c !Data\n        INTEGER :: errors = 0\n        LOGICAL,DIMENSION(1):: has_device\n\n        has_device(1) = .TRUE.\n        !$acc enter data copyin(has_device(1:1))\n        !$acc parallel present(has_device(1:1))\n          has_device(1) = .FALSE.\n        !$acc end parallel\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        IF (has_device(1) .eqv. .TRUE.) THEN\n          CALL RANDOM_NUMBER(a)\n          CALL RANDOM_NUMBER(b)\n          c = 0\n          \n          !$acc enter data copyin(c(1:LOOPCOUNT))\n          !$acc data copyin(a(1:LOOPCOUNT), b(1:LOOPCOUNT)) present(c(1:LOOPCOUNT))\n            !$acc parallel\n              !$acc loop\n              DO x = 1, LOOPCOUNT\n                c(x) = a(x) + b(x)\n              END DO\n            !$acc end parallel\n          !$acc end data\n          !$acc exit data delete(c(:LOOPCOUNT))\n\n          DO x = 1, LOOPCOUNT\n            IF (abs(c(x)) .gt. PRECISION) THEN\n              errors = errors + 1\n            END IF\n          END DO\n        END IF\n\n        IF (errors .eq. 0) THEN\n          test2 = .FALSE.\n        ELSE\n          test2 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T2\n        LOGICAL :: test2\n#endif\n#ifndef T2\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test2()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 1\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "data",
                            "executable-data",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "exit_data_delete_no_lower_bound.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:data,executable-data,construct-independent,syntactic,V:2.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n    real_t * c = (real_t *)malloc(n * sizeof(real_t));\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n        c[x] = 0.0;\n    }\n\n    #pragma acc enter data copyin(a[0:n], b[0:n]) create(c[0:n])\n    #pragma acc parallel present(a[0:n], b[0:n], c[0:n])\n    {\n        #pragma acc loop\n        for (int x = 0; x < n; ++x){\n            c[x] = a[x] + b[x];\n        }\n    }\n    #pragma acc exit data delete(a[:n], b[:n]) copyout(c[0:n])\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "data",
                            "executable-data",
                            "construct-independent",
                            "syntactic"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "exit_data_finalize.F90": {
                "num tests": 2,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:data,executable-data,devonly,construct-independent,V:2.0-2.7\n      LOGICAL FUNCTION test1()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT):: a, b, c !Data\n        INTEGER :: errors = 0\n        INTEGER,DIMENSION(1) :: devtest\n\n        devtest(1) = 1\n        !$acc enter data copyin(devtest(1:1))\n        !$acc parallel present(devtest(1:1))\n          devtest(1) = 0\n        !$acc end parallel\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(a)\n        CALL RANDOM_NUMBER(b)\n        c = 0\n\n        !$acc enter data copyin(a(1:LOOPCOUNT), b(1:LOOPCOUNT), c(1:LOOPCOUNT))\n        !$acc enter data create(a(1:LOOPCOUNT), b(1:LOOPCOUNT), c(1:LOOPCOUNT))\n        !$acc parallel present(a(1:LOOPCOUNT), b(1:LOOPCOUNT), c(1:LOOPCOUNT))\n          !$acc loop\n          DO x = 1, LOOPCOUNT\n            c(x) = a(x) + b(x)\n          END DO\n        !$acc end parallel\n        !$acc exit data copyout(a(1:LOOPCOUNT), b(1:LOOPCOUNT), c(1:LOOPCOUNT))\n        IF (devtest(1) .eq. 1) THEN\n          DO x = 1, LOOPCOUNT\n            IF (abs(c(x)) .gt. PRECISION) THEN\n              errors = errors + 1\n            END IF\n          END DO\n        END IF\n        !$acc exit data copyout(a(1:LOOPCOUNT), b(1:LOOPCOUNT), c(1:LOOPCOUNT))\n        DO x = 1, LOOPCOUNT\n          IF (abs(c(x) - (a(x) + b(x))) .gt. PRECISION) THEN\n            errors = errors + 1\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "data",
                            "executable-data",
                            "devonly",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "2": {
                        "content": "#ifndef T2\n!T2:data,executable-data,devonly,construct-independent,V:2.5-2.7\n      LOGICAL FUNCTION test2()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT):: a, b, c !Data\n        INTEGER :: errors = 0\n        INTEGER,DIMENSION(1) :: devtest\n\n        devtest(1) = 1\n        !$acc enter data copyin(devtest(1:1))\n        !$acc parallel present(devtest(1:1))\n          devtest(1) = 0\n        !$acc end parallel\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(a)\n        CALL RANDOM_NUMBER(b)\n        c = 0\n        !$acc enter data copyin(a(1:LOOPCOUNT), b(1:LOOPCOUNT), c(1:LOOPCOUNT))\n        !$acc enter data create(a(1:LOOPCOUNT), b(1:LOOPCOUNT), c(1:LOOPCOUNT))\n        !$acc parallel present(a(1:LOOPCOUNT), b(1:LOOPCOUNT), c(1:LOOPCOUNT))\n          !$acc loop\n          DO x = 1, LOOPCOUNT\n            c(x) = a(x) + b(x)\n          END DO\n        !$acc end parallel\n        !$acc exit data copyout(c(1:LOOPCOUNT)) delete(a(1:LOOPCOUNT), b(1:LOOPCOUNT)) finalize\n        DO x = 1, LOOPCOUNT\n          IF (abs(c(x) - (a(x) + b(x))) .gt. PRECISION) THEN\n            errors = errors + 1\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test2 = .FALSE.\n        ELSE\n          test2 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T2\n        LOGICAL :: test2\n#endif\n#ifndef T2\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test2()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 1\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "data",
                            "executable-data",
                            "devonly",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "exit_data_finalize.c": {
                "num tests": 2,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:data,executable-data,reference-counting,construct-independent,V:2.5-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n    real_t * c = (real_t *)malloc(n * sizeof(real_t));\n    int * devtest = (int *)malloc(sizeof(int));\n\n    devtest[0] = 1;\n    #pragma acc enter data copyin(devtest[0:1])\n    #pragma acc parallel\n    {\n        devtest[0] = 0;\n    }\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n        c[x] = 0;\n    }\n\n    #pragma acc enter data copyin(a[0:n], b[0:n], c[0:n])\n    #pragma acc enter data create(a[0:n], b[0:n], c[0:n])\n    #pragma acc parallel present(a[0:n], b[0:n], c[0:n])\n    {\n        #pragma acc loop\n        for (int x = 0; x < n; ++x){\n            c[x] = a[x] + b[x];\n        }\n    }\n    #pragma acc exit data copyout(a[0:n], b[0:n], c[0:n])\n    if (devtest[0] == 1){\n        for (int x = 0; x < n; ++x){\n            if (fabs(c[x]) > PRECISION) {\n                err += 1;\n            }\n        }\n    }\n    #pragma acc exit data copyout(c[0:n]) delete(a[0:n], b[0:n])\n    for (int x = 0; x < n; ++x){\n        if (fabs(c[x] - (a[x] + b[x])) > PRECISION){\n            err += 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "data",
                            "executable-data",
                            "reference-counting",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "2": {
                        "content": "#ifndef T2\n//T2:data,executable-data,reference-counting,construct-independent,V:2.5-2.7\nint test2(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n    real_t * c = (real_t *)malloc(n * sizeof(real_t));\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n        c[x] = 0.0;\n    }\n\n    #pragma acc enter data copyin(a[0:n], b[0:n], c[0:n])\n    #pragma acc enter data copyin(a[0:n], b[0:n], c[0:n])\n    #pragma acc parallel present(a[0:n], b[0:n], c[0:n])\n    {\n        #pragma acc loop\n        for (int x = 0; x < n; ++x){\n            c[x] = a[x] + b[x];\n        }\n    }\n    #pragma acc exit data delete(a[0:n], b[0:n]) copyout(c[0:n]) finalize\n    for (int x = 0; x < n; ++x){\n        if (fabs(c[x] - (a[x] + b[x])) > PRECISION) {\n            err += 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T2\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test2();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 1);\n    }\n#endif\n",
                        "tags": [
                            "data",
                            "executable-data",
                            "reference-counting",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "host_data.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:data,data-region,host-data,construct-independent,V:2.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(n * sizeof(real_t));\n    int * high = (int *)malloc(n * sizeof(int));\n    int high_current_index = 0;\n    size_t * a_points = (size_t *)malloc(n * sizeof(void *));\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        if (a[x] > 5) {\n            high[high_current_index] = x;\n            high_current_index += 1;\n        }\n    }\n\n    #pragma acc enter data copyin(a[0:n])\n\n    #pragma acc host_data use_device(a)\n    {\n        int x = 0;\n        for (x = 0; x < high_current_index; ++x){\n            a_points[x] = (size_t) a + (high[x]*sizeof(real_t*));\n        }\n        for (; x < n; ++x){\n            a_points[x] = 0;\n        }\n    }\n    #pragma acc enter data copyin(a_points[0:n])\n    #pragma acc parallel present(a[0:n], a_points[0:n])\n    {\n        #pragma acc loop\n        for (int x = 0; x < n; ++x){\n            if (a_points[x] != 0){\n                *((real_t *) a_points[x]) -= 5;\n            }\n        }\n    }\n    #pragma acc exit data delete(a_points[0:n]) copyout(a[0:n])\n    for (int x = 0; x < n; ++x){\n        if (a[x] < 0 || a[x] > 5) {\n            err += 1;\n            break;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "data",
                            "data-region",
                            "host-data",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "id": 1,
            "init.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:construct-independent,init,nonvalidating,V:2.5-2.7\n      LOGICAL FUNCTION test1()\n        USE OPENACC\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: errors = 0\n\n        !$acc init\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "construct-independent",
                            "init",
                            "nonvalidating"
                        ],
                        "versions": [
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "init.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:init,V:2.5-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n\n    #pragma acc init\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "init"
                        ],
                        "versions": [
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "init_device_num.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:runtime,construct-independent,internal-control-values,init,nonvalidating,V:2.5-2.7\n      LOGICAL FUNCTION test1()\n        USE OPENACC\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: device_num\n        INTEGER :: device_type\n        INTEGER :: errors = 0\n\n        device_num = acc_get_device_num(acc_get_device_type())\n        !$acc init device_num(device_num)\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "runtime",
                            "construct-independent",
                            "internal-control-values",
                            "init",
                            "nonvalidating"
                        ],
                        "versions": [
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "init_device_num.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:init,runtime,V:2.5-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    int device_num = acc_get_device_num(acc_get_device_type());\n\n    #pragma acc init device_num(device_num)\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "init",
                            "runtime"
                        ],
                        "versions": [
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "init_device_type.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:runtime,construct-independent,internal-control-values,init,nonvalidating,V:2.5-2.7\n      LOGICAL FUNCTION test1()\n        USE OPENACC\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: device_type\n        INTEGER :: errors = 0\n\n        device_type = acc_get_device_type()\n        !$acc init device_type(device_type)\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "runtime",
                            "construct-independent",
                            "internal-control-values",
                            "init",
                            "nonvalidating"
                        ],
                        "versions": [
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "init_device_type.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:init,runtime,V:2.5-2.7\nint test1(){\n    int err = 0;\n    int device_type = acc_get_device_type();\n    srand(SEED);\n\n    #pragma acc init device_type(device_type)\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "init",
                            "runtime"
                        ],
                        "versions": [
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "init_device_type_num.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:runtime,construct-independent,internal-control-values,init,nonvalidating,V:2.5-2.7\n      LOGICAL FUNCTION test1()\n        USE OPENACC\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: device_num\n        INTEGER :: device_type\n        INTEGER :: errors = 0\n\n        device_type = acc_get_device_type()\n        device_num = acc_get_device_num(device_type)\n        !$acc init device_type(device_num) device_num(device_num)\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "runtime",
                            "construct-independent",
                            "internal-control-values",
                            "init",
                            "nonvalidating"
                        ],
                        "versions": [
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "init_device_type_num.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:init,runtime,V:2.5-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    int device_type = acc_get_device_type();\n    int device_num = acc_get_device_num(device_type);\n\n    #pragma acc init device_type(device_type) device_num(device_num)\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "init",
                            "runtime"
                        ],
                        "versions": [
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "init_if.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:init,runtime,V:3.0-3.1\nint test1(){\n    int err = 0;\n    srand(SEED);\n\n    #pragma acc init if(1 == 1)\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "init",
                            "runtime"
                        ],
                        "versions": []
                    }
                }
            },
            "kernels_async.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:async,kernels,update,V:2.0-2.7\n      LOGICAL FUNCTION test1()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT):: a, b, c, d, e, f, g !Data\n        INTEGER :: errors = 0\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(a)\n        CALL RANDOM_NUMBER(b)\n        c = 0\n        CALL RANDOM_NUMBER(d)\n        CALL RANDOM_NUMBER(e)\n        f = 0\n        g = 0\n        !$acc enter data create(g(1:LOOPCOUNT), c(1:LOOPCOUNT), f(1:LOOPCOUNT))\n        !$acc data copyin(a(1:LOOPCOUNT), b(1:LOOPCOUNT), d(1:LOOPCOUNT), e(1:LOOPCOUNT))\n          !$acc kernels async(1)\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              c(x) = a(x) + b(x)\n            END DO\n          !$acc end kernels\n          !$acc kernels async(2)\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              f(x) = d(x) + e(x)\n            END DO\n          !$acc end kernels\n          !$acc kernels wait(1, 2) async(3)\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              g(x) = c(x) + f(x)\n            END DO\n          !$acc end kernels\n        !$acc end data\n        !$acc wait(1, 2)\n        !$acc update host(c(1:LOOPCOUNT), f(1:LOOPCOUNT))\n        !$acc exit data copyout(g(1:LOOPCOUNT)) async(3)\n        DO x = 1, LOOPCOUNT\n          IF (abs(c(x) - (a(x) + b(x))) .gt. PRECISION) THEN\n            errors = errors + 1\n            WRITE(*, *) x, \" a: \", c(x), \" = \", a(x), \" + \", b(x)\n          END IF\n          IF (abs(f(x) - (d(x) + e(x))) .gt. PRECISION) THEN\n            errors = errors + 1\n            WRITE(*, *) x, \" b: \", f(x), \" = \", d(x), \" + \", e(x)\n          END IF\n        END DO\n        !$acc wait(3)\n        DO x = 1, LOOPCOUNT\n          IF (abs(g(x) - (c(x) + f(x))) .gt. PRECISION) THEN\n            errors = errors + 1\n            WRITE(*, *) x, \" c: \", g(x), \" = \", c(x), \" + \", f(x)\n          END IF\n        END DO\n        !$acc exit data delete(c(1:LOOPCOUNT), f(1:LOOPCOUNT))\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "async",
                            "kernels",
                            "update"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "kernels_async.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:kernels,async,wait,V:2.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t * restrict a = (real_t *)malloc(n * sizeof(real_t));\n    real_t * restrict b = (real_t *)malloc(n * sizeof(real_t));\n    real_t * restrict c = (real_t *)malloc(n * sizeof(real_t));\n    real_t * restrict d = (real_t *)malloc(n * sizeof(real_t));\n    real_t * restrict e = (real_t *)malloc(n * sizeof(real_t));\n    real_t * restrict f = (real_t *)malloc(n * sizeof(real_t));\n    real_t * restrict g = (real_t *)malloc(n * sizeof(real_t));\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n      \tb[x] = rand() / (real_t)(RAND_MAX / 10);\n      \tc[x] = 0.0;\n      \td[x] = rand() / (real_t)(RAND_MAX / 10);\n      \te[x] = rand() / (real_t)(RAND_MAX / 10);\n      \tf[x] = 0.0;\n      \tg[x] = 0.0;\n    }\n    #pragma acc enter data create(g[0:n], c[0:n], f[0:n])\n    #pragma acc data copyin(a[0:n], b[0:n], d[0:n], e[0:n])\n    {\n        #pragma acc kernels async(1)\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                c[x] = a[x] + b[x];\n            }\n        }\n        #pragma acc kernels async(2)\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                f[x] = d[x] + e[x];\n            }\n        }\n        #pragma acc kernels wait(1, 2) async(3)\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                g[x] = c[x] + f[x];\n            }\n        }\n    }\n    #pragma acc wait(1, 2)\n    #pragma acc update host(c[0:n], f[0:n])\n    #pragma acc exit data copyout(g[0:n]) async(3)\n    for (int x = 0; x < n; ++x){\n        if (fabs(c[x] - (a[x] + b[x])) > PRECISION){\n            err += 1;\n      \t}\n        if (fabs(f[x] - (d[x] + e[x])) > PRECISION){\n            err += 1;\n        }\n    }\n    #pragma acc wait(3)\n    for (int x = 0; x < n; ++x){\n        if (fabs(g[x] - (c[x] + f[x])) > PRECISION){\n            err += 1;\n        }\n    }\n    #pragma acc exit data delete(c[0:n], f[0:n])\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "kernels",
                            "async",
                            "wait"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "kernels_copy.F90": {
                "num tests": 3,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:devonly,kernels,V:2.0-2.7\n      LOGICAL FUNCTION test1()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT):: a, b, c !Data\n        INTEGER :: errors = 0\n        INTEGER,DIMENSION(1):: devtest\n        devtest(1) = 1\n\n        !$acc enter data copyin(devtest(1:1))\n        !$acc kernels present(devtest)\n          devtest(1) = 0\n        !$acc end kernels\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(a)\n        CALL RANDOM_NUMBER(b)\n        c = 1\n\n        !$acc data copyin(a(1:LOOPCOUNT), b(1:LOOPCOUNT))\n          !$acc kernels copy(c(1:LOOPCOUNT))\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              c(x) = c(x) + a(x) + b(x)\n            END DO\n          !$acc end kernels\n        !$acc end data\n\n        DO x = 1, LOOPCOUNT\n          IF (abs(c(x) - (a(x) + b(x) + 1)) .gt. PRECISION) THEN\n            errors = errors + 1\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "devonly",
                            "kernels"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "2": {
                        "content": "#ifndef T2\n!T2:devonly,kernels,V:2.0-2.7\n      LOGICAL FUNCTION test2()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT):: a, b, c !Data\n        INTEGER :: errors = 0\n        INTEGER,DIMENSION(1):: devtest\n        devtest(1) = 1\n\n        !$acc enter data copyin(devtest(1:1))\n        !$acc kernels present(devtest)\n          devtest(1) = 0\n        !$acc end kernels\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        IF (devtest(1) .eq. 1) THEN\n          CALL RANDOM_NUMBER(a)\n          CALL RANDOM_NUMBER(b)\n          c = 1\n\n          !$acc data copyin(a(1:LOOPCOUNT), b(1:LOOPCOUNT), c(1:LOOPCOUNT))\n            !$acc kernels copy(c(1:LOOPCOUNT))\n              !$acc loop\n              DO x = 1, LOOPCOUNT\n                c(x) = c(x) + a(x) + b(x)\n              END DO\n            !$acc end kernels\n          !$acc end data\n\n          DO x = 1, LOOPCOUNT\n            IF (abs(c(x) - 1) .gt. PRECISION) THEN\n              IF ((a(x) + b(x)) .gt. PRECISION) THEN\n                errors = errors + 1\n              END IF\n            END IF\n          END DO\n        END IF\n\n        IF (errors .eq. 0) THEN\n          test2 = .FALSE.\n        ELSE\n          test2 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T2\n        LOGICAL :: test2\n#endif\n#ifndef T2\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test2()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 1\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "devonly",
                            "kernels"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "3": {
                        "content": "#ifndef T3\n!T3:devonly,kernels,V:2.0-2.7\n      LOGICAL FUNCTION test3()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT):: a, b, c !Data\n        INTEGER :: errors = 0\n        INTEGER,DIMENSION(1):: devtest\n        devtest(1) = 1\n\n        !$acc enter data copyin(devtest(1:1))\n        !$acc kernels present(devtest)\n          devtest(1) = 0\n        !$acc end kernels\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        IF (devtest(1) .eq. 1) THEN\n          CALL RANDOM_NUMBER(a)\n          CALL RANDOM_NUMBER(b)\n          c = 1\n\n          !$acc data copyin(a(1:LOOPCOUNT), b(1:LOOPCOUNT)) copy(c(1:LOOPCOUNT))\n            DO x = 1, LOOPCOUNT\n              c(x) = 0\n            END DO\n            !$acc kernels copy(c(1:LOOPCOUNT))\n              !$acc loop\n              DO x = 1, LOOPCOUNT\n                c(x) = c(x) + a(x) + b(x)\n              END DO\n            !$acc end kernels\n            DO x = 1, LOOPCOUNT\n              IF (abs(c(x)) .gt. PRECISION) THEN\n                errors = errors + 1\n              END IF\n            END DO\n          !$acc end data\n\n          DO x = 1, LOOPCOUNT\n            IF (abs(c(x) - (1 + a(x) + b(x))) .gt. PRECISION) THEN\n              errors = errors + 1\n            END IF\n          END DO\n        END IF\n\n        IF (errors .eq. 0) THEN\n          test3 = .FALSE.\n        ELSE\n          test3 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T3\n        LOGICAL :: test3\n#endif\n#ifndef T3\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test3()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 2\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "devonly",
                            "kernels"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "kernels_copy.c": {
                "num tests": 3,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:kernels,data,data-region,V:1.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n    real_t * c = (real_t *)malloc(n * sizeof(real_t));\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n        c[x] = 1;\n    }\n    #pragma acc data copyin(a[0:n], b[0:n])\n    {\n        #pragma acc kernels copy(c[0:n])\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                c[x] += a[x] + b[x];\n            }\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        if (fabs(c[x] - (1 + a[x] + b[x])) > PRECISION) {\n            err += 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "kernels",
                            "data",
                            "data-region"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "2": {
                        "content": "#ifndef T2\n//T2:kernels,data,data-region,devonly,reference-counting,V:2.5-2.7\nint test2(){\n    int err = 0;\n    srand(SEED);\n    int * devtest = (int *)malloc(sizeof(int));\n    real_t * a = (real_t *)malloc(n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n    real_t * c = (real_t *)malloc(n * sizeof(real_t));\n    devtest[0] = 1;\n    #pragma acc enter data copyin(devtest[0:1])\n    #pragma acc kernels present(devtest[0:1])\n    {\n      devtest[0] = 0;\n    }\n\n    if (devtest[0] == 1){\n        for (int x = 0; x < n; ++x){\n          a[x] = rand() / (real_t)(RAND_MAX / 10);\n          b[x] = rand() / (real_t)(RAND_MAX / 10);\n          c[x] = 1;\n        }\n        #pragma acc data copyin(a[0:n], b[0:n], c[0:n])\n        {\n            #pragma acc kernels copy(c[0:n])\n            {\n                #pragma acc loop\n                for (int x = 0; x < n; ++x){\n                    c[x] += a[x] + b[x];\n                }\n            }\n        }\n\n        for (int x = 0; x < n; ++x){\n            if (fabs(c[x] - 1) > PRECISION && (a[x] + b[x]) > PRECISION) {\n                err += 1;\n            }\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T2\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test2();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 1);\n    }\n#endif\n",
                        "tags": [
                            "kernels",
                            "data",
                            "data-region",
                            "devonly",
                            "reference-counting"
                        ],
                        "versions": [
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "3": {
                        "content": "#ifndef T3\n//T3:kernels,data,data-region,devonly,reference-counting,V:2.5-2.7\nint test3(){\n    int err = 0;\n    srand(SEED);\n    int * devtest = (int *)malloc(sizeof(int));\n    real_t * a = (real_t *)malloc(n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n    real_t * c = (real_t *)malloc(n * sizeof(real_t));\n    devtest[0] = 1;\n    #pragma acc enter data copyin(devtest[0:1])\n    #pragma acc kernels present(devtest[0:1])\n    {\n      devtest[0] = 0;\n    }\n\n    if (devtest[0] == 1){\n        for (int x = 0; x < n; ++ x){\n            a[x] = rand() / (real_t)(RAND_MAX / 10);\n            b[x] = rand() / (real_t)(RAND_MAX / 10);\n            c[x] = 1;\n        }\n\n        #pragma acc data copyin(a[0:n], b[0:n]) copy(c[0:n])\n        {\n            for (int x = 0; x < n; ++x){\n                c[x] = 0;\n            }\n            #pragma acc kernels copy(c[0:n])\n            {\n                #pragma acc loop\n                for (int x = 0; x < n; ++x){\n                    c[x] += a[x] + b[x];\n                }\n            }\n            for (int x = 0; x < n; ++x){\n                if (fabs(c[x]) > PRECISION) {\n                    err += 1;\n                }\n            }\n        }\n\n        for (int x = 0; x < n; ++x){\n            if (fabs(c[x] - (a[x] + b[x] + 1)) > PRECISION){\n                err += 1;\n            }\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T3\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test3();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 2);\n    }\n#endif\n",
                        "tags": [
                            "kernels",
                            "data",
                            "data-region",
                            "devonly",
                            "reference-counting"
                        ],
                        "versions": [
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "kernels_copyin.F90": {
                "num tests": 3,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:devonly,kernels,V:2.0-2.7\n      LOGICAL FUNCTION test1()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT):: a, b !Data\n        INTEGER :: errors = 0\n        INTEGER,DIMENSION(1):: devtest\n        devtest(1) = 1\n\n        !$acc enter data copyin(devtest(1:1))\n        !$acc kernels\n          devtest(1) = 0\n        !$acc end kernels\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(a)\n        b = 0\n\n        !$acc data copy(b(1:LOOPCOUNT))\n          !$acc kernels copyin(a(1:LOOPCOUNT))\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              b(x) = b(x) + a(x)\n            END DO\n          !$acc end kernels\n        !$acc end data\n\n        DO x = 1, LOOPCOUNT\n          IF (abs(a(x) - b(x)) .gt. PRECISION) THEN\n            errors = errors + 1\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "devonly",
                            "kernels"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "2": {
                        "content": "#ifndef T2\n!T2:devonly,kernels,V:2.0-2.7\n      LOGICAL FUNCTION test2()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT):: a, b !Data\n        INTEGER :: errors = 0\n        INTEGER,DIMENSION(1):: devtest\n        devtest(1) = 1\n\n        !$acc enter data copyin(devtest(1:1))\n        !$acc kernels\n          devtest(1) = 0\n        !$acc end kernels\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        IF (devtest(1) .eq. 1) THEN\n          CALL RANDOM_NUMBER(a)\n          b = 0\n          !$acc data copy(a(1:LOOPCOUNT), b(1:LOOPCOUNT))\n            DO x = 1, LOOPCOUNT\n              a(x) = -1\n            END DO\n            !$acc kernels copyin(a(1:LOOPCOUNT))\n              !$acc loop\n              DO x = 1, LOOPCOUNT\n                b(x) = a(x)\n              END DO\n            !$acc end kernels\n            DO x = 1, LOOPCOUNT\n              IF (abs(a(x) + 1) .gt. PRECISION) THEN\n                errors = errors + 1\n              END IF\n            END DO\n          !$acc end data\n          DO x = 1, LOOPCOUNT\n            IF (abs(a(x) - b(x)) .gt. PRECISION) THEN\n              errors = errors + 1\n            END IF\n          END DO\n        END IF\n\n        IF (errors .eq. 0) THEN\n          test2 = .FALSE.\n        ELSE\n          test2 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T2\n        LOGICAL :: test2\n#endif\n#ifndef T2\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test2()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 1\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "devonly",
                            "kernels"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "3": {
                        "content": "#ifndef T3\n!T3:devonly,kernels,V:2.0-2.7\n      LOGICAL FUNCTION test3()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT):: a, b !Data\n        INTEGER :: errors = 0\n        INTEGER,DIMENSION(1):: devtest\n        devtest(1) = 1\n\n        !$acc enter data copyin(devtest(1:1))\n        !$acc kernels\n          devtest(1) = 0\n        !$acc end kernels\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        IF (devtest(1) .eq. 1) THEN\n          CALL RANDOM_NUMBER(a)\n          b = 0\n\n          !$acc kernels copyin(a(1:LOOPCOUNT), b(1:LOOPCOUNT))\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              b(x) = a(x)\n            END DO\n          !$acc end kernels\n\n          DO x = 1, LOOPCOUNT\n            IF (abs(b(x)) .gt. PRECISION) THEN\n              errors = errors + 1\n            END IF\n          END DO\n        END IF\n\n        IF (errors .eq. 0) THEN\n          test3 = .FALSE.\n        ELSE\n          test3 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T3\n        LOGICAL :: test3\n#endif\n#ifndef T3\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test3()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 2\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "devonly",
                            "kernels"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "kernels_copyin.c": {
                "num tests": 3,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:kernels,data,data-region,V:1.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = 0.0;\n    }\n\n\n    #pragma acc data copy(b[0:n])\n    {\n        #pragma acc kernels copyin(a[0:n])\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                b[x] += a[x];\n            }\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        if (fabs(b[x] - a[x]) > PRECISION){\n            err += 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "kernels",
                            "data",
                            "data-region"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "2": {
                        "content": "#ifndef T2\n//T2:kernels,data,data-region,devonly,reference-counting,V:2.5-2.7\nint test2(){\n    int err = 0;\n    srand(SEED);\n    int * devtest = (int *)malloc(sizeof(int));\n    real_t * a = (real_t *)malloc(n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n    devtest[0] = 1;\n    #pragma acc enter data copyin(devtest[0:1])\n    #pragma acc kernels present(devtest[0:1])\n    {\n      devtest[0] = 0;\n    }\n\n    if (devtest[0] == 1){\n        for (int x = 0; x < n; ++x){\n            a[x] = rand() / (real_t)(RAND_MAX / 10);\n            b[x] = 0.0;\n        }\n\n        #pragma acc data copy(a[0:n], b[0:n])\n        {\n            for (int x = 0; x < n; ++x){\n                a[x] = -1;\n            }\n            #pragma acc kernels copyin(a[0:n])\n            {\n                #pragma acc loop\n                for (int x = 0; x < n; ++x){\n                    b[x] = a[x];\n                }\n            }\n        }\n\n        for (int x = 0; x < n; ++x){\n            if (fabs(b[x] - a[x]) > PRECISION){\n                err += 1;\n            }\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T2\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test2();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 1);\n    }\n#endif\n",
                        "tags": [
                            "kernels",
                            "data",
                            "data-region",
                            "devonly",
                            "reference-counting"
                        ],
                        "versions": [
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "3": {
                        "content": "#ifndef T3\n//T3:kernels,data,data-region,devonly,V:1.0-2.7\nint test3(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n\n    if (devtest[0] == 1){\n        for (int x = 0; x < n; ++x){\n            a[x] = rand() / (real_t)(RAND_MAX / 10);\n            b[x] = 0;\n        }\n        #pragma acc kernels copyin(a[0:n], b[0:n])\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                b[x] = a[x];\n            }\n        }\n\n        for (int x = 0; x < n; ++x){\n            if (fabs(b[x]) > PRECISION){\n                err += 1;\n            }\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T3\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test3();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 2);\n    }\n#endif\n",
                        "tags": [
                            "kernels",
                            "data",
                            "data-region",
                            "devonly"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "kernels_copyout.F90": {
                "num tests": 2,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:devonly,kernels,V:2.0-2.7\n      LOGICAL FUNCTION test1()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT):: a, b !Data\n        INTEGER :: errors = 0\n        INTEGER,DIMENSION(1):: devtest\n        devtest(1) = 1\n\n        !$acc enter data copyin(devtest(1:1))\n        !$acc kernels present(devtest(1:1))\n          devtest(1) = 0\n        !$acc end kernels\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(a)\n        b = 0\n\n        !$acc data copyin(a(1:LOOPCOUNT))\n          !$acc kernels copyout(b(1:LOOPCOUNT))\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              b(x) = a(x)\n            END DO\n          !$acc end kernels\n        !$acc end data\n\n        DO x = 1, LOOPCOUNT\n          IF (abs(a(x) - b(x)) .gt. PRECISION) THEN\n            errors = errors + 1\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "devonly",
                            "kernels"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "2": {
                        "content": "#ifndef T2\n!T2:devonly,kernels,V:2.0-2.7\n      LOGICAL FUNCTION test2()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT):: a, b !Data\n        INTEGER :: errors = 0\n        INTEGER,DIMENSION(1):: devtest\n        devtest(1) = 1\n\n        !$acc enter data copyin(devtest(1:1))\n        !$acc kernels present(devtest(1:1))\n          devtest(1) = 0\n        !$acc end kernels\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        IF (devtest(1) .eq. 1) THEN\n          CALL RANDOM_NUMBER(a)\n          b = 0\n          \n          !$acc data copyin(a(1:LOOPCOUNT), b(1:LOOPCOUNT))\n            !$acc kernels copyout(b(1:LOOPCOUNT))\n              !$acc loop\n              DO x = 1, LOOPCOUNT\n                b(x) = a(x)\n              END DO\n            !$acc end kernels\n          !$acc end data\n          \n          DO x = 1, LOOPCOUNT\n            IF (abs(b(x)) .gt. PRECISION) THEN\n              errors = errors + 1\n            END IF\n          END DO\n        END IF\n\n        IF (errors .eq. 0) THEN\n          test2 = .FALSE.\n        ELSE\n          test2 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T2\n        LOGICAL :: test2\n#endif\n#ifndef T2\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test2()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 1\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "devonly",
                            "kernels"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "kernels_copyout.c": {
                "num tests": 2,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:kernels,data,data-region,V:1.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = 0;\n    }\n\n    #pragma acc data copyin(a[0:n])\n    {\n        #pragma acc kernels copyout(b[0:n])\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                b[x] = a[x];\n            }\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        if (fabs(b[x] - a[x]) > PRECISION){\n            err += 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "kernels",
                            "data",
                            "data-region"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "2": {
                        "content": "#ifndef T2\n//T2:kernels,data,data-region,devonly,reference-counting,V:2.5-2.7\nint test2(){\n    int err = 0;\n    srand(SEED);\n    int * devtest = (int *)malloc(sizeof(int));\n    real_t * a = (real_t *)malloc(n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n    devtest[0] = 1;\n    #pragma acc enter data copyin(devtest[0:1])\n    #pragma acc kernels present(devtest[0:1])\n    {\n      devtest[0] = 0;\n    }\n\n    if (devtest[0] == 1){\n        for (int x = 0; x < n; ++x){\n            a[x] = rand() / (real_t)(RAND_MAX / 10);\n            b[x] = 0;\n        }\n\n        #pragma acc data copyin(a[0:n], b[0:n])\n        {\n            #pragma acc kernels copyout(b[0:n])\n            {\n                #pragma acc loop\n                for (int x = 0; x < n; ++x){\n                    b[x] = a[x];\n                }\n            }\n        }\n\n        for (int x = 0; x < n; ++x){\n            if (fabs(b[x]) > PRECISION){\n                err += 1;\n            }\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T2\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test2();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 1);\n    }\n#endif\n",
                        "tags": [
                            "kernels",
                            "data",
                            "data-region",
                            "devonly",
                            "reference-counting"
                        ],
                        "versions": [
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "kernels_create.F90": {
                "num tests": 3,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:devonly,kernels,V:2.0-2.7\n      LOGICAL FUNCTION test1()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT):: a, b, c !Data\n        INTEGER :: errors = 0\n        INTEGER,DIMENSION(1):: devtest\n        devtest(1) = 1\n\n        !$acc enter data copyin(devtest(1:1))\n        !$acc kernels present(devtest(1:1))\n          devtest(1) = 0\n        !$acc end kernels\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        IF (devtest(1) .eq. 1) THEN\n          CALL RANDOM_NUMBER(a)\n          b = 0\n          c = 0\n          !$acc data copyin(a(1:LOOPCOUNT))\n            !$acc kernels create(b(1:LOOPCOUNT))\n              !$acc loop\n              DO x = 1, LOOPCOUNT\n                b(x) = a(x)\n              END DO\n            !$acc end kernels\n          !$acc end data\n          DO x = 1, LOOPCOUNT\n            IF (abs(b(x)) .gt. PRECISION) THEN\n              errors = errors + 1\n            END IF\n          END DO\n        END IF\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "devonly",
                            "kernels"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "2": {
                        "content": "#ifndef T2\n!T2:devonly,kernels,V:2.0-2.7\n      LOGICAL FUNCTION test2()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT):: a, b, c !Data\n        INTEGER :: errors = 0\n        INTEGER,DIMENSION(1):: devtest\n        devtest(1) = 1\n\n        !$acc enter data copyin(devtest(1:1))\n        !$acc kernels present(devtest(1:1))\n          devtest(1) = 0\n        !$acc end kernels\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(a)\n        b = 0\n        !$acc data copyin(a(1:LOOPCOUNT)) copyout(b(1:LOOPCOUNT))\n          !$acc kernels create(b(1:LOOPCOUNT))\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              b(x) = a(x)\n            END DO\n          !$acc end kernels\n        !$acc end data\n        DO x = 1, LOOPCOUNT\n          IF (abs(b(x) - a(x)) .gt. PRECISION) THEN\n            errors = errors + 1\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test2 = .FALSE.\n        ELSE\n          test2 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T2\n        LOGICAL :: test2\n#endif\n#ifndef T2\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test2()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 1\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "devonly",
                            "kernels"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "3": {
                        "content": "#ifndef T3\n!T3:devonly,kernels,V:2.0-2.7\n      LOGICAL FUNCTION test3()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT):: a, b, c !Data\n        INTEGER :: errors = 0\n        INTEGER,DIMENSION(1):: devtest\n        devtest(1) = 1\n\n        !$acc enter data copyin(devtest(1:1))\n        !$acc kernels present(devtest(1:1))\n          devtest(1) = 0\n        !$acc end kernels\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(a)\n        b = 0\n\n        !$acc data copyin(a(1:LOOPCOUNT)) copyout(c(1:LOOPCOUNT))\n          !$acc kernels create(b(1:LOOPCOUNT))\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              b(x) = a(x)\n            END DO\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              c(x) = b(x)\n            END DO\n          !$acc end kernels\n        !$acc end data\n\n        DO x = 1, LOOPCOUNT\n          IF (abs(c(x) - a(x)) .gt. PRECISION) THEN\n            errors = errors + 1\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test3 = .FALSE.\n        ELSE\n          test3 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T3\n        LOGICAL :: test3\n#endif\n#ifndef T3\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test3()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 2\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "devonly",
                            "kernels"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "kernels_create.c": {
                "num tests": 3,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:kernels,data,data-region,devonly,V:1.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    int * devtest = (int *)malloc(sizeof(int));\n    real_t * a = (real_t *)malloc(n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n    devtest[0] = 1;\n    #pragma acc enter data copyin(devtest[0:1])\n    #pragma acc parallel present(devtest[0:1])\n    {\n      devtest[0] = 0;\n    }\n\n    if (devtest[0] == 1){\n        for (int x = 0; x < n; ++x){\n          a[x] = rand() / (real_t)(RAND_MAX / 10);\n          b[x] = 0.0;\n        }\n\n        #pragma acc data copyin(a[0:n])\n        {\n            #pragma acc kernels create(b[0:n])\n            {\n                #pragma acc loop\n                for (int x = 0; x < n; ++x){\n                    b[x] = a[x];\n                }\n            }\n        }\n\n        for (int x = 0; x < n; ++x){\n            if (fabs(b[x]) > PRECISION){\n                err += 1;\n            }\n        }\n\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "kernels",
                            "data",
                            "data-region",
                            "devonly"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "2": {
                        "content": "#ifndef T2\n//T2:kernels,data,data-region,reference-counting,V:2.5-2.7\nint test2(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n\n    for (int x = 0; x < n; ++x){\n      a[x] = rand() / (real_t)(RAND_MAX / 10);\n      b[x] = 0.0;\n    }\n\n    #pragma acc data copyin(a[0:n]) copyout(b[0:n])\n    {\n        #pragma acc kernels create(b[0:n])\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                b[x] = a[x];\n            }\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        if (fabs(a[x] - b[x]) > PRECISION){\n            err += 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T2\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test2();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 1);\n    }\n#endif\n",
                        "tags": [
                            "kernels",
                            "data",
                            "data-region",
                            "reference-counting"
                        ],
                        "versions": [
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "3": {
                        "content": "#ifndef T3\n//T3:kernels,data,data-region,V:1.0-2.7\nint test3(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n    real_t * c = (real_t *)malloc(n * sizeof(real_t));\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = 0.0;\n    }\n\n    #pragma acc data copyin(a[0:n]) copyout(c[0:n])\n    {\n        #pragma acc kernels create(b[0:n])\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                b[x] = a[x];\n            }\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                c[x] = b[x];\n            }\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        if (fabs(c[x] - a[x]) > PRECISION){\n            err += 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T3\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test3();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 2);\n    }\n#endif\n",
                        "tags": [
                            "kernels",
                            "data",
                            "data-region"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "kernels_default_copy.F90": {
                "num tests": 2,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:devonly,kernels,V:2.0-2.7\n      LOGICAL FUNCTION test1()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT):: a, b, c !Data\n        INTEGER :: errors = 0\n        LOGICAL,DIMENSION(1):: devtest\n        devtest(1) = .TRUE.\n\n        !$acc enter data copyin(devtest(1:1))\n        !$acc kernels\n          devtest(1) = .FALSE.\n        !$acc end kernels\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(a)\n        CALL RANDOM_NUMBER(b)\n        c = 0\n\n        !$acc data copyin(a(1:LOOPCOUNT), b(1:LOOPCOUNT))\n          !$acc kernels\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              c(x) = c(x) + a(x) + b(x)\n            END DO\n          !$acc end kernels\n        !$acc end data\n        DO x = 1, LOOPCOUNT\n          IF (abs(c(x) - (a(x) + b(x))) .gt. PRECISION) THEN\n            errors = errors + 1\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "devonly",
                            "kernels"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "2": {
                        "content": "#ifndef T2\n!T2:devonly,kernels,V:2.0-2.7\n      LOGICAL FUNCTION test2()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT):: a, b, c !Data\n        INTEGER :: errors = 0\n        LOGICAL,DIMENSION(1):: devtest\n        devtest(1) = .TRUE.\n\n        !$acc enter data copyin(devtest(1:1))\n        !$acc kernels\n          devtest(1) = .FALSE.\n        !$acc end kernels\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        IF (devtest(1)) THEN\n          CALL RANDOM_NUMBER(a)\n          CALL RANDOM_NUMBER(b)\n          c = 1\n\n          !$acc enter data copyin(c(1:LOOPCOUNT))\n          c = 0\n          !$acc data copyin(a(1:LOOPCOUNT), b(1:LOOPCOUNT))\n            !$acc kernels\n              !$acc loop\n              DO x = 1, LOOPCOUNT\n                c(x) = c(x) + a(x) + b(x)\n              END DO\n            !$acc end kernels\n          !$acc end data\n          DO x = 1, LOOPCOUNT\n            IF (abs(c(x)) .gt. PRECISION) THEN\n              errors = errors + 1\n            END IF\n          END DO\n          !$acc exit data copyout(c(1:LOOPCOUNT))\n          DO x = 1, LOOPCOUNT\n            IF (abs(c(x) - (a(x) + b(x) + 1)) .gt. PRECISION) THEN\n              errors = errors + 1\n            END IF\n          END DO\n        END IF\n\n        IF (errors .eq. 0) THEN\n          test2 = .FALSE.\n        ELSE\n          test2 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T2\n        LOGICAL :: test2\n#endif\n#ifndef T2\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test2()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 1\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "devonly",
                            "kernels"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "kernels_default_copy.c": {
                "num tests": 2,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:kernels,data-region,default-mapping,V:1.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n    real_t c[n];\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n        c[x] = 0.0;\n    }\n\n    #pragma acc data copyin(a[0:n], b[0:n])\n    {\n        #pragma acc kernels\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                c[x] += a[x] + b[x];\n            }\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        if (fabs(c[x] - (a[x] + b[x])) > PRECISION){\n            err += 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "kernels",
                            "data-region",
                            "default-mapping"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "2": {
                        "content": "#ifndef T2\n//T2:kernels,data-region,default-mapping,reference-counting,devonly,V:2.5-2.7\nint test2(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n    real_t c[n];\n    int * devtest = (int *)malloc(sizeof(real_t));\n\n    devtest[0] = 1;\n    #pragma acc enter data copyin(devtest[0:1])\n    #pragma acc kernels present(devtest[0:1])\n    {\n        devtest[0] = 0;\n    }\n\n    if (devtest[0] == 1){\n        for (int x = 0; x < n; ++x){\n            a[x] = rand() / (real_t)(RAND_MAX / 10);\n            b[x] = rand() / (real_t)(RAND_MAX / 10);\n            c[x] = 1;\n        }\n\n        #pragma acc enter data copyin(c[0:n])\n        for (int x = 0; x < n; ++x){\n            c[x] = 0.0;\n        }\n        #pragma acc data copyin(a[0:n], b[0:n])\n        {\n            #pragma acc kernels\n            {\n                #pragma acc loop\n                for (int x = 0; x < n; ++x){\n                    c[x] += a[x] + b[x];\n                }\n            }\n        }\n\n        for (int x = 0; x < n; ++x){\n            if (fabs(c[x]) > PRECISION){\n                err += 1;\n            }\n        }\n\n        #pragma acc exit data copyout(c[0:n])\n\n        for (int x = 0; x < n; ++x){\n            if (fabs(c[x] - (a[x] + b[x] + 1)) > PRECISION){\n                err += 1;\n            }\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T2\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test2();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 1);\n    }\n#endif\n",
                        "tags": [
                            "kernels",
                            "data-region",
                            "default-mapping",
                            "reference-counting",
                            "devonly"
                        ],
                        "versions": [
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "kernels_default_present.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:kernels,default,V:2.5-2.7\n      LOGICAL FUNCTION test1()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT):: a, b !Data\n        INTEGER :: errors = 0\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(a)\n        b = 0\n\n        !$acc enter data copyin(a(1:LOOPCOUNT)) create(b(1:LOOPCOUNT))\n        !$acc kernels default(present)\n          !$acc loop\n          DO x = 1, LOOPCOUNT\n            b(x) = a(x)\n          END DO\n        !$acc end kernels\n        !$acc exit data delete(a(1:LOOPCOUNT)) copyout(b(1:LOOPCOUNT)) \n        DO x = 1, LOOPCOUNT\n          IF (abs(a(x) - b(x)) .gt. PRECISION) THEN\n            errors = errors + 1\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "kernels",
                            "default"
                        ],
                        "versions": [
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "kernels_default_present.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:kernels,data,data-region,default,V:2.5-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = 0;\n    }\n\n    #pragma acc enter data copyin(a[0:n]), create(b[0:n])\n    #pragma acc kernels default(present)\n    {\n        #pragma acc loop\n        for (int x = 0; x < n; ++x){\n            b[x] = a[x];\n        }\n    }\n    #pragma acc exit data delete(a[0:n]), copyout(b[0:n])\n\n    for (int x = 0; x < n; ++x){\n        if (fabs(a[x] - b[x]) > PRECISION){\n            err += 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "kernels",
                            "data",
                            "data-region",
                            "default"
                        ],
                        "versions": [
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "kernels_if.F90": {
                "num tests": 4,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:devonly,kernels,if,V:2.0-2.7\n      LOGICAL FUNCTION test1()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT):: a, b !Data\n        INTEGER :: errors = 0\n        LOGICAL,DIMENSION(1):: devtest\n        LOGICAL:: data_on_device = .FALSE.\n        devtest(1) = .TRUE.\n\n        !$acc enter data copyin(devtest(1:1))\n        !$acc kernels present(devtest(1:1))\n          devtest(1) = .FALSE.\n        !$acc end kernels\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(a)\n        b = 0\n\n        !$acc kernels if(data_on_device) present(a(1:LOOPCOUNT), b(1:LOOPCOUNT))\n          !$acc loop\n          DO x = 1, LOOPCOUNT\n            b(x) = a(x)\n          END DO\n        !$acc end kernels\n\n        DO x = 1, LOOPCOUNT\n          IF (abs(a(x) - b(x)) .gt. PRECISION) THEN\n            errors = errors + 1\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "devonly",
                            "kernels",
                            "if"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "2": {
                        "content": "#ifndef T2\n!T2:devonly,kernels,if,V:2.0-2.7\n      LOGICAL FUNCTION test2()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT):: a, b !Data\n        INTEGER :: errors = 0\n        LOGICAL,DIMENSION(1):: devtest\n        LOGICAL:: data_on_device = .FALSE.\n        devtest(1) = .TRUE.\n\n        !$acc enter data copyin(devtest(1:1))\n        !$acc kernels present(devtest(1:1))\n          devtest(1) = .FALSE.\n        !$acc end kernels\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(a)\n        b = 0\n\n        data_on_device = .TRUE.\n        !$acc enter data copyin(a(1:LOOPCOUNT)) create(b(1:LOOPCOUNT))\n        !$acc kernels if(data_on_device) present(a(1:LOOPCOUNT), b(1:LOOPCOUNT))\n          !$acc loop\n          DO x = 1, LOOPCOUNT\n            b(x) = a(x)\n          END DO\n        !$acc end kernels\n        !$acc exit data copyout(b(1:LOOPCOUNT)) delete(a(1:LOOPCOUNT))\n\n        DO x = 1, LOOPCOUNT\n          IF (abs(b(x) - a(x)) .gt. PRECISION) THEN\n            errors = errors + 1\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test2 = .FALSE.\n        ELSE\n          test2 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T2\n        LOGICAL :: test2\n#endif\n#ifndef T2\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test2()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 1\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "devonly",
                            "kernels",
                            "if"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "3": {
                        "content": "#ifndef T3\n!T3:devonly,kernels,if,V:2.0-2.7\n      LOGICAL FUNCTION test3()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT):: a, b !Data\n        INTEGER :: errors = 0\n        LOGICAL,DIMENSION(1):: devtest\n        LOGICAL:: data_on_device = .FALSE.\n        devtest(1) = .TRUE.\n\n        !$acc enter data copyin(devtest(1:1))\n        !$acc kernels present(devtest(1:1))\n          devtest(1) = .FALSE.\n        !$acc end kernels\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        IF (devtest(1) .eqv. .TRUE.) THEN\n          CALL RANDOM_NUMBER(a)\n          b = 0\n\n          !$acc enter data copyin(a(1:LOOPCOUNT)) create(b(1:LOOPCOUNT))\n          DO x = 1, LOOPCOUNT\n            a(x) = -1\n          END DO\n\n          !$acc kernels if(data_on_device) present(a(1:LOOPCOUNT), b(1:LOOPCOUNT))\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              b(x) = a(x)\n            END DO\n          !$acc end kernels\n\n          DO x = 1, LOOPCOUNT\n            IF (abs(a(x) + 1) .gt. PRECISION) THEN\n              errors = errors + 1\n            END IF\n            IF (abs(b(x)) .gt. PRECISION) THEN\n              errors = errors + 1\n            END IF\n          END DO\n\n          !$acc exit data copyout(a(1:LOOPCOUNT), b(1:LOOPCOUNT))\n          data_on_device = .FALSE.\n\n          DO x = 1, LOOPCOUNT\n            IF (abs(a(x) - b(x)) .gt. PRECISION) THEN\n              errors = errors + 1\n            END IF\n          END DO\n        END IF\n\n        IF (errors .eq. 0) THEN\n          test3 = .FALSE.\n        ELSE\n          test3 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T3\n        LOGICAL :: test3\n#endif\n#ifndef T3\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test3()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 2\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "devonly",
                            "kernels",
                            "if"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "4": {
                        "content": "#ifndef T4\n!T4:devonly,kernels,if,V:2.0-2.7\n      LOGICAL FUNCTION test4()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT):: a, b !Data\n        INTEGER :: errors = 0\n        LOGICAL,DIMENSION(1):: devtest\n        LOGICAL:: data_on_device = .FALSE.\n        devtest(1) = .TRUE.\n\n        !$acc enter data copyin(devtest(1:1))\n        !$acc kernels present(devtest(1:1))\n          devtest(1) = .FALSE.\n        !$acc end kernels\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        IF (devtest(1) .eq. 1) THEN\n          CALL RANDOM_NUMBER(a)\n          b = 0\n\n          !$acc enter data copyin(a(1:LOOPCOUNT), b(1:LOOPCOUNT))\n          !$acc kernels if(data_on_device) present(a(1:LOOPCOUNT), b(1:LOOPCOUNT))\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              b(x) = a(x)\n            END DO\n          !$acc end kernels\n\n          DO x = 1, LOOPCOUNT\n            IF (abs(a(x) - b(x)) .gt. PRECISION) THEN\n              errors = errors + 1\n            END IF\n          END DO\n\n          !$acc exit data copyout(a(1:LOOPCOUNT), b(1:LOOPCOUNT))\n\n          DO x = 1, LOOPCOUNT\n            IF (abs(b(x)) .gt. PRECISION) THEN\n              IF (abs(b(x) - a(x)) .gt. PRECISION) THEN\n                errors = errors + 1\n              END IF\n            END IF\n          END DO\n        END IF\n\n        IF (errors .eq. 0) THEN\n          test4 = .FALSE.\n        ELSE\n          test4 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T4\n        LOGICAL :: test4\n#endif\n#ifndef T4\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test4()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 3\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "devonly",
                            "kernels",
                            "if"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "kernels_if.c": {
                "num tests": 4,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:kernels,if,V:1.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    int data_on_device = 0;\n    real_t * a = (real_t *)malloc(n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = 0;\n    }\n\n    #pragma acc kernels if(data_on_device) present(a[0:n], b[0:n])\n    {\n        #pragma acc loop\n        for (int x = 0; x < n; ++x){\n            b[x] = a[x];\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        if (fabs(b[x] - a[x]) > PRECISION){\n            err += 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "kernels",
                            "if"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "2": {
                        "content": "#ifndef T2\n//T2:kernels,if,V:2.0-2.7\nint test2(){\n    int err = 0;\n    srand(SEED);\n    int * devtest = (int *)malloc(sizeof(int));\n    real_t * a = (real_t *)malloc(n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = 0;\n    }\n\n    #pragma acc enter data copyin(a[0:n]) create(b[0:n])\n    data_on_device = 1;\n\n    #pragma acc kernels if(data_on_device) present(a[0:n], b[0:n])\n    {\n        #pragma acc loop\n        for (int x = 0; x < n; ++x){\n            b[x] = a[x];\n        }\n    }\n    #pragma acc exit data copyout(b[0:n]) delete(a[0:n])\n\n    for (int x = 0; x < n; ++x){\n        if (fabs(b[x] - a[x]) > PRECISION){\n            err += 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T2\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test2();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 1);\n    }\n#endif\n",
                        "tags": [
                            "kernels",
                            "if"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "3": {
                        "content": "#ifndef T3\n//T3:kernels,if,devonly,V:2.0-2.7\nint test3(){\n    int err = 0;\n    srand(SEED);\n    int data_on_device = 0;\n    int * devtest = (int *)malloc(sizeof(int));\n    real_t * a = (real_t *)malloc(n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n    devtest[0] = 1;\n    #pragma acc enter data copyin(devtest[0:1])\n    #pragma acc parallel present(devtest[0:1])\n    {\n      devtest[0] = 0;\n    }\n\n    if (devtest[0] == 1){\n        for (int x = 0; x < n; ++x){\n            a[x] = rand() / (real_t)(RAND_MAX / 10);\n            b[x] = 0;\n        }\n\n        #pragma acc enter data copyin(a[0:n]) create(b[0:n])\n        for (int x = 0; x < n; ++x){\n            a[x] = -1;\n        }\n\n        #pragma acc kernels if(data_on_device) present(a[0:n], b[0:n])\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                b[x] = a[x];\n            }\n        }\n        for (int x = 0; x < n; ++x){\n            if (fabs(a[x] + 1) > PRECISION){\n                err += 1;\n            }\n            if (fabs(b[x]) > PRECISION){\n                err += 1;\n            }\n        }\n        #pragma acc exit data copyout(a[0:n], b[0:n])\n        data_on_device = 0;\n        for (int x = 0; x < n; ++x){\n            if (fabs(a[x] - b[x]) > PRECISION){\n                err += 1;\n            }\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T3\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test3();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 2);\n    }\n#endif\n",
                        "tags": [
                            "kernels",
                            "if",
                            "devonly"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "4": {
                        "content": "#ifndef T4\n//T4:kernels,if,devonly,V:2.0-2.7\nint test4(){\n    int err = 0;\n    srand(SEED);\n    int data_on_device = 0;\n    int * devtest = (int *)malloc(sizeof(int));\n    real_t * a = (real_t *)malloc(n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n    devtest[0] = 1;\n    #pragma acc enter data copyin(devtest[0:1])\n    #pragma acc parallel present(devtest[0:1])\n    {\n      devtest[0] = 0;\n    }\n\n    if (devtest[0] == 1){\n        for (int x = 0; x < n; ++x){\n            a[x] = rand() / (real_t)(RAND_MAX / 10);\n            b[x] = 0;\n        }\n\n        #pragma acc enter data copyin(a[0:n], b[0:n])\n        #pragma acc kernels if(data_on_device) present(a[0:n], b[0:n])\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                b[x] = a[x];\n            }\n        }\n        for (int x = 0; x < n; ++x){\n            if (fabs(a[x] - b[x]) > PRECISION) {\n                err += 1;\n            }\n        }\n        #pragma acc exit data copyout(a[0:n], b[0:n])\n        for (int x = 0; x < n; ++x){\n            if (fabs(b[x]) > PRECISION && b[x] != a[x]){\n                err += 1;\n            }\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T4\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test4();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 3);\n    }\n#endif\n",
                        "tags": [
                            "kernels",
                            "if",
                            "devonly"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "kernels_loop.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:kernels,loop,V:1.0-2.7\n      LOGICAL FUNCTION test1()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x, _0, _1, _2, _3, _4, _5, _6, _7, _8, _9 !Iterators\n        REAL(8),DIMENSION(1024):: a, b !Data\n        INTEGER :: errors = 0\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(a)\n        b = 0\n\n        !$acc data copyin(a(1:1024)) copyout(b(1:1024))\n          !$acc kernels\n            !$acc loop\n            DO _0 = 0, 1\n              !$acc loop\n              DO _1 = 0, 1\n                !$acc loop\n                DO _2 = 0, 1\n                  !$acc loop\n                  DO _3 = 0, 1\n                    !$acc loop\n                    DO _4 = 0, 1\n                      !$acc loop\n                      DO _5 = 0, 1\n                        !$acc loop\n                        DO _6 = 0, 1\n                          !$acc loop\n                          DO _7 = 0, 1\n                            !$acc loop\n                            DO _8 = 0, 1\n                              !$acc loop\n                              DO _9 = 1, 2\n                                b(_0*512+_1*256+_2*128+_3*64+_4*32+_5*16+_6*8+_7*4+_8*2+_9)=a(_0*512+_1*256+_2*128+_3*64+_4*32+_5*16+_6*8+_7*4+_8*2+_9)\n                              END DO\n                            END DO\n                          END DO\n                        END DO\n                      END DO\n                    END DO\n                  END DO\n                END DO\n              END DO\n            END DO\n          !$acc end kernels\n        !$acc end data\n\n        DO x = 1, 1024\n          IF (abs(a(x) - b(x)) .gt. PRECISION) THEN\n            errors = errors + 1\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "kernels",
                            "loop"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "kernels_loop.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:kernels,loop,combined-constructs,V:1.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n\n    real_t * a = (real_t *)malloc(1024 * sizeof(real_t));\n    real_t * b = (real_t *)malloc(1024 * sizeof(real_t));\n\n    for (int x = 0; x < 1024; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = 0.0;\n    }\n\n    #pragma acc kernels loop copy(a[0:1024]) copyout(b[0:1024])\n    for (int _0 = 0; _0 < 2; ++_0){\n        #pragma acc loop\n        for (int _1 = 0; _1 < 2; ++_1){\n            #pragma acc loop\n            for (int _2 = 0; _2 < 2; ++_2){\n                #pragma acc loop\n                for (int _3 = 0; _3 < 2; ++_3){\n                    #pragma acc loop\n                    for (int _4 = 0; _4 < 2; ++_4){\n                        #pragma acc loop\n                        for (int _5 = 0; _5 < 2; ++_5){\n                            #pragma acc loop\n                            for (int _6 = 0; _6 < 2; ++_6){\n                                #pragma acc loop\n                                for (int _7 = 0; _7 < 2; ++_7){\n                                    #pragma acc loop\n                                    for (int _8 = 0; _8 < 2; ++_8){\n                                        #pragma acc loop\n                                        for (int _9 = 0; _9 < 2; ++_9){\n                                            b[_0 * 512 + _1 * 256 + _2 * 128 + _3 * 64 + _4 * 32 + _5 * 16 + _6 * 8 + _7 * 4 + _8 * 2 + _9] = a[_0 * 512 + _1 * 256 + _2 * 128 + _3 * 64 + _4 * 32 + _5 * 16 + _6 * 8 + _7 * 4 + _8 * 2 + _9];\n                                        }\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    for (int x = 0; x < 1024; ++x){\n        if (fabs(a[x] - b[x]) > PRECISION){\n            err += 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "kernels",
                            "loop",
                            "combined-constructs"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "kernels_loop_independent.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:kernels,combined-constructs,loop,V:1.0-2.7\n      LOGICAL FUNCTION test1()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT):: a, b !Data\n        INTEGER :: errors = 0\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(a)\n        b = 0\n\n        !$acc data copyin(a(1:LOOPCOUNT)) copy(b(1:LOOPCOUNT))\n          !$acc kernels loop independent\n          DO x = 1, LOOPCOUNT\n            b(x) = b(x) + a(x)\n          END DO\n        !$acc end data\n\n        DO x = 1, LOOPCOUNT\n          IF (abs(a(x) - b(x)) .gt. PRECISION) THEN\n            errors = errors + 1\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "kernels",
                            "combined-constructs",
                            "loop"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "kernels_loop_independent.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:kernels,loop,combined-constructs,V:1.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n    }\n\n    #pragma acc data copyin(a[0:n]) copyout(b[0:n])\n    {\n        #pragma acc kernels loop independent\n        for (int x = 0; x < n; ++x){\n            b[x] = a[x];\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        if (fabs(a[x] - b[x]) > PRECISION){\n            err += 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "kernels",
                            "loop",
                            "combined-constructs"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "kernels_loop_reduction_add_general.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:kernels,reduction,combined-constructs,loop,V:1.0-2.7\n      LOGICAL FUNCTION test1()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT):: a, b !Data\n        REAL(8) :: total\n        INTEGER :: errors = 0\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(a)\n        CALL RANDOM_NUMBER(b)\n        total = 0\n        !$acc data copyin(a(1:LOOPCOUNT), b(1:LOOPCOUNT)) copy(total)\n          !$acc parallel loop reduction(+:total)\n          DO x = 1, LOOPCOUNT\n            total = total + a(x) + b(x)\n          END DO\n        !$acc end data\n        DO x = 1, LOOPCOUNT\n          total = total - (a(x) + b(x))\n        END DO\n        IF (abs(total) .gt. LOOPCOUNT * PRECISION) THEN\n          WRITE(*, *) total\n          errors = 1\n        END IF\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "kernels",
                            "reduction",
                            "combined-constructs",
                            "loop"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "kernels_loop_reduction_add_general.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:kernels,loop,reduction,combined-constructs,V:1.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n    }\n\n    real_t total = 10; //Should be innitialized to 0 anyway.\n    #pragma acc data copyin(a[0:n], b[0:n])\n    {\n        #pragma acc kernels loop reduction(+:total)\n        for (int x = 0; x < n; ++x){\n            total += a[x] + b[x];\n        }\n    }\n    for (int x = 0; x < n; ++x){\n        total -= a[x] + b[x];\n    }\n    if (fabs(total - 10) > PRECISION * (2 * n - 1)){\n        err = 1;\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "kernels",
                            "loop",
                            "reduction",
                            "combined-constructs"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "kernels_loop_reduction_add_loop.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:kernels,private,reduction,combined-constructs,loop,V:1.0-2.7\n      LOGICAL FUNCTION test1()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x, y !Iterators\n        REAL(8),DIMENSION(10*LOOPCOUNT):: a, b, c, d !Data\n        REAL(8) :: avg\n        INTEGER :: errors = 0\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(a)\n        CALL RANDOM_NUMBER(b)\n        avg = 0\n        !$acc data copyin(a(1:10*LOOPCOUNT), b(1:10*LOOPCOUNT)) create(c(1:10*LOOPCOUNT)) copyout(d(1:10*LOOPCOUNT))\n          !$acc kernels loop gang private(avg)\n          DO x = 0, 9\n            avg = 0\n            !$acc loop worker reduction(+:avg)\n            DO y = 1, LOOPCOUNT\n              avg = avg + a(x * LOOPCOUNT + y) + b(x * LOOPCOUNT + y)\n              c(x * LOOPCOUNT + y) = a(x * LOOPCOUNT + y) + b(x * LOOPCOUNT + y)\n            END DO\n            avg = avg / LOOPCOUNT\n            !$acc loop worker\n            DO y = 1, LOOPCOUNT\n              d(x * LOOPCOUNT + y) = c(x * LOOPCOUNT + y) / avg\n            END DO\n          END DO\n        !$acc end data\n        DO x = 0, 9\n          avg = 0\n          DO y = 1, LOOPCOUNT\n            avg = avg + a(x * LOOPCOUNT + y) + b(x * LOOPCOUNT + y)\n          END DO\n          avg = avg / LOOPCOUNT\n          DO y = 1, LOOPCOUNT\n            IF (abs(d(x * LOOPCOUNT + y) - ((a(x * LOOPCOUNT + y) + b(x * LOOPCOUNT + y)) / avg)) .gt. PRECISION) THEN\n              errors = errors + 1\n            END IF\n          END DO\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "kernels",
                            "private",
                            "reduction",
                            "combined-constructs",
                            "loop"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "kernels_loop_reduction_add_loop.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:kernels,loop,combined-constructs,reduction,V:1.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(10 * n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(10 * n * sizeof(real_t));\n    real_t * c = (real_t *)malloc(10 * n * sizeof(real_t));\n    real_t * d = (real_t *)malloc(10 * n * sizeof(real_t));\n    real_t avg = 0.0;\n\n    for (int x = 0; x < 10 * n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n    }\n\n    #pragma acc data copyin(a[0:10*n], b[0:10*n]) create(c[0:10*n]) copyout(d[0:10*n])\n    {\n        #pragma acc kernels loop gang private(avg)\n        for (int x = 0; x < 10; ++x){\n            avg = 0;\n            #pragma acc loop worker reduction(+:avg)\n            for (int y = 0; y < n; ++y){\n                avg += c[x * n + y] = a[x * n + y] + b[x * n + y];\n            }\n            avg = avg / n;\n            #pragma acc loop worker\n            for (int y = 0; y < n; ++y){\n                d[x * n + y] = c[x * n + y] - avg;\n            }\n        }\n    }\n\n    real_t rolling_total = 0;\n\n    for (int x = 0; x < 10; ++x){\n        rolling_total = 0;\n        for (int y = 0; y < n; ++y){\n            rolling_total += a[x * n + y] + b[x * n + y];\n        }\n        rolling_total = rolling_total / n;\n        for (int y = 0; y < n; ++y){\n            if (fabs(d[x * n + y] - ((a[x * n + y] + b[x * n + y]) - rolling_total)) > PRECISION){\n                err += 1;\n            }\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "kernels",
                            "loop",
                            "combined-constructs",
                            "reduction"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "kernels_loop_reduction_add_vector_loop.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:kernels,private,reduction,combined-constructs,loop,V:1.0-2.7\n      LOGICAL FUNCTION test1()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x, y !Iterators\n        REAL(8),DIMENSION(10*LOOPCOUNT):: a, b !Data\n        REAL(8),DIMENSION(10) :: c\n        REAL(8) :: temp\n        INTEGER :: errors = 0\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(a)\n        CALL RANDOM_NUMBER(b)\n\n        !$acc data copyin(a(1:10*LOOPCOUNT), b(1:10*LOOPCOUNT)) copyout(c(1:10))\n          !$acc kernels loop private(temp)\n          DO x = 0, 9\n            temp = 0.0\n            !$acc loop vector reduction(+:temp)\n            DO y = 1, LOOPCOUNT\n              temp = temp + a(x * LOOPCOUNT + y) + b(x * LOOPCOUNT + y)\n            END DO\n            c(x + 1) = temp\n          END DO\n        !$acc end data\n\n        DO x = 0, 9\n          temp = 0\n          DO y = 1, LOOPCOUNT\n            temp = temp + a(x * LOOPCOUNT + y) + b(x * LOOPCOUNT + y)\n          END DO\n          IF (abs(temp - c(x + 1)) .gt. PRECISION) THEN\n            errors = errors + 1\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "kernels",
                            "private",
                            "reduction",
                            "combined-constructs",
                            "loop"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "kernels_loop_reduction_add_vector_loop.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:kernels,loop,reduction,combined-constructs,V:1.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(10 * n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(10 * n * sizeof(real_t));\n    real_t * c = (real_t *)malloc(10 * sizeof(real_t));\n    real_t temp = 0.0;\n\n    for(int x = 0; x < 10 * n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n    }\n    #pragma acc data copyin(a[0:10*n], b[0:10*n]) copyout(c[0:10])\n    {\n        #pragma acc kernels loop private(temp)\n        for (int x = 0; x < 10; ++x){\n            temp = 0.0;\n            #pragma acc loop vector reduction(+:temp)\n            for (int y = 0; y < n; ++y){\n                temp += a[(x * n) + y] + b[(x * n) + y];\n            }\n            c[x] = temp;\n        }\n    }\n    for (int x = 0; x < 10; ++x){\n        for (int y = 0; y < n; ++y){\n            c[x] -= a[(x * n) + y] + b[(x * n) + y];\n        }\n        if (fabs(c[x]) > PRECISION * (2 * n - 1)){\n            err = 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "kernels",
                            "loop",
                            "reduction",
                            "combined-constructs"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "kernels_loop_reduction_and_general.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:kernels,reduction,combined-constructs,loop,V:1.0-2.7\n      LOGICAL FUNCTION test1()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT):: randoms\n        LOGICAL,DIMENSION(LOOPCOUNT):: a !Data\n        LOGICAL :: results = .TRUE.\n        LOGICAL :: host_results = .TRUE.\n        REAL(8) :: false_margin\n        INTEGER :: errors = 0\n        false_margin = exp(log(.5) / LOOPCOUNT)\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(randoms)\n        DO x = 1, LOOPCOUNT\n          IF (randoms(x) .lt. false_margin) THEN\n            a(x) = .TRUE.\n          ELSE\n            a(x) = .FALSE.\n          END IF\n        END DO\n\n        !$acc data copyin(a(1:LOOPCOUNT))\n          !$acc kernels loop reduction(.and.:results)\n          DO x = 1, LOOPCOUNT\n            results = results .and. a(x)\n          END DO\n        !$acc end data\n\n        DO x = 1, LOOPCOUNT\n          host_results = host_results .and. a(x)\n        END DO\n        IF (host_results .neqv. results) THEN\n          errors = 1\n        END IF\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "kernels",
                            "reduction",
                            "combined-constructs",
                            "loop"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "kernels_loop_reduction_and_general.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:kernels,loop,reduction,combined-constructs,V:1.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n\n    char * a = (char *)malloc(n * sizeof(char));\n    real_t false_margin = pow(exp(1), log(.5)/n);\n    char result = 1;\n\n    for (int x = 0; x < n; ++x){\n        if(rand() / (real_t)(RAND_MAX) < false_margin){\n            a[x] = 1;\n        }\n        else{\n            a[x] = 0;\n        }\n    }\n\n\n    #pragma acc data copyin(a[0:n])\n    {\n        #pragma acc kernels loop reduction(&&:result)\n        for (int x = 0; x < n; ++x){\n            result = result && a[x];\n        }\n    }\n\n    char found = 0;\n    for (int x = 0; x < n; ++x){\n        if (a[x] == 0){\n            found = 1;\n            break;\n        }\n    }\n    if (found == result){\n        err = 1;\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "kernels",
                            "loop",
                            "reduction",
                            "combined-constructs"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "kernels_loop_reduction_and_loop.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:kernels,reduction,combined-constructs,loop,V:1.0-2.7\n      LOGICAL FUNCTION test1()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x, y !Iterators\n        LOGICAL,DIMENSION(10*LOOPCOUNT):: a, a_copy !Data\n        LOGICAL,DIMENSION(10) :: results, has_false\n        LOGICAL :: host_results = .TRUE.\n        LOGICAL :: temp = .TRUE.\n        REAL(8),DIMENSION(10*LOOPCOUNT):: randoms\n        REAL(8) :: false_margin = exp(log(.5) / LOOPCOUNT)\n        INTEGER :: errors = 0\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(randoms)\n        DO x = 1, 10\n          results(x) = .TRUE.\n          has_false(x) = .FALSE.\n        END DO\n        DO x = 1, 10*LOOPCOUNT\n          IF (randoms(x) .lt. false_margin) THEN\n            a(x) = .TRUE.\n            a_copy(x) = .TRUE.\n          ELSE\n            a(x) = .FALSE.\n            a_copy(x) = .FALSE.\n            has_false(x / LOOPCOUNT) = .TRUE.\n          END IF\n        END DO\n\n        !$acc data copy(a(1:10*LOOPCOUNT), results(1:10))\n          !$acc kernels loop gang\n          DO x = 0, 9\n            temp = .TRUE.\n            !$acc loop worker reduction(.AND.:temp)\n            DO y = 1, LOOPCOUNT\n              temp = temp .AND. a(x * LOOPCOUNT + y)\n            END DO\n            results(x + 1) = temp\n            !$acc loop worker\n            DO y = 1, LOOPCOUNT\n              IF (temp .eqv. .TRUE.) THEN\n                IF (a(x * LOOPCOUNT + y) .eqv. .TRUE.) THEN\n                  a(x * LOOPCOUNT + y) = .FALSE.\n                ELSE\n                  a(x * LOOPCOUNT + y) = .TRUE.\n                END IF\n              END IF\n            END DO\n          END DO\n        !$acc end data\n        DO x = 0, 9\n          temp = .TRUE.\n          DO y = 1, LOOPCOUNT\n            temp = temp .AND. a_copy(x * LOOPCOUNT + y)\n          END DO\n          IF (temp .neqv. results(x + 1)) THEN\n            errors = errors + 1\n          END IF\n          DO y = 1, LOOPCOUNT\n            IF (temp .eqv. .TRUE.) THEN\n              IF (a(x * LOOPCOUNT + y) .eqv. a_copy(x * LOOPCOUNT + y)) THEN\n                errors = errors + 1\n              END IF\n            ELSE\n              IF (a(x * LOOPCOUNT + y) .neqv. a_copy(x * LOOPCOUNT + y)) THEN\n                errors = errors + 1\n              END IF\n            END IF\n          END DO\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "kernels",
                            "reduction",
                            "combined-constructs",
                            "loop"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "kernels_loop_reduction_and_loop.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:kernels,loop,reduction,combined-constructs,V:1.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    char * a = (char *)malloc(10 * n * sizeof(char));\n    char * a_copy = (char *)malloc(10 * n * sizeof(char));\n    char * has_false = (char *)malloc(10 * sizeof(char));\n    real_t false_margin = pow(exp(1), log(.5)/n);\n\n    for (int x = 0; x < 10; ++x){\n        has_false[x] = 0;\n    }\n\n    for (int x = 0; x < 10; ++x){\n        for (int y = 0; y < n; ++y){\n            if (rand() / (real_t)(RAND_MAX) < false_margin){\n                a[x * n + y] = 1;\n                a_copy[x * n + y] = 1;\n            }\n            else {\n                a[x * n + y] = 0;\n                a_copy[x * n + y] = 0;\n                has_false[x] = 1;\n            }\n        }\n    }\n\n    char temp = 1;\n    #pragma acc data copy(a[0:10*n])\n    {\n        #pragma acc kernels loop gang private(temp)\n        for (int x = 0; x < 10; ++x){\n            temp = 1;\n            #pragma acc loop worker reduction(&&:temp)\n            for (int y = 0; y < n; ++y){\n                temp = temp && a[x * n + y];\n            }\n            #pragma acc loop worker\n            for (int y = 0; y < n; ++y){\n                if(temp == 1){\n                    if  (a[x * n + y] == 1){\n                        a[x * n + y] = 0;\n                    }\n                    else {\n                        a[x * n + y] = 1;\n                    }\n                }\n            }\n        }\n    }\n\n\n    for (int x = 0; x < 10; ++x){\n        for (int y = 0; y < n; ++y){\n            if (has_false[x] == 1 && a[x * n + y] != a_copy[x * n + y]){\n                err = 1;\n            }\n            else if (has_false[x] == 0 && a[x * n + y] == a_copy[x * n + y]){\n                err = 1;\n            }\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "kernels",
                            "loop",
                            "reduction",
                            "combined-constructs"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "kernels_loop_reduction_and_vector_loop.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:kernels,private,reduction,combined-constructs,loop,V:1.0-2.7\n      LOGICAL FUNCTION test1()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x, y !Iterators\n        LOGICAL,DIMENSION(10*LOOPCOUNT):: a !Data\n        LOGICAL,DIMENSION(10):: b\n        LOGICAL,DIMENSION(10):: has_false\n        LOGICAL :: temp\n        REAL(8) :: false_margin\n        REAL(8),DIMENSION(10*LOOPCOUNT) :: randoms\n        INTEGER :: errors = 0\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(randoms)\n        false_margin = exp(log(.5) / LOOPCOUNT)\n        DO x = 1, 10\n          has_false(x) = .FALSE.\n          b(x) = .TRUE.\n        END DO\n\n        DO x = 0, 9\n          DO y = 1, LOOPCOUNT\n            IF (randoms(x * LOOPCOUNT + y) .lt. false_margin) THEN\n              a(x * LOOPCOUNT + y) = .TRUE.\n            ELSE\n              a(x * LOOPCOUNT + y) = .FALSE.\n              has_false(x + 1) = .TRUE.\n            END IF\n          END DO\n        END DO\n\n        !$acc data copyin(a(1:10*LOOPCOUNT)) copy(b(1:10))\n          !$acc kernels loop private(temp)\n          DO x = 0, 9\n            temp = .TRUE.\n            !$acc loop vector reduction(.AND.:temp)\n            DO y = 1, LOOPCOUNT\n              temp = temp .AND. a(x * LOOPCOUNT + y)\n            END DO\n            b(x + 1) = temp\n          END DO\n        !$acc end data\n\n        DO x = 0, 9\n          temp = .FALSE.\n          DO y = 1, LOOPCOUNT\n            IF (a(x * LOOPCOUNT + y) .eqv. .FALSE.) THEN\n              temp = .TRUE.\n            END IF\n          END DO\n          IF (temp .neqv. has_false(x + 1)) THEN\n            errors = 1\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "kernels",
                            "private",
                            "reduction",
                            "combined-constructs",
                            "loop"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "kernels_loop_reduction_and_vector_loop.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:kernels,loop,reduction,combined-constructs,V:1.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    char * a = (char *)malloc(10 * n * sizeof(char));\n    char * b = (char *)malloc(10 * sizeof(char));\n    char * has_false = (char *)malloc(10 * sizeof(char));\n    real_t false_margin = pow(exp(1), log(.5)/n);\n\n    for (int x = 0; x < 10; ++x){\n        has_false[x] = 0;\n    }\n    for (int x = 0; x < 10 * n; ++x){\n        if(rand() / (real_t)(RAND_MAX) < false_margin){\n            a[x] = 1;\n        }\n        else{\n            a[x] = 0;\n            has_false[x/n] = 1;\n        }\n    }\n    char temp = 1;\n    #pragma acc data copyin(a[0:10*n]) copy(b[0:10])\n    {\n        #pragma acc kernels loop private(temp)\n        for (int x = 0; x < 10; ++x){\n            temp = 1;\n            #pragma acc loop vector reduction(&&:temp)\n            for (int y = 0; y < n; ++y){\n                temp = temp && a[x * n + y];\n            }\n            b[x] = temp;\n        }\n    }\n    for (int x = 0; x < 10; ++x){\n        if (has_false[x] == b[x]){\n            err = 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "kernels",
                            "loop",
                            "reduction",
                            "combined-constructs"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "kernels_loop_reduction_bitand_general.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:kernels,reduction,combined-constructs,loop,V:1.0-2.7\n      LOGICAL FUNCTION test1()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x, y, z !Iterators\n        INTEGER,DIMENSION(LOOPCOUNT):: a !Data\n        INTEGER :: b\n        REAL(8),DIMENSION(16 * LOOPCOUNT):: randoms\n        REAL(8) :: false_margin\n        INTEGER :: errors = 0\n        INTEGER :: temp = 1\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(randoms)\n        false_margin = exp(log(.5)/n)\n        DO x = 1, LOOPCOUNT\n          DO y = 0, 15\n            IF (randoms(y * LOOPCOUNT + x) .lt. false_margin) THEN\n              temp = 1\n              DO z = 0, y\n                temp = temp * 2\n              END DO\n              a(x) = a(x) + temp\n            END IF\n          END DO\n        END DO\n\n        b = a(1)\n\n        !$acc data copyin(a(1:LOOPCOUNT))\n          !$acc kernels loop reduction(iand:b)\n          DO x = 1, LOOPCOUNT\n            b = iand(b, a(x))\n          END DO\n        !$acc end data\n\n        temp = a(1)\n        DO x = 2, LOOPCOUNT\n          temp = iand(a(x), temp)\n        END DO\n        IF (temp .ne. b) THEN\n          WRITE(*, *) temp\n          WRITE(*, *) b\n          errors = 1\n        END IF\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "kernels",
                            "reduction",
                            "combined-constructs",
                            "loop"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "kernels_loop_reduction_bitand_general.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:kernels,loop,reduction,combined-constructs,V:1.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    n = 10;\n    unsigned int * a = (unsigned int *)malloc(n * sizeof(unsigned int));\n    real_t false_margin = pow(exp(1), log(.5)/n);\n    unsigned int temp = 1;\n\n    for (int x = 0; x < n; ++x){\n        for (int y = 0; y < 16; ++y){\n            if (rand() / (real_t) RAND_MAX < false_margin){\n                for (int z = 0; z < y; ++z){\n                    temp *= 2;\n                }\n                a[x] += temp;\n                temp = 1;\n            }\n        }\n    }\n    unsigned int b = 0;\n    for (int x = 0; x < 16; ++x){\n        temp = 1;\n        for (int y = 0; y < x; ++y){\n            temp *= 2;\n        }\n        b += temp;\n    }\n    #pragma acc data copyin(a[0:n])\n    {\n        #pragma acc kernels loop reduction(&:b)\n        for (int x = 0; x < n; ++x){\n            b = b & a[x];\n        }\n    }\n    unsigned int host_b = a[0];\n\n    for (int x = 1; x < n; ++x){\n        host_b = host_b & a[x];\n    }\n    if (b != host_b){\n        err = 1;\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "kernels",
                            "loop",
                            "reduction",
                            "combined-constructs"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "kernels_loop_reduction_bitand_loop.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:kernels,private,reduction,combined-constructs,loop,V:1.0-2.7\n      LOGICAL FUNCTION test1()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x, y, z !Iterators\n        INTEGER,DIMENSION(10*LOOPCOUNT):: a, b, b_copy !Data\n        REAL(8),DIMENSION(10*LOOPCOUNT):: randoms2\n        INTEGER,DIMENSION(10) :: c\n        REAL(8) :: false_margin\n        REAL(8),DIMENSION(160*LOOPCOUNT)::randoms\n        INTEGER :: errors = 0\n        INTEGER :: temp\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(randoms)\n        CALL RANDOM_NUMBER(randoms2)\n        b = FLOOR(10000 * randoms2)\n        b_copy = b\n        false_margin = exp(log(.5)/LOOPCOUNT)\n        DO x = 1, 10 * LOOPCOUNT\n          DO y = 1, 16\n            IF (randoms((y - 1) * 10 * LOOPCOUNT + x) < false_margin) THEN\n              temp = 1\n              DO z = 1, y\n                temp = temp * 2\n              END DO\n              a(x) = a(x) + temp\n            END IF\n          END DO\n        END DO\n\n        DO x = 1, 10\n         c(x) = a((x - 1) * LOOPCOUNT + x)\n        END DO\n\n        !$acc data copyin(a(1:10*LOOPCOUNT)) copy(b(1:10*LOOPCOUNT), c(1:10))\n          !$acc kernels loop gang private(temp)\n          DO x = 1, 10\n            temp = a((x - 1) * LOOPCOUNT + 1)\n            !$acc loop worker reduction(iand:temp)\n            DO y = 2, LOOPCOUNT\n              temp = iand(temp, a((x - 1) * LOOPCOUNT + y))\n            END DO\n            c(x) = temp\n            !$acc loop worker\n            DO y = 1, LOOPCOUNT\n              b((x - 1) * LOOPCOUNT + y) = b((x - 1) * LOOPCOUNT + y) + c(x)\n            END DO\n          END DO\n        !$acc end data\n\n       DO x = 1, 10\n         temp = a((x - 1) * LOOPCOUNT + 1)\n         DO y = 2, LOOPCOUNT\n           temp = iand(temp, a((x - 1) * LOOPCOUNT + y))\n         END DO\n         IF (temp .ne. c(x)) THEN\n           errors = errors + 1\n         END IF\n         DO y = 1, LOOPCOUNT\n           IF (b((x - 1) * LOOPCOUNT + y) .ne. b_copy((x - 1) * LOOPCOUNT + y) + temp) THEN\n             errors = errors + 1\n           END IF\n         END DO\n       END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "kernels",
                            "private",
                            "reduction",
                            "combined-constructs",
                            "loop"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "kernels_loop_reduction_bitand_loop.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:kernels,loop,reduction,combined-constructs,V:1.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    unsigned int * a = (unsigned int *)malloc(10 * n * sizeof(unsigned int));\n    unsigned int * b = (unsigned int *)malloc(10 * n * sizeof(unsigned int));\n    unsigned int * b_copy = (unsigned int *)malloc(10 * n * sizeof(unsigned int));\n    unsigned int * c = (unsigned int *)malloc(10 * sizeof(unsigned int));\n\n    real_t false_margin = pow(exp(1), log(.5)/n);\n    unsigned int temp = 1;\n\n    for (int x = 0; x < 10 * n; ++x){\n        b[x] = (unsigned int) rand() / (real_t)(RAND_MAX / 1000);\n        b_copy[x] = b[x];\n        for (int y = 0; y < 16; ++y){\n            if (rand() / (real_t) RAND_MAX < false_margin){\n                for (int z = 0; z < y; ++z){\n                    temp *= 2;\n                }\n                a[x] += temp;\n                temp = 1;\n            }\n        }\n    }\n    #pragma acc data copyin(a[0:10 * n]) copy(b[0:10 * n], c[0:10])\n    {\n        #pragma acc kernels loop gang private(temp)\n        for (int y = 0; y < 10; ++y){\n            temp = a[y * n];\n            #pragma acc loop worker reduction(&:temp)\n            for (int x = 1; x < n; ++x){\n                temp = temp & a[y * n + x];\n            }\n            c[y] = temp;\n            #pragma acc loop worker\n            for (int x = 0; x < n; ++x){\n                b[y * n + x] = b[y * n + x] + c[y];\n            }\n        }\n    }\n    unsigned int* host_c = (unsigned int *)malloc(10 * sizeof(unsigned int));\n    for (int x = 0; x < 10; ++x){\n        host_c[x] = a[x * n];\n        for (int y = 1; y < n; ++y){\n            host_c[x] = host_c[x] & a[x * n + y];\n        }\n        if (host_c[x] != c[x]){\n          err += 1;\n        }\n    }\n\n    for (int x = 0; x < 10; ++x){\n        for (int y = 0; y < n; ++y){\n            if (b[x * n + y] != b_copy[x * n + y] + c[x]){\n                err += 1;\n            }\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "kernels",
                            "loop",
                            "reduction",
                            "combined-constructs"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "kernels_loop_reduction_bitand_vector_loop.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:kernels,private,reduction,combined-constructs,loop,V:1.0-2.7\n      LOGICAL FUNCTION test1()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x, y, z, i !Iterators\n        INTEGER,DIMENSION(10*LOOPCOUNT):: a !Data\n        INTEGER,DIMENSION(10):: b\n        INTEGER :: c\n        REAL(8),DIMENSION(160*LOOPCOUNT):: random\n        REAL(8) :: false_margin\n        INTEGER :: errors = 0\n        INTEGER :: temp\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(random)\n        false_margin = exp(log(.5) / n)\n        DO x = 0, 9\n          DO y = 1, LOOPCOUNT\n            DO z = 1, 16\n              IF (random(x * 16 * LOOPCOUNT + (y - 1) * 16 + z - 1) < false_margin) THEN\n                temp = 1\n                DO i = 1, z\n                  temp = temp * 2\n                END DO\n                a(x * LOOPCOUNT + y) = a(x * LOOPCOUNT + y) + temp\n              END IF\n            END DO\n          END DO\n        END DO\n\n        !$acc data copyin(a(1:10*LOOPCOUNT)), copy(b(1:10))\n          !$acc kernels loop private(c)\n          DO x = 0, 9\n            c = a(x * LOOPCOUNT + 1)\n            !$acc loop vector reduction(iand:c)\n            DO y = 1, LOOPCOUNT\n              c = iand(c, a(x * LOOPCOUNT + y))\n            END DO\n            b(x + 1) = c\n          END DO\n        !$acc end data\n\n        DO x = 0, 9\n          temp = a(x * LOOPCOUNT + 1)\n          DO y = 2, LOOPCOUNT\n            temp = iand(temp, a(x * LOOPCOUNT + y))\n          END DO\n          IF (b(x + 1) .ne. temp) THEN\n            errors = errors + 1\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "kernels",
                            "private",
                            "reduction",
                            "combined-constructs",
                            "loop"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "kernels_loop_reduction_bitand_vector_loop.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:kernels,loop,reduction,combined-constructs,V:1.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    unsigned int* a = (unsigned int *)malloc(10 * n * sizeof(unsigned int));\n    unsigned int* b = (unsigned int *)malloc(10 * sizeof(unsigned int));\n\n    real_t false_margin = pow(exp(1), log(.5)/n);\n    unsigned int temp = 1;\n    unsigned int c = 0;\n    unsigned int b_host;\n\n    for (int x = 0; x < 10 * n; ++x){\n        for (int y = 0; y < 16; ++y){\n            if (rand() / (real_t) RAND_MAX < false_margin){\n                for (int z = 0; z < y; ++z){\n                    temp *= 2;\n                }\n                a[x] += temp;\n                temp = 1;\n            }\n        }\n    }\n\n    #pragma acc data copyin(a[0:10*n]) copy(b[0:10])\n    {\n        #pragma acc kernels loop private(c)\n        for (int x = 0; x < 10; ++x){\n            c = a[x * n];\n            #pragma acc loop vector reduction(&:c)\n            for (int y = 1; y < n; ++y){\n                c = c & a[x * n + y];\n            }\n            b[x] = c;\n        }\n    }\n    for (int x = 0; x < 10; ++x){\n        b_host = a[x * n];\n        for (int y = 1; y < n; ++y){\n            b_host = b_host & a[x * n + y];\n        }\n        if (b_host != b[x]){\n            err = 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "kernels",
                            "loop",
                            "reduction",
                            "combined-constructs"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "kernels_loop_reduction_bitor_general.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:kernels,reduction,combined-constructs,loop,V:1.0-2.7\n      LOGICAL FUNCTION test1()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x, y, z !Iterators\n        INTEGER,DIMENSION(LOOPCOUNT):: a !Data\n        REAL(8) :: false_margin\n        REAL(8),DIMENSION(16*LOOPCOUNT):: random\n        INTEGER :: errors = 0\n        INTEGER :: temp\n        INTEGER :: b\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(random)\n        false_margin = exp(log(.5)/n)\n        DO x = 1, LOOPCOUNT\n          DO y = 1, 16\n            IF (random((y - 1) * LOOPCOUNT + x) < false_margin) THEN\n              temp = 1\n              DO z = 1, y\n                temp = temp * 2\n              END DO\n              a(x) = a(x) + temp\n            END IF\n          END DO\n        END DO\n        b = a(1)\n        !$acc data copyin(a(1:LOOPCOUNT))\n          !$acc kernels loop reduction(ior:b)\n          DO x = 2, LOOPCOUNT\n            b = ior(b, a(x))\n          END DO\n        !$acc end data\n        temp = a(1)\n        DO x = 2, LOOPCOUNT\n          temp = ior(temp, a(x))\n        END DO\n        IF (temp .ne. b) THEN\n          errors = errors + 1\n        END IF\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "kernels",
                            "reduction",
                            "combined-constructs",
                            "loop"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "kernels_loop_reduction_bitor_general.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:kernels,loop,reduction,combined-constructs,V:1.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    unsigned int * a = (unsigned int *)malloc(n * sizeof(unsigned int));\n    real_t false_margin = pow(exp(1), log(.5)/n);\n    unsigned int temp = 1;\n    unsigned int b = 0;\n    unsigned int host_b = a[0];\n\n    for (int x = 0; x < n; ++x){\n        for (int y = 0; y < 16; ++y){\n            if (rand() / (real_t) RAND_MAX > false_margin){\n                for (int z = 0; z < y; ++z){\n                    temp *= 2;\n                }\n                a[x] += temp;\n                temp = 1;\n            }\n        }\n    }\n\n    #pragma acc data copyin(a[0:n])\n    {\n        #pragma acc kernels loop reduction(|:b)\n        for (int x = 0; x < n; ++x){\n            b = b | a[x];\n        }\n    }\n\n\n    for (int x = 1; x < n; ++x){\n        host_b = host_b | a[x];\n    }\n    if (b != host_b){\n        err = 1;\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "kernels",
                            "loop",
                            "reduction",
                            "combined-constructs"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "kernels_loop_reduction_bitor_loop.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:kernels,private,reduction,combined-constructs,loop,V:1.0-2.7\n      LOGICAL FUNCTION test1()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x, y, z, i !Iterators\n        INTEGER,DIMENSION(10*LOOPCOUNT):: a, b, b_copy !Data\n        REAL(8),DIMENSION(10*LOOPCOUNT):: randoms2\n        INTEGER,DIMENSION(10) :: c\n        REAL(8),DIMENSION(160*LOOPCOUNT):: randoms\n        REAL(8) :: false_margin\n        INTEGER :: errors = 0\n        INTEGER :: temp\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(randoms)\n        CALL RANDOM_NUMBER(randoms2)\n        false_margin = exp(log(.5)/n)\n        b = FLOOR(6*randoms2)\n        b_copy = b\n        DO x = 0, 9\n          DO y = 1, LOOPCOUNT\n            DO z = 1, 16\n              IF (randoms(x * 16 * LOOPCOUNT + y * 16 + z - 1) .gt. false_margin) THEN\n                temp = 1\n                DO i = 1, z\n                  temp = temp * 2\n                END DO\n                a(x * LOOPCOUNT + y) = a(x * LOOPCOUNT + y) + temp\n              END IF\n            END DO\n          END DO\n        END DO\n\n        !$acc data copyin(a(1:10*LOOPCOUNT)) copy(b(1:10*LOOPCOUNT), c(1:10))\n          !$acc kernels loop gang private(temp)\n          DO x = 0, 9\n            temp = 0\n            !$acc loop worker reduction(ior:temp)\n            DO y = 1, LOOPCOUNT\n              temp = ior(temp, a(x * LOOPCOUNT + y))\n            END DO\n            c(x + 1) = temp\n            !$acc loop worker\n            DO y = 1, LOOPCOUNT\n              b(x * LOOPCOUNT + y) = b(x * LOOPCOUNT + y) + c(x + 1)\n            END DO\n          END DO\n        !$acc end data\n\n        DO x = 0, 9\n          temp = 0\n          DO y = 1, LOOPCOUNT\n            temp = ior(temp, a(x * LOOPCOUNT + y))\n          END DO\n          IF (temp .ne. c(x + 1)) THEN\n            errors = errors + 1\n          END IF\n          DO y = 1, LOOPCOUNT\n            IF (b(x * LOOPCOUNT + y) .ne. b_copy(x * LOOPCOUNT + y) + c(x + 1)) THEN\n              errors = errors + 1\n            END IF\n          END DO\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "kernels",
                            "private",
                            "reduction",
                            "combined-constructs",
                            "loop"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "kernels_loop_reduction_bitor_loop.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:kernels,loop,reduction,combined-constructs,V:1.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    unsigned int * a = (unsigned int *)malloc(10 * n * sizeof(unsigned int));\n    unsigned int * b = (unsigned int *)malloc(10 * n * sizeof(unsigned int));\n    unsigned int * b_copy = (unsigned int *)malloc(10 * n * sizeof(unsigned int));\n    unsigned int * c = (unsigned int *)malloc(10 * sizeof(unsigned int));\n\n    real_t false_margin = pow(exp(1), log(.5)/n);\n    unsigned int temp = 1;\n    unsigned int host_c;\n\n    for (int x = 0; x < 10; ++x){\n        for (int y = 0; y < n; ++y){\n            b[x * n + y] = (unsigned int) rand() / (real_t)(RAND_MAX / 1000);\n            b_copy[x * n + y] = b[x * n + y];\n            for (int z = 0; z < 16; ++z){\n                if (rand() / (real_t) RAND_MAX > false_margin){\n                    temp = 1;\n                    for (int i = 0; i < z; ++i){\n                        temp = temp * 2;\n                    }\n                    a[x * n + y] += temp;\n                }\n            }\n        }\n    }\n\n    #pragma acc data copyin(a[0:10*n]) copy(b[0:10*n], c[0:10])\n    {\n        #pragma acc kernels loop gang private(temp)\n        for (int x = 0; x < 10; ++x){\n            temp = 0;\n            #pragma acc loop worker reduction(|:temp)\n            for (int y = 0; y < n; ++y){\n                temp = temp | a[x * n + y];\n            }\n            c[x] = temp;\n            #pragma acc loop worker\n            for (int y = 0; y < n; ++y){\n                b[x * n + y] = b[x * n + y] + c[x];\n            }\n        }\n    }\n    for (int x = 0; x < 10; ++x){\n        host_c = a[x * n];\n        for (int y = 1; y < n; ++y){\n            host_c = host_c | a[x * n + y];\n        }\n        if (host_c != c[x]){\n            err += 1;\n        }\n        for (int y = 0; y < n; ++y){\n            if (b[x * n + y] != b_copy[x * n + y] + host_c){\n                err += 1;\n            }\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "kernels",
                            "loop",
                            "reduction",
                            "combined-constructs"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "kernels_loop_reduction_bitor_vector_loop.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:kernels,private,reduction,combined-constructs,loop,V:1.0-2.7\n      LOGICAL FUNCTION test1()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x, y, z !Iterators\n        INTEGER,DIMENSION(10 * LOOPCOUNT):: a !Data\n        INTEGER,DIMENSION(10) :: b\n        REAL(8) :: false_margin\n        REAL(8),DIMENSION(160 * LOOPCOUNT) :: randoms\n        INTEGER :: errors = 0\n        INTEGER :: temp\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(randoms)\n        false_margin = exp(log(.5) / n)\n        DO x = 1, 10 * LOOPCOUNT\n          DO y = 1, 16\n            IF (randoms(y * 10 * LOOPCOUNT + y - 1) .gt. false_margin) THEN\n              temp = 1\n              DO z = 1, y\n                temp = temp * 2\n              END DO\n              a(x) = a(x) + temp\n            END IF\n          END DO\n        END DO\n\n        !$acc data copyin(a(1:10*LOOPCOUNT)) copy(b(1:10))\n          !$acc kernels loop private(temp)\n          DO x = 0, 9\n            temp = 0\n            !$acc loop vector reduction(ior:temp)\n            DO y = 1, LOOPCOUNT\n              temp = ior(temp, a(x * LOOPCOUNT + y))\n            END DO\n            b(x + 1) = temp\n          END DO\n        !$acc end data\n\n        DO x = 0, 9\n          temp = 0\n          DO y = 1, LOOPCOUNT\n            temp = ior(temp, a(x * LOOPCOUNT + y))\n          END DO\n          IF (temp .ne. b(x + 1)) THEN\n            errors = errors + 1\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "kernels",
                            "private",
                            "reduction",
                            "combined-constructs",
                            "loop"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "kernels_loop_reduction_bitor_vector_loop.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:kernels,loop,reduction,combined-constructs,V:1.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    unsigned int* a = (unsigned int *)malloc(10 * n * sizeof(unsigned int));\n    unsigned int* b = (unsigned int *)malloc(10 * sizeof(unsigned int));\n\n    real_t false_margin = pow(exp(1), log(.5)/n);\n    unsigned int temp = 1;\n    unsigned int b_host;\n\n    for (int x = 0; x < 10 * n; ++x){\n        for (int y = 0; y < 16; ++y){\n            if (rand() / (real_t) RAND_MAX > false_margin){\n                for (int z = 0; z < y; ++z){\n                    temp *= 2;\n                }\n                a[x] += temp;\n                temp = 1;\n            }\n        }\n    }\n    temp = 0;\n    #pragma acc data copyin(a[0:10*n]) copy(b[0:10])\n    {\n        #pragma acc kernels loop private(temp)\n        for (int x = 0; x < 10; ++x){\n            temp = 0;\n            #pragma acc loop vector reduction(|:temp)\n            for (int y = 0; y < n; ++y){\n                temp = temp | a[x * n + y];\n            }\n            b[x] = temp;\n        }\n    }\n\n    for (int x = 0; x < 10; ++x){\n        b_host = a[x * n];\n        for (int y = 1; y < n; ++y){\n            b_host = b_host | a[x * n + y];\n        }\n        if (b_host != b[x]){\n            err = 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "kernels",
                            "loop",
                            "reduction",
                            "combined-constructs"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "kernels_loop_reduction_bitxor_general.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:kernels,reduction,combined-constructs,loop,V:1.0-2.7\n      LOGICAL FUNCTION test1()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x !Iterators\n        INTEGER,DIMENSION(LOOPCOUNT):: a !Data\n        REAL(8),DIMENSION(LOOPCOUNT):: randoms\n        INTEGER :: errors = 0\n        INTEGER :: b = 0\n        INTEGER :: temp = 0\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(randoms)\n        a = FLOOR(randoms*1000000)\n\n        !$acc data copyin(a(1:LOOPCOUNT))\n          !$acc kernels loop reduction(ieor:b)\n          DO x = 1, LOOPCOUNT\n            b = ieor(b, a(x))\n          END DO\n        !$acc end data\n\n        DO x = 1, LOOPCOUNT\n          temp = ieor(temp, a(x))\n        END DO\n        IF (temp .ne. b) THEN\n          errors = errors + 1\n        END IF\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "kernels",
                            "reduction",
                            "combined-constructs",
                            "loop"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "kernels_loop_reduction_bitxor_general.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:kernels,loop,reduction,combined-constructs,V:1.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    unsigned int * a = (unsigned int *)malloc(n * sizeof(unsigned int));\n    unsigned int b = 0;\n    unsigned int host_b = a[0];\n\n    for (int x = 0; x < n; ++x){\n        a[x] = (unsigned int) rand() / (real_t) (RAND_MAX / 2);\n    }\n\n    #pragma acc data copyin(a[0:n])\n    {\n        #pragma acc kernels loop reduction(^:b)\n        for (int x = 0; x < n; ++x){\n            b = b ^ a[x];\n        }\n    }\n\n\n    for (int x = 1; x < n; ++x){\n        host_b = host_b ^ a[x];\n    }\n    if (b != host_b){\n        err = 1;\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "kernels",
                            "loop",
                            "reduction",
                            "combined-constructs"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "kernels_loop_reduction_bitxor_loop.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:kernels,private,reduction,combined-constructs,loop,V:1.0-2.7\n      LOGICAL FUNCTION test1()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x, y !Iterators\n        INTEGER,DIMENSION(10*LOOPCOUNT):: a, b, b_copy !Data\n        REAL(8),DIMENSION(10*LOOPCOUNT):: randoms, randoms2\n        INTEGER,DIMENSION(10):: c\n        REAL*8 :: RAND\n        INTEGER :: errors = 0\n        INTEGER :: temp\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(randoms)\n        a = FLOOR(randoms*1000000)\n        CALL RANDOM_NUMBER(randoms2)\n        b = FLOOR(randoms2*1000000)\n        b_copy = b\n        c = 0\n\n        !$acc data copyin(a(1:10*LOOPCOUNT)) copy(b(1:10*LOOPCOUNT), c(1:10))\n          !$acc kernels loop gang private(temp)\n          DO x = 0, 9\n            temp = 0\n            !$acc loop worker reduction(ieor:temp)\n            DO y = 1, LOOPCOUNT\n              temp = ieor(temp, a(x * LOOPCOUNT + y))\n            END DO\n            c(x + 1) = temp\n            !$acc loop worker\n            DO y = 1, LOOPCOUNT\n              b(x * LOOPCOUNT + y) = b(x * LOOPCOUNT + y) + c(x + 1)\n            END DO\n          END DO\n        !$acc end data\n\n        DO x = 0, 9\n          temp = 0\n          DO y = 1, LOOPCOUNT\n            temp = ieor(temp, a(x * LOOPCOUNT + y))\n          END DO\n          IF (temp .ne. c(x + 1)) THEN\n            errors = errors + 1\n          END IF\n          DO y = 1, LOOPCOUNT\n            IF (b(x * LOOPCOUNT + y) .ne. b_copy(x * LOOPCOUNT + y) + c(x + 1)) THEN\n              errors = errors + 1\n            END IF\n          END DO\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "kernels",
                            "private",
                            "reduction",
                            "combined-constructs",
                            "loop"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "kernels_loop_reduction_bitxor_loop.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:kernels,loop,reduction,combined-constructs,V:1.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    unsigned int * a = (unsigned int *)malloc(10 * n * sizeof(unsigned int));\n    unsigned int * b = (unsigned int *)malloc(10 * n * sizeof(unsigned int));\n    unsigned int * b_copy = (unsigned int *)malloc(10 * n * sizeof(unsigned int));\n    unsigned int * c = (unsigned int *)malloc(10 * sizeof(unsigned int));\n    unsigned int temp = 0;\n\n    for (int x = 0; x < 10*n; ++x){\n        b[x] = (unsigned int) rand() / (real_t)(RAND_MAX / 1000);\n        b_copy[x] = b[x];\n        a[x] = (unsigned int) rand() / (real_t)(RAND_MAX / 1000);\n    }\n    for (int x = 0; x < 10; ++x){\n        c[x] = 0;\n    }\n\n    #pragma acc data copyin(a[0:10*n]) copy(b[0:10*n], c[0:10])\n    {\n        #pragma acc kernels loop gang private(temp)\n        for (int x = 0; x < 10; ++x){\n            temp = 0;\n            #pragma acc loop worker reduction(^:temp)\n            for (int y = 0; y < n; ++y){\n                temp = temp ^ a[x * n + y];\n            }\n            c[x] = temp;\n            #pragma acc loop worker\n            for (int y = 0; y < n; ++y){\n                b[x * n + y] = b[x * n + y] + c[x];\n            }\n        }\n    }\n\n    for (int x = 0; x < 10; ++x){\n        temp = 0;\n        for (int y = 0; y < n; ++y){\n            temp = temp ^ a[x * n + y];\n        }\n        if (temp != c[x]){\n            err += 1;\n        }\n        for (int y = 0; y < n; ++y){\n            if (b[x * n + y] != b_copy[x * n + y] + c[x]){\n                err += 1;\n            }\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "kernels",
                            "loop",
                            "reduction",
                            "combined-constructs"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "kernels_loop_reduction_bitxor_vector_loop.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:kernels,private,reduction,combined-constructs,loop,V:1.0-2.7\n      LOGICAL FUNCTION test1()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x, y !Iterators\n        INTEGER,DIMENSION(10*LOOPCOUNT):: a !Data\n        REAL(8),DIMENSION(10*LOOPCOUNT):: randoms\n        INTEGER,DIMENSION(10):: b\n        INTEGER :: errors = 0\n        INTEGER :: temp\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(randoms)\n        a = FLOOR(randoms*1000000)\n\n        !$acc data copyin(a(1:10*LOOPCOUNT)) copy(b(1:10))\n          !$acc kernels loop gang private(temp)\n          DO x = 0, 9\n            temp = 0\n            !$acc loop vector reduction(ieor:temp)\n            DO y = 1, LOOPCOUNT\n              temp = ieor(temp, a(x * LOOPCOUNT + y))\n            END DO\n            b(x + 1) = temp\n          END DO\n        !$acc end data\n\n        DO x = 0, 9\n          temp = 0\n          DO y = 1, LOOPCOUNT\n            temp = ieor(temp, a(x * LOOPCOUNT + y))\n          END DO\n          IF (temp .ne. b(x + 1)) THEN\n            errors = errors + 1\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "kernels",
                            "private",
                            "reduction",
                            "combined-constructs",
                            "loop"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "kernels_loop_reduction_bitxor_vector_loop.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:kernels,loop,reduction,combined-constructs,V:1.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    unsigned int* a = (unsigned int *)malloc(10 * n * sizeof(unsigned int));\n    unsigned int* b = (unsigned int *)malloc(10 * sizeof(unsigned int));\n\n    unsigned int temp = 0;\n    unsigned int b_host;\n\n    for (int x = 0; x < 10 * n; ++x){\n        a[x] = (unsigned int) rand() / (real_t) (RAND_MAX / 2);\n    }\n\n    #pragma acc data copyin(a[0:10*n]) copy(b[0:10])\n    {\n        #pragma acc kernels loop private(temp)\n        for (int x = 0; x < 10; ++x){\n            temp = 0;\n            #pragma acc loop vector reduction(^:temp)\n            for (int y = 0; y < n; ++y){\n                temp = temp ^ a[x * n + y];\n            }\n            b[x] = temp;\n        }\n    }\n\n    for (int x = 0; x < 10; ++x){\n        b_host = a[x * n];\n        for (int y = 1; y < n; ++y){\n            b_host = b_host ^ a[x * n + y];\n        }\n        if (b_host != b[x]){\n            err = 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "kernels",
                            "loop",
                            "reduction",
                            "combined-constructs"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "kernels_loop_reduction_max_general.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:kernels,reduction,combined-constructs,loop,V:1.0-2.7\n      LOGICAL FUNCTION test1()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT):: a, b !Data\n        REAL(8) :: maximum, temp\n        INTEGER :: errors = 0\n\n        !Initilization\n        maximum = 0\n        temp = 0\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(a)\n        CALL RANDOM_NUMBER(b)\n\n        !$acc data copyin(a(1:LOOPCOUNT), b(1:LOOPCOUNT))\n          !$acc kernels loop reduction(max:maximum)\n          DO x = 1, LOOPCOUNT\n            maximum = max(maximum, a(x) * b(x))\n          END DO\n        !$acc end data\n\n        DO x = 1, LOOPCOUNT\n          temp = max(temp, a(x) * b(x))\n        END DO\n        IF (abs(temp - maximum) .gt. PRECISION) THEN\n          errors = errors + 1\n        END IF\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "kernels",
                            "reduction",
                            "combined-constructs",
                            "loop"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "kernels_loop_reduction_max_general.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:kernels,loop,reduction,combined-constructs,V:1.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n    real_t max = 0.0;\n    int found = 0;\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX/10);\n        b[x] = rand() / (real_t)(RAND_MAX/10);\n    }\n    #pragma acc data copyin(a[0:n], b[0:n]) copy(max)\n    {\n        #pragma acc kernels loop reduction(max:max)\n        for (int x = 0; x < n; ++x){\n            max = fmax(a[x] * b[x], max);\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        if (fabs(max - (a[x] * b[x] + PRECISION)) < 0){\n            err = 1;\n        }\n        if (fabs(max - (a[x] * b[x] - PRECISION)) > 0){\n            found = 1;\n        }\n    }\n    if (found = 0){\n        err = 1;\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "kernels",
                            "loop",
                            "reduction",
                            "combined-constructs"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "kernels_loop_reduction_max_loop.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:kernels,private,reduction,combined-constructs,loop,V:1.0-2.7\n      LOGICAL FUNCTION test1()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x, y !Iterators\n        REAL(8),DIMENSION(10 * LOOPCOUNT):: a, b, c !Data\n        REAL(8),DIMENSION(10):: maximum\n        REAL(8) :: temp\n        INTEGER :: errors = 0\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(a)\n        CALL RANDOM_NUMBER(b)\n        c = 0\n\n        !$acc data copyin(a(1:10*LOOPCOUNT), b(1:10*LOOPCOUNT)) copy(c(1:10*LOOPCOUNT))\n          !$acc kernels loop gang private(temp)\n          DO x = 0, 9\n            temp = 0\n            !$acc loop worker reduction(max:temp)\n            DO y = 1, LOOPCOUNT\n              temp = max(temp, a(x * LOOPCOUNT + y) * b(x * LOOPCOUNT + y))\n            END DO\n            maximum(x + 1) = temp\n            !$acc loop worker\n            DO y = 1, LOOPCOUNT\n              c(x * LOOPCOUNT + y) = (a(x * LOOPCOUNT + y) * b(x * LOOPCOUNT + y)) / maximum(x + 1)\n            END DO\n          END DO\n        !$acc end data\n\n        DO x = 0, 9\n          DO y = 1, LOOPCOUNT\n            IF (a(x * LOOPCOUNT + y) * b(x * LOOPCOUNT + y) - maximum(x + 1) .gt. PRECISION) THEN\n              errors = errors + 1\n            ELSE IF ((c(x * LOOPCOUNT + y) - 1) .gt. PRECISION) THEN\n              errors = errors + 1\n            END IF\n          END DO\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "kernels",
                            "private",
                            "reduction",
                            "combined-constructs",
                            "loop"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "kernels_loop_reduction_max_loop.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:kernels,loop,reduction,combined-constructs,V:1.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(10 * n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(10 * n * sizeof(real_t));\n    real_t * c = (real_t *)malloc(10 * n * sizeof(real_t));\n    real_t * maximum = (real_t *)malloc(10 * sizeof(real_t));\n    real_t temp = 0;\n    real_t max = 0.0;\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX/10);\n        b[x] = rand() / (real_t)(RAND_MAX/10);\n        c[x] = 0.0;\n    }\n    for (int x = 0; x < 10; ++x){\n        maximum[x] = 0;\n    }\n\n    #pragma acc data copyin(a[0:10*n], b[0:10*n]) copy(c[0:10*n], maximum[0:10])\n    {\n        #pragma acc kernels loop gang private(temp)\n        for (int x = 0; x < 10; ++x){\n            temp = 0;\n            #pragma acc loop worker reduction(max:temp)\n            for (int y = 0; y < n; ++y){\n                temp = fmax(a[x * n + y] * b[x * n + y], temp);\n            }\n            maximum[x] = temp;\n            #pragma acc loop worker\n            for (int y = 0; y < n; ++y){\n                c[x * n + y] = (a[x * n + y] * b[x * n + y]) / maximum[x];\n            }\n        }\n    }\n    for (int x = 0; x < 10; ++x){\n        temp = 0;\n        for (int y = 0; y < n; ++y){\n            temp = fmax(temp, a[x * n + y] * b[x * n + y]);\n        }\n        if (fabs(temp - maximum[x]) > PRECISION){\n            err += 1;\n        }\n        for (int y = 0; y < n; ++y){\n            if (c[x * n + y] > 1){\n                err += 1;\n            }\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "kernels",
                            "loop",
                            "reduction",
                            "combined-constructs"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "kernels_loop_reduction_max_vector_loop.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:kernels,private,reduction,combined-constructs,loop,V:1.0-2.7\n      LOGICAL FUNCTION test1()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x, y !Iterators\n        REAL(8),DIMENSION(10 * LOOPCOUNT):: a, b !Data\n        REAL(8),DIMENSION(10):: maximum\n        INTEGER :: errors = 0\n        REAL(8) :: temp\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(a)\n        CALL RANDOM_NUMBER(b)\n        maximum = 0\n\n        !$acc data copyin(a(1:10*LOOPCOUNT), b(1:10*LOOPCOUNT)) copy(maximum(1:10))\n          !$acc kernels loop private(temp)\n          DO x = 0, 9\n            temp = 0\n            !$acc loop vector reduction(max:temp)\n            DO y = 1, LOOPCOUNT\n              temp = max(temp, a(x * LOOPCOUNT + y) * b(x * LOOPCOUNT + y))\n            END DO\n            maximum(x + 1) = temp\n          END DO\n        !$acc end data\n\n        DO x = 0, 9\n          temp = 0\n          DO y = 1, LOOPCOUNT\n            temp = max(temp, a(x * LOOPCOUNT + y) * b(x * LOOPCOUNT + y))\n          END DO\n          IF (abs(temp - maximum(x + 1)) .gt. PRECISION) THEN\n            errors = errors + 1\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "kernels",
                            "private",
                            "reduction",
                            "combined-constructs",
                            "loop"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "kernels_loop_reduction_max_vector_loop.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:kernels,loop,reduction,combined-constructs,V:1.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(10 * n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(10 * n * sizeof(real_t));\n    real_t * max = (real_t *)malloc(10 * sizeof(real_t));\n    real_t temp = 0;\n    real_t temp_max;\n\n    for (int x = 0; x < 10 * n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX/10);\n        b[x] = rand() / (real_t)(RAND_MAX/10);\n    }\n    #pragma acc data copyin(a[0:10*n], b[0:10*n]) copy(max[0:10])\n    {\n        #pragma acc kernels loop private(temp)\n        for (int x = 0; x < 10; ++x){\n            temp = 0;\n            #pragma acc loop vector reduction(max:temp)\n            for (int y = 0; y < n; ++y){\n                temp = fmax(a[x * n + y] * b[x * n + y], temp);\n            }\n            max[x] = temp;\n        }\n    }\n    for (int x = 0; x < 10; ++x){\n        temp_max = 0;\n        for (int y = 0; y < n; ++y){\n            if (temp_max < a[x * n + y] * b[x * n + y]){\n                temp_max = a[x * n + y] * b[x * n + y];\n            }\n        }\n        if (fabs(temp_max - max[x]) > PRECISION){\n            err = 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "kernels",
                            "loop",
                            "reduction",
                            "combined-constructs"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "kernels_loop_reduction_min_general.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:kernels,reduction,combined-constructs,loop,V:1.0-2.7\n      LOGICAL FUNCTION test1()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT):: a, b !Data\n        REAL(8):: minimum = 1000\n        REAL(8):: temp = 1000\n        INTEGER :: errors = 0\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(a)\n        CALL RANDOM_NUMBER(b)\n\n        !$acc data copyin(a(1:LOOPCOUNT), b(1:LOOPCOUNT))\n          !$acc kernels loop reduction(min:minimum)\n          DO x = 1, LOOPCOUNT\n            minimum = min(minimum, a(x) * b(x))\n          END DO\n        !$acc end data\n\n        DO x = 1, LOOPCOUNT\n          temp = min(temp, a(x) * b(x))\n        END DO\n        IF (abs(temp - minimum) .gt. PRECISION) THEN\n          errors = errors + 1\n        END IF\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "kernels",
                            "reduction",
                            "combined-constructs",
                            "loop"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "kernels_loop_reduction_min_general.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:kernels,loop,reduction,combined-constructs,V:1.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n    real_t min = 1000.0;\n    int found = 0;\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX/10);\n        b[x] = rand() / (real_t)(RAND_MAX/10);\n    }\n    #pragma acc data copyin(a[0:n], b[0:n]) copy(min)\n    {\n        #pragma acc kernels loop reduction(min:min)\n        for (int x = 0; x < n; ++x){\n            min = fmin(a[x] * b[x], min);\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        if (fabs((a[x] * b[x]) - (min + PRECISION)) < 0){\n            err = 1;\n        }\n        if (fabs(min - (a[x] * b[x])) < PRECISION){\n            found = 1;\n        }\n    }\n    if (found == 0){\n        err = 1;\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "kernels",
                            "loop",
                            "reduction",
                            "combined-constructs"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "kernels_loop_reduction_min_loop.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:kernels,private,reduction,combined-constructs,loop,V:1.0-2.7\n      LOGICAL FUNCTION test1()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x, y !Iterators\n        REAL(8),DIMENSION(10 * LOOPCOUNT):: a, b, c !Data\n        REAL(8),DIMENSION(10):: minimum\n        REAL(8):: temp\n        INTEGER :: errors = 0\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(a)\n        CALL RANDOM_NUMBER(b)\n        c = 0\n        a = a + 1\n        b = b + 1\n\n        !$acc data copyin(a(1:10*LOOPCOUNT), b(1:10*LOOPCOUNT)) copy(c(1:10*LOOPCOUNT)) copy(minimum(1:10))\n          !$acc kernels loop gang independent private(temp)\n          DO x = 0, 9\n            temp = 1000\n            !$acc loop worker independent reduction(min:temp)\n            DO y = 1, LOOPCOUNT\n              temp = min(temp, a(x * LOOPCOUNT + y) * b(x * LOOPCOUNT + y))\n            END DO\n            minimum(x + 1) = temp\n            !$acc loop independent\n            DO y = 1, LOOPCOUNT\n              c(x * LOOPCOUNT + y) = (a(x * LOOPCOUNT + y) * b(x * LOOPCOUNT + y)) / minimum(x + 1)\n            END DO\n          END DO\n        !$acc end data\n\n        DO x = 0, 9\n          temp = 1000\n          DO y = 1, LOOPCOUNT\n            temp = min(temp, a(x * LOOPCOUNT + y) * b(x * LOOPCOUNT + y))\n          END DO\n          IF (abs(temp - minimum(x + 1)) .gt. PRECISION) THEN\n            errors = errors + 1\n            WRITE(*, *) minimum(x + 1)\n          END IF\n          DO y = 1, LOOPCOUNT\n            IF (abs(c(x * LOOPCOUNT + y) - (a(x * LOOPCOUNT + y) * b(x * LOOPCOUNT + y) / temp)) .gt. PRECISION) THEN\n              errors = errors + 1\n            END IF\n          END DO\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "kernels",
                            "private",
                            "reduction",
                            "combined-constructs",
                            "loop"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "kernels_loop_reduction_min_loop.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:kernels,loop,reduction,combined-constructs,V:1.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(10 * n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(10 * n * sizeof(real_t));\n    real_t * c = (real_t *)malloc(10 * n * sizeof(real_t));\n    real_t * minimum = (real_t *)malloc(10 * sizeof(real_t));\n    real_t temp = 0;\n\n    for (int x = 0; x < 10 * n; ++x){\n        a[x] = 1 + rand() / (real_t)(RAND_MAX/10);\n        b[x] = 1 + rand() / (real_t)(RAND_MAX/10);\n        c[x] = 0.0;\n    }\n\n    #pragma acc data copyin(a[0:10*n], b[0:10*n]) copy(c[0:10*n], minimum[0:10])\n    {\n        #pragma acc kernels loop gang private(temp)\n        for (int x = 0; x < 10; ++x){\n            temp = 1000;\n            #pragma acc loop reduction(min:temp)\n            for (int y = 0; y < n; ++y){\n                temp = fmin(a[x * n + y] * b[x * n + y], temp);\n            }\n            minimum[x] = temp;\n            #pragma acc loop\n            for (int y = 0; y < n; ++y){\n                c[x * n + y] = (a[x * n + y] * b[x * n + y]) / minimum[x];\n            }\n        }\n    }\n\n    for (int x = 0; x < 10; ++x){\n        temp = 1000;\n        for (int y = 0; y < n; ++y){\n            temp = fmin(temp, a[x * n + y] * b[x * n + y]);\n        }\n        if (fabs(temp - minimum[x]) > PRECISION){\n            err += 1;\n        }\n        for (int y = 0; y < n; ++y){\n            if (fabs(c[x * n + y] - (a[x * n + y] * b[x * n + y] / minimum[x])) > PRECISION){\n                err += 1;\n            }\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "kernels",
                            "loop",
                            "reduction",
                            "combined-constructs"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "kernels_loop_reduction_min_vector_loop.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:kernels,private,reduction,combined-constructs,loop,V:1.0-2.7\n      LOGICAL FUNCTION test1()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x, y!Iterators\n        REAL(8),DIMENSION(10*LOOPCOUNT):: a, b !Data\n        REAL(8),DIMENSION(10):: minimum\n        REAL(8):: temp = 1000\n        INTEGER :: errors = 0\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(a)\n        CALL RANDOM_NUMBER(b)\n\n        !$acc data copyin(a(1:10*LOOPCOUNT), b(1:10*LOOPCOUNT)) copy(minimum(1:10))\n          !$acc kernels loop gang private(temp)\n          DO x = 0, 9\n            temp = 1000\n            !$acc loop vector reduction(min:temp)\n            DO y = 1, LOOPCOUNT\n              temp = min(temp, a(x * LOOPCOUNT + y) * b(x * LOOPCOUNT + y))\n            END DO\n            minimum(x + 1) = temp\n          END DO\n        !$acc end data\n\n        DO x = 0, 9\n          temp = 1000\n          DO y = 1, LOOPCOUNT\n            temp = min(temp, a(x * LOOPCOUNT + y) * b(x * LOOPCOUNT + y))\n          END DO\n          IF (abs(temp - minimum(x + 1)) .gt. PRECISION) THEN\n            errors = errors + 1\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "kernels",
                            "private",
                            "reduction",
                            "combined-constructs",
                            "loop"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "kernels_loop_reduction_min_vector_loop.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:kernels,loop,reduction,combined-constructs,V:1.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(10 * n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(10 * n * sizeof(real_t));\n    real_t * min = (real_t *)malloc(10 * sizeof(real_t));\n    real_t temp = 100;\n    real_t temp_min;\n\n    for (int x = 0; x < 10 * n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX/10);\n        b[x] = rand() / (real_t)(RAND_MAX/10);\n    }\n\n    #pragma acc data copyin(a[0:10*n], b[0:10*n]) copy(min[0:10])\n    {\n        #pragma acc kernels loop gang private(temp)\n        for (int x = 0; x < 10; ++x){\n            temp = 100;\n            #pragma acc loop vector reduction(min:temp)\n            for (int y = 0; y < n; ++y){\n                temp = fmin(a[x * n + y] * b[x * n + y], temp);\n            }\n            min[x] = temp;\n        }\n    }\n    for (int x = 0; x < 10; ++x){\n        temp_min = 100;\n        for (int y = 0; y < n; ++y){\n            if (temp_min > a[x * n + y] * b[x * n + y]){\n                temp_min = a[x * n + y] * b[x * n + y];\n            }\n        }\n        if (fabs(temp_min - min[x]) > PRECISION){\n            err = 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "kernels",
                            "loop",
                            "reduction",
                            "combined-constructs"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "kernels_loop_reduction_multiply_general.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:kernels,reduction,combined-constructs,loop,V:1.0-2.7\n      LOGICAL FUNCTION test1()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT):: a, b !Data\n        INTEGER :: errors = 0\n        REAL(8) :: temp = 1\n        REAL(8) :: multiplied_total = 1\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(a)\n        CALL RANDOM_NUMBER(b)\n        a = (999.4 + a)/1000\n        b = (999.4 + b)/1000\n\n        !$acc data copyin(a(1:LOOPCOUNT))\n          !$acc kernels loop reduction(*:multiplied_total)\n          DO x = 1, LOOPCOUNT\n            multiplied_total = multiplied_total * (a(x) + b(x))\n          END DO\n        !$acc end data\n\n        DO x = 1, LOOPCOUNT\n          temp = temp * (a(x) + b(x))\n        END DO\n        IF (abs(temp - multiplied_total) .gt. ((temp / 2) + (multiplied_total / 2)) * PRECISION) THEN\n          WRITE(*, *) temp\n          WRITE(*, *) multiplied_total\n          errors = errors + 1\n        END IF\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "kernels",
                            "reduction",
                            "combined-constructs",
                            "loop"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "kernels_loop_reduction_multiply_general.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:kernels,loop,reduction,combined-constructs,V:1.0-2.7\nint test1(){\n    int err = 0;\n    int multiplicitive_n = 128;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(multiplicitive_n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(multiplicitive_n * sizeof(real_t));\n\n    real_t multiplied_total = 1.0;\n\n    for (int x = 0; x < multiplicitive_n; ++x){\n        a[x] = rand() / (real_t) RAND_MAX;\n        b[x] = rand() / (real_t) RAND_MAX;\n    }\n\n    #pragma acc data copyin(a[0:multiplicitive_n], b[0:multiplicitive_n]) copy(multiplied_total)\n    {\n        #pragma acc kernels loop reduction(*:multiplied_total)\n        for (int x = 0; x < multiplicitive_n; ++x){\n            multiplied_total *= a[x] + b[x];\n        }\n    }\n\n    for (int x = 0; x < multiplicitive_n; ++x){\n        multiplied_total /= (a[x] + b[x]);\n    }\n    if (fabs(multiplied_total - 1) > PRECISION * (2 * multiplicitive_n - 1)){\n        err = 1;\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "kernels",
                            "loop",
                            "reduction",
                            "combined-constructs"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "kernels_loop_reduction_multiply_loop.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:kernels,private,reduction,combined-constructs,loop,V:1.0-2.7\n      LOGICAL FUNCTION test1()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x, y !Iterators\n        REAL(8),DIMENSION(10*LOOPCOUNT):: a, b, c !Data\n        REAL(8),DIMENSION(10):: totals\n        REAL(8) :: temp\n        INTEGER :: errors = 0\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(a)\n        CALL RANDOM_NUMBER(b)\n        c = 0\n        a = (999.4 + a) / 2000\n        b = (999.4 + b) / 2000\n\n        !$acc data copyin(a(1:10*LOOPCOUNT), b(1:10*LOOPCOUNT)) copy(c(1:10*LOOPCOUNT), totals(1:10))\n          !$acc kernels loop gang private(temp)\n          DO x = 0, 9\n            temp = 1\n            !$acc loop worker reduction(*:temp)\n            DO y = 1, LOOPCOUNT\n              temp = temp * (a(x * LOOPCOUNT + y) + b(x * LOOPCOUNT + y))\n            END DO\n            totals(x + 1) = temp\n            !$acc loop worker\n            DO y = 1, LOOPCOUNT\n              c(x * LOOPCOUNT + y) = (a(x * LOOPCOUNT + y) + b(x * LOOPCOUNT + y)) / totals(x + 1)\n            END DO\n          END DO\n        !$acc end data\n\n        DO x = 0, 9\n          temp = 1\n          DO y = 1, LOOPCOUNT\n            temp = temp * (a(x * LOOPCOUNT + y) + b(x * LOOPCOUNT + y))\n          END DO\n          IF (abs(temp - totals(x + 1)) .gt. ((temp / 2) + (totals(x + 1) / 2)) * PRECISION) THEN\n            errors = errors + 1\n            WRITE(*, *) temp\n            WRITE(*, *) totals(x + 1)\n            WRITE(*, *) \" \"\n          END IF\n          DO y = 1, LOOPCOUNT\n            IF (abs(c(x * LOOPCOUNT + y) - ((a(x * LOOPCOUNT + y) + b(x * LOOPCOUNT + y)) / totals(x + 1))) .gt. c(x * LOOPCOUNT + y) * PRECISION) THEN\n              errors = errors + 1\n              WRITE(*, *) c(x * LOOPCOUNT + y)\n              WRITE(*, *) a(x * LOOPCOUNT + y) + b(x * LOOPCOUNT + y)\n              WRITE(*, *) \" \"\n            END IF\n          END DO\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "kernels",
                            "private",
                            "reduction",
                            "combined-constructs",
                            "loop"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "kernels_loop_reduction_multiply_loop.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:kernels,loop,reduction,combined-constructs,V:1.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(10 * n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(10 * n * sizeof(real_t));\n    real_t * c = (real_t *)malloc(10 * n * sizeof(real_t));\n    real_t * totals = (real_t *)malloc(10 * sizeof(real_t));\n    real_t temp;\n\n    for (int x = 0; x < n; ++x){\n        a[x] = (999.4 + rand() / (real_t)(RAND_MAX)) / 1000;\n        b[x] = (999.4 + rand() / (real_t)(RAND_MAX)) / 1000;\n        c[x] = 0.0;\n    }\n\n\n    #pragma acc data copyin(a[0:10*n], b[0:10*n]) copyout(c[0:10*n]) copy(totals[0:10])\n    {\n        #pragma acc kernels loop gang private(temp)\n        for (int x = 0; x < 10; ++x){\n            temp = 1;\n            #pragma acc loop worker reduction(*:temp)\n            for (int y = 0; y < n; ++y){\n                temp *= a[x * n + y] + b[x * n + y];\n            }\n            totals[x] = temp;\n            #pragma acc loop worker\n            for (int y = 0; y < n; ++y){\n                c[x * n + y] = (a[x * n + y] + b[x * n + y]) / totals[x];\n            }\n        }\n    }\n\n    for (int x = 0; x < 10; ++x){\n        temp = 1;\n        for (int y = 0; y < n; ++y){\n            temp *= a[x * n + y] + b[x * n + y];\n        }\n        if (fabs(temp - totals[x]) > (temp / 2 + totals[x] / 2) * PRECISION){\n            err += 1;\n        }\n        for (int y = 0; y < n; ++y){\n            if (fabs(c[x * n + y] - ((a[x * n + y] + b[x * n + y]) / totals[x])) > PRECISION){\n                err += 1;\n            }\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "kernels",
                            "loop",
                            "reduction",
                            "combined-constructs"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "kernels_loop_reduction_multiply_vector_loop.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:kernels,private,reduction,combined-constructs,loop,V:1.0-2.7\n      LOGICAL FUNCTION test1()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x, y !Iterators\n        REAL(8),DIMENSION(10 * LOOPCOUNT):: a, b !Data\n        REAL(8),DIMENSION(10) :: c\n        REAL(8) :: temp\n        INTEGER :: errors = 0\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(a)\n        CALL RANDOM_NUMBER(b)\n        a = (999.4 + a) / 1000\n        b = (999.4 + b) / 1000\n\n        !$acc data copyin(a(1:10*LOOPCOUNT), b(1:10*LOOPCOUNT)) copyout(c(1:10))\n          !$acc parallel loop private(temp)\n          DO x = 0, 9\n            temp = 1\n            !$acc loop vector reduction(*:temp)\n            DO y = 1, LOOPCOUNT\n              temp = temp * (a(x * LOOPCOUNT + y) + b(x * LOOPCOUNT + y))\n            END DO\n            c(x + 1) = temp\n          END DO\n        !$acc end data\n\n        DO x = 0, 9\n          temp = 1\n          DO y = 1, LOOPCOUNT\n            temp = temp * (a(x * LOOPCOUNT + y) + b(x * LOOPCOUNT + y))\n          END DO\n          IF (abs(temp - c(x + 1)) .gt. ((temp / 2) + (c(x + 1) / 2)) * PRECISION) THEN\n            errors = errors + 1\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "kernels",
                            "private",
                            "reduction",
                            "combined-constructs",
                            "loop"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "kernels_loop_reduction_multiply_vector_loop.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:kernels,loop,reduction,combined-constructs,V:1.0-2.7\nint test1(){\n    int err = 0;\n    int multiplicitive_n = 128;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(10 * multiplicitive_n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(10 * multiplicitive_n * sizeof(real_t));\n    real_t * c = (real_t *)malloc(10 * sizeof(real_t));\n    real_t temp;\n\n    for (int x = 0; x < 10 * multiplicitive_n; ++x){\n        a[x] = rand() / (real_t) RAND_MAX;\n        b[x] = rand() / (real_t) RAND_MAX;\n    }\n\n    #pragma acc data copyin(a[0:10*multiplicitive_n], b[0:10*multiplicitive_n]) copyout(c[0:10])\n    {\n        #pragma acc kernels loop private(temp)\n        for (int x = 0; x < 10; ++x){\n            temp = 1.0;\n            #pragma acc loop vector reduction(*:temp)\n            for (int y = 0; y < multiplicitive_n; ++y){\n                temp *= a[(x * multiplicitive_n) + y] + b[(x * multiplicitive_n) + y];\n            }\n            c[x] = temp;\n        }\n    }\n\n    for (int x = 0; x < 10; ++x){\n        for (int y = 0; y < multiplicitive_n; ++y){\n            c[x] /= a[(x * multiplicitive_n) + y] + b[(x * multiplicitive_n) + y];\n        }\n    }\n\n    for (int x = 0; x < 10; ++x){\n        if (fabs(c[x] - 1) > PRECISION * (4 * multiplicitive_n - 1)){\n            err = 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "kernels",
                            "loop",
                            "reduction",
                            "combined-constructs"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "kernels_loop_reduction_or_general.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:kernels,reduction,combined-constructs,loop,V:1.0-2.7\n      LOGICAL FUNCTION test1()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x !Iterators\n        LOGICAL,DIMENSION(LOOPCOUNT):: a !Data\n        LOGICAL :: results = .FALSE.\n        LOGICAL :: temp = .FALSE.\n        REAL(8) :: false_margin = exp(log(.5) / n)\n        REAL(8),DIMENSION(LOOPCOUNT):: random\n        INTEGER :: errors = 0\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(random)\n        DO x = 1, LOOPCOUNT\n          IF (random(x) > false_margin) THEN\n            a(x) = .TRUE.\n          ELSE\n            a(x) = .FALSE.\n          END IF\n        END DO\n\n        !$acc data copyin(a(1:LOOPCOUNT))\n          !$acc kernels loop reduction(.OR.:results)\n          DO x = 1, LOOPCOUNT\n            results = results .OR. a(x)\n          END DO\n        !$acc end data\n\n        DO x = 1, LOOPCOUNT\n          temp = temp .OR. a(x)\n        END DO\n        IF (temp .neqv. results) THEN\n          errors = errors + 1\n        END IF\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "kernels",
                            "reduction",
                            "combined-constructs",
                            "loop"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "kernels_loop_reduction_or_general.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:kernels,loop,reduction,combined-constructs,V:1.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    char * a = (char *)malloc(n * sizeof(char));\n    real_t false_margin = pow(exp(1), log(.5)/n);\n    char result = 0;\n    char found = 0;\n\n    for (int x = 0; x < n; ++x){\n        if(a[x] = rand() / (real_t)(RAND_MAX) > false_margin){\n            a[x] = 1;\n        }\n        else{\n            a[x] = 0;\n        }\n    }\n\n\n    #pragma acc data copyin(a[0:n])\n    {\n        #pragma acc kernels loop reduction(||:result)\n        for (int x = 0; x < n; ++x){\n            result = result || a[x];\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        if (a[x] == 1){\n            found = 1;\n        }\n    }\n    if (found != result){\n        err = 1;\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "kernels",
                            "loop",
                            "reduction",
                            "combined-constructs"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "kernels_loop_reduction_or_loop.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:kernels,private,reduction,combined-constructs,loop,V:1.0-2.7\n      LOGICAL FUNCTION test1()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x, y !Iterators\n        LOGICAL,DIMENSION(10*LOOPCOUNT):: a, a_copy !Data\n        LOGICAL,DIMENSION(10) :: results\n        LOGICAL :: temp = .FALSE.\n        REAL(8),DIMENSION(10 * LOOPCOUNT) :: random\n        REAL(8) :: false_margin = exp(log(.5) / n)\n        INTEGER :: errors = 0\n\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(random)\n\n        !Initilization\n        DO x = 1, 10 * LOOPCOUNT\n          IF (random(x) .gt. false_margin) THEN\n            a(x) = .TRUE.\n          ELSE\n            a(x) = .FALSE.\n          END IF\n          a_copy(x) = a(x)\n        END DO\n\n        DO x = 1, 10\n          results(x) = .FALSE.\n        END DO\n\n        !$acc data copy(a(1:10*LOOPCOUNT), results(1:10))\n          !$acc kernels loop gang private(temp)\n          DO x = 0, 9\n            temp = .FALSE.\n            !$acc loop worker reduction(.OR.:temp)\n            DO y = 1, LOOPCOUNT\n              temp = temp .OR. a(x * LOOPCOUNT + y)\n            END DO\n            results(x + 1) = temp\n            !$acc loop worker\n            DO y = 1, LOOPCOUNT\n              IF (results(x + 1) .eqv. .TRUE.) THEN\n                IF(a(x * LOOPCOUNT + y) .eqv. .TRUE.) THEN\n                  a(x * LOOPCOUNT + y) = .FALSE.\n                ELSE\n                  a(x * LOOPCOUNT + y) = .TRUE.\n                END IF\n              END IF\n            END DO\n          END DO\n        !$acc end data\n\n        DO x = 0, 9\n          temp = .FALSE.\n          DO y = 1, LOOPCOUNT\n            temp = temp .OR. a_copy(x * LOOPCOUNT + y)\n          END DO\n          IF (temp .neqv. results(x + 1)) THEN\n            errors = errors + 1\n          END IF\n          DO y = 1, LOOPCOUNT\n            IF (temp .eqv. .FALSE.) THEN\n              IF (a(x * LOOPCOUNT + y) .neqv. a_copy(x * LOOPCOUNT + y)) THEN\n                errors = errors + 1\n              END IF\n            ELSE\n              IF (a(x * LOOPCOUNT + y) .eqv. a_copy(x * LOOPCOUNT + y)) THEN\n                errors = errors + 1\n              END IF\n            END IF\n          END DO\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "kernels",
                            "private",
                            "reduction",
                            "combined-constructs",
                            "loop"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "kernels_loop_reduction_or_loop.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:kernels,loop,reduction,combined-constructs,V:1.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    char * a = (char *)malloc(10 * n * sizeof(char));\n    char * a_copy = (char *)malloc(10 * n * sizeof(char));\n    char * results = (char *)malloc(10 * sizeof(char));\n    char temp = 0;\n    real_t false_margin = pow(exp(1), log(.5)/n);\n\n    for (int x = 0; x < 10 * n; ++x){\n        if (rand() / (real_t)(RAND_MAX) > false_margin){\n            a[x] = 1;\n            a_copy[x] = 1;\n        }\n        else{\n            a[x] = 0;\n            a_copy[x] = 0;\n        }\n    }\n    #pragma acc data copy(a[0:10*n])\n    {\n        #pragma acc kernels loop gang private(temp)\n        for (int x = 0; x < 10; ++x){\n            temp = 0;\n            #pragma acc loop worker reduction(||:temp)\n            for (int y = 0; y < n; ++y){\n                temp = temp || a[x * n + y];\n            }\n            results[x] = temp;\n            #pragma acc loop worker\n            for (int y = 0; y < n; ++y){\n                if(results[x] == 1){\n                    if (a[x * n + y] == 1){\n                        a[x * n + y] = 0;\n                    }\n                    else{\n                        a[x * n + y] = 1;\n                    }\n                }\n            }\n        }\n    }\n    for (int x = 0; x < 10; ++x){\n        temp = 0;\n        for (int y = 0; y < n; ++y){\n            temp = temp || a_copy[x * n + y];\n        }\n        if (temp != results[x]) {\n            err += 1;\n        }\n        for (int y = 0; y < n; ++y){\n            if (temp == 1){\n                if (a[x * n + y] == a_copy[x * n + y]){\n                    err += 1;\n                }\n            }\n            else {\n                if (a[x * n + y] != a_copy[x * n + y]){\n                    err += 1;\n                }\n            }\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "kernels",
                            "loop",
                            "reduction",
                            "combined-constructs"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "kernels_loop_reduction_or_vector_loop.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:kernels,private,reduction,combined-constructs,loop,V:1.0-2.7\n      LOGICAL FUNCTION test1()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x, y !Iterators\n        LOGICAL,DIMENSION(10*LOOPCOUNT):: a !Data\n        LOGICAL,DIMENSION(10) :: b\n        LOGICAL :: temp\n        REAL(8),DIMENSION(10*LOOPCOUNT):: randoms\n        REAL(8) :: false_margin = exp(log(.5) / 2)\n        INTEGER :: errors = 0\n\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(randoms)\n\n        !Initilization\n        DO x = 1, 10 * LOOPCOUNT\n          IF (randoms(x) > false_margin) THEN\n            a(x) = .TRUE.\n          ELSE\n            a(x) = .FALSE.\n          END IF\n        END DO\n\n        !$acc data copyin(a(1:10*LOOPCOUNT)), copy(b(1:10))\n          !$acc kernels loop private(temp)\n          DO x = 0, 9\n            temp = .FALSE.\n            !$acc loop vector reduction(.OR.:temp)\n            DO y = 1, LOOPCOUNT\n              temp = temp .OR. a(x * LOOPCOUNT + y)\n            END DO\n            b(x + 1) = temp\n          END DO\n        !$acc end data\n\n        DO x = 0, 9\n          temp = .FALSE.\n          DO y = 1, LOOPCOUNT\n            temp = temp .OR. a(x * LOOPCOUNT + y)\n          END DO\n          IF (temp .neqv. b(x + 1)) THEN\n            errors = errors + 1\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "kernels",
                            "private",
                            "reduction",
                            "combined-constructs",
                            "loop"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "kernels_loop_reduction_or_vector_loop.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:kernels,loop,reduction,combined-constructs,V:1.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    char * a = (char *)malloc(10 * n * sizeof(char));\n    char * b = (char *)malloc(10 * sizeof(char));\n    real_t false_margin = pow(exp(1), log(.5)/n);\n    char temp = 0;\n    char found;\n\n    for (int x = 0; x < 10 * n; ++x){\n        if(rand() / (real_t)(RAND_MAX) > false_margin){\n            a[x] = 1;\n        }\n        else{\n            a[x] = 0;\n        }\n    }\n    #pragma acc data copyin(a[0:10*n]) copy(b[0:10])\n    {\n        #pragma acc kernels loop private(temp)\n        for (int x = 0; x < 10; ++x){\n            temp = 0;\n            #pragma acc loop vector reduction(||:temp)\n            for (int y = 0; y < n; ++y){\n                temp = temp || a[x * n + y];\n            }\n            b[x] = temp;\n        }\n    }\n    for (int x = 0; x < 10; ++x){\n        found = 0;\n        for (int y = 0; y < n; ++y){\n            if (a[x * n + y] &! 0){\n                found = 1;\n            }\n        }\n        if (found != b[x]){\n            err = 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "kernels",
                            "loop",
                            "reduction",
                            "combined-constructs"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "kernels_loop_seq.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:kernels,combined-constructs,loop,V:1.0-2.7\n      LOGICAL FUNCTION test1()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT):: a, b !Data\n        INTEGER :: errors = 0\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(a)\n        b = 0\n\n        !$acc data copyin(a(1:LOOPCOUNT)) copy(b(1:LOOPCOUNT))\n          !$acc kernels loop seq\n          DO x = 2, LOOPCOUNT\n            b(x) = b(x - 1) + a(x)\n          END DO\n        !$acc end data\n\n        DO x = 2, LOOPCOUNT\n          IF (abs(b(x) - (b(x - 1) + a(x))) .gt. PRECISION) THEN\n            errors = errors + 1\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "kernels",
                            "combined-constructs",
                            "loop"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "kernels_loop_seq.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:kernels,loop,combined-constructs,V:1.0-2.7\nint test1(){\n  int err = 0;\n  srand(SEED);\n  real_t * a = (real_t *)malloc(n * sizeof(real_t));\n  real_t * b = (real_t *)malloc(n * sizeof(real_t));\n  real_t temp = 0.0;\n\n  for (int x = 0; x < n; ++x){\n      a[x] = rand() / (real_t)(RAND_MAX / 10);\n      b[x] = 0.0;\n  }\n\n  #pragma acc data copyin(a[0:n]) copy(b[0:n])\n  {\n      #pragma acc kernels loop seq\n      for (int x = 1; x < n; ++x){\n          b[x] = b[x-1] + a[x];\n      }\n  }\n\n  for (int x = 1; x < n; ++x){\n      temp += a[x];\n      if (fabs(b[x] - temp) > PRECISION){\n          err = 1;\n      }\n  }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "kernels",
                            "loop",
                            "combined-constructs"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "kernels_loop_tile.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:kernels,reduction,combined-constructs,loop,tile,V:2.0-2.7\n      LOGICAL FUNCTION test1()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x, y, z !Iterators\n        REAL(8),DIMENSION(SMALL_LOOPCOUNT):: a, b, c !Data\n        REAL(8),DIMENSION(SMALL_LOOPCOUNT,SMALL_LOOPCOUNT)::d\n        REAL(8) :: temp\n        INTEGER :: errors = 0\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(a)\n        CALL RANDOM_NUMBER(b)\n        CALL RANDOM_NUMBER(c)\n\n        !$acc data copyin(a(1:SMALL_LOOPCOUNT), b(1:SMALL_LOOPCOUNT), c(1:SMALL_LOOPCOUNT)) copyout(d(1:SMALL_LOOPCOUNT,1:SMALL_LOOPCOUNT))\n          !$acc kernels loop tile(*, *) reduction(+:temp)\n          DO x = 1, SMALL_LOOPCOUNT\n            DO y = 1, SMALL_LOOPCOUNT\n              temp = 0\n              DO z = 1, SMALL_LOOPCOUNT\n                temp = temp + a(z) + b(z) + c(z)\n              END DO\n              d(x,y) = temp\n            END DO\n          END DO\n        !$acc end data\n\n        DO x = 1, SMALL_LOOPCOUNT\n          DO y = 1, SMALL_LOOPCOUNT\n            temp = 0\n            DO z = 1, SMALL_LOOPCOUNT\n              temp = temp + a(z) + b(z) + c(z)\n            END DO\n            IF (abs(d(x,y) - temp) .gt. PRECISION) THEN\n              errors = errors + 1\n            END IF\n          END DO\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "kernels",
                            "reduction",
                            "combined-constructs",
                            "loop",
                            "tile"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "kernels_loop_tile.c": {
                "num tests": 2,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:kernels,loop,tile,reduction,combined-constructs,V:2.0-2.7\nint test1(){\n  int err = 0;\n  srand(SEED);\n  real_t * a = (real_t *)malloc(n * sizeof(real_t));\n  real_t * b = (real_t *)malloc(n * sizeof(real_t));\n  real_t * c = (real_t *)malloc(n * sizeof(real_t));\n  real_t * d2 = (real_t *)malloc(n * n * sizeof(real_t));\n  real_t * d3 = (real_t *)malloc(n * n * n * sizeof(real_t));\n  real_t temp = 0.0;\n\n  for (int x = 0; x < n; ++x){\n      a[x] = rand() / (real_t)(RAND_MAX / 10);\n      b[x] = rand() / (real_t)(RAND_MAX / 10);\n      c[x] = rand() / (real_t)(RAND_MAX / 10);\n  }\n  #pragma acc data copy(a[0:n], b[0:n], c[0:n], d2[0:n*n])\n  {\n      #pragma acc kernels loop tile(*, *) reduction(+:temp)\n      for (int x = 0; x < n; ++x){\n          for (int y = 0; y < n; ++y){\n              temp = 0;\n              for (int z = 0; z < n; ++z){\n                  temp += a[x] + b[y] + c[z];\n              }\n              d2[x * n + y] = temp;\n          }\n      }\n  }\n  for (int x = 0; x < n; ++x){\n      for (int y = 0; y < n; ++y){\n          temp = 0.0;\n          for (int z = 0; z < n; ++z){\n              temp += a[x] + b[y] + c[z];\n          }\n          if (fabs(temp - d2[x * n + y]) > PRECISION * n){\n              err += 1;\n          }\n      }\n  }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "kernels",
                            "loop",
                            "tile",
                            "reduction",
                            "combined-constructs"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "2": {
                        "content": "#ifndef T2\n//T2:kernels,loop,tile,combined-constructs,V:2.0-2.7\nint test2(){\n  int err = 0;\n  srand(SEED);\n  real_t * a = (real_t *)malloc(n * sizeof(real_t));\n  real_t * b = (real_t *)malloc(n * sizeof(real_t));\n  real_t * c = (real_t *)malloc(n * sizeof(real_t));\n  real_t * d2 = (real_t *)malloc(n * n * sizeof(real_t));\n  real_t * d3 = (real_t *)malloc(n * n * n * sizeof(real_t));\n  real_t temp = 0.0;\n\n  for (int x = 0; x < n; ++x){\n      a[x] = rand() / (real_t)(RAND_MAX / 10);\n      b[x] = rand() / (real_t)(RAND_MAX / 10);\n      c[x] = rand() / (real_t)(RAND_MAX / 10);\n  }\n\n  #pragma acc data copyin(a[0:n], b[0:n], c[0:n]) copyout(d3[0:n*n*n])\n  {\n      #pragma acc kernels loop tile(n/10, n, n*2)\n      for (int x = 0; x < n; ++x){\n          for (int y = 0; y < n; ++y){\n              for (int z = 0; z < n; ++z){\n                  d3[(n * n * x) + (n * y) + z] = a[x] + b[x] + c[x];\n              }\n          }\n      }\n  }\n\n  for (int x = 0; x < n; ++x){\n      for (int y = 0; y < n; ++y){\n          for (int z = 0; z < n; ++z){\n              if (fabs(d3[(n * n * x) + (n * y) + z] - a[x] - b[x] - c[x]) > PRECISION * 2){\n                  err = 1;\n              }\n          }\n      }\n  }\n\n    return err;\n}\n#endif\n#ifndef T2\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test2();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 1);\n    }\n#endif\n",
                        "tags": [
                            "kernels",
                            "loop",
                            "tile",
                            "combined-constructs"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "kernels_loop_vector_blocking.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:kernels,loop,V:1.0-2.7\n      LOGICAL FUNCTION test1()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT):: a, b, c !Data\n        REAL(8) :: multiplier\n        INTEGER :: errors = 0\n\n        multiplier = 1\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(a)\n        CALL RANDOM_NUMBER(b)\n        c = 0\n\n        !$acc data copyin(a(1:LOOPCOUNT), b(1:LOOPCOUNT)) copyout(c(1:LOOPCOUNT))\n          !$acc kernels\n            !$acc loop vector\n            DO x = 1, LOOPCOUNT\n              c(x) = (a(x) + b(x)) * multiplier\n            END DO\n            multiplier = multiplier + 1\n            !$acc loop vector\n            DO x = 1, LOOPCOUNT\n              c(x) = c(x) + ((a(x) + b(x)) * multiplier)\n            END DO\n          !$acc end kernels\n        !$acc end data\n\n        DO x = 1, LOOPCOUNT\n          IF (abs(c(x) - (3 * (a(x) + b(x)))) .gt. PRECISION) THEN\n            errors = errors + 1\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "kernels",
                            "loop"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "kernels_loop_vector_blocking.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:kernels,loop,V:1.0-2.7\nint test1(){\n  int err = 0;\n  srand(SEED);\n  real_t * a = (real_t *)malloc(n * sizeof(real_t));\n  real_t * b = (real_t *)malloc(n * sizeof(real_t));\n  real_t * c = (real_t *)malloc(n * sizeof(real_t));\n  real_t multiplyer = 1;\n\n  for (int x = 0; x < n; ++x){\n      a[x] = rand() / (real_t)(RAND_MAX / 10);\n      b[x] = rand() / (real_t)(RAND_MAX / 10);\n      c[x] = 0.0;\n  }\n\n  #pragma acc data copyin(a[0:n], b[0:n]) copyout(c[0:n])\n  {\n    #pragma acc kernels\n    {\n      #pragma acc loop vector\n      for (int x = 0; x < n; ++x){\n        c[x] = (a[x] + b[x]) * multiplyer;\n      }\n      multiplyer += 1;\n      #pragma acc loop vector\n      for (int x = 0; x < n; ++x){\n        c[x] += (a[x] + b[x]) * multiplyer;\n      }\n    }\n  }\n\n  for (int x = 0; x < n; ++x){\n    if (fabs(c[x] - 3 * (a[x] + b[x])) > PRECISION){\n      err + 1;\n      break;\n    }\n  }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "kernels",
                            "loop"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "kernels_loop_worker_blocking.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:kernels,loop,V:1.0-2.7\n      LOGICAL FUNCTION test1()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT):: a, b, c !Data\n        REAL(8) :: RAND\n        REAL(8) :: multiplier\n        INTEGER :: errors = 0\n\n        multiplier = 1\n\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(a)\n        CALL RANDOM_NUMBER(b)\n        c = 0\n\n        !$acc data copyin(a(1:LOOPCOUNT), b(1:LOOPCOUNT)) copyout(c(1:LOOPCOUNT))\n          !$acc kernels\n            !$acc loop worker\n            DO x = 1, LOOPCOUNT\n              c(x) = (a(x) + b(x)) * multiplier\n            END DO\n            multiplier = multiplier + 1\n            !$acc loop worker\n            DO x = 1, LOOPCOUNT\n              c(x) = c(x) + (a(x) + b(x)) * multiplier\n            END DO\n          !$acc end kernels\n        !$acc end data\n\n        DO x = 1, LOOPCOUNT\n          IF (abs(c(x) - (3 * (a(x) + b(x)))) .gt. PRECISION) THEN\n            errors = errors + 1\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "kernels",
                            "loop"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "kernels_loop_worker_blocking.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:kernels,loop,V:1.0-2.7\nint test1(){\n  int err = 0;\n  srand(SEED);\n  real_t * a = (real_t *)malloc(n * sizeof(real_t));\n  real_t * b = (real_t *)malloc(n * sizeof(real_t));\n  real_t * c = (real_t *)malloc(n * sizeof(real_t));\n  real_t multiplyer = 1;\n\n  for (int x = 0; x < n; ++x){\n      a[x] = rand() / (real_t)(RAND_MAX / 10);\n      b[x] = rand() / (real_t)(RAND_MAX / 10);\n      c[x] = 0.0;\n  }\n\n  #pragma acc data copyin(a[0:n], b[0:n]) copyout(c[0:n])\n  {\n    #pragma acc kernels\n    {\n      #pragma acc loop worker\n      for (int x = 0; x < n; ++x){\n        c[x] = (a[x] + b[x]) * multiplyer;\n      }\n      multiplyer += 1;\n      #pragma acc loop worker\n      for (int x = 0; x < n; ++x){\n        c[x] += (a[x] + b[x]) * multiplyer;\n      }\n    }\n  }\n\n  for (int x = 0; x < n; ++x){\n    if (fabs(c[x] - 3 * (a[x] + b[x])) > PRECISION){\n      err + 1;\n      break;\n    }\n  }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "kernels",
                            "loop"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "kernels_num_gangs.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:kernels,reduction,V:2.5-2.7\n      LOGICAL FUNCTION test1()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x !Iterators\n        INTEGER :: results !Data\n        INTEGER :: errors = 0\n\n        results = 0\n\n        !$acc kernels num_gangs(8)\n          !$acc loop gang reduction(+:results)\n          DO x = 1, LOOPCOUNT\n            results = 1\n          END DO\n        !$acc end kernels\n          \n        IF (results .ne. 8) THEN\n          errors = errors + 1\n        END IF\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "kernels",
                            "reduction"
                        ],
                        "versions": [
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "kernels_num_gangs.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:kernels,loop,V:2.5-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t * restrict a = (real_t *)malloc(n * sizeof(real_t));\n    real_t * restrict b = (real_t *)malloc(n * sizeof(real_t));\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = 0;\n    }\n\n    #pragma acc data copyin(a[0:n]) copyout(b[0:n])\n    {\n        #pragma acc kernels loop num_gangs(16)\n        for (int x = 0; x < n; ++x){\n            b[x] = a[x];\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        if (fabs(a[x] - b[x]) > PRECISION){\n            err += 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "kernels",
                            "loop"
                        ],
                        "versions": [
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "kernels_num_workers.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:kernels,V:2.5-2.7\n      LOGICAL FUNCTION test1()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT):: a, b !Data\n        INTEGER :: errors = 0\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(a)\n        b = 0\n\n        !$acc data copyin(a(1:LOOPCOUNT)) copyout(b(1:LOOPCOUNT))\n          !$acc kernels loop num_workers(16)\n          DO x = 1, LOOPCOUNT\n            b(x) = a(x)\n          END DO\n          !$acc end kernels\n        !$acc end data\n\n        DO x = 1, LOOPCOUNT\n          IF (abs(a(x) - b(x)) .gt. PRECISION) THEN\n            errors = errors + 1\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "kernels"
                        ],
                        "versions": [
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "kernels_num_workers.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:kernels,loop,V:2.5-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t * restrict a = (real_t *)malloc(n * sizeof(real_t));\n    real_t * restrict b = (real_t *)malloc(n * sizeof(real_t));\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = 0;\n    }\n\n    #pragma acc data copyin(a[0:n]) copyout(b[0:n])\n    {\n        #pragma acc kernels loop num_workers(16)\n        for (int x = 0; x < n; ++x){\n            b[x] = a[x];\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        if (fabs(a[x] - b[x]) > PRECISION){\n            err += 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "kernels",
                            "loop"
                        ],
                        "versions": [
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "kernels_present.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:kernels,V:2.0-2.7\n      LOGICAL FUNCTION test1()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT):: a, b !Data\n        INTEGER :: errors = 0\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(a)\n        b = 0\n\n        !$acc enter data copyin(a(1:LOOPCOUNT)) create(b(1:LOOPCOUNT))\n        !$acc kernels present(a(1:LOOPCOUNT), b(1:LOOPCOUNT))\n          !$acc loop\n          DO x = 1, LOOPCOUNT\n            b(x) = a(x)\n          END DO\n        !$acc end kernels\n        !$acc exit data delete(a(1:LOOPCOUNT)) copyout(b(1:LOOPCOUNT))\n\n        DO x = 1, LOOPCOUNT\n          IF (abs(a(x) - b(x)) .gt. PRECISION) THEN\n            errors = errors + 1\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "kernels"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "kernels_present.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:kernels,data,structured-data,V:2.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = 0.0;\n    }\n\n    #pragma acc enter data copyin(a[0:n]) create(b[0:n])\n    #pragma acc kernels present(a[0:n], b[0:n])\n    {\n        #pragma acc loop\n        for (int x = 0; x < n; ++x){\n            b[x] = a[x];\n        }\n    }\n    #pragma acc exit data copyout(b[0:n]) delete(a[0:n])\n\n    for (int x = 0; x < n; ++x){\n        if (fabs(b[x] - a[x]) > PRECISION){\n            err += 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "kernels",
                            "data",
                            "structured-data"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "kernels_scalar_default_copy.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:kernels,V:2.5-2.7\n      LOGICAL FUNCTION test1()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT):: a, b !Data\n        INTEGER :: errors = 0\n        REAL(8) :: total = 0.0\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(a)\n        CALL RANDOM_NUMBER(b)\n\n        DO x = 1, LOOPCOUNT\n          total = total + a(x)\n        END DO\n        !$acc data copyin(b(1:LOOPCOUNT))\n          !$acc kernels num_gangs(1) vector_length(1)\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              total = total + b(x)\n            END DO\n          !$acc end kernels\n        !$acc end data\n\n        DO x = 1, LOOPCOUNT\n          total = total - (a(x) + b(x))\n        END DO\n        IF (abs(total) .gt. (2 * LOOPCOUNT - 2) * PRECISION) THEN\n          errors = errors + 1\n        END IF\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "kernels"
                        ],
                        "versions": [
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "kernels_scalar_default_copy.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:kernels,data,data-region,default-mapping,V:2.5-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n    real_t sum = 0.0;\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n    }\n\n    for (int x = 0; x < n; ++x){\n        sum = sum + a[x];\n    }\n\n    #pragma acc data copyin(b[0:n])\n    {\n        #pragma acc kernels num_gangs(1) vector_length(1)\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                sum = sum + b[x];\n            }\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        sum = sum - (a[x] + b[x]);\n    }\n\n    if (fabs(sum) > (2 * n - 2) * PRECISION){\n        err += 1;\n        sum = 0.0;\n        for (int x = 0; x < n; ++x){\n            sum = sum + a[x];\n        }\n        sum = 0.0;\n        for (int x = 0; x < n; ++x){\n            sum = sum + b[x];\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "kernels",
                            "data",
                            "data-region",
                            "default-mapping"
                        ],
                        "versions": [
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "kernels_vector_length.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:kernels,V:2.5-2.7\n      LOGICAL FUNCTION test1()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT):: a, b !Data\n        INTEGER :: errors = 0\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(a)\n        b = 0\n\n        !$acc data copyin(a(1:LOOPCOUNT)) copyout(b(1:LOOPCOUNT))\n          !$acc kernels vector_length(16)\n            !$acc loop vector\n            DO x = 1, LOOPCOUNT\n              b(x) = a(x)\n            END DO\n          !$acc end kernels\n        !$acc end data\n\n        DO x = 1, LOOPCOUNT\n          IF (abs(a(x) - b(x)) .gt. PRECISION) THEN\n            errors = errors + 1\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "kernels"
                        ],
                        "versions": [
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "kernels_vector_length.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:kernels,V:2.5-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = 0;\n    }\n\n    #pragma acc data copyin(a[0:n]) copyout(b[0:n])\n    {\n        #pragma acc kernels vector_length(16)\n        {\n            #pragma acc loop vector\n            for (int x = 0; x < n; ++x){\n                b[x] = a[x];\n            }\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        if (fabs(a[x] - b[x]) > PRECISION) {\n            err += 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "kernels"
                        ],
                        "versions": [
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "kernels_wait.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:async,kernels,V:2.0-2.7\n      LOGICAL FUNCTION test1()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT):: a, b, c !Data\n        INTEGER :: errors = 0\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(a)\n        CALL RANDOM_NUMBER(b)\n        c = 0\n\n        !$acc enter data copyin(a(1:LOOPCOUNT), b(1:LOOPCOUNT), c(1:LOOPCOUNT)) async(1)\n        !$acc kernels wait(1)\n          !$acc loop\n          DO x = 1, LOOPCOUNT\n            c(x) = a(x) + b(x)\n          END DO\n        !$acc end kernels\n        !$acc exit data copyout(c(1:LOOPCOUNT)) delete(a(1:LOOPCOUNT), b(1:LOOPCOUNT))\n\n        DO x = 1, LOOPCOUNT\n          IF (abs(c(x) - (a(x) + b(x))) .gt. PRECISION) THEN\n            errors = errors + 1\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "async",
                            "kernels"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "kernels_wait.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:kernels,wait,V:2.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n    real_t * c = (real_t *)malloc(n * sizeof(real_t));\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n        c[x] = 0.0;\n    }\n\n    #pragma acc enter data copyin(a[0:n], b[0:n], c[0:n]) async(1)\n    #pragma acc kernels wait(1)\n    {\n        #pragma acc loop\n        for (int x = 0; x < n; ++x){\n            c[x] += a[x] + b[x];\n        }\n    }\n\n    #pragma acc exit data copyout(c[0:n]) delete(a[0:n], b[0:n])\n\n    for (int x = 0; x < n; ++x){\n        if (fabs(c[x] - (a[x] + b[x])) > PRECISION) {\n            err += 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "kernels",
                            "wait"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "loop_collapse.F90": {
                "num tests": 2,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:construct-independent,loop,V:1.0-2.7\n      LOGICAL FUNCTION test1()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x, y !Iterators\n        REAL(8),DIMENSION(10*LOOPCOUNT):: a, b, c !Data\n        REAL(8):: total\n        INTEGER :: errors = 0\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(a)\n        CALL RANDOM_NUMBER(b)\n        c = 0\n\n        DO x = 0, 9\n          c(x*LOOPCOUNT + 1) = a(x*LOOPCOUNT + 1) + b(x*LOOPCOUNT + 1)\n        END DO\n\n        !$acc data copyin(a(1:10*LOOPCOUNT), b(1:10*LOOPCOUNT)) copy(c(1:10*LOOPCOUNT))\n          !$acc parallel\n            !$acc loop independent\n            DO x = 0, 9\n              DO y = 2, LOOPCOUNT\n                c(x*LOOPCOUNT + y) = c(x*LOOPCOUNT + y - 1) + a(x*LOOPCOUNT + y) + b(x*LOOPCOUNT + y)\n              END DO\n            END DO\n          !$acc end parallel\n        !$acc end data\n        DO x = 0, 9\n          total = 0\n          DO y = 1, LOOPCOUNT\n            total = total + a(x * LOOPCOUNT + y) + b(x * LOOPCOUNT + y)\n            IF (abs(total - c(x * LOOPCOUNT + y)) .gt. PRECISION) THEN\n              errors = errors + 1\n            END IF\n          END DO\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "construct-independent",
                            "loop"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "2": {
                        "content": "#ifndef T2\n!T2:construct-independent,loop,V:1.0-2.7\n      LOGICAL FUNCTION test2()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x, y !Iterators\n        REAL(8),DIMENSION(10*LOOPCOUNT):: a, b, c !Data\n        REAL(8):: total\n        INTEGER :: errors = 0\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(a)\n        CALL RANDOM_NUMBER(b)\n        c = 0\n\n        !$acc data copyin(a(1:10*LOOPCOUNT), b(1:10*LOOPCOUNT)) copyout(c(1:10*LOOPCOUNT))\n          !$acc parallel\n            !$acc loop independent collapse(2)\n            DO x = 0, 9\n              DO y = 1, LOOPCOUNT\n                c(x*LOOPCOUNT + y) = a(x*LOOPCOUNT + y) + b(x*LOOPCOUNT + y)\n              END DO\n            END DO\n          !$acc end parallel\n        !$acc end data\n\n        DO x = 0, 9\n          DO y = 1, LOOPCOUNT\n            IF (abs(c(x*LOOPCOUNT+y) - (a(x*LOOPCOUNT+y)+b(x*LOOPCOUNT+y))) .gt. PRECISION) THEN\n              errors = errors + 1\n            END IF\n          END DO\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test2 = .FALSE.\n        ELSE\n          test2 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T2\n        LOGICAL :: test2\n#endif\n#ifndef T2\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test2()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 1\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "construct-independent",
                            "loop"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "loop_collapse.c": {
                "num tests": 2,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:loop,construct-independent,V:1.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(10 * n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(10 * n * sizeof(real_t));\n    real_t * c = (real_t *)malloc(10 * n * sizeof(real_t));\n\n    for (int x = 0; x < 10 * n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n        c[x] = 0;\n    }\n    for (int x = 0; x < 10; ++x){\n        c[x * n] = a[x * n] + b[x * n];\n    }\n\n    #pragma acc data copyin(a[0:10*n], b[0:10*n]) copy(c[0:10*n])\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop independent collapse(1)\n            for (int x = 0; x < 10; ++x){\n                for (int y = 1; y < n; ++y){\n                    c[x * n + y] = c[x * n + y - 1] + a[x * n + y] + b[x * n + y];\n                }\n            }\n        }\n    }\n\n    real_t total;\n    for (int x = 0; x < 10; ++x){\n        total = 0;\n        for (int y = 0; y < n; ++y){\n            total += a[x * n + y] + b[x * n + y];\n            if (fabs(c[x * n + y] - total) > PRECISION){\n                err += 1;\n            }\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "loop",
                            "construct-independent"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "2": {
                        "content": "#ifndef T2\n//T2:loop,syntactic,construct-independent,V:1.0-2.7\nint test2(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(10 * n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(10 * n * sizeof(real_t));\n    real_t * c = (real_t *)malloc(10 * n * sizeof(real_t));\n\n    for (int x = 0; x < 10 * n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n        c[x] = 0.0;\n    }\n\n    #pragma acc data copyin(a[0:10*n], b[0:10*n]) copyout(c[0:10*n])\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop independent collapse(2)\n            for (int x = 0; x < 10; ++x){\n                for (int y = 0; y < n; ++y){\n                    c[x * n + y] = a[x * n + y] + b[x * n + y];\n                }\n            }\n        }\n    }\n\n    for (int x = 0; x < 10 * n; ++x){\n        if (fabs(c[x] - (a[x] + b[x])) > PRECISION){\n            err += 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T2\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test2();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 1);\n    }\n#endif\n",
                        "tags": [
                            "loop",
                            "syntactic",
                            "construct-independent"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "loop_no_collapse.F90": {
                "num tests": 2,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:construct-independent,loop,V:1.0-2.7\n      LOGICAL FUNCTION test1()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x, y !Iterators\n        REAL(8),DIMENSION(10 * LOOPCOUNT):: a, b, c !Data\n        REAL(8):: total\n        INTEGER :: errors = 0\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(a)\n        CALL RANDOM_NUMBER(b)\n        c = 0\n\n        DO x = 0, 9\n          c(x * LOOPCOUNT + 1) = a(x * LOOPCOUNT + 1) + b(x * LOOPCOUNT + 1)\n        END DO\n\n        !$acc data copyin(a(1:10*LOOPCOUNT), b(1:10*LOOPCOUNT)) copy(c(1:10*LOOPCOUNT))\n          !$acc parallel\n            !$acc loop independent\n            DO x = 0, 9\n              DO y = 2, LOOPCOUNT\n                c(x * LOOPCOUNT + y) = c(x * LOOPCOUNT + y - 1) + a(x * LOOPCOUNT + y) + b(x * LOOPCOUNT + y)\n              END DO\n            END DO\n          !$acc end parallel\n        !$acc end data\n\n        DO x = 0, 9\n          total = 0\n          DO y = 1, LOOPCOUNT\n            total = total + a(x * LOOPCOUNT + y) + b(x * LOOPCOUNT + y)\n            IF (abs(total - c(x * LOOPCOUNT + y)) .gt. PRECISION) THEN\n              errors = errors + 1\n            END IF\n          END DO\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "construct-independent",
                            "loop"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "2": {
                        "content": "#ifndef T2\n!T2:construct-independent,loop,V:1.0-2.7\n      LOGICAL FUNCTION test2()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x, y !Iterators\n        REAL(8),DIMENSION(10 * LOOPCOUNT):: a, b, c !Data\n        REAL(8):: total\n        INTEGER :: errors = 0\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(a)\n        CALL RANDOM_NUMBER(b)\n        c = 0\n\n        DO x = 0, 9\n          c(x * LOOPCOUNT + 1) = a(x * LOOPCOUNT + 1) + b(x * LOOPCOUNT + 1)\n        END DO\n\n        !$acc data copyin(a(1:10*LOOPCOUNT), b(1:10*LOOPCOUNT)) copy(c(1:10*LOOPCOUNT))\n          !$acc kernels\n            !$acc loop independent\n            DO x = 0, 9\n              DO y = 2, LOOPCOUNT\n                c(x * LOOPCOUNT + y) = c(x * LOOPCOUNT + y - 1) + a(x * LOOPCOUNT + y) + b(x * LOOPCOUNT + y)\n              END DO\n            END DO\n          !$acc end kernels\n        !$acc end data\n\n        DO x = 0, 9\n          total = 0\n          DO y = 1, LOOPCOUNT\n            total = total + a(x * LOOPCOUNT + y) + b(x * LOOPCOUNT + y)\n            IF (abs(total - c(x * LOOPCOUNT + y)) .gt. PRECISION) THEN\n              errors = errors + 1\n            END IF\n          END DO\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test2 = .FALSE.\n        ELSE\n          test2 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T2\n        LOGICAL :: test2\n#endif\n#ifndef T2\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test2()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 1\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "construct-independent",
                            "loop"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "loop_no_collapse_default.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:loop,construct-independent,V:1.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(10 * n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(10 * n * sizeof(real_t));\n    real_t * c = (real_t *)malloc(10 * n * sizeof(real_t));\n    real_t total = 0;\n\n    for (int x = 0; x < 10 * n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n    }\n    for (int x = 0; x < 10; ++x){\n        c[x * n] = a[x * n] + b[x * n];\n    }\n\n    #pragma acc data copyin(a[0:10*n], b[0:10*n]) copy(c[0:10*n])\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop independent\n            for (int x = 0; x < 10; ++x){\n                for (int y = 1; y < n; ++y){\n                    c[x * n + y] = c[x * n + y - 1] + a[x * n + y] + b[x * n + y];\n                }\n            }\n        }\n    }\n    for (int x = 0; x < 10; ++x){\n        total = 0;\n        for (int y = 0; y < n; ++y){\n            total += a[x * n + y] + b[x * n +y];\n            if (fabs(total - c[x * n + y]) > PRECISION * y){\n                err += 1;\n            }\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "loop",
                            "construct-independent"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "parallel.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:parallel,V:1.0-2.7\n      LOGICAL FUNCTION test1()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x, i_a, i_b, i_c, i_d, i_e, i_f, i_g, i_h, i_i, i_j !Iterators\n        INTEGER, PARAMETER :: PRIVATE_LOOPCOUNT = 1024\n        REAL(8),DIMENSION(PRIVATE_LOOPCOUNT):: a, b, c !Data\n        INTEGER :: errors\n        errors = 0\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(a)\n        CALL RANDOM_NUMBER(b)\n        c = 0\n\n        !$acc data copyin(a(1:PRIVATE_LOOPCOUNT), b(1:PRIVATE_LOOPCOUNT)) copy(c(1:PRIVATE_LOOPCOUNT))\n          !$acc parallel\n            !$acc loop\n            DO i_a = 0, 1\n              !$acc loop\n              DO i_b = 0, 1\n                !$acc loop\n                DO i_c = 0, 1\n                  !$acc loop\n                  DO i_d = 0, 1\n                    !$acc loop\n                    DO i_e = 0, 1\n                      !$acc loop\n                      DO i_f = 0, 1\n                        !$acc loop\n                        DO i_g = 0, 1\n                          !$acc loop\n                          DO i_h = 0, 1\n                            !$acc loop\n                            DO i_i = 0, 1\n                              !$acc loop\n                              DO i_j = 0, 1\n                                c(i_a*512 + i_b*256 + i_c*128 + i_d*64 + i_e*32 + i_f*16 + i_g*8 + i_h*4 + i_i*2 + i_j + 1) = &\n                                a(i_a*512 + i_b*256 + i_c*128 + i_d*64 + i_e*32 + i_f*16 + i_g*8 + i_h*4 + i_i*2 + i_j + 1) + &\n                                b(i_a*512 + i_b*256 + i_c*128 + i_d*64 + i_e*32 + i_f*16 + i_g*8 + i_h*4 + i_i*2 + i_j + 1)\n                              END DO\n                            END DO\n                          END DO\n                        END DO\n                      END DO\n                    END DO\n                  END DO\n                END DO\n              END DO\n            END DO\n          !$acc end parallel\n        !$acc end data\n        DO x = 1, PRIVATE_LOOPCOUNT\n          IF (abs(c(x) - (a(x) + b(x))) .gt. PRECISION) THEN\n            errors = errors + 1\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "parallel"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "parallel.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:parallel,V:1.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t* a = (real_t *) malloc(1024 * sizeof(real_t));\n    real_t* b = (real_t *) malloc(1024 * sizeof(real_t));\n    real_t* c = (real_t *) malloc(1024 * sizeof(real_t));\n\n    for(int x = 0; x < 1024; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n        c[x] = 0.0;\n    }\n\n    #pragma acc data copyin(a[0:1024], b[0:1024]) copy(c[0:1024])\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int _0 = 0; _0 < 2; ++_0){\n                #pragma acc loop\n                for (int _1 = 0; _1 < 2; ++_1){\n                    #pragma acc loop\n                    for (int _2 = 0; _2 < 2; ++_2){\n                        #pragma acc loop\n                        for (int _3 = 0; _3 < 2; ++_3){\n                            #pragma acc loop\n                            for (int _4 = 0; _4 < 2; ++_4){\n                                #pragma acc loop\n                                for (int _5 = 0; _5 < 2; ++_5){\n                                    #pragma acc loop\n                                    for (int _6 = 0; _6 < 2; ++_6){\n                                        #pragma acc loop\n                                        for (int _7 = 0; _7 < 2; ++_7){\n                                            #pragma acc loop\n                                            for (int _8 = 0; _8 < 2; ++_8){\n                                                #pragma acc loop\n                                                for (int _9 = 0; _9 < 2; ++_9){\n                                                    c[_0*512 + _1*256 + _2*128 + _3*64 + _4*32 + _5*16 + _6*8+ _7*4 + _8*2 + _9] =\n                                                    a[_0*512 + _1*256 + _2*128 + _3*64 + _4*32 + _5*16 + _6*8+ _7*4 + _8*2 + _9] +\n                                                    b[_0*512 + _1*256 + _2*128 + _3*64 + _4*32 + _5*16 + _6*8+ _7*4 + _8*2 + _9];\n                                                }\n                                            }\n                                        }\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    for (int x = 0; x < 1024; ++x){\n        if(fabs(c[x] - (a[x] +b[x])) > PRECISION){\n            err = 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "parallel"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "parallel_async.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:async,parallel,update,V:2.0-2.7\n      LOGICAL FUNCTION test1()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x, y, z !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT):: a, b, c, d, e, f, g !Data\n        INTEGER :: errors = 0\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(a)\n        CALL RANDOM_NUMBER(b)\n        c = 0\n        CALL RANDOM_NUMBER(d)\n        CALL RANDOM_NUMBER(e)\n        f = 0\n        g = 0\n        \n        !$acc data copyin(a(1:LOOPCOUNT), b(1:LOOPCOUNT), d(1:LOOPCOUNT), e(1:LOOPCOUNT), c(1:LOOPCOUNT), f(1:LOOPCOUNT), g(1:LOOPCOUNT))\n          !$acc parallel async(1)\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              c(x) = a(x) + b(x)\n            END DO\n          !$acc end parallel\n          !$acc parallel async(2)\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              f(x) = d(x) + e(x)\n            END DO\n          !$acc end parallel\n          !$acc update host(c(1:LOOPCOUNT)) wait(1) async(4)\n          !$acc update host(f(1:LOOPCOUNT)) wait(2) async(5)\n          !$acc parallel wait(1, 2) async(3)\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              g(x) = c(x) + f(x)\n            END DO\n          !$acc end parallel\n          !$acc update host(g(1:LOOPCOUNT)) async(3)\n        !$acc end data\n        !$acc wait\n        DO x = 1, LOOPCOUNT\n          IF (abs(c(x) - (a(x) + b(x))) .gt. PRECISION) THEN\n            errors = errors + 1\n          ELSE IF (abs(f(x) - (d(x) + e(x))) .gt. PRECISION) THEN\n            errors = errors + 1\n          ELSE IF (abs(g(x) - (f(x) + c(x))) .gt. PRECISION) THEN\n            errors = errors + 1\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "async",
                            "parallel",
                            "update"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "parallel_async.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:parallel,async,wait,V:2.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n    real_t * c = (real_t *)malloc(n * sizeof(real_t));\n    real_t * d = (real_t *)malloc(n * sizeof(real_t));\n    real_t * e = (real_t *)malloc(n * sizeof(real_t));\n    real_t * f = (real_t *)malloc(n * sizeof(real_t));\n    real_t * g = (real_t *)malloc(n * sizeof(real_t));\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n        c[x] = 0.0;\n        d[x] = rand() / (real_t)(RAND_MAX / 10);\n        e[x] = rand() / (real_t)(RAND_MAX / 10);\n        f[x] = 0.0;\n        g[x] = 0.0;\n    }\n\n    #pragma acc data copyin(a[0:n], b[0:n], d[0:n], e[0:n], c[0:n], f[0:n], g[0:n])\n    {\n        #pragma acc parallel async(1)\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                c[x] = a[x] + b[x];\n            }\n        }\n        #pragma acc parallel async(2)\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                f[x] = d[x] + e[x];\n            }\n        }\n        #pragma acc parallel wait(1, 2) async(3)\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                g[x] = c[x] + f[x];\n            }\n        }\n        #pragma acc update host(c[0:n]) async(1)\n        #pragma acc update host(f[0:n]) async(2)\n        #pragma acc update host(g[0:n]) async(3)\n\n        #pragma acc wait(1)\n        for (int x = 0; x < n; ++x){\n            if (fabs(c[x] - (a[x] + b[x])) > PRECISION){\n                err += 1;\n            }\n        }\n        #pragma acc wait(2)\n        for (int x = 0; x < n; ++x){\n            if (fabs(f[x] - (d[x] + e[x])) > PRECISION){\n                err += 1;\n            }\n        }\n        #pragma acc wait(3)\n        for (int x = 0; x < n; ++x){\n            if (fabs(g[x] - (a[x] + b[x] + d[x] + e[x])) > PRECISION){\n                err += 1;\n            }\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "parallel",
                            "async",
                            "wait"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "parallel_copy.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:parallel,V:1.0-2.7\n      LOGICAL FUNCTION test1()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT):: a, a_host !Data\n        INTEGER :: errors = 0\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(a)\n        a_host = a\n\n        !$acc parallel copy(a(1:LOOPCOUNT))\n          !$acc loop\n          DO x = 1, LOOPCOUNT\n            a(x) = 2 * a(x)\n          END DO \n        !$acc end parallel\n    \n\n        DO x = 1, LOOPCOUNT\n          IF (abs(a_host(x) - (a(x) / 2)) .gt. PRECISION) THEN\n            errors = errors + 1\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "parallel"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "parallel_copy.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:parallel,data,data-region,V:1.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(n * sizeof(real_t));\n    real_t * a_host = (real_t *)malloc(n * sizeof(real_t));\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        a_host[x] = a[x];\n    }\n\n    #pragma acc parallel copy(a[0:n])\n    {\n        #pragma acc loop\n        for (int x = 0; x < n; ++x){\n            a[x] = 2 * a[x];\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        if (fabs(a[x] - (2 * a_host[x])) > PRECISION){\n            err = 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "parallel",
                            "data",
                            "data-region"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "parallel_copyin.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:parallel,V:2.0-2.7\n      LOGICAL FUNCTION test1()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT):: a, a_copy, b !Data\n        INTEGER :: errors = 0\n        INTEGER,DIMENSION(1):: hasDevice\n        hasDevice(1) = 1\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(a)\n        a_copy = a\n        b = 0\n\n        !$acc enter data copyin(hasDevice(1:1))\n        !$acc parallel present(hasDevice(1:1))\n          hasDevice(1) = 0\n        !$acc end parallel\n\n\n        !$acc parallel copyin(a(1:LOOPCOUNT))\n          !$acc loop\n          DO x = 1, LOOPCOUNT\n            a(x) = 0.0\n          END DO\n\n        !$acc end parallel\n\n        DO x = 1, LOOPCOUNT\n          IF ((abs(a(x) - a_copy(x)) > PRECISION .AND. hasDevice(1) .eq. 1) .OR. (hasDevice(1) .eq. 0 .AND. abs(a(x)) > PRECISION)) THEN\n            errors = errors + 1\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "parallel"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "parallel_copyin.c": {
                "num tests": 2,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:parallel,data,data-region,V:2.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(n * sizeof(real_t));\n    real_t * a_copy = (real_t *)malloc(n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n    int* hasDevice = (int *) malloc(sizeof(int));\n    hasDevice[0] = 1;\n    #pragma acc enter data copyin(hasDevice[0:1])\n    #pragma acc parallel present(hasDevice[0:1])\n    {\n      hasDevice[0] = 0;\n    }\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        a_copy[x] = a[x];\n        b[x] = 0.0;\n    }\n\n    #pragma acc parallel copyin(a[0:n])\n    {\n        #pragma acc loop\n        for (int x = 0; x < n; ++x){\n            a[x] = 0.0;\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        if (((fabs(a[x] - a_copy[x]) > PRECISION) && (hasDevice[0] == 1)) || ((hasDevice[0] == 0) && (fabs(a[x]) > PRECISION))){\n            err = 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "parallel",
                            "data",
                            "data-region"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "2": {
                        "content": "#ifndef T2\n//T2:parallel,data,data-region,V:1.0-2.7\nint test2(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(n * sizeof(real_t));\n    real_t * a_copy = (real_t *)malloc(n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n    }\n\n    #pragma acc data copy(b[0:n])\n    {\n        #pragma acc parallel copyin(a[0:n])\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                b[x] = a[x];\n            }\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        if (fabs(a[x] - b[x]) > PRECISION){\n            err = 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T2\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test2();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 1);\n    }\n#endif\n",
                        "tags": [
                            "parallel",
                            "data",
                            "data-region"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "parallel_copyout.F90": {
                "num tests": 3,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:parallel,V:2.0-2.7\n      LOGICAL FUNCTION test1()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT):: a, b !Data\n        INTEGER :: errors = 0\n        INTEGER,DIMENSION(1):: hasDevice\n        hasDevice(1) = 1\n        !$acc enter data copyin(hasDevice(1:1))\n        !$acc parallel present(hasDevice(1:1))\n          hasDevice(1) = 0\n        !$acc end parallel\n\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(a)\n        b = 0\n\n        !$acc data copyin(a(1:LOOPCOUNT))\n          !$acc parallel copyout(b(1:LOOPCOUNT))\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              b(x) = a(x)\n            END DO\n          !$acc end parallel\n        !$acc end data\n\n        DO x = 1, LOOPCOUNT\n          IF (abs(a(x) - b(x)) .gt. PRECISION) THEN\n            errors = errors + 1\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "parallel"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "2": {
                        "content": "#ifndef T2\n!T2:parallel,V:2.0-2.7\n      LOGICAL FUNCTION test2()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT):: a, b !Data\n        INTEGER :: errors = 0\n        INTEGER,DIMENSION(1):: hasDevice\n        hasDevice(1) = 1\n        !$acc enter data copyin(hasDevice(1:1))\n        !$acc parallel present(hasDevice(1:1))\n          hasDevice(1) = 0\n        !$acc end parallel\n\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(a)\n        b = a\n        IF (hasDevice(1) .eq. 1) THEN\n          !$acc data copyin(a(1:LOOPCOUNT), b(1:LOOPCOUNT))\n            !$acc parallel copyout(b(1:LOOPCOUNT))\n              !$acc loop\n              DO x = 1, LOOPCOUNT\n                b(x) = b(x) - a(x)\n              END DO\n            !$acc end parallel\n          !$acc end data\n\n          DO x = 1, LOOPCOUNT\n            IF (abs(a(x) - b(x)) .gt. PRECISION) THEN\n              errors = errors + 1\n            END IF\n          END DO\n        END IF\n\n        IF (errors .eq. 0) THEN\n          test2 = .FALSE.\n        ELSE\n          test2 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T2\n        LOGICAL :: test2\n#endif\n#ifndef T2\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test2()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 1\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "parallel"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "3": {
                        "content": "#ifndef T3\n!T3:parallel,update,V:2.0-2.7\n      LOGICAL FUNCTION test3()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT):: a, b !Data\n        INTEGER :: errors = 0\n        INTEGER,DIMENSION(1):: hasDevice\n        hasDevice(1) = 1\n        !$acc enter data copyin(hasDevice(1:1))\n        !$acc parallel present(hasDevice(1:1))\n          hasDevice(1) = 0\n        !$acc end parallel\n\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(a)\n        b = a\n\n        !$acc data copyin(a(1:LOOPCOUNT), b(1:LOOPCOUNT))\n          !$acc parallel copyout(b(1:LOOPCOUNT))\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              b(x) = b(x) - a(x)\n            END DO\n          !$acc end parallel\n          !$acc update host(b(1:LOOPCOUNT))\n        !$acc end data\n\n        DO x = 1, LOOPCOUNT\n          IF (abs(b(x)) > 2 * PRECISION) THEN\n            errors = errors + 1\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test3 = .FALSE.\n        ELSE\n          test3 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T3\n        LOGICAL :: test3\n#endif\n#ifndef T3\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test3()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 2\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "parallel",
                            "update"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "parallel_copyout.c": {
                "num tests": 3,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:parallel,data,data-region,V:1.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n\n    real_t * a = (real_t *)malloc(n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = 0.0;\n    }\n\n    #pragma acc data copyin(a[0:n])\n    {\n        #pragma acc parallel copyout(b[0:n])\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                b[x] = a[x];\n            }\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        if (fabs(a[x] - b[x]) > PRECISION){\n            err += 1;\n            break;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "parallel",
                            "data",
                            "data-region"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "2": {
                        "content": "#ifndef T2\n//T2:parallel,data,data-region,devonly,V:2.0-2.7\nint test2(){\n    int err = 0;\n    srand(SEED);\n\n    real_t * a = (real_t *)malloc(n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n\n    int* hasDevice = (int *) malloc(sizeof(int));\n    hasDevice[0] = 1;\n    #pragma acc enter data copyin(hasDevice[0:1])\n    #pragma acc parallel present(hasDevice[0:1])\n    {\n      hasDevice[0] = 0;\n    }\n\n    if (hasDevice[0] == 1){\n        for (int x = 0; x < n; ++x){\n            a[x] = rand() / (real_t)(RAND_MAX / 10);\n            b[x] = a[x];\n        }\n\n        #pragma acc data copyin(a[0:n], b[0:n])\n        {\n            #pragma acc parallel copyout(b[0:n])\n            {\n                #pragma acc loop\n                for (int x = 0; x < n; ++x){\n                    b[x] = b[x] - a[x];\n                }\n            }\n        }\n        for (int x = 0; x < n; ++x){\n          if (fabs(a[x] - b[x]) > PRECISION){\n            err += 2;\n            break;\n          }\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T2\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test2();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 1);\n    }\n#endif\n",
                        "tags": [
                            "parallel",
                            "data",
                            "data-region",
                            "devonly"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "3": {
                        "content": "#ifndef T3\n//T3:parallel,data,data-region,V:1.0-2.7\nint test3(){\n    int err = 0;\n    srand(SEED);\n\n    real_t * a = (real_t *)malloc(n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = a[x];\n    }\n\n    #pragma acc data copyin(a[0:n], b[0:n])\n    {\n        #pragma acc parallel copyout(b[0:n])\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                b[x] = b[x] - a[x];\n            }\n        }\n        #pragma acc update host(b[0:n])\n    }\n\n    for (int x = 0; x < n; ++x){\n        if (fabs(b[x]) > 2 * PRECISION){\n            err += 4;\n            break;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T3\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test3();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 2);\n    }\n#endif\n",
                        "tags": [
                            "parallel",
                            "data",
                            "data-region"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "parallel_copyout_zero.c": {
                "num tests": 3,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:parallel,data,executable-data,data-region,V:3.0-3.1\nint test1(){\n    int err = 0;\n    srand(SEED);\n\n    real_t * a = (real_t *)malloc(n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = 0.0;\n    }\n\n    #pragma acc data copyin(a[0:n]) copyout(b[0:n])\n    {\n      #pragma acc parallel\n      {\n        #pragma acc loop\n        {\n          for (int x = 0; x < n; ++x){\n            b[x] += a[x];\n          }\n        }\n      }\n    }\n\n    for (int x = 0; x < n; ++x){\n        if(fabs(a[x] - b[x]) > PRECISION){\n                err += 1;\n                break;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "parallel",
                            "data",
                            "executable-data",
                            "data-region"
                        ],
                        "versions": []
                    },
                    "2": {
                        "content": "#ifndef T2\n//T2:runtime,data,executable-data,construct-independent,V:3.0-3.1\nint test2(){\n    int err = 0;\n    srand(SEED);\n\n    real_t * a = (real_t *)malloc(n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = 0.0;\n    }\n\n    #pragma acc data copyin(a[0:n]) copyout(b[0:n])\n    {\n      #pragma acc parallel\n      {\n        #pragma acc loop\n        {\n          for (int x = 0; x < n; ++x){\n            b[x] = 0.0;\n          }\n        }\n      }\n      #pragma acc parallel\n      {\n        #pragma acc loop\n        {\n          for (int x = 0; x < n; ++x){\n            b[x] += a[x];\n          }\n        }\n      }\n    }\n\n    for (int x = 0; x < n; ++x){\n        if(fabs(a[x] - b[x]) > PRECISION){\n                err += 2;\n                break;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T2\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test2();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "runtime",
                            "data",
                            "executable-data",
                            "construct-independent"
                        ],
                        "versions": []
                    },
                    "3": {
                        "content": "#ifndef T3\n//T3:runtime,data,executable-data,construct-independent,V:3.0-3.1\nint test3(){\n    int err = 0;\n    srand(SEED);\n\n    real_t * a = (real_t *)malloc(n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = 0;\n    }\n\n    #pragma acc data copyin(a[0:n]) copyout(zero: b[0:n])\n    {\n      #pragma acc parallel\n      {\n        #pragma acc loop\n        {\n          for (int x = 0; x < n; ++x){\n            b[x] += a[x];\n          }\n        }\n      }\n    }\n\n    for (int x = 0; x < n; ++x){\n        if(fabs(a[x] - b[x]) > PRECISION){\n                err += 3;\n                break;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T3\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test3();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "runtime",
                            "data",
                            "executable-data",
                            "construct-independent"
                        ],
                        "versions": []
                    }
                }
            },
            "parallel_create.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:parallel,V:1.0-2.7\n      LOGICAL FUNCTION test1()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT):: a, b, c !Data\n        INTEGER :: errors = 0\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(a)\n        b = 0\n        c = 0\n\n        !$acc data copyin(a(1:LOOPCOUNT)) copy(c(1:LOOPCOUNT))\n          !$acc parallel create(b(1:LOOPCOUNT))\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              b(x) = a(x)\n            END DO\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              c(x) = b(x)\n            END DO\n          !$acc end parallel\n        !$acc end data\n        DO x = 1, LOOPCOUNT\n          IF (abs(a(x) - c(x)) .gt. PRECISION) THEN\n            errors = errors + 1\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "parallel"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "parallel_create.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:parallel,data,data-region,V:1.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n    real_t * c = (real_t *)malloc(n * sizeof(real_t));\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = 0.0;\n        c[x] = 0.0;\n    }\n\n    #pragma acc data copyin(a[0:n]) copy(c[0:n])\n    {\n        #pragma acc parallel create(b[0:n])\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                b[x] = a[x];\n            }\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                c[x] = b[x];\n            }\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        if (fabs(a[x] - c[x]) > PRECISION){\n            err = 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "parallel",
                            "data",
                            "data-region"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "parallel_create_zero.c": {
                "num tests": 3,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:parallel,data,data-region,V:3.0-3.1\nint test1(){\n    int err = 0;\n    srand(SEED);\n\n    real_t * a = (real_t *)malloc(n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = 0.0;\n    }\n\n    #pragma acc data copyin(a[0:n]) create(b[0:n])\n    {\n      #pragma acc parallel\n      {\n        #pragma acc loop\n        {\n          for (int x = 0; x < n; ++x){\n            b[x] += a[x];\n          }\n        }\n      }\n    }\n\n    for (int x = 0; x < n; ++x){\n        if (fabs(a[x] - b[x]) > PRECISION){\n            err = 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "parallel",
                            "data",
                            "data-region"
                        ],
                        "versions": []
                    },
                    "2": {
                        "content": "#ifndef T2\n//T2:parallel,data,data-region,V:3.0-3.1\nint test2(){\n    int err = 0;\n    srand(SEED);\n\n    real_t * a = (real_t *)malloc(n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = 0.0;\n    }\n\n    #pragma acc data copyin(a[0:n]) create(b[0:n])\n    {\n      #pragma acc parallel\n      {\n        #pragma acc loop\n        {\n          for (int x = 0; x < n; ++x){\n            b[x] = 0.0;\n          }\n        }\n      }\n      #pragma acc parallel\n      {\n        #pragma acc loop\n        {\n          for (int x = 0; x < n; ++x){\n            b[x] += a[x];\n          }\n        }\n      }\n    }\n\n    for (int x = 0; x < n; ++x){\n        if (fabs(a[x] - b[x]) > PRECISION){\n            err = 2;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T2\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test2();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "parallel",
                            "data",
                            "data-region"
                        ],
                        "versions": []
                    },
                    "3": {
                        "content": "#ifndef T3\n//T3:parallel,data,data-region,V:3.0-3.1\nint test3(){\n    int err = 0;\n    srand(SEED);\n\n    real_t * a = (real_t *)malloc(n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = 0.0;\n    }\n\n    #pragma acc data copyin(a[0:n]) create(zero: b[0:n])\n    {\n      #pragma acc parallel\n      {\n        #pragma acc loop\n        {\n          for (int x = 0; x < n; ++x){\n            b[x] += a[x];\n          }\n        }\n      }\n    }\n\n    for (int x = 0; x < n; ++x){\n        if (fabs(a[x] - b[x]) > PRECISION){\n            err = 3;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T3\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test3();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "parallel",
                            "data",
                            "data-region"
                        ],
                        "versions": []
                    }
                }
            },
            "parallel_default_copy.F90": {
                "num tests": 2,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:devonly,parallel,V:2.0-2.7\n      LOGICAL FUNCTION test1()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT):: a, b, c !Data\n        INTEGER :: errors = 0\n        LOGICAL,DIMENSION(1):: devtest\n        devtest(1) = .TRUE.\n\n        !$acc enter data copyin(devtest(1:1))\n        !$acc parallel\n          devtest(1) = .FALSE.\n        !$acc end parallel\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(a)\n        CALL RANDOM_NUMBER(b)\n        c = 0\n\n        !$acc data copyin(a(1:LOOPCOUNT), b(1:LOOPCOUNT))\n          !$acc parallel\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              c(x) = c(x) + a(x) + b(x)\n            END DO\n          !$acc end parallel\n        !$acc end data\n        DO x = 1, LOOPCOUNT\n          IF (abs(c(x) - (a(x) + b(x))) .gt. PRECISION) THEN\n            errors = errors + 1\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "devonly",
                            "parallel"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "2": {
                        "content": "#ifndef T2\n!T2:devonly,parallel,V:2.0-2.7\n      LOGICAL FUNCTION test2()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT):: a, b, c !Data\n        INTEGER :: errors = 0\n        LOGICAL,DIMENSION(1):: devtest\n        devtest(1) = .TRUE.\n\n        !$acc enter data copyin(devtest(1:1))\n        !$acc parallel\n          devtest(1) = .FALSE.\n        !$acc end parallel\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        IF (devtest(1)) THEN\n          CALL RANDOM_NUMBER(a)\n          CALL RANDOM_NUMBER(b)\n          c = 1\n\n          !$acc enter data copyin(c(1:LOOPCOUNT))\n          c = 0\n          !$acc data copyin(a(1:LOOPCOUNT), b(1:LOOPCOUNT))\n            !$acc parallel\n              !$acc loop\n              DO x = 1, LOOPCOUNT\n                c(x) = c(x) + a(x) + b(x)\n              END DO\n            !$acc end parallel\n          !$acc end data\n          DO x = 1, LOOPCOUNT\n            IF (abs(c(x)) .gt. PRECISION) THEN\n              errors = errors + 1\n            END IF\n          END DO\n          !$acc exit data copyout(c(1:LOOPCOUNT))\n          DO x = 1, LOOPCOUNT\n            IF (abs(c(x) - (a(x) + b(x) + 1)) .gt. PRECISION) THEN\n              errors = errors + 1\n            END IF\n          END DO\n        END IF\n\n        IF (errors .eq. 0) THEN\n          test2 = .FALSE.\n        ELSE\n          test2 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T2\n        LOGICAL :: test2\n#endif\n#ifndef T2\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test2()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 1\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "devonly",
                            "parallel"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "parallel_default_copy.c": {
                "num tests": 2,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:parallel,data,data-region,default-mapping,V:1.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n    real_t c[n];\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n        c[x] = 0.0;\n    }\n\n    #pragma acc data copyin(a[0:n], b[0:n])\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                c[x] += a[x] + b[x];\n            }\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        if (fabs(c[x] - (a[x] + b[x])) > PRECISION){\n            err += 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "parallel",
                            "data",
                            "data-region",
                            "default-mapping"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "2": {
                        "content": "#ifndef T2\n//T2:parallel,data,data-region,default-mapping,V:2.0-2.7\nint test2(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n    real_t c[n];\n    int * devtest = (int *)malloc(sizeof(real_t));\n\n    devtest[0] = 1;\n    #pragma acc enter data copyin(devtest[0:1])\n    #pragma acc parallel present(devtest[0:1])\n    {\n        devtest[0] = 0;\n    }\n\n    if (devtest[0] == 1){\n        for (int x = 0; x < n; ++x){\n            a[x] = rand() / (real_t)(RAND_MAX / 10);\n            b[x] = rand() / (real_t)(RAND_MAX / 10);\n            c[x] = 1;\n        }\n\n        #pragma acc enter data copyin(c[0:n])\n        for (int x = 0; x < n; ++x){\n            c[x] = 0.0;\n        }\n        #pragma acc data copyin(a[0:n], b[0:n])\n        {\n            #pragma acc parallel\n            {\n                #pragma acc loop\n                for (int x = 0; x < n; ++x){\n                    c[x] += a[x] + b[x];\n                }\n            }\n        }\n\n        for (int x = 0; x < n; ++x){\n            if (fabs(c[x]) > PRECISION){\n                err += 1;\n            }\n        }\n\n        #pragma acc exit data copyout(c[0:n])\n\n        for (int x = 0; x < n; ++x){\n            if (fabs(c[x] - (a[x] + b[x] + 1)) > PRECISION){\n                err += 1;\n            }\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T2\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test2();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 1);\n    }\n#endif\n",
                        "tags": [
                            "parallel",
                            "data",
                            "data-region",
                            "default-mapping"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "parallel_default_present.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:parallel,default,V:2.5-2.7\n      LOGICAL FUNCTION test1()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT):: a !Data\n        INTEGER :: errors = 0\n\n        a = 0\n\n        !$acc data copy(a(1:LOOPCOUNT))\n          !$acc parallel default(present)\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              a(x) = 1.0\n            END DO\n          !$acc end parallel\n        !$acc end data\n\n        DO x = 1, LOOPCOUNT\n          IF (abs(a(x) - 1) .gt. PRECISION) THEN\n            errors = errors + 1\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "parallel",
                            "default"
                        ],
                        "versions": [
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "parallel_default_present.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:parallel,default,data,data-region,V:2.5-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(n * sizeof(real_t));\n\n    for (int x = 0; x < n; ++x){\n        a[x] = 0.0;\n    }\n    #pragma acc enter data copyin(a[0:n])\n    #pragma acc parallel default(present)\n    {\n        #pragma acc loop\n        for (int x = 0; x < n; ++x){\n            a[x] = 1.0;\n        }\n    }\n    #pragma acc exit data copyout(a[0:n])\n\n    for (int x = 0; x < n; ++x){\n        if (fabs(a[x] - 1.0) > PRECISION){\n            err = 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "parallel",
                            "default",
                            "data",
                            "data-region"
                        ],
                        "versions": [
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "parallel_deviceptr.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:parallel,runtime,V:2.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(n * sizeof(real_t));\n    real_t * b;\n\n    for (int x = 0; x < n; ++x){\n        a[x] = 0;\n    }\n\n    #pragma acc enter data copyin(a[0:n])\n    b = (real_t *) acc_deviceptr(a);\n    if (b == NULL){\n        err = 1;\n    }\n    else{\n        #pragma acc parallel deviceptr(b)\n        {\n            #pragma acc loop\n            for (int x = 0; x < (int) n/2; ++x){\n                b[x] = 1;\n            }\n        }\n        #pragma acc exit data copyout(a[0:n])\n    }\n    for (int x = 0; x < n; ++x){\n        if (x < (int) n/2){\n            if (fabs(a[x] - 1) > PRECISION){\n                err = 1;\n            }\n        }\n        else {\n            if (fabs(a[x]) > PRECISION){\n                err = 1;\n            }\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "parallel",
                            "runtime"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "parallel_firstprivate.F90": {
                "num tests": 2,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:parallel,firstprivate,V:1.0-2.7\n      LOGICAL FUNCTION test1()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x, y !Iterators\n        REAL(8),DIMENSION(10 * LOOPCOUNT):: a, b, d !Data\n        REAL(8),DIMENSION(LOOPCOUNT):: c, c_copy\n        REAL*8 :: RAND\n        INTEGER :: errors = 0\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(a)\n        CALL RANDOM_NUMBER(b)\n        CALL RANDOM_NUMBER(c)\n        c_copy = c\n        d = 0\n        \n        !$acc data copyin(a(1:10*LOOPCOUNT), b(1:10*LOOPCOUNT)) copy(d(1:10*LOOPCOUNT))\n          !$acc parallel firstprivate(c(1:LOOPCOUNT))\n            !$acc loop gang\n            DO x = 0, 9\n              !$acc loop worker\n              DO y = 1, LOOPCOUNT\n                d(x * LOOPCOUNT + y) = a(x * LOOPCOUNT + y) + b(x * LOOPCOUNT + y) + c(y)\n              END DO\n            END DO\n          !$acc end parallel\n        !$acc end data\n\n        DO x = 0, 9\n          DO y = 1, LOOPCOUNT\n            IF (abs(d(x * LOOPCOUNT + y) - (a(x * LOOPCOUNT + y) + b(x * LOOPCOUNT + y) + c(y))) .gt. PRECISION) THEN\n              errors = errors + 1\n            END IF\n          END DO\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "parallel",
                            "firstprivate"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "2": {
                        "content": "#ifndef T2\n!T2:parallel,firstprivate,V:1.0-2.7\n      LOGICAL FUNCTION test2()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x, y !Iterators\n        REAL(8),DIMENSION(10 * LOOPCOUNT):: a, b, d !Data\n        REAL(8),DIMENSION(LOOPCOUNT):: c, c_copy\n        REAL*8 :: RAND\n        INTEGER :: errors = 0\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(a)\n        CALL RANDOM_NUMBER(b)\n        c = 0\n        d = 0\n        \n        !$acc data copyin(a(1:10*LOOPCOUNT), b(1:10*LOOPCOUNT)) copy(d(1:10*LOOPCOUNT))\n          !$acc parallel firstprivate(c(1:LOOPCOUNT))\n            !$acc loop gang independent\n            DO x = 0, 9\n              !$acc loop worker independent\n              DO y = 1, LOOPCOUNT\n                c(y) = a(x * LOOPCOUNT + y) - b(x * LOOPCOUNT + y)\n              END DO\n              !$acc loop worker independent\n              DO y = 1, LOOPCOUNT\n                d(x * LOOPCOUNT + y) = a(x * LOOPCOUNT + y) + b(x * LOOPCOUNT + y) + c(y)\n              END DO\n            END DO\n          !$acc end parallel\n        !$acc end data\n\n        DO x = 1, 10 * LOOPCOUNT\n          IF (abs(d(x) - (2 * a(x))) .gt. PRECISION) THEN\n            errors = errors + 1\n          END IF\n        END DO       \n\n        IF (errors .eq. 0) THEN\n          test2 = .FALSE.\n        ELSE\n          test2 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T2\n        LOGICAL :: test2\n#endif\n#ifndef T2\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test2()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 1\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "parallel",
                            "firstprivate"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "parallel_firstprivate.c": {
                "num tests": 2,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:parallel,firstprivate,V:1.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(10 * n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(10 * n * sizeof(real_t));\n    real_t * c = (real_t *)malloc(n * sizeof(real_t));\n    real_t * c_copy = (real_t *)malloc(n * sizeof(real_t));\n    real_t * d = (real_t *)malloc(10 * n * sizeof(real_t));\n\n    for (int x = 0; x < 10*n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n        d[x] = 0.0;\n    }\n    for (int x = 0; x < n; ++x){\n        c[x] = rand() / (real_t)(RAND_MAX / 10);\n        c_copy[x] = c[x];\n    }\n    #pragma acc data copyin(a[0:10*n], b[0:10*n]) copy(d[0:10*n])\n    {\n        #pragma acc parallel firstprivate(c[0:n])\n        {\n            #pragma acc loop gang\n            for (int x = 0; x < 10; ++x){\n                #pragma acc loop worker\n                for (int y = 0; y < n; ++y){\n                    d[x * n + y] = a[x * n + y] + b[x * n + y] + c[y];\n                }\n            }\n        }\n    }\n\n    for (int x = 0; x < 10; ++x){\n        for (int y = 0; y < n; ++y){\n            if (fabs(d[x * n + y] - (a[x * n + y] + b[x * n + y] + c_copy[y])) > PRECISION){\n                err += 1;\n            }\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "parallel",
                            "firstprivate"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "2": {
                        "content": "#ifndef T2\n//T2:parallel,firstprivate,V:1.0-2.7\nint test2(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(10 * n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(10 * n * sizeof(real_t));\n    real_t * c = (real_t *)malloc(n * sizeof(real_t));\n    real_t * c_copy = (real_t *)malloc(n * sizeof(real_t));\n    real_t * d = (real_t *)malloc(10 * n * sizeof(real_t));\n\n    for (int x = 0; x < 10*n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n        d[x] = 0.0;\n    }\n    for (int x = 0; x < n; ++x){\n        c[x] = 0.0;\n    }\n\n    #pragma acc data copyin(a[0:10*n], b[0:10*n]) copy(d[0:10*n])\n    {\n        #pragma acc parallel firstprivate(c[0:n])\n        {\n            #pragma acc loop gang independent\n            for (int x = 0; x < 10; ++x){\n                #pragma acc loop worker independent\n                for (int y = 0; y < n; ++y){\n                    c[y] = a[x * n + y] - b[x * n + y];\n                }\n                #pragma acc loop worker independent\n                for (int y = 0; y < n; ++y){\n                    d[x * n + y] = a[x * n + y] + b[x * n + y] + c[y];\n                }\n            }\n        }\n    }\n\n    for (int x = 0; x < 10 * n; ++x){\n        if (fabs(d[x] - 2 * a[x]) > PRECISION){\n            err += 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T2\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test2();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 1);\n    }\n#endif\n",
                        "tags": [
                            "parallel",
                            "firstprivate"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "parallel_if.F90": {
                "num tests": 3,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:devonly,parallel,if,V:2.0-2.7\n      LOGICAL FUNCTION test1()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT):: a, b, c !Data\n        INTEGER :: errors = 0\n        LOGICAL :: host = .FALSE.\n        LOGICAL :: device = .TRUE.\n        INTEGER,DIMENSION(1) :: dev_test\n        dev_test(1) = 0\n\n        !$acc enter data copyin(dev_test(1:1))\n        !$acc parallel present(dev_test(1:1))\n          dev_test(1) = 1\n        !$acc end parallel\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(a)\n        CALL RANDOM_NUMBER(b)\n        c = 0\n\n        !$acc parallel if(host)\n          !$acc loop\n          DO x = 1, LOOPCOUNT\n            c(x) = a(x) + b(x)\n          END DO\n        !$acc end parallel\n\n        DO x = 1, LOOPCOUNT\n          IF (abs(c(x) - (a(x) + b(x))) .gt. PRECISION) THEN\n            errors = errors + 1\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "devonly",
                            "parallel",
                            "if"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "2": {
                        "content": "#ifndef T2\n!T2:devonly,parallel,if,V:2.0-2.7\n      LOGICAL FUNCTION test2()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT):: a, b, c !Data\n        INTEGER :: errors = 0\n        LOGICAL :: host = .FALSE.\n        LOGICAL :: device = .TRUE.\n        INTEGER,DIMENSION(1) :: dev_test\n        dev_test(1) = 0\n\n        !$acc enter data copyin(dev_test(1:1))\n        !$acc parallel present(dev_test(1:1))\n          dev_test(1) = 1\n        !$acc end parallel\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        IF (dev_test(1) .eq. 0) THEN\n          CALL RANDOM_NUMBER(a)\n          CALL RANDOM_NUMBER(b)\n          c = a + b\n\n          !$acc enter data copyin(a(1:LOOPCOUNT), b(1:LOOPCOUNT), c(1:LOOPCOUNT))\n          !$acc parallel if(host) present(a(1:LOOPCOUNT), b(1:LOOPCOUNT), c(1:LOOPCOUNT))\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              c(x) = c(x) + a(x) + b(x)\n            END DO\n          !$acc end parallel\n          !$acc exit data delete(a(1:LOOPCOUNT), b(1:LOOPCOUNT)) copyout(c(1:LOOPCOUNT))\n\n          DO x = 1, LOOPCOUNT\n            IF (abs(c(x) - (a(x) + b(x))) .gt. PRECISION) THEN\n              errors = errors + 1\n            END IF\n          END DO\n        END IF\n\n        IF (errors .eq. 0) THEN\n          test2 = .FALSE.\n        ELSE\n          test2 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T2\n        LOGICAL :: test2\n#endif\n#ifndef T2\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test2()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 1\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "devonly",
                            "parallel",
                            "if"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "3": {
                        "content": "#ifndef T3\n!T3:devonly,parallel,if,V:2.0-2.7\n      LOGICAL FUNCTION test3()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT):: a, b, c !Data\n        INTEGER :: errors = 0\n        LOGICAL :: host = .FALSE.\n        LOGICAL :: device = .TRUE.\n        INTEGER,DIMENSION(1) :: dev_test\n        dev_test(1) = 0\n\n        !$acc enter data copyin(dev_test(1:1))\n        !$acc parallel present(dev_test(1:1))\n          dev_test(1) = 1\n        !$acc end parallel\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(a)\n        CALL RANDOM_NUMBER(b)\n        c = a + b\n        !$acc enter data copyin(a(1:LOOPCOUNT), b(1:LOOPCOUNT), c(1:LOOPCOUNT))\n        !$acc parallel if(device) present(a(1:LOOPCOUNT), b(1:LOOPCOUNT), c(1:LOOPCOUNT))\n          !$acc loop\n          DO x = 1, LOOPCOUNT\n            c(x) = c(x) + a(x) + b(x)\n          END DO\n        !$acc end parallel\n        !$acc exit data delete(a(1:LOOPCOUNT), b(1:LOOPCOUNT)), copyout(c(1:LOOPCOUNT))\n\n        DO x = 1, LOOPCOUNT\n          IF (abs(c(x) - (2 * (a(x) + b(x)))) .gt. 2 * PRECISION) THEN\n            errors = errors + 1\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test3 = .FALSE.\n        ELSE\n          test3 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T3\n        LOGICAL :: test3\n#endif\n#ifndef T3\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test3()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 2\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "devonly",
                            "parallel",
                            "if"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "parallel_if.c": {
                "num tests": 3,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:parallel,if,V:1.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n    real_t * c = (real_t *)malloc(n * sizeof(real_t));\n    int accel = 1;\n    int host = 0;\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n        c[x] = 0.0;\n    }\n    #pragma acc parallel if(host)\n    {\n        #pragma acc loop\n        for (int x = 0; x < n; ++x){\n            c[x] = a[x] + b[x];\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        if (fabs(c[x] - (a[x] + b[x])) > PRECISION){\n            err = 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "parallel",
                            "if"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "2": {
                        "content": "#ifndef T2\n//T2:parallel,if,devonly,V:2.0-2.7\nint test2(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n    real_t * c = (real_t *)malloc(n * sizeof(real_t));\n    int * dev_test = (int *)malloc(sizeof(int));\n    int accel = 1;\n    int host = 0;\n\n    dev_test[0] = 1;\n    #pragma acc data copyin(dev_test[0:1])\n    #pragma acc parallel\n    {\n      dev_test[0] = 0;\n    }\n\n    if (devtest[0] != 0){\n        for (int x = 0; x < n;  ++x){\n            a[x] = rand() / (real_t)(RAND_MAX / 10);\n            b[x] = rand() / (real_t)(RAND_MAX / 10);\n            c[x] = 0;\n        }\n\n        #pragma acc enter data copyin(a[0:n], b[0:n], c[0:n])\n        #pragma acc parallel if(host) present(a[0:n], b[0:n], c[0:n])\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                c[x] += a[x] + b[x];\n            }\n        }\n        #pragma acc exit data delete(a[0:n], b[0:n]) copyout(c[0:n])\n\n        for (int x = 0; x < n; ++x){\n            if (fabs(c[x]) > PRECISION){\n                err = 1;\n            }\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T2\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test2();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 1);\n    }\n#endif\n",
                        "tags": [
                            "parallel",
                            "if",
                            "devonly"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "3": {
                        "content": "#ifndef T3\n//T3:parallel,if,V:2.0-2.7\nint test3(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n    real_t * c = (real_t *)malloc(n * sizeof(real_t));\n    int accel = 1;\n    int host = 0;\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n        c[x] = 0;\n    }\n\n    #pragma acc enter data copyin(a[0:n], b[0:n], c[0:n])\n\n    #pragma acc parallel if(accel) present(a[0:n], b[0:n], c[0:n])\n    {\n        #pragma acc loop\n        for (int x = 0; x < n; ++x){\n            c[x] += a[x] + b[x];\n        }\n    }\n\n    #pragma acc exit data delete(a[0:n], b[0:n]) copyout(c[0:n])\n\n    for (int x = 0; x < n; ++x){\n        if (fabs(c[x] - (a[x] + b[x])) > PRECISION * 2){\n            err = 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T3\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test3();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 2);\n    }\n#endif\n",
                        "tags": [
                            "parallel",
                            "if"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "parallel_loop.F90": {
                "num tests": 2,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:parallel,loop,V:1.0-2.7\n      LOGICAL FUNCTION test1()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT):: a, b, c !Data\n        INTEGER :: errors = 0\n\n        !Initilization\n        a = 0\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        !$acc data copy(a(1:LOOPCOUNT))\n          !$acc parallel loop\n          DO x = 1, LOOPCOUNT\n            a(x) = 1\n          END DO\n        !$acc end data\n\n        DO x = 1, LOOPCOUNT\n          IF (abs(a(x) - 1) .gt. PRECISION) THEN\n            errors = errors + 1\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "parallel",
                            "loop"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "2": {
                        "content": "#ifndef T2\n!T2:parallel,loop,V:1.0-2.7\n      LOGICAL FUNCTION test2()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT):: a, b, c !Data\n        INTEGER :: errors = 0\n\n        !Initilization\n        a = 0\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(b)\n        CALL RANDOM_NUMBER(c)\n\n        !$acc data copy(a(1:LOOPCOUNT), b(1:LOOPCOUNT), c(1:LOOPCOUNT))\n          !$acc parallel\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              a(x) = b(x)\n            END DO\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              a(x) = a(x) + c(x)\n            END DO\n          !$acc end parallel\n        !$acc end data\n\n        DO x = 1, LOOPCOUNT\n          IF (abs(a(x) - (b(x) + c(x))) .gt. PRECISION) THEN\n            errors = errors + 1\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test2 = .FALSE.\n        ELSE\n          test2 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T2\n        LOGICAL :: test2\n#endif\n#ifndef T2\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test2()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 1\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "parallel",
                            "loop"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "parallel_loop.c": {
                "num tests": 2,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:parallel,loop,combined-constructs,V:1.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n    real_t * c = (real_t *)malloc(n * sizeof(real_t));\n\n    for (int x = 0; x < n; ++x){\n        a[x] = 0;\n    }\n\n    #pragma acc data copy(a[0:n])\n    {\n        #pragma acc parallel loop\n        for (int x = 0; x < n; ++x){\n            a[x] = 1.0;\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        if (fabs(a[x] - 1.0) > PRECISION){\n            err = 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "parallel",
                            "loop",
                            "combined-constructs"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "2": {
                        "content": "#ifndef T2\n//T2:parallel,loop,V:1.0-2.7\nint test2(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n    real_t * c = (real_t *)malloc(n * sizeof(real_t));\n\n    for (int x = 0; x < n; ++x){\n      a[x] = 0.0;\n      b[x] = rand() / (real_t)(RAND_MAX / 10);\n      c[x] = rand() / (real_t)(RAND_MAX / 10);\n    }\n    #pragma acc data copy(a[0:n], b[0:n], c[0:n])\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                a[x] = b[x];\n            }\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                a[x] += c[x];\n            }\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        if (fabs(a[x] - (b[x] + c[x])) > PRECISION * 2){\n            err = 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T2\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test2();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 1);\n    }\n#endif\n",
                        "tags": [
                            "parallel",
                            "loop"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "parallel_loop_async.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:async,parallel,reduction,combined-constructs,loop,V:1.0-2.7\n      LOGICAL FUNCTION test1()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x, y !Iterators\n        REAL(8),DIMENSION(10 * LOOPCOUNT):: a, b, c, d !Data\n\t\t\t\tINTEGER,DIMENSION(10):: errors_array\n        INTEGER :: errors\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(a)\n        CALL RANDOM_NUMBER(b)\n        c = 0\n        d = a + b\n\t\t\t\terrors = 0\n\n        !$acc data copyin(a(1:10*LOOPCOUNT), b(1:10*LOOPCOUNT), c(1:10*LOOPCOUNT), d(1:10*LOOPCOUNT)) copy(errors(1:10))\n          DO x = 0, 9\n            !$acc parallel loop async(x)\n            DO y = 1, LOOPCOUNT\n              c(x * LOOPCOUNT + y) = a(x * LOOPCOUNT + y) + b(x * LOOPCOUNT + y)\n            END DO\n            !$acc parallel loop async(x) reduction(+:errors(x))\n            DO y = 1, LOOPCOUNT\n              IF (c(x * LOOPCOUNT + y) - d(x * LOOPCOUNT + y) .gt. PRECISION .OR. d(x * LOOPCOUNT + y) - c(x * LOOPCOUNT + y) .gt. PRECISION) THEN\n                errors_array(x) = errors_array(x) + 1\n              END IF\n            END DO\n          END DO\n\t\t\t\t\t!$acc wait\n        !$acc end data\n\n\t\t\t\tDO x = 1, 10\n\t\t\t\t\terrors = errors + errors_array(x)\n\t\t\t\tEND DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "async",
                            "parallel",
                            "reduction",
                            "combined-constructs",
                            "loop"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "parallel_loop_async.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:parallel,loop,async,combined-constructs,V:1.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(10 * n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(10 * n * sizeof(real_t));\n    real_t * c = (real_t *)malloc(10 * n * sizeof(real_t));\n    real_t * d = (real_t *)malloc(10 * n * sizeof(real_t));\n\t\tint * errors = (int *)malloc(10 * sizeof(int));\n\n\t\tfor (int x = 0; x < 10; ++x){\n\t\t\terrors[x] = 0;\n\t\t}\n\n    for (int x = 0; x < 10 * n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n        c[x] = 0.0;\n        d[x] = a[x] + b[x];\n    }\n\n    #pragma acc data copyin(a[0:10*n], b[0:10*n], c[0:10*n], d[0:10*n]) copy(errors[0:10])\n    {\n        for (int x = 0; x < 10; ++x){\n            #pragma acc parallel loop async(x)\n            for (int y = 0; y < n; ++y){\n                c[x * n + y] = a[x * n + y] + b[x * n + y];\n            }\n            #pragma acc parallel loop async(x) reduction(+:errors[x])\n            for (int y = 0; y < n; ++y){\n                if(c[x * n + y] - d[x * n + y] > PRECISION || d[x * n + y] - c[x * n + y] > PRECISION){\n                    errors[x] += 1;\n                }\n            }\n        }\n\t\t\t\t#pragma acc wait\n    }\n\n    for (int x = 0; x < 10; ++x){\n        err += errors[x];\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "parallel",
                            "loop",
                            "async",
                            "combined-constructs"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "parallel_loop_auto.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:parallel,combined-constructs,loop,auto,V:2.0-2.7\n      LOGICAL FUNCTION test1()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT):: a, a_copy, b !Data\n        REAL(8) :: temp\n        INTEGER :: errors = 0\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(a)\n        a_copy = a\n        b = 0\n\n        !$acc data copyin(a(1:LOOPCOUNT)) copyout(b(1:LOOPCOUNT))\n          !$acc parallel loop auto\n          DO x = 1, LOOPCOUNT\n            b(x) = a(x)\n          END DO\n        !$acc end data\n\n        DO x = 1, LOOPCOUNT\n          IF (abs(a(x) - b(x)) .gt. PRECISION) THEN\n            errors = errors + 1\n          END IF\n        END DO\n\n        !$acc data copy(a(1:LOOPCOUNT))\n          !$acc parallel loop auto\n          DO x = 2, LOOPCOUNT\n            a(x) = a(x - 1) + a(x)\n          END DO\n        !$acc end data\n\n        temp = 0\n        DO x = 1, LOOPCOUNT\n          temp = temp + a_copy(x)\n          IF (abs(temp - a(x)) .gt. PRECISION) THEN\n            errors = errors + 1\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "parallel",
                            "combined-constructs",
                            "loop",
                            "auto"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "parallel_loop_auto.c": {
                "num tests": 2,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:parallel,loop,combined-constructs,syntactic,V:2.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(n * sizeof(real_t));\n    real_t * a_copy = (real_t *)malloc(n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = 0;\n    }\n\n    #pragma acc data copyin(a[0:n]) copyout(b[0:n])\n    {\n      #pragma acc parallel loop auto\n      for (int x = 0; x < n; ++x){\n        b[x] = a[x];\n      }\n    }\n\n    for (int x = 0; x < n; ++x){\n      if (fabs(b[x] - a[x]) > PRECISION){\n        err = 1;\n      }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "parallel",
                            "loop",
                            "combined-constructs",
                            "syntactic"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "2": {
                        "content": "#ifndef T2\n//T2:parallel,loop,combined-constructs,V:2.0-2.7\nint test2(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(n * sizeof(real_t));\n    real_t * a_copy = (real_t *)malloc(n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        a_copy[x] = a[x];\n    }\n\n    #pragma acc data copy(a[0:n])\n    {\n      #pragma acc parallel loop auto\n      for (int x = 1; x < n; ++x){\n        a[x] = a[x - 1] + a[x];\n      }\n    }\n\n    real_t rolling_total = 0.0;\n    for (int x = 0; x < n; ++x){\n      rolling_total += a_copy[x];\n      if (fabs(rolling_total - a[x]) > PRECISION){\n        err = 1;\n      }\n    }\n\n    return err;\n}\n#endif\n#ifndef T2\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test2();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 1);\n    }\n#endif\n",
                        "tags": [
                            "parallel",
                            "loop",
                            "combined-constructs"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "parallel_loop_gang.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:parallel,combined-constructs,loop,V:1.0-2.7\n      LOGICAL FUNCTION test1()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT):: a, b, c !Data\n        INTEGER :: errors = 0\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(a)\n        CALL RANDOM_NUMBER(b)\n        c = 0\n\n        !$acc data copyin(a(1:LOOPCOUNT), b(1:LOOPCOUNT)) copy(c(1:LOOPCOUNT))\n          !$acc parallel loop gang\n          DO x = 1, LOOPCOUNT\n            c(x) = a(x) + b(x)\n          END DO\n        !$acc end data\n\n        DO x = 1, LOOPCOUNT\n          IF (abs(c(x) - (a(x) + b(x))) .gt. PRECISION) THEN\n            errors = errors + 1\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "parallel",
                            "combined-constructs",
                            "loop"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "parallel_loop_gang.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:parallel,loop,combined-constructs,V:1.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n    real_t * c = (real_t *)malloc(n * sizeof(real_t));\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n        c[x] = 0.0;\n    }\n\n    #pragma acc data copyin(a[0:n], b[0:n]) copy(c[0:n])\n    {\n        #pragma acc parallel loop gang\n        for (int x = 0; x < n; ++x){\n            c[x] = a[x] + b[x];\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        if (fabs(c[x] - (a[x] + b[x])) > PRECISION){\n            err = 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "parallel",
                            "loop",
                            "combined-constructs"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "parallel_loop_reduction_add_general.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:parallel,reduction,combined-constructs,loop,V:1.0-2.7\n      LOGICAL FUNCTION test1()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT):: a, b !Data\n        REAL(8) :: total\n        INTEGER :: errors = 0\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(a)\n        CALL RANDOM_NUMBER(b)\n        total = 0\n        !$acc data copyin(a(1:LOOPCOUNT), b(1:LOOPCOUNT)) copy(total)\n          !$acc parallel loop reduction(+:total)\n          DO x = 1, LOOPCOUNT\n            total = total + a(x) + b(x)\n          END DO\n        !$acc end data\n        DO x = 1, LOOPCOUNT\n          total = total - (a(x) + b(x))\n        END DO\n        IF (abs(total) .gt. LOOPCOUNT * PRECISION) THEN\n          WRITE(*, *) total\n          errors = 1\n        END IF\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "parallel",
                            "reduction",
                            "combined-constructs",
                            "loop"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "parallel_loop_reduction_add_general.c": {
                "num tests": 2,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:parallel,loop,reduction,combined-constructs,V:1.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n    real_t total;\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n    }\n\n    total = 10;\n    #pragma acc data copyin(a[0:n], b[0:n]) copy(total)\n    {\n        #pragma acc parallel loop reduction(+:total)\n        for (int x = 0; x < n; ++x){\n            total += a[x] + b[x];\n        }\n    }\n    for (int x = 0; x < n; ++x){\n        total -= a[x] + b[x];\n    }\n    if (fabs(total - 10) > PRECISION * (2 * n - 1)){ //199 = # of mathematical operations necessary\n        err = 1;\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "parallel",
                            "loop",
                            "reduction",
                            "combined-constructs"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "2": {
                        "content": "#ifndef T2\n//T2:parallel,loop,reduction,combined-constructs,V:2.7-2.7\nint test2(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(n * 10 * sizeof(real_t));\n    real_t * b = (real_t *)malloc(n * 10 * sizeof(real_t));\n    real_t c[10];\n    real_t c_host[10];\n\n    for (int x = 0; x < 10 * n; ++x) {\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n    }\n\n    for (int x = 0; x < 10; ++x) {\n        c[x] = 1.0;\n        c_host[x] = 1.0;\n    }\n\n    #pragma acc data copyin(a[0:10*n], b[0:10*n])\n    {\n        #pragma acc parallel loop reduction(+:c[0:10])\n        for (int x = 0; x < n; ++x) {\n            for (int y = 0; y < 10; ++y) {\n                c[y] += a[x * 10 + y] + b[x * 10 + y];\n            }\n        }\n    }\n\n    for (int x = 0; x < n; ++x) {\n        for (int y = 0; y < 10; ++y) {\n            c_host[y] += a[x * 10 + y] + b[x * 10 + y];\n        }\n    }\n\n    for (int x = 0; x < 10; ++x) {\n        if (fabs(c_host[x] - c[x]) > PRECISION) {\n            err += 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T2\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test2();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 1);\n    }\n#endif\n",
                        "tags": [
                            "parallel",
                            "loop",
                            "reduction",
                            "combined-constructs"
                        ],
                        "versions": [
                            "2.7"
                        ]
                    }
                }
            },
            "parallel_loop_reduction_add_general_type_check_pt1.c": {
                "num tests": 8,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:parallel,reduction,combined-constructs,loop,V:1.0-2.7\nint test1() {\n    int err = 0;\n    srand(SEED);\n    _Bool* a = (_Bool*)malloc(n * sizeof(_Bool));\n    _Bool* b = (_Bool*)malloc(n * sizeof(_Bool));\n    _Bool total = 1;\n    _Bool host_total = 1;\n\n    for (int x = 0; x < n; ++x) {\n        if ((rand()/((real_t) RAND_MAX)) > .5) {\n            a[x] = 1;\n        }\n        else {\n            a[x] = 0;\n        }\n        if ((rand()/((real_t) RAND_MAX)) > .5) {\n            b[x] = 1;\n        }\n        else {\n            b[x] = 0;\n        }\n    }\n    \n    #pragma acc data copyin(a[0:n], b[0:n])\n    {\n        #pragma acc parallel loop reduction(+:total)\n        for (int x = 0; x < n; ++x) {\n            total += a[x] + b[x];\n        }\n    }\n    \n\n    for (int x = 0; x < n; ++x) {\n        host_total += a[x] + b[x];\n    }\n\n    if (total != host_total) {\n        err += 1;\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x) {\n        failed = failed + test1();\n    }\n    if (failed != 0) {\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "parallel",
                            "reduction",
                            "combined-constructs",
                            "loop"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "2": {
                        "content": "#ifndef T2\n//T2:parallel,reduction,combined-constructs,loop,V:1.0-2.7\nint test2(){\n    int err = 0;\n    srand(SEED);\n    char * a = (char *)malloc(n * sizeof(char));\n    char * b = (char *)malloc(n * sizeof(char));\n    char total = 10;\n    char host_total = 10;\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(UCHAR_MAX / 10);\n        b[x] = rand() / (real_t)(UCHAR_MAX / 10);\n    }\n\n    #pragma acc data copyin(a[0:n], b[0:n])\n    {\n        #pragma acc parallel loop reduction(+:total)\n        for (int x = 0; x < n; ++x) {\n            total += a[x] + b[x];\n        }\n    }\n\n    for (int x = 0; x < n; ++x) {\n        host_total += a[x] + b[x];\n    }\n\n    if (host_total != total) {\n        err += 1;\n    }\n\n    return err;\n}\n#endif\n#ifndef T2\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test2();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 1);\n    }\n#endif\n",
                        "tags": [
                            "parallel",
                            "reduction",
                            "combined-constructs",
                            "loop"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "3": {
                        "content": "#ifndef T3\n//T3:parallel,reduction,combined-constructs,loop,V:1.0-2.7\nint test3(){\n    int err = 0;\n    srand(SEED);\n    signed char * a = (signed char *)malloc(n * sizeof(signed char));\n    signed char * b = (signed char *)malloc(n * sizeof(signed char));\n    signed char total = 10;\n    signed char host_total = 10;\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n    }\n\n    #pragma acc data copyin(a[0:n], b[0:n])\n    {\n        #pragma acc parallel loop reduction(+:total)\n        for (int x = 0; x < n; ++x) {\n            total += a[x] + b[x];\n        }\n    }\n\n    for (int x = 0; x < n; ++x) {\n        host_total += a[x] + b[x];\n    }\n\n    if (host_total != total) {\n        err += 1;\n    }\n\n    return err;\n}\n#endif\n#ifndef T3\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test3();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 2);\n    }\n#endif\n",
                        "tags": [
                            "parallel",
                            "reduction",
                            "combined-constructs",
                            "loop"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "4": {
                        "content": "#ifndef T4\n//T4:parallel,reduction,combined-constructs,loop,V:1.0-2.7\nint test4(){\n    int err = 0;\n    srand(SEED);\n    unsigned char * a = (unsigned char *)malloc(n * sizeof(unsigned char));\n    unsigned char * b = (unsigned char *)malloc(n * sizeof(unsigned char));\n    unsigned char total = 10;\n    unsigned char host_total = 10;\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n    }\n\n    #pragma acc data copyin(a[0:n], b[0:n])\n    {\n        #pragma acc parallel loop reduction(+:total)\n        for (int x = 0; x < n; ++x) {\n            total += a[x] + b[x];\n        }\n    }\n\n    for (int x = 0; x < n; ++x) {\n        host_total += a[x] + b[x];\n    }\n\n    if (total != host_total) {\n        err += 1;\n    }\n\n    return err;\n}\n#endif\n#ifndef T4\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test4();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 3);\n    }\n#endif\n",
                        "tags": [
                            "parallel",
                            "reduction",
                            "combined-constructs",
                            "loop"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "5": {
                        "content": "#ifndef T5\n//T5:parallel,reduction,combined-constructs,loop,V:1.0-2.7\nint test5(){\n    int err = 0;\n    srand(SEED);\n    short int * a = (short int *)malloc(n * sizeof(short int));\n    short int * b = (short int *)malloc(n * sizeof(short int));\n    short int total = 10;\n    short int host_total = 10;    \n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n    }\n\n    #pragma acc data copyin(a[0:n], b[0:n])\n    {\n        #pragma acc parallel loop reduction(+:total)\n        for (int x = 0; x < n; ++x) {\n            total += a[x] + b[x];\n        }\n    }\n\n    for (int x = 0; x < n; ++x) {\n        host_total += a[x] + b[x];\n    }\n\n    if (total != host_total) {\n        err += 1;\n    }\n\n    return err;\n}\n#endif\n#ifndef T5\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test5();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 4);\n    }\n#endif\n",
                        "tags": [
                            "parallel",
                            "reduction",
                            "combined-constructs",
                            "loop"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "6": {
                        "content": "#ifndef T6\n//T6:parallel,reduction,combined-constructs,loop,V:1.0-2.7\nint test6(){\n    int err = 0;\n    srand(SEED);\n    int * a = (int *)malloc(n * sizeof(int));\n    int * b = (int *)malloc(n * sizeof(int));\n    int total = 10;\n    int host_total = 10;\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n    }\n\n    #pragma acc data copyin(a[0:n], b[0:n])\n    {\n        #pragma acc parallel loop reduction(+:total)\n        for (int x = 0; x < n; ++x) {\n            total += a[x] + b[x];\n        }\n    }\n\n    for (int x = 0; x < n; ++x) {\n        host_total += a[x] + b[x];\n    }\n\n    if (total != host_total) {\n        err += 1;\n    }\n\n    return err;\n}\n#endif\n#ifndef T6\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test6();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 5);\n    }\n#endif\n",
                        "tags": [
                            "parallel",
                            "reduction",
                            "combined-constructs",
                            "loop"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "7": {
                        "content": "#ifndef T7\n//T7:parallel,reduction,combined-constructs,loop,nonvalidating,V:1.0-2.7\nint test7(){\n    int err = 0;\n    srand(SEED);\n    long int * a = (long int *)malloc(n * sizeof(long int));\n    long int * b = (long int *)malloc(n * sizeof(long int));\n    long int total = 10;\n    long int host_total = 10;\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n    }\n\n    #pragma acc data copyin(a[0:n], b[0:n])\n    {\n        #pragma acc parallel loop reduction(+:total)\n        for (int x = 0; x < n; ++x) {\n            total += a[x] + b[x];\n        }\n    }\n\n    for (int x = 0; x < n; ++x) {\n        host_total += a[x] + b[x];\n    }\n\n    return err;\n}\n#endif\n#ifndef T7\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test7();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 6);\n    }\n#endif\n",
                        "tags": [
                            "parallel",
                            "reduction",
                            "combined-constructs",
                            "loop",
                            "nonvalidating"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "8": {
                        "content": "#ifndef T8\n//T8:parallel,reduction,combined-constructs,loop,V:1.0-2.7\nint test8(){\n    int err = 0;\n    srand(SEED);\n    long long int * a = (long long int *)malloc(n * sizeof(long long int));\n    long long int * b = (long long int *)malloc(n * sizeof(long long int));\n    long long int total = 10;\n    long long int host_total = 10;\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n    }\n\n    #pragma acc data copyin(a[0:n], b[0:n])\n    {\n        #pragma acc parallel loop reduction(+:total)\n        for (int x = 0; x < n; ++x) {\n            total += a[x] + b[x];\n        }\n    }\n\n    for (int x = 0; x < n; ++x) {\n        host_total += a[x] + b[x];\n    }\n\n    if (host_total != total) {\n        err += 1;\n    }\n\n    return err;\n}\n#endif\n#ifndef T8\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test8();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 7);\n    }\n#endif\n",
                        "tags": [
                            "parallel",
                            "reduction",
                            "combined-constructs",
                            "loop"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "parallel_loop_reduction_add_general_type_check_pt2.c": {
                "num tests": 8,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:parallel,reduction,combined-constructs,loop,V:1.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    unsigned short int * a = (unsigned short int*)malloc(n * sizeof(unsigned short int));\n    unsigned short int * b = (unsigned short int *)malloc(n * sizeof(unsigned short int));\n    unsigned short int total = 10;\n    unsigned short int host_total = 10;\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n    }\n\n    #pragma acc data copyin(a[0:n], b[0:n])\n    {\n        #pragma acc parallel loop reduction(+:total)\n        for (int x = 0; x < n; ++x) {\n            total += a[x] + b[x];\n        }\n    }\n\n    for (int x = 0; x < n; ++x) {\n        host_total += a[x] + b[x];\n    }\n\n    if (host_total != total) {\n        err += 1;\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "parallel",
                            "reduction",
                            "combined-constructs",
                            "loop"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "2": {
                        "content": "#ifndef T2\n//T2:parallel,reduction,combined-constructs,loop,V:1.0-2.7\nint test2(){\n    int err = 0;\n    srand(SEED);\n    unsigned int * a = (unsigned int *)malloc(n * sizeof(unsigned int));\n    unsigned int * b = (unsigned int *)malloc(n * sizeof(unsigned int));\n    unsigned int total = 10;\n    unsigned int host_total = 10;\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n    }\n\n    #pragma acc data copyin(a[0:n], b[0:n])\n    {\n        #pragma acc parallel loop reduction(+:total)\n        for (int x = 0; x < n; ++x) {\n            total += a[x] + b[x];\n        }\n    }\n\n    for (int x = 0; x < n; ++x) {\n        host_total += a[x] + b[x];\n    }\n\n    if (host_total != total) {\n        err += 1;\n    }\n\n    return err;\n}\n#endif\n#ifndef T2\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test2();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 1);\n    }\n#endif\n",
                        "tags": [
                            "parallel",
                            "reduction",
                            "combined-constructs",
                            "loop"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "3": {
                        "content": "#ifndef T3\n//T3:parallel,reduction,combined-constructs,loop,V:1.0-2.7\nint test3(){\n    int err = 0;\n    srand(SEED);\n    unsigned long int * a = (unsigned long int *)malloc(n * sizeof(unsigned long int));\n    unsigned long int * b = (unsigned long int *)malloc(n * sizeof(unsigned long int));\n    unsigned long int total = 10;\n    unsigned long int host_total = 10;\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n    }\n\n    #pragma acc data copyin(a[0:n], b[0:n])\n    {\n        #pragma acc parallel loop reduction(+:total)\n        for (int x = 0; x < n; ++x) {\n            total += a[x] + b[x];\n        }\n    }\n\n    for (int x = 0; x < n; ++x) {\n        host_total += a[x] + b[x];\n    }\n\n    if (host_total != total) {\n        err += 1;\n    }\n\n    return err;\n}\n#endif\n#ifndef T3\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test3();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 2);\n    }\n#endif\n",
                        "tags": [
                            "parallel",
                            "reduction",
                            "combined-constructs",
                            "loop"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "4": {
                        "content": "#ifndef T4\n//T4:parallel,reduction,combined-constructs,loop,V:1.0-2.7\nint test4(){\n    int err = 0;\n    srand(SEED);\n    unsigned long long int * a = (unsigned long long int *)malloc(n * sizeof(unsigned long long int));\n    unsigned long long int * b = (unsigned long long int *)malloc(n * sizeof(unsigned long long int));\n    unsigned long long int total = 10;\n    unsigned long long int host_total = 10;\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n    }\n\n    #pragma acc data copyin(a[0:n], b[0:n])\n    {\n        #pragma acc parallel loop reduction(+:total)\n        for (int x = 0; x < n; ++x) {\n            total += a[x] + b[x];\n        }\n    }\n\n    for (int x = 0; x < n; ++x) {\n        host_total += a[x] + b[x];\n    }\n    \n    if (total != host_total) {\n        err += 1;\n    }\n\n    return err;\n}\n#endif\n#ifndef T4\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test4();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 3);\n    }\n#endif\n",
                        "tags": [
                            "parallel",
                            "reduction",
                            "combined-constructs",
                            "loop"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "5": {
                        "content": "#ifndef T5\n//T5:parallel,reduction,combined-constructs,loop,V:1.0-2.7\nint test5(){\n    int err = 0;\n    srand(SEED);\n    float * a = (float *)malloc(n * sizeof(float));\n    float * b = (float *)malloc(n * sizeof(float));\n    float total = 10;\n    float host_total = 10;\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n    }\n\n    #pragma acc data copyin(a[0:n], b[0:n])\n    {\n        #pragma acc parallel loop reduction(+:total)\n        for (int x = 0; x < n; ++x) {\n            total += a[x] + b[x];\n        }\n    }\n\n    for (int x = 0; x < n; ++x) {\n        host_total += a[x] + b[x];\n    }\n\n    if (fabsf(total - host_total) > PRECISION) {\n        err += 1;\n    }\n\n    return err;\n}\n#endif\n#ifndef T5\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test5();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 4);\n    }\n#endif\n",
                        "tags": [
                            "parallel",
                            "reduction",
                            "combined-constructs",
                            "loop"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "6": {
                        "content": "#ifndef T6\n//T6:parallel,reduction,combined-constructs,loop,V:1.0-2.7\nint test6(){\n    int err = 0;\n    srand(SEED);\n    double * a = (double *)malloc(n * sizeof(double));\n    double * b = (double *)malloc(n * sizeof(double));\n    double total = 10;\n    double host_total = 10;\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n    }\n\n    #pragma acc data copyin(a[0:n], b[0:n])\n    {\n        #pragma acc parallel loop reduction(+:total)\n        for (int x = 0; x < n; ++x) {\n            total += a[x] + b[x];\n        }\n    }\n\n    for (int x = 0; x < n; ++x) {\n        host_total += a[x] + b[x];\n    }\n\n    if (fabs(host_total - total) > PRECISION) {\n        err += 1;\n    }\n\n    return err;\n}\n#endif\n#ifndef T6\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test6();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 5);\n    }\n#endif\n",
                        "tags": [
                            "parallel",
                            "reduction",
                            "combined-constructs",
                            "loop"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "7": {
                        "content": "#ifndef T7\n//T7:parallel,reduction,combined-constructs,loop,V:1.0-2.7\nint test7(){\n    int err = 0;\n    srand(SEED);\n    long double * a = (long double *)malloc(n * sizeof(long double));\n    long double * b = (long double *)malloc(n * sizeof(long double));\n    long double total = 10;\n    long double host_total = 10;\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n    }\n    \n    #pragma acc data copyin(a[0:n], b[0:n])\n    {\n        #pragma acc parallel loop reduction(+:total)\n        for (int x = 0; x < n; ++x){\n            total += a[x] + b[x];\n        }\n    }\n    \n    for (int x = 0; x < n; ++x) {\n        host_total += a[x] + b[x];\n    }\n\n    if (fabsl(host_total - total) > PRECISION) {\n        err += 1;\n    }\n\n    return err;\n}\n#endif\n#ifndef T7\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test7();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 6);\n    }\n#endif\n",
                        "tags": [
                            "parallel",
                            "reduction",
                            "combined-constructs",
                            "loop"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "8": {
                        "content": "#ifndef T8\n//T8:parallel,reduction,combined-constructs,loop,V:1.0-2.7\nint test8(){\n    int err = 0;\n    srand(SEED);\n    float _Complex * a = (float _Complex *)malloc(n * sizeof(float _Complex));\n    float _Complex * b = (float _Complex *)malloc(n * sizeof(float _Complex));\n    float _Complex total = 10 + 10 * I;\n    float _Complex host_total = 10 + 10 * I;\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10) + rand() / (real_t)(RAND_MAX / 10) * I;\n        b[x] = rand() / (real_t)(RAND_MAX / 10) + rand() / (real_t)(RAND_MAX / 10) * I;\n    }\n\n    #pragma acc data copyin(a[0:n], b[0:n])\n    {\n        #pragma acc parallel loop reduction(+:total)\n        for (int x = 0; x < n; ++x) {\n            total += a[x] + b[x];\n        }\n    }\n\n    for (int x = 0; x < n; ++x) {\n        host_total += a[x] + b[x];\n    }\n\n    if (fabsf(crealf(total) - crealf(host_total)) > PRECISION) {\n        err += 1;\n    }\n    if (fabsf(cimagf(total) - cimagf(host_total)) > PRECISION) {\n        err += 1;\n    }\n\n    return err;\n}\n#endif\n#ifndef T8\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test8();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 7);\n    }\n#endif\n",
                        "tags": [
                            "parallel",
                            "reduction",
                            "combined-constructs",
                            "loop"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "parallel_loop_reduction_add_general_type_check_pt3.c": {
                "num tests": 2,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:parallel,reduction,combined-constructs,loop,V:1.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    double _Complex * a = (double _Complex *)malloc(n * sizeof(double _Complex));\n    double _Complex * b = (double _Complex *)malloc(n * sizeof(double _Complex));\n    double _Complex total = 10 + 10 * I;\n    double _Complex host_total = 10 + 10 * I;\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10) + rand() / (real_t)(RAND_MAX / 10) * I;\n        b[x] = rand() / (real_t)(RAND_MAX / 10) + rand() / (real_t)(RAND_MAX / 10) * I;\n    }\n\n    #pragma acc data copyin(a[0:n], b[0:n])\n    {\n        #pragma acc parallel loop reduction(+:total)\n        for (int x = 0; x < n; ++x) {\n            total += a[x] + b[x];\n        }\n    }\n\n    for (int x = 0; x < n; ++x) {\n        host_total += a[x] + b[x];\n    }\n\n    if (fabs(creal(total) - creal(host_total)) > PRECISION) {\n        err += 1;\n    }\n    if (fabs(cimag(total) - cimag(host_total)) > PRECISION) {\n        err += 1;\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "parallel",
                            "reduction",
                            "combined-constructs",
                            "loop"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "2": {
                        "content": "#ifndef T2\n//T2:parallel,reduction,combined-constructs,loop,V:1.0-2.7\nint test2(){\n    int err = 0;\n    srand(SEED);\n    long double _Complex * a = (long double _Complex*)malloc(n * sizeof(long double _Complex));\n    long double _Complex * b = (long double _Complex*)malloc(n * sizeof(long double _Complex));\n    long double _Complex total = 10 + 10 * I;\n    long double _Complex host_total = 10 + 10 * I;\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10) + rand() / (real_t)(RAND_MAX / 10) * I;\n        b[x] = rand() / (real_t)(RAND_MAX / 10) + rand() / (real_t)(RAND_MAX / 10) * I;\n    }\n\n    #pragma acc data copyin(a[0:n], b[0:n])\n    {\n        #pragma acc parallel loop reduction(+:total)\n        for (int x = 0; x < n; ++x) {\n            total += a[x] + b[x];\n        }\n    }\n\n    for (int x = 0; x < n; ++x) {\n        host_total += a[x] + b[x];\n    }\n\n    if (fabsl(creall(total) - creall(host_total)) > PRECISION) {\n        err += 1;\n    }\n    if (fabsl(cimagl(total) - cimagl(host_total)) > PRECISION) {\n        err += 1;\n    }\n\n    return err;\n}\n#endif\n#ifndef T2\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test2();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 1);\n    }\n#endif\n",
                        "tags": [
                            "parallel",
                            "reduction",
                            "combined-constructs",
                            "loop"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "parallel_loop_reduction_add_loop.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:parallel,private,reduction,combined-constructs,loop,V:1.0-2.7\n      LOGICAL FUNCTION test1()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x, y !Iterators\n        REAL(8),DIMENSION(10*LOOPCOUNT):: a, b, c, d !Data\n        REAL(8) :: avg\n        INTEGER :: errors = 0\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(a)\n        CALL RANDOM_NUMBER(b)\n        avg = 0\n        !$acc data copyin(a(1:10*LOOPCOUNT), b(1:10*LOOPCOUNT)) create(c(1:10*LOOPCOUNT)) copyout(d(1:10*LOOPCOUNT))\n          !$acc parallel loop gang private(avg)\n          DO x = 0, 9\n            avg = 0\n            !$acc loop worker reduction(+:avg)\n            DO y = 1, LOOPCOUNT\n              avg = avg + a(x * LOOPCOUNT + y) + b(x * LOOPCOUNT + y)\n              c(x * LOOPCOUNT + y) = a(x * LOOPCOUNT + y) + b(x * LOOPCOUNT + y)\n            END DO\n            avg = avg / LOOPCOUNT\n            !$acc loop worker\n            DO y = 1, LOOPCOUNT\n              d(x * LOOPCOUNT + y) = c(x * LOOPCOUNT + y) / avg\n            END DO\n          END DO\n        !$acc end data\n        DO x = 0, 9\n          avg = 0\n          DO y = 1, LOOPCOUNT\n            avg = avg + a(x * LOOPCOUNT + y) + b(x * LOOPCOUNT + y)\n          END DO\n          avg = avg / LOOPCOUNT\n          DO y = 1, LOOPCOUNT\n            IF (abs(d(x * LOOPCOUNT + y) - ((a(x * LOOPCOUNT + y) + b(x * LOOPCOUNT + y)) / avg)) .gt. PRECISION) THEN\n              errors = errors + 1\n            END IF\n          END DO\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "parallel",
                            "private",
                            "reduction",
                            "combined-constructs",
                            "loop"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "parallel_loop_reduction_add_loop.c": {
                "num tests": 2,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:parallel,loop,reduction,combined-constructs,V:1.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(10 * n * sizeof(real_t));\n    real_t* b = (real_t*)malloc(10 * n * sizeof(real_t));\n    real_t* c = (real_t*)malloc(10 * n * sizeof(real_t));\n    real_t* d = (real_t*)malloc(10 * n * sizeof(real_t));\n    real_t avg = 0.0;\n    real_t rolling_total = 0;\n\n    for (int x = 0; x < 10 * n; ++x) {\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n    }\n\n    #pragma acc data copyin(a[0:10*n], b[0:10*n]) create(c[0:10*n]) copyout(d[0:10*n])\n    {\n        #pragma acc parallel loop gang private(avg)\n        for (int x = 0; x < 10; ++x) {\n            avg = 0;\n            #pragma acc loop worker reduction(+:avg)\n            for (int y = 0; y < n; ++y) {\n                avg += c[x * n + y] = a[x * n + y] + b[x * n + y];\n            }\n            avg = avg / n;\n            #pragma acc loop worker\n            for (int y = 0; y < n; ++y) {\n                d[x * n + y] = c[x * n + y] - avg;\n            }\n        }\n    }\n\n\n    for (int x = 0; x < 10; ++x) {\n        rolling_total = 0;\n        for (int y = 0; y < n; ++y) {\n            rolling_total += a[x * n + y] + b[x * n + y];\n        }\n        rolling_total = rolling_total / n;\n        for (int y = 0; y < n; ++y) {\n            if (fabs(d[x * n + y] - ((a[x * n + y] + b[x * n + y]) - rolling_total)) > PRECISION) {\n                err += 1;\n            }\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "parallel",
                            "loop",
                            "reduction",
                            "combined-constructs"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "2": {
                        "content": "#ifndef T2\n//T2:parallel,loop,reduction,combined-constructs,V:2.7-2.7\nint test2() {\n    int err = 0;\n    srand(SEED);\n    real_t* a = (real_t*)malloc(25 * n * sizeof(real_t));\n    real_t* b = (real_t*)malloc(25 * n * sizeof(real_t));\n    real_t* c = (real_t*)malloc(25 * n * sizeof(real_t));\n    real_t* d = (real_t*)malloc(25 * n * sizeof(real_t));\n    real_t avgs[5];\n    real_t host_avgs[5];\n\n    for (int x = 0; x < 25 * n; ++x) {\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n        c[x] = 0;\n        d[x] = 0;\n    }\n\n    #pragma acc data copyin(a[0:25*n], b[0:25*n]) copyout(c[0:25*n], d[0:25*n])\n    {\n        #pragma acc parallel loop gang private(avgs)\n        for (int x = 0; x < 5; ++x) {\n            for (int y = 0; y < 5; ++y) {\n                avgs[y] = 0;\n            }\n            #pragma acc loop worker reduction(+:avgs)\n            for (int y = 0; y < 5 * n; ++y) {\n                avgs[y % 5] += c[x * 5 * n + y] = a[x * 5 * n + y] + b[x * 5 * n + y];\n            }\n            for (int y = 0; y < 5; ++y) {\n                avgs[y] = avgs[y] / n;\n            }\n            #pragma acc loop worker\n            for (int y = 0; y < 5 * n; ++y) {\n                d[x * 5 * n + y] = c[x * 5 * n + y] - avgs[y % 5];\n            }\n        }\n    }\n\n    for (int x = 0; x < 5; ++x) {\n        for (int y = 0; y < 5; ++y) {\n            host_avgs[y] = 0;\n        }\n        for (int y = 0; y < 5 * n; ++y) {\n            host_avgs[y % 5] += a[x * 5 * n + y] + b[x * 5 * n + y];\n            if (fabs(c[x * 5 * n + y] - (a[x * n * 5 + y] + b[x * n * 5 + y])) > PRECISION) {\n                err += 1;\n            }\n        }\n        for (int y = 0; y < 5; ++y) {\n            host_avgs[y] = host_avgs[y] / n;\n        }\n        for (int y = 0; y < 5 * n; ++y) {\n            if (fabs(d[x * 5 * n + y] - (c[x * 5 * n + y] - host_avgs[y % 5])) > PRECISION){\n                err += 1;\n            \n            }\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T2\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test2();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 1);\n    }\n#endif\n",
                        "tags": [
                            "parallel",
                            "loop",
                            "reduction",
                            "combined-constructs"
                        ],
                        "versions": [
                            "2.7"
                        ]
                    }
                }
            },
            "parallel_loop_reduction_add_loop_type_check_pt1.c": {
                "num tests": 2,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:parallel,private,reduction,combined-constructs,loop,V:1.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    _Bool * a = (_Bool *)malloc(10 * n * sizeof(_Bool));\n    _Bool * b = (_Bool *)malloc(10 * n * sizeof(_Bool));\n    _Bool * c = (_Bool *)malloc(10 * n * sizeof(_Bool));\n    _Bool * d = (_Bool *)malloc(10 * n * sizeof(_Bool));\n    _Bool total = 1;\n    _Bool host_total = 1;\n\n    for (int x = 0; x < 10 * n; ++x){\n        if ((rand() / ((real_t)RAND_MAX)) > .5) {\n            a[x] = 1;\n        }\n        else {\n            a[x] = 0;\n        }\n        if ((rand() / ((real_t)RAND_MAX)) > .5) {\n            b[x] = 1;\n        }\n        else {\n            b[x] = 0;\n        }\n        if ((rand() / ((real_t)RAND_MAX)) > .5) {\n            c[x] = 1;\n        }\n        else {\n            c[x] = 0;\n        }\n    }\n    /*\n    #pragma acc data copyin(a[0:10*n], b[0:10*n], c[0:10*n]) copyout(d[0:10*n])\n    {\n        #pragma acc parallel loop gang private(total)\n        for (int x = 0; x < 10; ++x) {\n            total = 1;\n            #pragma acc loop worker reduction(+:total)\n            for (int y = 0; y < n; ++y) {\n                total += a[x * n + y] + b[x * n + y];\n            }\n            #pragma acc loop worker\n            for (int y = 0; y < n; ++y) {\n                d[x * n + y] = c[x * n + y] + total;\n            }\n        }\n    }\n    */\n    for (int x = 0; x < 10; ++x) {\n        host_total = 1;\n        for (int y = 0; y < n; ++y) {\n            host_total += a[x * n + y] + b[x * n + y];\n        }\n        for (int y = 0; y < n; ++y) {\n            if (d[x * n + y] != (host_total + c[x * n + y])) {\n                err += 1;\n            }\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "parallel",
                            "private",
                            "reduction",
                            "combined-constructs",
                            "loop"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "2": {
                        "content": "#ifndef T2\n//T2:parallel,private,reduction,combined-constructs,loop,V:1.0-2.7\nint test2(){\n    int err = 0;\n    srand(SEED);\n    char * a = (char *)malloc(10 * n * sizeof(char));\n    char * b = (char *)malloc(10 * n * sizeof(char));\n    char * c = (char *)malloc(10 * n * sizeof(char));\n    char * d = (char *)malloc(10 * n * sizeof(char));\n    char total = 10;\n    char host_total = 10;\n    char temp;\n\n    for (int x = 0; x < 10 * n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n        c[x] = rand() / (real_t)(RAND_MAX / 10);\n    }\n\n    #pragma acc data copyin(a[0:10*n],b[0:10*n], c[0:10*n]) copyout(d[0:10*n])\n    {\n        #pragma acc parallel loop gang private(total)\n        for (int x = 0; x < 10; ++x) {\n            total = 10;\n            #pragma acc loop worker reduction(+:total)\n            for (int y = 0; y < n; ++y) {\n                total += a[x * n + y] + b[x * n + y];\n            }\n            #pragma acc loop worker\n            for (int y = 0; y < n; ++y) {\n                d[x * n + y] = c[x * n + y] + total;\n            }\n        }\n    }\n    int error_count = 0;\n    int total_count = 0;\n    for (int x = 0; x < 10; ++x) {\n        host_total = 10;\n        for (int y = 0; y < n; ++y) {\n            host_total += a[x * n + y] + b[x * n + y];\n        }\n        for (int y = 0; y < n; ++y) {\n            temp = host_total + c[x * n + y];\n            if (d[x * n + y] != (host_total + c[x * n + y])) {\n                err += 1;\n                error_count += 1;\n                printf(\"Error location x: %d \\t y: %d\\n\", x, y); \n                printf(\"%d != %d\\n\", d[x * n + y], host_total + c[x * n + y]);\n            }\n            total_count += 1;\n        }\n    }\n\n    printf(\"%d out of %d failed\\n\", error_count, total_count);\n\n    return err;\n}\n#endif\n#ifndef T2\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test2();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 1);\n    }\n#endif\n",
                        "tags": [
                            "parallel",
                            "private",
                            "reduction",
                            "combined-constructs",
                            "loop"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "parallel_loop_reduction_add_vector_loop.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:parallel,private,reduction,combined-constructs,loop,V:1.0-2.7\n      LOGICAL FUNCTION test1()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x, y !Iterators\n        REAL(8),DIMENSION(10*LOOPCOUNT):: a, b !Data\n        REAL(8),DIMENSION(10) :: c\n        REAL(8) :: temp\n        INTEGER :: errors = 0\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(a)\n        CALL RANDOM_NUMBER(b)\n\n        !$acc data copyin(a(1:10*LOOPCOUNT), b(1:10*LOOPCOUNT)) copyout(c(1:10))\n          !$acc parallel loop private(temp)\n          DO x = 0, 9\n            temp = 0.0\n            !$acc loop vector reduction(+:temp)\n            DO y = 1, LOOPCOUNT\n              temp = temp + a(x * LOOPCOUNT + y) + b(x * LOOPCOUNT + y)\n            END DO\n            c(x + 1) = temp\n          END DO\n        !$acc end data\n\n        DO x = 0, 9\n          temp = 0\n          DO y = 1, LOOPCOUNT\n            temp = temp + a(x * LOOPCOUNT + y) + b(x * LOOPCOUNT + y)\n          END DO\n          IF (abs(temp - c(x + 1)) .gt. PRECISION) THEN\n            errors = errors + 1\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "parallel",
                            "private",
                            "reduction",
                            "combined-constructs",
                            "loop"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "parallel_loop_reduction_add_vector_loop.c": {
                "num tests": 2,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:parallel,private,reduction,combined-constructs,loop,V:1.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(10 * n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(10 * n * sizeof(real_t));\n    real_t * c = (real_t *)malloc(10 * sizeof(real_t));\n    real_t temp = 0.0;\n\n    for(int x = 0; x < 10 * n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n    }\n    #pragma acc data copyin(a[0:10*n], b[0:10*n]) copyout(c[0:10])\n    {\n        #pragma acc parallel loop private(temp)\n        for (int x = 0; x < 10; ++x){\n            temp = 0.0;\n            #pragma acc loop vector reduction(+:temp)\n            for (int y = 0; y < n; ++y){\n                temp += a[(x * n) + y] + b[(x * n) + y];\n            }\n            c[x] = temp;\n        }\n    }\n    for (int x = 0; x < 10; ++x){\n        for (int y = 0; y < n; ++y){\n            c[x] -= a[(x * n) + y] + b[(x * n) + y];\n        }\n        if (fabs(c[x]) > PRECISION * (2 * n - 1)){\n            err = 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "parallel",
                            "private",
                            "reduction",
                            "combined-constructs",
                            "loop"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "2": {
                        "content": "#ifndef T2\n//T2:parallel,private,reduction,combined-constructs,loop,V:2.7-2.7\nint test2(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(25 * n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(25 * n * sizeof(real_t));\n    real_t * c = (real_t *)malloc(25 * sizeof(real_t));\n    real_t * c_host = (real_t *)malloc(25 * sizeof(real_t));\n    real_t temp[5];\n\n    for (int x = 0; x < 25 * n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n    }\n\n    for (int x = 0; x < 25; ++x) {\n        c[x] = 0;\n        c_host[x] = 0;\n    }\n\n    #pragma acc data copyin(a[0:25*n], b[0:25*n]) copyout(c[0:25])\n    {\n        #pragma acc parallel loop private(temp)\n        for (int x = 0; x < 5; ++x) {\n            for (int y = 0; y < 5; ++y) {\n                temp[y] = 0;\n            }\n            #pragma acc loop vector reduction(+:temp)\n            for (int y = 0; y < 5 * n; ++y) {\n                temp[y % 5] += a[x * 5 * n + y] + b[x * 5 * n + y];\n            }\n            for (int y = 0; y < 5; ++y) {\n                c[x * 5 + y] = temp[y];\n            }\n        }\n    }\n\n    for (int x = 0; x < 5; ++x) {\n        for (int y = 0; y < 5 * n; ++y) {\n            c_host[x * 5 + (y % 5)] += a[x * 5 * n + y] + b[x * 5 * n + y];\n        }\n    }\n\n    for (int x = 0; x < 25; ++x) {\n        if (fabs(c[x] - c_host[x]) > PRECISION) {\n            err += 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T2\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test2();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 1);\n    }\n#endif\n",
                        "tags": [
                            "parallel",
                            "private",
                            "reduction",
                            "combined-constructs",
                            "loop"
                        ],
                        "versions": [
                            "2.7"
                        ]
                    }
                }
            },
            "parallel_loop_reduction_and_general.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:parallel,reduction,combined-constructs,loop,V:1.0-2.7\n      LOGICAL FUNCTION test1()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT):: randoms\n        LOGICAL,DIMENSION(LOOPCOUNT):: a !Data\n        LOGICAL :: results = .TRUE.\n        LOGICAL :: host_results = .TRUE.\n        REAL(8) :: false_margin\n        INTEGER :: errors = 0\n        false_margin = exp(log(.5) / LOOPCOUNT)\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(randoms)\n        DO x = 1, LOOPCOUNT\n          IF (randoms(x) .lt. false_margin) THEN\n            a(x) = .TRUE.\n          ELSE\n            a(x) = .FALSE.\n          END IF\n        END DO\n\n        !$acc data copyin(a(1:LOOPCOUNT))\n          !$acc parallel loop reduction(.and.:results)\n          DO x = 1, LOOPCOUNT\n            results = results .and. a(x)\n          END DO\n        !$acc end data\n\n        DO x = 1, LOOPCOUNT\n          host_results = host_results .and. a(x)\n        END DO\n        IF (host_results .neqv. results) THEN\n          errors = 1\n        END IF\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "parallel",
                            "reduction",
                            "combined-constructs",
                            "loop"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "parallel_loop_reduction_and_general.c": {
                "num tests": 2,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:parallel,loop,reduction,combined-constructs,V:1.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n\n    char * a = (char *)malloc(n * sizeof(char));\n    real_t false_margin = pow(exp(1), log(.5)/n);\n    char result = 1;\n    char found = 0;\n\n    for (int x = 0; x < n; ++x){\n        if(rand() / (real_t)(RAND_MAX) < false_margin){\n            a[x] = 1;\n        }\n        else{\n            a[x] = 0;\n        }\n    }\n\n    #pragma acc data copyin(a[0:n])\n    {\n        #pragma acc parallel loop reduction(&&:result)\n        for (int x = 0; x < n; ++x){\n            result = result && a[x];\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        if (a[x] == 0){\n            found = 1;\n            break;\n        }\n    }\n    if (found == result){\n        err = 1;\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "parallel",
                            "loop",
                            "reduction",
                            "combined-constructs"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "2": {
                        "content": "#ifndef T2\n//T2:parallel,combined-constructs,loop,V:2.7-2.7\nint test2(){\n    int err = 0;\n    srand(SEED);\n    char * a = (char *)malloc(n * 5 * sizeof(char));\n    real_t false_margin = pow(exp(1), log(.5/n));\n    char result[5];\n    char host_result[5];\n\n    for (int x = 0; x < 5; ++x) {\n        result[x] = 1;\n        host_result[x] = 1;\n    }\n\n    for (int x = 0; x < 5 * n; ++x) {\n        if (rand() / (real_t)(RAND_MAX) < false_margin) {\n            a[x] = 1;\n        }\n        else {\n            a[x] = 0;\n        }\n    }\n\n    #pragma acc data copyin(a[0:5*n])\n    {\n        #pragma acc parallel loop reduction(&&:result)\n        for (int x = 0; x < 5 * n; ++x) {\n            result[x%5] = result[x%5] && a[x];\n        }\n    }\n\n    for (int x = 0; x < 5 * n; ++x) {\n        host_result[x%5] = host_result[x%5] && a[x];\n    }\n\n    for (int x = 0; x < 5; ++x){\n        if (host_result[x] != result[x]) {\n            err += 1;\n        } \n    }\n\n    return err;\n}\n#endif\n#ifndef T2\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test2();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 1);\n    }\n#endif\n",
                        "tags": [
                            "parallel",
                            "combined-constructs",
                            "loop"
                        ],
                        "versions": [
                            "2.7"
                        ]
                    }
                }
            },
            "parallel_loop_reduction_and_loop.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:parallel,reduction,combined-constructs,loop,V:1.0-2.7\n      LOGICAL FUNCTION test1()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x, y !Iterators\n        LOGICAL,DIMENSION(10*LOOPCOUNT):: a, a_copy !Data\n        LOGICAL,DIMENSION(10) :: results, has_false\n        LOGICAL :: host_results = .TRUE.\n        LOGICAL :: temp = .TRUE.\n        REAL(8),DIMENSION(10*LOOPCOUNT):: randoms\n        REAL(8) :: false_margin = exp(log(.5) / LOOPCOUNT)\n        INTEGER :: errors = 0\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(randoms)\n        DO x = 1, 10\n          results(x) = .TRUE.\n          has_false(x) = .FALSE.\n        END DO\n        DO x = 1, 10*LOOPCOUNT\n          IF (randoms(x) .lt. false_margin) THEN\n            a(x) = .TRUE.\n            a_copy(x) = .TRUE.\n          ELSE\n            a(x) = .FALSE.\n            a_copy(x) = .FALSE.\n            has_false(x / LOOPCOUNT) = .TRUE.\n          END IF\n        END DO\n\n        !$acc data copy(a(1:10*LOOPCOUNT), results(1:10))\n          !$acc parallel loop gang\n          DO x = 0, 9\n            temp = .TRUE.\n            !$acc loop worker reduction(.AND.:temp)\n            DO y = 1, LOOPCOUNT\n              temp = temp .AND. a(x * LOOPCOUNT + y)\n            END DO\n            results(x + 1) = temp\n            !$acc loop worker\n            DO y = 1, LOOPCOUNT\n              IF (temp .eqv. .TRUE.) THEN\n                IF (a(x * LOOPCOUNT + y) .eqv. .TRUE.) THEN\n                  a(x * LOOPCOUNT + y) = .FALSE.\n                ELSE\n                  a(x * LOOPCOUNT + y) = .TRUE.\n                END IF\n              END IF\n            END DO\n          END DO\n        !$acc end data\n        DO x = 0, 9\n          temp = .TRUE.\n          DO y = 1, LOOPCOUNT\n            temp = temp .AND. a_copy(x * LOOPCOUNT + y)\n          END DO\n          IF (temp .neqv. results(x + 1)) THEN\n            errors = errors + 1\n          END IF\n          DO y = 1, LOOPCOUNT\n            IF (temp .eqv. .TRUE.) THEN\n              IF (a(x * LOOPCOUNT + y) .eqv. a_copy(x * LOOPCOUNT + y)) THEN\n                errors = errors + 1\n              END IF\n            ELSE\n              IF (a(x * LOOPCOUNT + y) .neqv. a_copy(x * LOOPCOUNT + y)) THEN\n                errors = errors + 1\n              END IF\n            END IF\n          END DO\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "parallel",
                            "reduction",
                            "combined-constructs",
                            "loop"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "parallel_loop_reduction_and_loop.c": {
                "num tests": 2,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:parallel,loop,reduction,combined-constructs,V:1.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    char * a = (char *)malloc(10 * n * sizeof(char));\n    char * a_copy = (char *)malloc(10 * n * sizeof(char));\n    char * has_false = (char *)malloc(10 * sizeof(char));\n    real_t false_margin = pow(exp(1), log(.5)/n);\n    char temp = 1;\n\n    for (int x = 0; x < 10; ++x){\n        has_false[x] = 0;\n    }\n\n    for (int x = 0; x < 10; ++x){\n        for (int y = 0; y < n; ++y){\n            if (rand() / (real_t)(RAND_MAX) < false_margin){\n                a[x * n + y] = 1;\n                a_copy[x * n + y] = 1;\n            }\n            else {\n                a[x * n + y] = 0;\n                a_copy[x * n + y] = 0;\n                has_false[x] = 1;\n            }\n        }\n    }\n\n    #pragma acc data copy(a[0:10*n])\n    {\n        #pragma acc parallel loop gang private(temp)\n        for (int x = 0; x < 10; ++x){\n            temp = 1;\n            #pragma acc loop worker reduction(&&:temp)\n            for (int y = 0; y < n; ++y){\n                temp = temp && a[x * n + y];\n            }\n            #pragma acc loop worker\n            for (int y = 0; y < n; ++y){\n                a[x * n + y] = a[x * n + y] ^ temp;\n            }\n        }\n    }\n\n\n    for (int x = 0; x < 10; ++x){\n        for (int y = 0; y < n; ++y){\n            if (has_false[x] == 1 && a[x * n + y] != a_copy[x * n + y]){\n                err = 1;\n            }\n            else if (has_false[x] == 0 && a[x * n + y] == a_copy[x * n + y]){\n                err = 1;\n            }\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "parallel",
                            "loop",
                            "reduction",
                            "combined-constructs"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "2": {
                        "content": "#ifndef T2\n//T2:parallel,private,reduction,combined-constructs,loop,V:2.7-2.7\nint test2(){\n    int err = 0;\n    srand(SEED);\n    char * a = (char *)malloc(n * 25 * sizeof(char));\n    char * a_copy = (char *)malloc(n * 25 * sizeof(char));\n    char * has_false = (char *)malloc(25 * sizeof(char));\n    real_t false_margin = pow(exp(1), log(.5)/n);\n    char device[5];\n    char host[5];\n\n    for (int x = 0; x < 5; ++x) {\n        device[x] = 1;\n        host[x] = 1;\n        for (int y = 0; y < 5; ++y) {\n            has_false[x * 5 + y] = 0;\n        }\n    }\n\n    for (int x = 0; x < 25 * n; ++x){\n        if (rand() / (real_t)(RAND_MAX) < false_margin) {\n            a[x] = 1;\n            a_copy[x] = 1;\n        }\n        else {\n            a[x] = 0;\n            a_copy[x] = 0;\n            has_false[x % 25] = 1;\n        }\n    }\n\n    #pragma acc data copy(a[0:25*n])\n    {\n        #pragma acc parallel loop gang private(device)\n        for (int x = 0; x < 5; ++x) {\n            for (int y = 0; y < 5; ++y) {\n                device[y] = 1;\n            }\n            #pragma acc loop worker reduction(&&:device)\n            for (int y = 0; y < 5 * n; ++y) {\n                device[y%5] = device[y%5] && a[x * 5 * n + y];\n            }\n            #pragma acc loop worker\n            for (int y = 0; y < 5 * n; ++y) {\n                a[x * 5 * n + y] = a[x * 5 * n + y] ^ device[y%5];\n            }\n        }\n    }\n\n    for (int x = 0; x < 5; ++x) {\n        for (int y = 0; y < 5; ++y) {\n            host[y] = 1;\n        }\n        for (int y = 0; y < 5 * n; ++y) {\n            host[y%5] = host[y%5] && a_copy[x * 5 * n + y];\n        }\n        for (int y = 0; y < 5 * n; ++y) {\n            if (a[x * 5 * n + y] != (a_copy[x * 5 * n + y] ^ host[y % 5])) {\n                err += 1;\n            }\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T2\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test2();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 1);\n    }\n#endif\n",
                        "tags": [
                            "parallel",
                            "private",
                            "reduction",
                            "combined-constructs",
                            "loop"
                        ],
                        "versions": [
                            "2.7"
                        ]
                    }
                }
            },
            "parallel_loop_reduction_and_vector_loop.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:parallel,private,reduction,combined-constructs,loop,V:1.0-2.7\n      LOGICAL FUNCTION test1()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x, y !Iterators\n        LOGICAL,DIMENSION(10*LOOPCOUNT):: a !Data\n        LOGICAL,DIMENSION(10):: b\n        LOGICAL,DIMENSION(10):: has_false\n        LOGICAL :: temp\n        REAL(8) :: false_margin\n        REAL(8),DIMENSION(10*LOOPCOUNT) :: randoms\n        INTEGER :: errors = 0\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(randoms)\n        false_margin = exp(log(.5) / LOOPCOUNT)\n        DO x = 1, 10\n          has_false(x) = .FALSE.\n          b(x) = .TRUE.\n        END DO\n\n        DO x = 0, 9\n          DO y = 1, LOOPCOUNT\n            IF (randoms(x * LOOPCOUNT + y) .lt. false_margin) THEN\n              a(x * LOOPCOUNT + y) = .TRUE.\n            ELSE\n              a(x * LOOPCOUNT + y) = .FALSE.\n              has_false(x + 1) = .TRUE.\n            END IF\n          END DO\n        END DO\n\n        !$acc data copyin(a(1:10*LOOPCOUNT)) copy(b(1:10))\n          !$acc parallel loop private(temp)\n          DO x = 0, 9\n            temp = .TRUE.\n            !$acc loop vector reduction(.AND.:temp)\n            DO y = 1, LOOPCOUNT\n              temp = temp .AND. a(x * LOOPCOUNT + y)\n            END DO\n            b(x + 1) = temp\n          END DO\n        !$acc end data\n\n        DO x = 0, 9\n          temp = .FALSE.\n          DO y = 1, LOOPCOUNT\n            IF (a(x * LOOPCOUNT + y) .eqv. .FALSE.) THEN\n              temp = .TRUE.\n            END IF\n          END DO\n          IF (temp .neqv. has_false(x + 1)) THEN\n            errors = 1\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "parallel",
                            "private",
                            "reduction",
                            "combined-constructs",
                            "loop"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "parallel_loop_reduction_and_vector_loop.c": {
                "num tests": 2,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:parallel,loop,reduction,combined-constructs,V:1.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    char * a = (char *)malloc(10 * n * sizeof(char));\n    char * b = (char *)malloc(10 * sizeof(char));\n    char * has_false = (char *)malloc(10 * sizeof(char));\n    real_t false_margin = pow(exp(1), log(.5)/n);\n    char temp = 1;\n\n    for (int x = 0; x < 10; ++x){\n        has_false[x] = 0;\n    }\n    for (int x = 0; x < 10 * n; ++x){\n        if(rand() / (real_t)(RAND_MAX) < false_margin){\n            a[x] = 1;\n        }\n        else{\n            a[x] = 0;\n            has_false[x/n] = 1;\n        }\n    }\n    #pragma acc data copyin(a[0:10*n]) copy(b[0:10])\n    {\n        #pragma acc parallel loop private(temp)\n        for (int x = 0; x < 10; ++x){\n            temp = 1;\n            #pragma acc loop vector reduction(&&:temp)\n            for (int y = 0; y < n; ++y){\n                temp = temp && a[x * n + y];\n            }\n            b[x] = temp;\n        }\n    }\n    for (int x = 0; x < 10; ++x){\n        if (has_false[x] == b[x]){\n            err = 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "parallel",
                            "loop",
                            "reduction",
                            "combined-constructs"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "2": {
                        "content": "#ifndef T2\n//T2:parallel,private,reduction,combined-constructs,loop,V:2.7-2.7\nint test2(){\n    int err = 0;\n    srand(SEED);\n    char * a = (char *)malloc(25 * n * sizeof(char));\n    char * b = (char *)malloc(25 * sizeof(char));\n    char * has_false = (char *)malloc(25 * sizeof(char));\n    real_t false_margin = pow(exp(1), log(.5)/n);\n    char device[5];\n    char host[5];\n\n    for (int x = 0; x < 5; ++x) {\n        for (int y = 0; y < 5 * n; ++y){\n            if (rand() / (real_t)(RAND_MAX) < false_margin) {\n                a[x] = 1;\n            }\n            else {\n                a[x] = 0;\n                has_false[x * 5 + y % 5];\n            }\n        }\n    }\n\n    #pragma acc data copyin(a[0:25*n]) copy(b[0:25])\n    {\n        #pragma acc parallel loop private(device)\n        for (int x = 0; x < 5; ++x) {\n            for (int y = 0; y < 5; ++y) {\n                device[y] = 1;\n            }\n            #pragma acc loop vector reduction(&&:device)\n            for (int y = 0; y < 5 * n; ++y) {\n                device[y%5] = device[y%5] && a[x * 5 * n + y];\n            }\n            for (int y = 0; y < 5; ++y){\n                b[x * 5 + y] = device[y];\n            }\n        }\n    }\n\n    for (int x = 0; x < 5; ++x) {\n        for (int y = 0; y < 5; ++y) {\n            host[y] = 1;\n        }\n        for (int y = 0; y < 5 * n; ++y) {\n            host[y%5] = host[y%5] && a[x * 5 * n + y];\n        }\n        for (int y = 0; y < 5; ++y) {\n            if (b[x * 5 + y] != host[y]) {\n                err += 1;\n            }\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T2\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test2();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 1);\n    }\n#endif\n",
                        "tags": [
                            "parallel",
                            "private",
                            "reduction",
                            "combined-constructs",
                            "loop"
                        ],
                        "versions": [
                            "2.7"
                        ]
                    }
                }
            },
            "parallel_loop_reduction_bitand_general.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:parallel,reduction,combined-constructs,loop,V:1.0-2.7\n      LOGICAL FUNCTION test1()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x, y, z !Iterators\n        INTEGER,DIMENSION(LOOPCOUNT):: a !Data\n        INTEGER :: b\n        REAL(8),DIMENSION(16 * LOOPCOUNT):: randoms\n        REAL(8) :: false_margin\n        INTEGER :: errors = 0\n        INTEGER :: temp = 1\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(randoms)\n        false_margin = exp(log(.5)/n)\n        DO x = 1, LOOPCOUNT\n          DO y = 0, 15\n            IF (randoms(y * LOOPCOUNT + x) .lt. false_margin) THEN\n              temp = 1\n              DO z = 0, y\n                temp = temp * 2\n              END DO\n              a(x) = a(x) + temp\n            END IF\n          END DO\n        END DO\n        \n        b = a(1)\n\n        !$acc data copyin(a(1:LOOPCOUNT))\n          !$acc parallel loop reduction(iand:b)\n          DO x = 1, LOOPCOUNT\n            b = iand(b, a(x))\n          END DO\n        !$acc end data\n \n        temp = a(1)\n        DO x = 2, LOOPCOUNT\n          temp = iand(a(x), temp)\n        END DO\n        IF (temp .ne. b) THEN\n          WRITE(*, *) temp\n          WRITE(*, *) b\n          errors = 1\n        END IF\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "parallel",
                            "reduction",
                            "combined-constructs",
                            "loop"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "parallel_loop_reduction_bitand_general.c": {
                "num tests": 2,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:parallel,loop,reduction,combined-constructs,V:1.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    n = 10;\n    unsigned int * a = (unsigned int *)malloc(n * sizeof(unsigned int));\n    real_t false_margin = pow(exp(1), log(.5)/n);\n    unsigned int temp = 1;\n    unsigned int b;\n    unsigned int host_b;\n\n    for (int x = 0; x < n; ++x){\n        a[x] = 0;\n        for (int y = 0; y < 16; ++y){\n            if (rand() / (real_t) RAND_MAX < false_margin){\n                for (int z = 0; z < y; ++z){\n                    temp *= 2;\n                }\n                a[x] += temp;\n                temp = 1;\n            }\n        }\n    }\n\n    b = a[0];\n    host_b = a[0];\n\n    #pragma acc data copyin(a[0:n])\n    {\n        #pragma acc parallel loop reduction(&:b)\n        for (int x = 0; x < n; ++x){\n            b = b & a[x];\n        }\n    }\n\n    for (int x = 1; x < n; ++x){\n        host_b = host_b & a[x];\n    }\n    if (b != host_b){\n        err = 1;\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "parallel",
                            "loop",
                            "reduction",
                            "combined-constructs"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "2": {
                        "content": "#ifndef T2\n//T2:parallel,reduction,combined-constructs,loop,V:2.7-2.7\nint test2(){\n    int err = 0;\n    srand(SEED);\n    unsigned int * a = (unsigned int *)malloc(10 * n * sizeof(int));\n    real_t false_margin = pow(exp(1), log(.5)/n);\n    unsigned int device[10];\n    unsigned int host[10];\n\n    for (int x = 0; x < 10 * n; ++x) {\n        a[x] = 0;\n        for (int y = 0; y < 16; ++y){\n            if (rand() / (real_t)RAND_MAX < false_margin) {\n                a[x] += 1<<y;\n            }\n        }\n    }\n\n    for (int x = 0; x < 10; ++x) {\n        device[x] = 0;\n        host[x] = 0;\n        for (int y = 0; y < 16; ++y) {\n            device[x] += 1<<y;\n            host[x] += 1<<y;\n        }\n    }\n\n    #pragma acc data copyin(a[0:10*n])\n    {\n        #pragma acc parallel loop reduction(&:device)\n        for (int x = 0; x < 10 * n; ++x) {\n            device[x%10] = device[x%10] & a[x];\n        }\n    }\n\n    for (int x = 0; x < 10 * n; ++x) {\n        host[x%10] = host[x%10] & a[x];\n    }\n\n    for (int x = 0; x < 10; ++x) {\n        if (host[x] != device[x]) {\n            err += 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T2\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test2();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 1);\n    }\n#endif\n",
                        "tags": [
                            "parallel",
                            "reduction",
                            "combined-constructs",
                            "loop"
                        ],
                        "versions": [
                            "2.7"
                        ]
                    }
                }
            },
            "parallel_loop_reduction_bitand_loop.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:parallel,private,reduction,combined-constructs,loop,V:1.0-2.7\n      LOGICAL FUNCTION test1()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x, y, z !Iterators\n        INTEGER,DIMENSION(10*LOOPCOUNT):: a, b, b_copy !Data\n        REAL(8),DIMENSION(10*LOOPCOUNT):: randoms2\n        INTEGER,DIMENSION(10) :: c\n        REAL(8) :: false_margin\n        REAL(8),DIMENSION(160*LOOPCOUNT)::randoms\n        INTEGER :: errors = 0\n        INTEGER :: temp\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(randoms)\n        CALL RANDOM_NUMBER(randoms2)\n        b = FLOOR(10000 * randoms2)\n        b_copy = b\n        false_margin = exp(log(.5)/LOOPCOUNT)\n        DO x = 1, 10 * LOOPCOUNT\n          DO y = 1, 16\n            IF (randoms((y - 1) * 10 * LOOPCOUNT + x) < false_margin) THEN\n              temp = 1\n              DO z = 1, y\n                temp = temp * 2\n              END DO\n              a(x) = a(x) + temp\n            END IF\n          END DO\n        END DO\n        \n        DO x = 1, 10\n         c(x) = a((x - 1) * LOOPCOUNT + x)\n        END DO\n        \n        \n\n        !$acc data copyin(a(1:10*LOOPCOUNT)) copy(b(1:10*LOOPCOUNT), c(1:10))\n          !$acc parallel loop gang private(temp)\n          DO x = 1, 10\n            temp = a((x - 1) * LOOPCOUNT + 1)\n            !$acc loop worker reduction(iand:temp)\n            DO y = 2, LOOPCOUNT\n              temp = iand(temp, a((x - 1) * LOOPCOUNT + y))\n            END DO\n            c(x) = temp\n            !$acc loop worker\n            DO y = 1, LOOPCOUNT\n              b((x - 1) * LOOPCOUNT + y) = b((x - 1) * LOOPCOUNT + y) + c(x)\n            END DO\n          END DO\n        !$acc end data\n\n       DO x = 1, 10\n         temp = a((x - 1) * LOOPCOUNT + 1)\n         DO y = 2, LOOPCOUNT\n           temp = iand(temp, a((x - 1) * LOOPCOUNT + y))\n         END DO\n         IF (temp .ne. c(x)) THEN\n           errors = errors + 1\n         END IF\n         DO y = 1, LOOPCOUNT\n           IF (b((x - 1) * LOOPCOUNT + y) .ne. b_copy((x - 1) * LOOPCOUNT + y) + temp) THEN\n             errors = errors + 1\n           END IF\n         END DO\n       END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "parallel",
                            "private",
                            "reduction",
                            "combined-constructs",
                            "loop"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "parallel_loop_reduction_bitand_loop.c": {
                "num tests": 2,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:parallel,loop,reduction,combined-constructs,V:1.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    unsigned int * a = (unsigned int *)malloc(10 * n * sizeof(unsigned int));\n    unsigned int * b = (unsigned int *)malloc(10 * n * sizeof(unsigned int));\n    unsigned int * b_copy = (unsigned int *)malloc(10 * n * sizeof(unsigned int));\n    unsigned int * c = (unsigned int *)malloc(10 * sizeof(unsigned int));\n    unsigned int * host_c = (unsigned int *)malloc(10 * sizeof(unsigned int));\n\n    real_t false_margin = pow(exp(1), log(.5)/n);\n    unsigned int temp = 1;\n\n    for (int x = 0; x < 10 * n; ++x){\n        a[x] = 0;\n        b[x] = (unsigned int) rand() / (real_t)(RAND_MAX / 1000);\n        b_copy[x] = b[x];\n        for (int y = 0; y < 16; ++y){\n            if (rand() / (real_t) RAND_MAX < false_margin){\n                a[x] += 1 << y;\n            }\n        }\n    }\n    #pragma acc data copyin(a[0:10 * n]) copy(b[0:10 * n], c[0:10])\n    {\n        #pragma acc parallel loop gang private(temp)\n        for (int y = 0; y < 10; ++y){\n            temp = a[y * n];\n            #pragma acc loop worker reduction(&:temp)\n            for (int x = 1; x < n; ++x){\n                temp = temp & a[y * n + x];\n            }\n            c[y] = temp;\n            #pragma acc loop worker\n            for (int x = 0; x < n; ++x){\n                b[y * n + x] = b[y * n + x] + c[y];\n            }\n        }\n    }\n    for (int x = 0; x < 10; ++x){\n        host_c[x] = a[x * n];\n        for (int y = 1; y < n; ++y){\n            host_c[x] = host_c[x] & a[x * n + y];\n        }\n        if (host_c[x] != c[x]){\n          err += 1;\n        }\n    }\n\n    for (int x = 0; x < 10; ++x){\n        for (int y = 0; y < n; ++y){\n            if (b[x * n + y] != b_copy[x * n + y] + c[x]){\n                err += 1;\n            }\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "parallel",
                            "loop",
                            "reduction",
                            "combined-constructs"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "2": {
                        "content": "#ifndef T2\n//T2:parallel,private,reduction,combined-constructs,loop,V:2.7-2.7\nint test2(){\n    int err = 0;\n    srand(SEED);\n    unsigned int * a = (unsigned int *)malloc(25 * n * sizeof(unsigned int));\n    unsigned int * b = (unsigned int *)malloc(25 * n * sizeof(unsigned int));\n    unsigned int * b_copy = (unsigned int *)malloc(25 * n * sizeof(unsigned int));\n    unsigned int * c = (unsigned int *)malloc(25 * sizeof(unsigned int));\n    unsigned int device[5];\n    unsigned int host[5];\n\n    real_t false_margin = pow(exp(1), log(.5)/n);\n    \n    for (int x = 0; x < 25 * n; ++x){\n        a[x] = 0;\n        b[x] = (unsigned int) rand() / (real_t)(RAND_MAX / 1000);\n        b_copy[x] = b[x];\n        for (int y = 0; y < 16; ++y) {\n            if (rand() / (real_t)RAND_MAX < false_margin) {\n                a[x] += 1 << y;\n            }\n        }\n    }\n\n    #pragma acc data copyin(a[0:25*n]) copy(b[0:25*n], c[0:25])\n    {\n        #pragma acc parallel loop gang private(device)\n        for (int x = 0; x < 5; ++x) {\n            for (int y = 0; y < 5; ++y) {\n                device[y] = a[x * 5 * n + y];\n            }\n            #pragma acc loop worker reduction(&:device)\n            for (int y = 0; y < 5 * n; ++y) {\n                device[y%5] = device[y%5] & a[x * 5 * n + y];\n            }\n            for (int y = 0; y < 5; ++y) {\n                c[x * 5 + y] = device[y];\n            }\n            #pragma acc loop worker\n            for (int y = 0; y < 5 * n; ++y) {\n                b[x * 5 * n + y] = b[x * 5 * n + y] + c[x * 5 + (y % 5)];\n            }\n        }\n    }\n\n    for (int x = 0; x < 5; ++x) {\n        for (int y = 0; y < 5; ++y) {\n            host[y] = a[x * 5 * n + y];\n        }\n        for (int y = 0; y < 5 * n; ++y) {\n            host[y%5] = host[y%5] & a[x * 5 * n + y];\n        }\n        for (int y = 0; y < 5; ++y) {\n            if (host[y] != c[x * 5 + y]) {\n                err += 1;\n            }\n        }\n        for (int y = 0; y < 5 * n; ++y) {\n            if (b[x * 5 * n + y] != (host[y%5] + b_copy[x * 5 * n + y])) {\n                err += 1;\n            }\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T2\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test2();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 1);\n    }\n#endif\n",
                        "tags": [
                            "parallel",
                            "private",
                            "reduction",
                            "combined-constructs",
                            "loop"
                        ],
                        "versions": [
                            "2.7"
                        ]
                    }
                }
            },
            "parallel_loop_reduction_bitand_vector_loop.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:parallel,private,reduction,combined-constructs,loop,V:1.0-2.7\n      LOGICAL FUNCTION test1()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x, y, z, i !Iterators\n        INTEGER,DIMENSION(10*LOOPCOUNT):: a !Data\n        INTEGER,DIMENSION(10):: b\n        INTEGER :: c\n        REAL(8),DIMENSION(160*LOOPCOUNT):: random\n        REAL(8) :: false_margin\n        INTEGER :: errors = 0\n        INTEGER :: temp\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(random)\n        false_margin = exp(log(.5) / n)\n        DO x = 0, 9\n          DO y = 1, LOOPCOUNT\n            DO z = 1, 16\n              IF (random(x * 16 * LOOPCOUNT + (y - 1) * 16 + z - 1) < false_margin) THEN\n                temp = 1\n                DO i = 1, z\n                  temp = temp * 2\n                END DO\n                a(x * LOOPCOUNT + y) = a(x * LOOPCOUNT + y) + temp\n              END IF\n            END DO\n          END DO\n        END DO\n                \n        !$acc data copyin(a(1:10*LOOPCOUNT)), copy(b(1:10))\n          !$acc parallel loop private(c)\n          DO x = 0, 9\n            c = a(x * LOOPCOUNT + 1)\n            !$acc loop vector reduction(iand:c)\n            DO y = 1, LOOPCOUNT\n              c = iand(c, a(x * LOOPCOUNT + y))\n            END DO\n            b(x + 1) = c\n          END DO\n        !$acc end data\n\n        DO x = 0, 9\n          temp = a(x * LOOPCOUNT + 1)\n          DO y = 2, LOOPCOUNT\n            temp = iand(temp, a(x * LOOPCOUNT + y))\n          END DO\n          IF (b(x + 1) .ne. temp) THEN\n            errors = errors + 1\n          END IF\n        END DO       \n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "parallel",
                            "private",
                            "reduction",
                            "combined-constructs",
                            "loop"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "parallel_loop_reduction_bitand_vector_loop.c": {
                "num tests": 2,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:parallel,loop,reduction,combined-constructs,V:1.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    unsigned int* a = (unsigned int *)malloc(10 * n * sizeof(unsigned int));\n    unsigned int* b = (unsigned int *)malloc(10 * sizeof(unsigned int));\n\n    real_t false_margin = pow(exp(1), log(.5)/n);\n    unsigned int temp = 1;\n    unsigned int c = 0;\n    unsigned int b_host;\n\n    for (int x = 0; x < 10 * n; ++x){\n        a[x] = 0;\n        for (int y = 0; y < 16; ++y){\n            if (rand() / (real_t) RAND_MAX < false_margin){\n                a[x] += 1 << y;\n            }\n        }\n    }\n\n    #pragma acc data copyin(a[0:10*n]) copyout(b[0:10])\n    {\n        #pragma acc parallel loop private(c)\n        for (int x = 0; x < 10; ++x){\n            c = a[x * n];\n            #pragma acc loop vector reduction(&:c)\n            for (int y = 1; y < n; ++y){\n                c = c & a[x * n + y];\n            }\n            b[x] = c;\n        }\n    }\n    for (int x = 0; x < 10; ++x){\n        b_host = a[x * n];\n        for (int y = 1; y < n; ++y){\n            b_host = b_host & a[x * n + y];\n        }\n        if (b_host != b[x]){\n            err = 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "parallel",
                            "loop",
                            "reduction",
                            "combined-constructs"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "2": {
                        "content": "#ifndef T2\n//T2:parallel,private,reduction,combined-constructs,loop,V:2.7-2.7\nint test2(){\n    int err = 0;\n    srand(SEED);\n    unsigned int * a = (unsigned int *)malloc(25 * n * sizeof(unsigned int));\n    unsigned int * b = (unsigned int *)malloc(25 * sizeof(unsigned int));\n    real_t false_margin = pow(exp(1), log(.5)/n);\n    unsigned int c[5];\n    unsigned int * b_host = (unsigned int *)malloc(5 * sizeof(unsigned int));\n    \n\n    for (int x = 0; x < 25 * n; ++x){\n        a[x] = 0;\n        for (int y = 0; y < 16; ++y) {\n            if (rand() / (real_t)RAND_MAX < false_margin) {\n                a[x] += 1 << y;\n            }\n        }\n    }\n\n    #pragma acc data copyin(a[0:25*n]) copyout(b[0:25])\n    {\n        #pragma acc parallel loop private(c)\n        for (int x = 0; x < 5; ++x) {\n            for (int y = 0; y < 5; ++y) {\n                c[y] = a[x * 5 * n + y];\n            }\n            #pragma acc loop vector reduction(&:c)\n            for (int y = 0; y < 5 * n; ++y) {\n                c[y%5] = c[y%5] & a[x * 5 * n + y];\n            }\n            for (int y = 0; y < 5; ++y) {\n                b[x * 5 + y] = c[y];\n            }\n        }\n    }\n\n    for (int x = 0; x < 5; ++x) {\n        for (int y = 0; y < 5; ++y) {\n            b_host[y] = a[x * 5 * n + y];\n        }\n        for (int y = 0; y < 5 * n; ++y) {\n            b_host[y%5] = b_host[y%5] & a[x * 5 * n + y];\n        }\n        for (int y = 0; y < 5; ++y) {\n            if (b_host[y] != b[x * 5 + y]){\n                err += 1;\n            }\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T2\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test2();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 1);\n    }\n#endif\n",
                        "tags": [
                            "parallel",
                            "private",
                            "reduction",
                            "combined-constructs",
                            "loop"
                        ],
                        "versions": [
                            "2.7"
                        ]
                    }
                }
            },
            "parallel_loop_reduction_bitor_general.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:parallel,reduction,combined-constructs,loop,V:1.0-2.7\n      LOGICAL FUNCTION test1()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x, y, z !Iterators\n        INTEGER,DIMENSION(LOOPCOUNT):: a !Data\n        REAL(8) :: false_margin\n        REAL(8),DIMENSION(16*LOOPCOUNT):: random\n        INTEGER :: errors = 0\n        INTEGER :: temp\n        INTEGER :: b\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(random)\n        false_margin = exp(log(.5)/n)\n        DO x = 1, LOOPCOUNT\n          DO y = 1, 16\n            IF (random((y - 1) * LOOPCOUNT + x) < false_margin) THEN\n              temp = 1\n              DO z = 1, y\n                temp = temp * 2\n              END DO\n              a(x) = a(x) + temp\n            END IF\n          END DO\n        END DO\n        b = a(1)\n        !$acc data copyin(a(1:LOOPCOUNT))\n          !$acc parallel loop reduction(ior:b)\n          DO x = 2, LOOPCOUNT\n            b = ior(b, a(x))\n          END DO\n        !$acc end data\n        temp = a(1)\n        DO x = 2, LOOPCOUNT\n          temp = ior(temp, a(x))\n        END DO\n        IF (temp .ne. b) THEN\n          errors = errors + 1\n        END IF\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "parallel",
                            "reduction",
                            "combined-constructs",
                            "loop"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "parallel_loop_reduction_bitor_general.c": {
                "num tests": 2,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:parallel,loop,reduction,combined-constructs,V:1.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    unsigned int * a = (unsigned int *)malloc(n * sizeof(unsigned int));\n    real_t false_margin = pow(exp(1), log(.5)/n);\n    unsigned int temp = 1;\n    unsigned int b = 0;\n    unsigned int host_b;\n\n    for (int x = 0; x < n; ++x){\n        a[x] = 0;\n        for (int y = 0; y < 16; ++y){\n            if (rand() / (real_t) RAND_MAX > false_margin){\n                a[x] += 1 << y;\n            }\n        }\n    }\n\n    #pragma acc data copyin(a[0:n])\n    {\n        #pragma acc parallel loop reduction(|:b)\n        for (int x = 0; x < n; ++x){\n            b = b | a[x];\n        }\n    }\n\n    host_b = a[0];\n    for (int x = 1; x < n; ++x){\n        host_b = host_b | a[x];\n    }\n\n    if (b != host_b){\n        err = 1;\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "parallel",
                            "loop",
                            "reduction",
                            "combined-constructs"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "2": {
                        "content": "#ifndef T2\n//T2:parallel,reduction,combined-constructs,loop,V:2.7-2.7\nint test2(){\n    int err = 0;\n    srand(SEED);\n    unsigned int * a = (unsigned int *)malloc(5 * n * sizeof(unsigned int));\n    real_t false_margin = pow(exp(1), log(.5)/n);\n    unsigned int b[5];\n    unsigned int host_b[5];\n\n    for (int x = 0; x < 5 * n; ++x){\n        a[x] = 0;\n        for (int y = 0; y < 16; ++y) {\n            if (rand() / (real_t) RAND_MAX > false_margin) {\n                a[x] += 1 << y;\n            }\n        }\n    }\n\n    for (int x = 0; x < 5; ++x) {\n        b[x] = 0;\n        host_b[x] = 0;\n    }\n\n    #pragma acc data copyin(a[0:5*n])\n    {\n        #pragma acc parallel loop reduction(|:b)\n        for (int x = 0; x < 5 * n; ++x) {\n            b[x%5] = b[x%5] | a[x];\n        }\n    }\n\n    for (int x = 0; x < 5 * n; ++x){\n        host_b[x%5] = host_b[x%5] | a[x];\n    }\n\n    for (int x = 0; x < 5; ++x) {\n        if (host_b[x] != b[x]) {\n            err += 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T2\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test2();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 1);\n    }\n#endif\n",
                        "tags": [
                            "parallel",
                            "reduction",
                            "combined-constructs",
                            "loop"
                        ],
                        "versions": [
                            "2.7"
                        ]
                    }
                }
            },
            "parallel_loop_reduction_bitor_loop.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:parallel,private,reduction,combined-constructs,loop,V:1.0-2.7\n      LOGICAL FUNCTION test1()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x, y, z, i !Iterators\n        INTEGER,DIMENSION(10*LOOPCOUNT):: a, b, b_copy !Data\n        REAL(8),DIMENSION(10*LOOPCOUNT):: randoms2\n        INTEGER,DIMENSION(10) :: c\n        REAL(8),DIMENSION(160*LOOPCOUNT):: randoms\n        REAL(8) :: false_margin\n        INTEGER :: errors = 0\n        INTEGER :: temp\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(randoms)\n        CALL RANDOM_NUMBER(randoms2)\n        false_margin = exp(log(.5)/n)\n        b = FLOOR(6*randoms2)\n        b_copy = b\n        DO x = 0, 9\n          DO y = 1, LOOPCOUNT\n            DO z = 1, 16\n              IF (randoms(x * 16 * LOOPCOUNT + y * 16 + z - 1) .gt. false_margin) THEN\n                temp = 1\n                DO i = 1, z\n                  temp = temp * 2\n                END DO\n                a(x * LOOPCOUNT + y) = a(x * LOOPCOUNT + y) + temp\n              END IF\n            END DO\n          END DO\n        END DO\n\n        !$acc data copyin(a(1:10*LOOPCOUNT)) copy(b(1:10*LOOPCOUNT), c(1:10))\n          !$acc parallel loop gang private(temp)\n          DO x = 0, 9\n            temp = 0\n            !$acc loop worker reduction(ior:temp)\n            DO y = 1, LOOPCOUNT\n              temp = ior(temp, a(x * LOOPCOUNT + y))\n            END DO\n            c(x + 1) = temp\n            !$acc loop worker\n            DO y = 1, LOOPCOUNT\n              b(x * LOOPCOUNT + y) = b(x * LOOPCOUNT + y) + c(x + 1)\n            END DO\n          END DO\n        !$acc end data\n        \n        DO x = 0, 9\n          temp = 0\n          DO y = 1, LOOPCOUNT\n            temp = ior(temp, a(x * LOOPCOUNT + y))\n          END DO\n          IF (temp .ne. c(x + 1)) THEN\n            errors = errors + 1\n          END IF\n          DO y = 1, LOOPCOUNT\n            IF (b(x * LOOPCOUNT + y) .ne. b_copy(x * LOOPCOUNT + y) + c(x + 1)) THEN\n              errors = errors + 1\n            END IF\n          END DO\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "parallel",
                            "private",
                            "reduction",
                            "combined-constructs",
                            "loop"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "parallel_loop_reduction_bitor_loop.c": {
                "num tests": 2,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:parallel,loop,reduction,combined-constructs,V:1.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    unsigned int * a = (unsigned int *)malloc(10 * n * sizeof(unsigned int));\n    unsigned int * b = (unsigned int *)malloc(10 * n * sizeof(unsigned int));\n    unsigned int * b_copy = (unsigned int *)malloc(10 * n * sizeof(unsigned int));\n    unsigned int * c = (unsigned int *)malloc(10 * sizeof(unsigned int));\n\n    real_t false_margin = pow(exp(1), log(.5)/n);\n    unsigned int temp = 1;\n    unsigned int host_c;\n\n    for (int x = 0; x < 10; ++x){\n        for (int y = 0; y < n; ++y){\n            b[x * n + y] = (unsigned int) rand() / (real_t)(RAND_MAX / 1000);\n            b_copy[x * n + y] = b[x * n + y];\n            for (int z = 0; z < 16; ++z){\n                a[x * n + y] += (1<<z);\n            }\n        }\n    }\n\n    #pragma acc data copyin(a[0:10*n]) copy(b[0:10*n], c[0:10])\n    {\n        #pragma acc parallel loop gang private(temp)\n        for (int x = 0; x < 10; ++x){\n            temp = 0;\n            #pragma acc loop worker reduction(|:temp)\n            for (int y = 0; y < n; ++y){\n                temp = temp | a[x * n + y];\n            }\n            c[x] = temp;\n            #pragma acc loop worker\n            for (int y = 0; y < n; ++y){\n                b[x * n + y] = b[x * n + y] + c[x];\n            }\n        }\n    }\n    for (int x = 0; x < 10; ++x){\n        host_c = a[x * n];\n        for (int y = 1; y < n; ++y){\n            host_c = host_c | a[x * n + y];\n        }\n        if (host_c != c[x]){\n            err += 1;\n        }\n        for (int y = 0; y < n; ++y){\n            if (b[x * n + y] != b_copy[x * n + y] + host_c){\n                err += 1;\n            }\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "parallel",
                            "loop",
                            "reduction",
                            "combined-constructs"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "2": {
                        "content": "#ifndef T2\n//T2:parallel,private,reduction,combined-constructs,loop,V:2.7-2.7\nint test2(){\n    int err = 0;\n    srand(SEED);\n    unsigned int * a = (unsigned int *)malloc(25 * n * sizeof(unsigned int));\n    unsigned int * b = (unsigned int *)malloc(25 * n * sizeof(unsigned int));\n    unsigned int * b_copy = (unsigned int *)malloc(25 * n * sizeof(unsigned int));\n    unsigned int * c = (unsigned int *)malloc(25 * sizeof(unsigned int));\n    unsigned int temp[5];\n\n    real_t false_margin = pow(exp(1), log(.5)/n);\n\n    for (int x = 0; x < 25 * n; ++x){\n        b[x] = (unsigned int) rand() / (real_t)(RAND_MAX / 1000);\n        b_copy[x] = b[x];\n        for (int y = 0; y < 16; ++y) {\n            if (rand() / (real_t)RAND_MAX > false_margin) {\n                a[x] += (1<<y);\n            }\n        }\n    }\n\n    #pragma acc data copyin(a[0:25*n]) copy(b[0:25*n], c[0:25])\n    {\n        #pragma acc parallel loop gang private(temp)\n        for (int x = 0; x < 5; ++x) {\n            for (int y = 0; y < 5; ++y) {\n                temp[y] = 0;\n            }\n            #pragma acc loop worker reduction(|:temp)\n            for (int y = 0; y < 5 * n; ++y) {\n                temp[y%5] = temp[y%5] | a[x * 5 * n + y];\n            }\n            for (int y = 0; y < 5; ++y) {\n                c[x * 5 + y] = temp[y];\n            }\n            #pragma acc loop worker\n            for (int y = 0; y < 5 * n; ++y) {\n                b[x * 5 * n + y] = b[x * 5 * n + y] + c[x * 5 + (y % 5)];\n            }\n        }\n    }\n\n    for (int x = 0; x < 5; ++x){\n        for (int y = 0; y < 5; ++y){\n            temp[y] = 0;\n        }\n        for (int y = 0; y < 5 * n; ++y) {\n            temp[y%5] = temp[y%5] | a[x * 5 * n + y];\n        }\n        for (int y = 0; y < 5; ++y){\n            if (c[x * 5 + y] != temp[y]) {\n                err += 1;\n            }\n        }\n        for (int y = 0; y < 5 * n; ++y) {\n            if ((b_copy[x * 5 * n + y] + c[x * 5 + (y % 5)]) != b[x * 5 * n + y]) {\n                err += 1;\n            }\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T2\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test2();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 1);\n    }\n#endif\n",
                        "tags": [
                            "parallel",
                            "private",
                            "reduction",
                            "combined-constructs",
                            "loop"
                        ],
                        "versions": [
                            "2.7"
                        ]
                    }
                }
            },
            "parallel_loop_reduction_bitor_vector_loop.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:parallel,private,reduction,combined-constructs,loop,V:1.0-2.7\n      LOGICAL FUNCTION test1()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x, y, z !Iterators\n        INTEGER,DIMENSION(10 * LOOPCOUNT):: a !Data\n        INTEGER,DIMENSION(10) :: b\n        REAL(8) :: false_margin\n        REAL(8),DIMENSION(160 * LOOPCOUNT) :: randoms\n        INTEGER :: errors = 0\n        INTEGER :: temp\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(randoms)\n        false_margin = exp(log(.5) / n)\n        DO x = 1, 10 * LOOPCOUNT\n          DO y = 1, 16\n            IF (randoms(y * 10 * LOOPCOUNT + y - 1) .gt. false_margin) THEN\n              temp = 1\n              DO z = 1, y\n                temp = temp * 2\n              END DO\n              a(x) = a(x) + temp\n            END IF\n          END DO\n        END DO\n\n        !$acc data copyin(a(1:10*LOOPCOUNT)) copy(b(1:10))\n          !$acc parallel loop private(temp)\n          DO x = 0, 9\n            temp = 0\n            !$acc loop vector reduction(ior:temp)\n            DO y = 1, LOOPCOUNT\n              temp = ior(temp, a(x * LOOPCOUNT + y))\n            END DO\n            b(x + 1) = temp\n          END DO\n        !$acc end data\n\n        DO x = 0, 9\n          temp = 0\n          DO y = 1, LOOPCOUNT\n            temp = ior(temp, a(x * LOOPCOUNT + y))\n          END DO\n          IF (temp .ne. b(x + 1)) THEN\n            errors = errors + 1\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "parallel",
                            "private",
                            "reduction",
                            "combined-constructs",
                            "loop"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "parallel_loop_reduction_bitor_vector_loop.c": {
                "num tests": 2,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:parallel,loop,reduction,combined-constructs,V:1.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    unsigned int* a = (unsigned int *)malloc(10 * n * sizeof(unsigned int));\n    unsigned int* b = (unsigned int *)malloc(10 * sizeof(unsigned int));\n\n    real_t false_margin = pow(exp(1), log(.5)/n);\n    unsigned int temp = 1;\n    unsigned int b_host;\n\n    for (int x = 0; x < 10 * n; ++x){\n        for (int y = 0; y < 16; ++y){\n            if (rand() / (real_t) RAND_MAX > false_margin){\n                for (int z = 0; z < y; ++z){\n                    temp *= 2;\n                }\n                a[x] += temp;\n                temp = 1;\n            }\n        }\n    }\n    temp = 0;\n    #pragma acc data copyin(a[0:10*n]) copy(b[0:10])\n    {\n        #pragma acc parallel loop private(temp)\n        for (int x = 0; x < 10; ++x){\n            temp = 0;\n            #pragma acc loop vector reduction(|:temp)\n            for (int y = 0; y < n; ++y){\n                temp = temp | a[x * n + y];\n            }\n            b[x] = temp;\n        }\n    }\n\n    for (int x = 0; x < 10; ++x){\n        b_host = a[x * n];\n        for (int y = 1; y < n; ++y){\n            b_host = b_host | a[x * n + y];\n        }\n        if (b_host != b[x]){\n            err = 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "parallel",
                            "loop",
                            "reduction",
                            "combined-constructs"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "2": {
                        "content": "#ifndef T2\n//T2:parallel,private,reduction,combined-constructs,loop,V:2.7-2.7\nint test2(){\n    int err = 0;\n    srand(SEED);\n    unsigned int * a = (unsigned int *)malloc(25 * n * sizeof(unsigned int));\n    unsigned int * b = (unsigned int *)malloc(25 * sizeof(unsigned int));\n\n    unsigned int reduced[5];\n    real_t false_margin = pow(exp(1), log(.5)/n);\n    \n    for (int x = 0; x < 25 * n; ++x) {\n        a[x] = 0;\n        for (int y = 0; y < 16; ++y) {\n            if (rand() / (real_t)RAND_MAX > false_margin) {\n                a[x] += 1<<y;\n            }\n        }\n    }\n\n    #pragma acc data copyin(a[0:25*n]) copy(b[0:25])\n    {\n        #pragma acc parallel loop private(reduced)\n        for (int x = 0; x < 5; ++x) {\n            for (int y = 0; y < 5; ++y) {\n                reduced[y] = 0;\n            }\n            #pragma acc loop vector reduction(|:reduced)\n            for (int y = 0; y < 5 * n; ++y) {\n                reduced[y%5] = reduced[y%5] | a[x * 5 * n + y];\n            }\n            for (int y = 0; y < 5; ++y) {\n                b[x * 5 + y] = reduced[y];\n            }\n        }\n    }\n\n    for (int x = 0; x < 5; ++x) {\n        for (int y = 0; y < 5; ++y) {\n            reduced[y] = 0;\n        }\n        for (int y = 0; y < 5 * n; ++y) {\n            reduced[y%5] = reduced[y%5] | a[x * 5 * n + y];\n        }\n        for (int y = 0; y < 5; ++y) {\n            if (b[x * 5 + y] != reduced[y]) {\n                err += 1;\n            }\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T2\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test2();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 1);\n    }\n#endif\n",
                        "tags": [
                            "parallel",
                            "private",
                            "reduction",
                            "combined-constructs",
                            "loop"
                        ],
                        "versions": [
                            "2.7"
                        ]
                    }
                }
            },
            "parallel_loop_reduction_bitxor_general.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:parallel,reduction,combined-constructs,loop,V:1.0-2.7\n      LOGICAL FUNCTION test1()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x !Iterators\n        INTEGER,DIMENSION(LOOPCOUNT):: a !Data\n        REAL(8),DIMENSION(LOOPCOUNT):: randoms\n        INTEGER :: errors = 0\n        INTEGER :: b = 0\n        INTEGER :: temp = 0\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(randoms)\n        a = FLOOR(randoms*1000000)\n\n        !$acc data copyin(a(1:LOOPCOUNT))\n          !$acc parallel loop reduction(ieor:b)\n          DO x = 1, LOOPCOUNT\n            b = ieor(b, a(x))\n          END DO\n        !$acc end data\n\n        DO x = 1, LOOPCOUNT\n          temp = ieor(temp, a(x))\n        END DO\n        IF (temp .ne. b) THEN\n          errors = errors + 1\n        END IF\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "parallel",
                            "reduction",
                            "combined-constructs",
                            "loop"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "parallel_loop_reduction_bitxor_general.c": {
                "num tests": 2,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:parallel,reduction,combined-constructs,loop,V:1.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    unsigned int * a = (unsigned int *)malloc(n * sizeof(unsigned int));\n    unsigned int b = 0;\n    unsigned int host_b = 0;\n\n    for (int x = 0; x < n; ++x){\n        a[x] = (unsigned int) rand() / (real_t) (RAND_MAX / 2);\n    }\n\n    #pragma acc data copyin(a[0:n])\n    {\n        #pragma acc parallel loop reduction(^:b)\n        for (int x = 0; x < n; ++x){\n            b = b ^ a[x];\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        host_b = host_b ^ a[x];\n    }\n    if (b != host_b){\n        err = 1;\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "parallel",
                            "reduction",
                            "combined-constructs",
                            "loop"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "2": {
                        "content": "#ifndef T2\n//T2:parallel,reduction,combined-constructs,loop,V:2.7-2.7\nint test2(){\n    int err = 0;\n    srand(SEED);\n    unsigned int * a = (unsigned int *)malloc(10 * n * sizeof(unsigned int));\n    unsigned int b[10];\n    unsigned int host_b[10];\n\n    for (int x = 0; x < 10 * n; ++x){\n        a[x] = (unsigned int) rand() / (real_t) (RAND_MAX / 2);\n    }\n\n    for (int x = 0; x < 10; ++x) {\n        b[x] = 0;\n        host_b[x] = 0;\n    }\n\n    #pragma acc data copyin(a[0:10*n])\n    {\n        #pragma acc parallel loop reduction(^:b)\n        for (int x = 0; x < 10 * n; ++x) {\n            b[x % 10] = b[x % 10] ^ a[x];\n        }\n    }\n\n    for (int x = 0; x < 10 * n; ++x) {\n        host_b[x % 10] = host_b[x % 10] ^ a[x];\n    }\n\n    for (int x = 0; x < 10; ++x) {\n        if (host_b[x] != b[x]) {\n            err += 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T2\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test2();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 1);\n    }\n#endif\n",
                        "tags": [
                            "parallel",
                            "reduction",
                            "combined-constructs",
                            "loop"
                        ],
                        "versions": [
                            "2.7"
                        ]
                    }
                }
            },
            "parallel_loop_reduction_bitxor_loop.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:parallel,private,reduction,combined-constructs,loop,V:1.0-2.7\n      LOGICAL FUNCTION test1()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x, y !Iterators\n        INTEGER,DIMENSION(10*LOOPCOUNT):: a, b, b_copy !Data\n        REAL(8),DIMENSION(10*LOOPCOUNT):: randoms, randoms2\n        INTEGER,DIMENSION(10):: c\n        REAL*8 :: RAND\n        INTEGER :: errors = 0\n        INTEGER :: temp\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(randoms)\n        a = FLOOR(randoms*1000000)\n        CALL RANDOM_NUMBER(randoms2)\n        b = FLOOR(randoms2*1000000)\n        b_copy = b\n        c = 0\n\n        !$acc data copyin(a(1:10*LOOPCOUNT)) copy(b(1:10*LOOPCOUNT), c(1:10))\n          !$acc parallel loop gang private(temp)\n          DO x = 0, 9\n            temp = 0\n            !$acc loop worker reduction(ieor:temp)\n            DO y = 1, LOOPCOUNT\n              temp = ieor(temp, a(x * LOOPCOUNT + y))\n            END DO\n            c(x + 1) = temp\n            !$acc loop worker\n            DO y = 1, LOOPCOUNT\n              b(x * LOOPCOUNT + y) = b(x * LOOPCOUNT + y) + c(x + 1)\n            END DO\n          END DO\n        !$acc end data\n\n        DO x = 0, 9\n          temp = 0\n          DO y = 1, LOOPCOUNT\n            temp = ieor(temp, a(x * LOOPCOUNT + y))\n          END DO\n          IF (temp .ne. c(x + 1)) THEN\n            errors = errors + 1\n          END IF\n          DO y = 1, LOOPCOUNT\n            IF (b(x * LOOPCOUNT + y) .ne. b_copy(x * LOOPCOUNT + y) + c(x + 1)) THEN\n              errors = errors + 1\n            END IF\n          END DO\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "parallel",
                            "private",
                            "reduction",
                            "combined-constructs",
                            "loop"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "parallel_loop_reduction_bitxor_loop.c": {
                "num tests": 2,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:parallel,loop,reduction,combined-constructs,V:1.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    unsigned int * a = (unsigned int *)malloc(10 * n * sizeof(unsigned int));\n    unsigned int * b = (unsigned int *)malloc(10 * n * sizeof(unsigned int));\n    unsigned int * b_copy = (unsigned int *)malloc(10 * n * sizeof(unsigned int));\n    unsigned int * c = (unsigned int *)malloc(10 * sizeof(unsigned int));\n    unsigned int temp = 0;\n\n    for (int x = 0; x < 10*n; ++x){\n        b[x] = (unsigned int) rand() / (real_t)(RAND_MAX / 1000);\n        b_copy[x] = b[x];\n        a[x] = (unsigned int) rand() / (real_t)(RAND_MAX / 1000);\n    }\n    for (int x = 0; x < 10; ++x){\n        c[x] = 0;\n    }\n\n    #pragma acc data copyin(a[0:10*n]) copy(b[0:10*n], c[0:10])\n    {\n        #pragma acc parallel loop gang private(temp)\n        for (int x = 0; x < 10; ++x){\n            temp = 0;\n            #pragma acc loop worker reduction(^:temp)\n            for (int y = 0; y < n; ++y){\n                temp = temp ^ a[x * n + y];\n            }\n            c[x] = temp;\n            #pragma acc loop worker\n            for (int y = 0; y < n; ++y){\n                b[x * n + y] = b[x * n + y] + c[x];\n            }\n        }\n    }\n\n    for (int x = 0; x < 10; ++x){\n        temp = 0;\n        for (int y = 0; y < n; ++y){\n            temp = temp ^ a[x * n + y];\n        }\n        if (temp != c[x]){\n            err += 1;\n        }\n        for (int y = 0; y < n; ++y){\n            if (b[x * n + y] != b_copy[x * n + y] + c[x]){\n                err += 1;\n            }\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "parallel",
                            "loop",
                            "reduction",
                            "combined-constructs"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "2": {
                        "content": "#ifndef T2\n//T2:parallel,private,reduction,combined-constructs,loop,nonvalidating,V:2.7-2.7\nint test2(){\n    int err = 0;\n    srand(SEED);\n    unsigned int * a = (unsigned int *)malloc(25 * n * sizeof(unsigned int));\n    unsigned int * b = (unsigned int *)malloc(25 * n * sizeof(unsigned int));\n    unsigned int * b_copy = (unsigned int *)malloc(25 * n * sizeof(unsigned int));\n    unsigned int * c = (unsigned int *)malloc(25 * sizeof(unsigned int));\n\n    unsigned int temp[5];\n\n    for (int x = 0; x < n; ++x){\n        a[x] = (unsigned int) rand() / (real_t)(RAND_MAX / 1000);\n        b[x] = (unsigned int) rand() / (real_t)(RAND_MAX / 1000);\n        b_copy[x] = b[x];\n    }\n\n    for (int x = 0; x < 25; ++x) {\n        c[x] = 0;\n    }\n\n    for (int x = 0; x < 5; ++x) {\n        temp[x] = 0;\n    }\n\n    #pragma acc data copyin(a[0:25*n]) copy(b[0:25*n], c[0:25])\n    {\n        #pragma acc parallel loop gang private(temp)\n        for (int x = 0; x < 5; ++x) {\n            for (int y = 0; y < 5; ++y) {\n                temp[y] = 0;\n            }\n            #pragma acc loop worker reduction(^:temp)\n            for (int y = 0; y < 5 * n; ++y) {\n                temp[y % 5] = temp[y % 5] ^ a[x * 5 * n + y];\n            }\n            for (int y = 0; y < 5; ++y) {\n                c[x * 5 + y] = temp[y];\n            }\n            #pragma acc loop worker\n            for (int y = 0; y < 5 * n; ++y) {\n                b[x * 5 * n + y] = b[x * 5 * n + y] + c[x * 5 + (y % 5)];\n            }\n        }\n    }\n\n    for (int x = 0; x < 5; ++x) {\n        for (int y = 0; y < 5; ++y) {\n            temp[y] = 0;\n        }\n        for (int y = 0; y < 5 * n; ++y) {\n            temp[y % 5] = temp[y % 5] ^ a[x * 5 * n + y];\n        }\n        \n    }\n\n    return err;\n}\n#endif\n#ifndef T2\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test2();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 1);\n    }\n#endif\n",
                        "tags": [
                            "parallel",
                            "private",
                            "reduction",
                            "combined-constructs",
                            "loop",
                            "nonvalidating"
                        ],
                        "versions": [
                            "2.7"
                        ]
                    }
                }
            },
            "parallel_loop_reduction_bitxor_vector_loop.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:parallel,private,reduction,combined-constructs,loop,V:1.0-2.7\n      LOGICAL FUNCTION test1()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x, y !Iterators\n        INTEGER,DIMENSION(10*LOOPCOUNT):: a !Data\n        REAL(8),DIMENSION(10*LOOPCOUNT):: randoms\n        INTEGER,DIMENSION(10):: b\n        INTEGER :: errors = 0\n        INTEGER :: temp\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(randoms)\n        a = FLOOR(randoms*1000000)\n\n        !$acc data copyin(a(1:10*LOOPCOUNT)) copy(b(1:10))\n          !$acc parallel loop gang private(temp)\n          DO x = 0, 9\n            temp = 0\n            !$acc loop vector reduction(ieor:temp)\n            DO y = 1, LOOPCOUNT\n              temp = ieor(temp, a(x * LOOPCOUNT + y))\n            END DO\n            b(x + 1) = temp\n          END DO\n        !$acc end data\n        \n        DO x = 0, 9\n          temp = 0\n          DO y = 1, LOOPCOUNT\n            temp = ieor(temp, a(x * LOOPCOUNT + y))\n          END DO\n          IF (temp .ne. b(x + 1)) THEN\n            errors = errors + 1\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "parallel",
                            "private",
                            "reduction",
                            "combined-constructs",
                            "loop"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "parallel_loop_reduction_bitxor_vector_loop.c": {
                "num tests": 2,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:parallel,loop,reduction,combined-constructs,V:1.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    unsigned int* a = (unsigned int *)malloc(10 * n * sizeof(unsigned int));\n    unsigned int* b = (unsigned int *)malloc(10 * sizeof(unsigned int));\n\n    unsigned int temp = 0;\n    unsigned int b_host;\n\n    for (int x = 0; x < 10 * n; ++x){\n        a[x] = (unsigned int) rand() / (real_t) (RAND_MAX / 2);\n    }\n\n    #pragma acc data copyin(a[0:10*n]) copy(b[0:10])\n    {\n        #pragma acc parallel loop private(temp)\n        for (int x = 0; x < 10; ++x){\n            temp = 0;\n            #pragma acc loop vector reduction(^:temp)\n            for (int y = 0; y < n; ++y){\n                temp = temp ^ a[x * n + y];\n            }\n            b[x] = temp;\n        }\n    }\n\n    for (int x = 0; x < 10; ++x){\n        b_host = a[x * n];\n        for (int y = 1; y < n; ++y){\n            b_host = b_host ^ a[x * n + y];\n        }\n        if (b_host != b[x]){\n            err = 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "parallel",
                            "loop",
                            "reduction",
                            "combined-constructs"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "2": {
                        "content": "#ifndef T2\n//T2:parallel,private,reduction,combined-constructs,loop,V:2.7-2.7\nint test2(){\n    int err = 0;\n    srand(SEED);\n    unsigned int * a = (unsigned int *)malloc(25 * n * sizeof(unsigned int));\n    unsigned int * b = (unsigned int *)malloc(25 * sizeof(unsigned int));\n\n    unsigned int temp[5];\n\n    for (int x = 0; x < 25 * n; ++x){\n        a[x] = (unsigned int) rand() / (real_t) (RAND_MAX / 2);\n    }\n\n    #pragma acc data copyin(a[0:25*n]) copy(b[0:25])\n    {\n        #pragma acc parallel loop private(temp)\n        for (int x = 0; x < 5; ++x) {\n            for (int y = 0; y < 5; ++y){\n                temp[y] = 0;\n            }\n            #pragma acc loop vector reduction(^:temp)\n            for (int y = 0; y < 5 * n; ++y) {\n                temp[y % 5] = temp[y % 5] ^ a[x * 5 * n + y];\n            }\n            for (int y = 0; y < 5; ++y) {\n                b[x * 5 + y] = temp[y];\n            }\n        }\n    }\n\n    for (int x = 0; x < 5; ++x) {\n        for (int y = 0; y < 5; ++y) {\n            temp[y] = 0;\n        }\n        for (int y = 0; y < 5 * n; ++y) {\n            temp[y % 5] = temp[y % 5] ^ a[x * 5 * n + y];\n        }\n        for (int y = 0; y < 5; ++y) {\n            if (b[x * 5 + y] != temp[y]) {\n                err += 1;\n            }\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T2\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test2();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 1);\n    }\n#endif\n",
                        "tags": [
                            "parallel",
                            "private",
                            "reduction",
                            "combined-constructs",
                            "loop"
                        ],
                        "versions": [
                            "2.7"
                        ]
                    }
                }
            },
            "parallel_loop_reduction_max_general.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:parallel,reduction,combined-constructs,loop,V:1.0-2.7\n      LOGICAL FUNCTION test1()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT):: a, b !Data\n        REAL(8) :: maximum, temp\n        INTEGER :: errors = 0\n\n        !Initilization\n        maximum = 0\n        temp = 0\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(a)\n        CALL RANDOM_NUMBER(b)\n\n        !$acc data copyin(a(1:LOOPCOUNT), b(1:LOOPCOUNT))\n          !$acc parallel loop reduction(max:maximum)\n          DO x = 1, LOOPCOUNT\n            maximum = max(maximum, a(x) * b(x))\n          END DO\n        !$acc end data\n\n        DO x = 1, LOOPCOUNT\n          temp = max(temp, a(x) * b(x))\n        END DO\n        IF (abs(temp - maximum) .gt. PRECISION) THEN\n          errors = errors + 1\n        END IF\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "parallel",
                            "reduction",
                            "combined-constructs",
                            "loop"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "parallel_loop_reduction_max_general.c": {
                "num tests": 2,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:parallel,loop,reduction,combined-constructs,V:1.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n    real_t max = 0.0;\n    int found = 0;\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX/10);\n        b[x] = rand() / (real_t)(RAND_MAX/10);\n    }\n    #pragma acc data copyin(a[0:n], b[0:n])\n    {\n        #pragma acc parallel loop reduction(max:max)\n        for (int x = 0; x < n; ++x){\n            max = fmax(a[x] * b[x], max);\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        if (fabs(max - (a[x] * b[x] + PRECISION)) < 0){\n            err = 1;\n        }\n        if (fabs(max - (a[x] * b[x] - PRECISION)) > 0){\n            found = 1;\n        }\n    }\n    if (found = 0){\n        err = 1;\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "parallel",
                            "loop",
                            "reduction",
                            "combined-constructs"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "2": {
                        "content": "#ifndef T2\n//T2:parallel,reduction,combined-constructs,loop,V:2.7-2.7\nint test2(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(10 * n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(10 * n * sizeof(real_t));\n    real_t maximums[10];\n    real_t max_host[10];\n\n    for (int x = 0; x < 10 * n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n    }\n\n    for (int x = 0; x < 10; ++x) {\n        maximums[x] = 0;\n        max_host[x] = 0;\n    }\n\n    #pragma acc data copyin(a[0:10*n], b[0:10*n])\n    {\n        #pragma acc parallel loop reduction(max:maximums)\n        for (int x = 0; x < 10 * n; ++x) {\n            maximums[x%10] = fmax(a[x] * b[x], maximums[x%10]);\n        }\n    }\n\n    for (int x = 0; x < 10 * n; ++x) {\n        max_host[x%10] = fmax(a[x] * b[x], maximums[x%10]);\n    }\n    \n    for (int x = 0; x < 10; ++x) {\n        if (fabs(max_host[x] - maximums[x]) > PRECISION) {\n            err += 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T2\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test2();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 1);\n    }\n#endif\n",
                        "tags": [
                            "parallel",
                            "reduction",
                            "combined-constructs",
                            "loop"
                        ],
                        "versions": [
                            "2.7"
                        ]
                    }
                }
            },
            "parallel_loop_reduction_max_loop.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:parallel,private,reduction,combined-constructs,loop,V:1.0-2.7\n      LOGICAL FUNCTION test1()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x, y !Iterators\n        REAL(8),DIMENSION(10 * LOOPCOUNT):: a, b, c !Data\n        REAL(8),DIMENSION(10):: maximum\n        REAL(8) :: temp\n        INTEGER :: errors = 0\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(a)\n        CALL RANDOM_NUMBER(b)\n        c = 0\n\n        !$acc data copyin(a(1:10*LOOPCOUNT), b(1:10*LOOPCOUNT)) copy(c(1:10*LOOPCOUNT))\n          !$acc parallel loop gang private(temp)\n          DO x = 0, 9\n            temp = 0\n            !$acc loop worker reduction(max:temp)\n            DO y = 1, LOOPCOUNT\n              temp = max(temp, a(x * LOOPCOUNT + y) * b(x * LOOPCOUNT + y))\n            END DO\n            maximum(x + 1) = temp\n            !$acc loop worker\n            DO y = 1, LOOPCOUNT\n              c(x * LOOPCOUNT + y) = (a(x * LOOPCOUNT + y) * b(x * LOOPCOUNT + y)) / maximum(x + 1)\n            END DO\n          END DO\n        !$acc end data\n        \n        DO x = 0, 9\n          DO y = 1, LOOPCOUNT\n            IF (a(x * LOOPCOUNT + y) * b(x * LOOPCOUNT + y) - maximum(x + 1) .gt. PRECISION) THEN\n              errors = errors + 1\n            ELSE IF ((c(x * LOOPCOUNT + y) - 1) .gt. PRECISION) THEN\n              errors = errors + 1\n            END IF\n          END DO\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "parallel",
                            "private",
                            "reduction",
                            "combined-constructs",
                            "loop"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "parallel_loop_reduction_max_loop.c": {
                "num tests": 2,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:parallel,loop,reduction,combined-constructs,V:1.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(10 * n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(10 * n * sizeof(real_t));\n    real_t * c = (real_t *)malloc(10 * n * sizeof(real_t));\n    real_t * maximum = (real_t *)malloc(10 * sizeof(real_t));\n    real_t temp = 0;\n    real_t max = 0.0;\n\n    for (int x = 0; x < 10 * n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX/10);\n        b[x] = rand() / (real_t)(RAND_MAX/10);\n        c[x] = 0.0;\n    }\n    for (int x = 0; x < 10; ++x){\n        maximum[x] = 0;\n    }\n\n    #pragma acc data copyin(a[0:10*n], b[0:10*n]) copy(c[0:10*n], maximum[0:10])\n    {\n        #pragma acc parallel loop gang private(temp)\n        for (int x = 0; x < 10; ++x){\n            temp = 0;\n            #pragma acc loop worker reduction(max:temp)\n            for (int y = 0; y < n; ++y){\n                temp = fmax(a[x * n + y] * b[x * n + y], temp);\n            }\n            maximum[x] = temp;\n            #pragma acc loop worker\n            for (int y = 0; y < n; ++y){\n                c[x * n + y] = (a[x * n + y] * b[x * n + y]) / maximum[x];\n            }\n        }\n    }\n    for (int x = 0; x < 10; ++x){\n        temp = 0;\n        for (int y = 0; y < n; ++y){\n            temp = fmax(temp, a[x * n + y] * b[x * n + y]);\n        }\n        if (fabs(temp - maximum[x]) > PRECISION){\n            err += 1;\n        }\n        for (int y = 0; y < n; ++y){\n            if (c[x * n + y] > 1){\n                err += 1;\n            }\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "parallel",
                            "loop",
                            "reduction",
                            "combined-constructs"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "2": {
                        "content": "#ifndef T2\n//T2:parallel,private,reduction,combined-constructs,loop,V:2.7-2.7\nint test2(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(25 * n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(25 * n * sizeof(real_t));\n    real_t * c = (real_t *)malloc(25 * n * sizeof(real_t));\n    real_t * maximum = (real_t *)malloc(25 * sizeof(real_t));\n    real_t * host_maximum = (real_t *)malloc(25 * sizeof(real_t));\n    real_t temp[5];\n\n    for (int x = 0; x < 25 * n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n        c[x] = 0;\n    }\n\n    for (int x = 0; x < 25; ++x) {\n        maximum[x] = 0;\n        host_maximum[x] = 0;\n    }\n\n    #pragma acc data copyin(a[0:25*n], b[0:25*n]) copy(c[0:25*n], maximum[0:25])\n    {\n        #pragma acc parallel loop gang private(temp)\n        for (int x = 0; x < 5; ++x) {\n            for (int y = 0; y < 5; ++y) {\n                temp[y] = 0;\n            }\n            #pragma acc loop worker reduction(max:temp)\n            for (int y = 0; y < 5 * n; ++y) {\n                temp[y%5] = fmax(a[x * 5 * n + y] * b[x * 5 * n + y], temp[y%5]);\n            }\n            for (int y = 0; y < 5; ++y) {\n                maximum[x * 5 + y] = temp[y];\n            }\n            #pragma acc loop worker\n            for (int y = 0; y < 5 * n; ++y) {\n                c[x * 5 * n + y] = (a[x * 5 * n + y] * b[x * 5 * n + y]) / maximum[x * 5 + (y % 5)];\n            }\n        }\n    }\n\n    for (int x = 0; x < 5; ++x) {\n        for (int y = 0; y < 5 * n; ++y) {\n            host_maximum[x * 5 + (y % 5)] = fmax(a[x * 5 * n + y] * b[x * 5 * n + y], host_maximum[x * 5 + (y % 5)]);\n        }\n        for (int y = 0; y < 5; ++y) {\n            if (fabs(host_maximum[x * 5 + y] - maximum[x * 5 + y]) > PRECISION) {\n                err += 1;\n            }\n        }\n        for (int y = 0; y < 5 * n; ++y) {\n            if (fabs(c[x * 5 * n + y] - ((a[x * 5 * n + y] * b[x * 5 * n + y]) / maximum[x * 5 + (y % 5)])) > PRECISION) {\n                err += 1;\n            }\n        }\n    }\n\n\n    return err;\n}\n#endif\n#ifndef T2\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test2();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 1);\n    }\n#endif\n",
                        "tags": [
                            "parallel",
                            "private",
                            "reduction",
                            "combined-constructs",
                            "loop"
                        ],
                        "versions": [
                            "2.7"
                        ]
                    }
                }
            },
            "parallel_loop_reduction_max_vector_loop.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:parallel,private,reduction,combined-constructs,loop,V:1.0-2.7\n      LOGICAL FUNCTION test1()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x, y !Iterators\n        REAL(8),DIMENSION(10 * LOOPCOUNT):: a, b !Data\n        REAL(8),DIMENSION(10):: maximum\n        INTEGER :: errors = 0\n        REAL(8) :: temp\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(a)\n        CALL RANDOM_NUMBER(b)\n        maximum = 0\n\n        !$acc data copyin(a(1:10*LOOPCOUNT), b(1:10*LOOPCOUNT)) copy(maximum(1:10))\n          !$acc parallel loop private(temp)\n          DO x = 0, 9\n            temp = 0\n            !$acc loop vector reduction(max:temp)\n            DO y = 1, LOOPCOUNT\n              temp = max(temp, a(x * LOOPCOUNT + y) * b(x * LOOPCOUNT + y))\n            END DO\n            maximum(x + 1) = temp\n          END DO\n        !$acc end data\n\n        DO x = 0, 9\n          temp = 0\n          DO y = 1, LOOPCOUNT\n            temp = max(temp, a(x * LOOPCOUNT + y) * b(x * LOOPCOUNT + y))\n          END DO\n          IF (abs(temp - maximum(x + 1)) .gt. PRECISION) THEN\n            errors = errors + 1\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "parallel",
                            "private",
                            "reduction",
                            "combined-constructs",
                            "loop"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "parallel_loop_reduction_max_vector_loop.c": {
                "num tests": 2,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:parallel,loop,reduction,combined-constructs,V:1.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(10 * n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(10 * n * sizeof(real_t));\n    real_t * max = (real_t *)malloc(10 * sizeof(real_t));\n    real_t temp = 0;\n    real_t temp_max;\n\n    for (int x = 0; x < 10 * n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX/10);\n        b[x] = rand() / (real_t)(RAND_MAX/10);\n    }\n    #pragma acc data copyin(a[0:10*n], b[0:10*n]) copy(max[0:10])\n    {\n        #pragma acc parallel loop private(temp)\n        for (int x = 0; x < 10; ++x){\n            temp = 0;\n            #pragma acc loop vector reduction(max:temp)\n            for (int y = 0; y < n; ++y){\n                temp = fmax(a[x * n + y] * b[x * n + y], temp);\n            }\n            max[x] = temp;\n        }\n    }\n    for (int x = 0; x < 10; ++x){\n        temp_max = 0;\n        for (int y = 0; y < n; ++y){\n            if (temp_max < a[x * n + y] * b[x * n + y]){\n                temp_max = a[x * n + y] * b[x * n + y];\n            }\n        }\n        if (fabs(temp_max - max[x]) > PRECISION){\n            err = 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "parallel",
                            "loop",
                            "reduction",
                            "combined-constructs"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "2": {
                        "content": "#ifndef T2\n//T2:parallel,private,reduction,combined-constructs,loop,V:2.7-2.7\nint test2(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(25 * n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(25 * n * sizeof(real_t));\n    real_t * maximums = (real_t *)malloc(25 * sizeof(real_t));\n    real_t reduced[5];\n\n    for (int x = 0; x < 25 * n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n    }\n\n    for (int x = 0; x < 25; ++x) {\n        maximums[x] = 0;\n    }\n\n    #pragma acc data copyin(a[0:25*n], b[0:25*n]) copy(maximums[0:25])\n    {\n        #pragma acc parallel loop private(reduced)\n        for (int x = 0; x < 5; ++x) {\n            for (int y = 0; y < 5; ++y) {\n                reduced[y] = 0;\n            }\n            #pragma acc loop vector reduction(max:reduced)\n            for (int y = 0; y < 5 * n; ++y) {\n                reduced[y%5] = fmax(a[x * 5 * n + y] * b[x * 5 * n + y], reduced[y%5]);\n            }\n            for (int y = 0; y < 5; ++y) {\n                maximums[x * 5 + y] = reduced[y];\n            }\n        }\n    }\n\n    for (int x = 0; x < 5; ++x) {\n        for (int y = 0; y < 5; ++y) {\n            reduced[y] = 0;\n        }\n        for (int y = 0; y < 5 * n; ++y) {\n            reduced[y%5] = fmax(a[x * 5 * n + y] * b[x * 5 * n + y], reduced[y%5]);\n        }\n        for (int y = 0; y < 5; ++y) {\n            if (fabs(maximums[x * 5 + y] - reduced[y]) > PRECISION) {\n                err += 1;\n            }\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T2\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test2();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 1);\n    }\n#endif\n",
                        "tags": [
                            "parallel",
                            "private",
                            "reduction",
                            "combined-constructs",
                            "loop"
                        ],
                        "versions": [
                            "2.7"
                        ]
                    }
                }
            },
            "parallel_loop_reduction_min_general.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:parallel,reduction,combined-constructs,loop,V:1.0-2.7\n      LOGICAL FUNCTION test1()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT):: a, b !Data\n        REAL(8):: minimum = 1000\n        REAL(8):: temp = 1000\n        INTEGER :: errors = 0\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(a)\n        CALL RANDOM_NUMBER(b)\n\n        !$acc data copyin(a(1:LOOPCOUNT), b(1:LOOPCOUNT))\n          !$acc parallel loop reduction(min:minimum)\n          DO x = 1, LOOPCOUNT\n            minimum = min(minimum, a(x) * b(x))\n          END DO\n        !$acc end data\n\n        DO x = 1, LOOPCOUNT\n          temp = min(temp, a(x) * b(x))\n        END DO\n        IF (abs(temp - minimum) .gt. PRECISION) THEN\n          errors = errors + 1\n        END IF\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "parallel",
                            "reduction",
                            "combined-constructs",
                            "loop"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "parallel_loop_reduction_min_general.c": {
                "num tests": 2,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:parallel,loop,reduction,combined-constructs,V:1.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n    real_t min = 1000.0;\n    int found = 0;\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX/10);\n        b[x] = rand() / (real_t)(RAND_MAX/10);\n    }\n    #pragma acc data copyin(a[0:n], b[0:n]) copy(min)\n    {\n        #pragma acc parallel loop reduction(min:min)\n        for (int x = 0; x < n; ++x){\n            min = fmin(a[x] * b[x], min);\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        if (fabs((a[x] * b[x]) - (min + PRECISION)) < 0){\n            err = 1;\n        }\n        if (fabs(min - (a[x] * b[x])) < PRECISION){\n            found = 1;\n        }\n    }\n    if (found == 0){\n        err = 1;\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "parallel",
                            "loop",
                            "reduction",
                            "combined-constructs"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "2": {
                        "content": "#ifndef T2\n//T2:parallel,reduction,combined-constructs,loop,V:2.7-2.7\nint test2(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(10 * n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(10 * n * sizeof(real_t));\n    real_t minimums[10];\n    real_t host_minimums[10];\n\n    for (int x = 0; x < 10 * n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n    }\n\n    for (int x = 0; x < 10; ++x) {\n        minimums[x] = 1000;\n        host_minimums[x] = 1000;\n    }\n\n    printf(\"Here\");\n\n    #pragma acc data copyin(a[0:10*n], b[0:10*n])\n    {\n        #pragma acc parallel loop reduction(min:minimums)\n        for (int x = 0; x < 10 * n; ++x) {\n            minimums[x%10] = fmin(a[x] * b[x], minimums[x%10]);\n        }\n    }\n\n    for (int x = 0; x < 10 * n; ++x) {\n        host_minimums[x%10] = fmin(a[x] * b[x], host_minimums[x%10]);\n    }\n    for (int x = 0; x < 10; ++x) {\n        if (fabs(minimums[x] - host_minimums[x]) > PRECISION) {\n            err += 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T2\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test2();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 1);\n    }\n#endif\n",
                        "tags": [
                            "parallel",
                            "reduction",
                            "combined-constructs",
                            "loop"
                        ],
                        "versions": [
                            "2.7"
                        ]
                    }
                }
            },
            "parallel_loop_reduction_min_loop.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:parallel,private,reduction,combined-constructs,loop,V:1.0-2.7\n      LOGICAL FUNCTION test1()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x, y !Iterators\n        REAL(8),DIMENSION(10 * LOOPCOUNT):: a, b, c !Data\n        REAL(8),DIMENSION(10):: minimum\n        REAL(8):: temp\n        INTEGER :: errors = 0\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(a)\n        CALL RANDOM_NUMBER(b)\n        c = 0\n        a = a + 1\n        b = b + 1\n\n        !$acc data copyin(a(1:10*LOOPCOUNT), b(1:10*LOOPCOUNT)) copy(c(1:10*LOOPCOUNT)) copy(minimum(1:10))\n          !$acc parallel loop gang private(temp)\n          DO x = 0, 9\n            temp = 1000\n            !$acc loop worker reduction(min:temp)\n            DO y = 1, LOOPCOUNT\n              temp = min(temp, a(x * LOOPCOUNT + y) * b(x * LOOPCOUNT + y))\n            END DO\n            minimum(x + 1) = temp\n            !$acc loop\n            DO y = 1, LOOPCOUNT\n              c(x * LOOPCOUNT + y) = (a(x * LOOPCOUNT + y) * b(x * LOOPCOUNT + y)) / minimum(x + 1)\n            END DO\n          END DO\n        !$acc end data\n\n        DO x = 0, 9\n          temp = 1000\n          DO y = 1, LOOPCOUNT\n            temp = min(temp, a(x * LOOPCOUNT + y) * b(x * LOOPCOUNT + y))\n          END DO\n          IF (abs(temp - minimum(x + 1)) .gt. PRECISION) THEN\n            errors = errors + 1\n          END IF\n          DO y = 1, LOOPCOUNT\n            IF (abs(c(x * LOOPCOUNT + y) - (a(x * LOOPCOUNT + y) * b(x * LOOPCOUNT + y) / temp)) .gt. PRECISION) THEN\n              errors = errors + 1\n            END IF\n          END DO\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "parallel",
                            "private",
                            "reduction",
                            "combined-constructs",
                            "loop"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "parallel_loop_reduction_min_loop.c": {
                "num tests": 2,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:parallel,loop,reduction,combined-constructs,V:1.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(10 * n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(10 * n * sizeof(real_t));\n    real_t * c = (real_t *)malloc(10 * n * sizeof(real_t));\n    real_t * minimum = (real_t *)malloc(10 * sizeof(real_t));\n    real_t temp = 0;\n\n    for (int x = 0; x < 10 * n; ++x){\n        a[x] = 1 + rand() / (real_t)(RAND_MAX/10);\n        b[x] = 1 + rand() / (real_t)(RAND_MAX/10);\n        c[x] = 0.0;\n    }\n\n    #pragma acc data copyin(a[0:10*n], b[0:10*n]) copy(c[0:10*n], minimum[0:10])\n    {\n        #pragma acc parallel loop gang private(temp)\n        for (int x = 0; x < 10; ++x){\n            temp = 1000;\n            #pragma acc loop reduction(min:temp)\n            for (int y = 0; y < n; ++y){\n                temp = fmin(a[x * n + y] * b[x * n + y], temp);\n            }\n            minimum[x] = temp;\n            #pragma acc loop\n            for (int y = 0; y < n; ++y){\n                c[x * n + y] = (a[x * n + y] * b[x * n + y]) / minimum[x];\n            }\n        }\n    }\n\n    for (int x = 0; x < 10; ++x){\n        temp = 1000;\n        for (int y = 0; y < n; ++y){\n            temp = fmin(temp, a[x * n + y] * b[x * n + y]);\n        }\n        if (fabs(temp - minimum[x]) > PRECISION){\n            err += 1;\n        }\n        for (int y = 0; y < n; ++y){\n            if (fabs(c[x * n + y] - (a[x * n + y] * b[x * n + y] / minimum[x])) > PRECISION){\n                err += 1;\n            }\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "parallel",
                            "loop",
                            "reduction",
                            "combined-constructs"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "2": {
                        "content": "#ifndef T2\n//T2:parallel,private,reduction,combined-constructs,loop,V:2.7-2.7\nint test2(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(25 * n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(25 * n * sizeof(real_t));\n    real_t * c = (real_t *)malloc(25 * n * sizeof(real_t));\n    real_t minimums[25];\n    real_t host_minimums[25];\n    real_t reduced[5];\n\n    for (int x = 0; x < n; ++x){\n        a[x] = 1 + rand() / (real_t)(RAND_MAX / 10);\n        b[x] = 1 + rand() / (real_t)(RAND_MAX / 10);\n        c[x] = 0.0;\n    }\n\n    #pragma acc data copyin(a[0:25*n], b[0:25*n]) copy(minimums[0:25], c[0:25*n])\n    {\n        #pragma acc parallel loop gang private(reduced)\n        for (int x = 0; x < 5; ++x) {\n            for (int y = 0; y < 5; ++y) {\n                reduced[y] = 1000;\n            }\n            #pragma acc loop reduction(min:reduced)\n            for (int y = 0; y < 5 * n; ++y) {\n                reduced[y%5] = fmin(a[x * 5 * n + y] * b[x * 5 * n + y], reduced[y%5]);\n            }\n            for (int y = 0; y < 5; ++y) {\n                minimums[x * 5 + y] = reduced[y];\n            }\n            #pragma acc loop\n            for (int y = 0; y < 5 * n; ++y) {\n                c[x * 5 * n + y] = (a[x * 5 * n + y] * b[x * 5 * n + y]) / minimums[x * 5 + (y % 5)];\n            }\n        }\n    }\n\n    for (int x = 0; x < 5; ++x) {\n        for (int y = 0; y < 5; ++y) {\n            reduced[y] = 1000;\n        }\n        for (int y = 0; y < 5 * n; ++y) {\n            reduced[y%5] = fmin(a[x * 5 * n + y] * b[x * 5 * n + y], reduced[y%5]);\n        }\n        for (int y = 0; y < 5; ++y) {\n            host_minimums[x * 5 + y] = reduced[y];\n            if (fabs(host_minimums[x * 5 + y] - minimums[x * 5 + y]) > PRECISION) {\n                err += 1;\n            }\n        }\n        for (int y = 0; y < 5 * n; ++y) {\n            if (fabs(c[x * 5 * n + y] - ((a[x * 5 * n + y] * b[x * 5 * n + y]) / minimums[x * 5 + (y % 5)])) > PRECISION) {\n                err += 1;\n            }\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T2\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test2();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 1);\n    }\n#endif\n",
                        "tags": [
                            "parallel",
                            "private",
                            "reduction",
                            "combined-constructs",
                            "loop"
                        ],
                        "versions": [
                            "2.7"
                        ]
                    }
                }
            },
            "parallel_loop_reduction_min_vector_loop.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:parallel,private,reduction,combined-constructs,loop,V:1.0-2.7\n      LOGICAL FUNCTION test1()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x, y!Iterators\n        REAL(8),DIMENSION(10*LOOPCOUNT):: a, b !Data\n        REAL(8),DIMENSION(10):: minimum\n        REAL(8):: temp = 1000\n        INTEGER :: errors = 0\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(a)\n        CALL RANDOM_NUMBER(b)\n\n        !$acc data copyin(a(1:10*LOOPCOUNT), b(1:10*LOOPCOUNT)) copy(minimum(1:10))\n          !$acc parallel loop gang private(temp)\n          DO x = 0, 9\n            temp = 1000\n            !$acc loop vector reduction(min:temp)\n            DO y = 1, LOOPCOUNT\n              temp = min(temp, a(x * LOOPCOUNT + y) * b(x * LOOPCOUNT + y))\n            END DO\n            minimum(x + 1) = temp\n          END DO\n        !$acc end data\n        \n        DO x = 0, 9\n          temp = 1000\n          DO y = 1, LOOPCOUNT\n            temp = min(temp, a(x * LOOPCOUNT + y) * b(x * LOOPCOUNT + y))\n          END DO\n          IF (abs(temp - minimum(x + 1)) .gt. PRECISION) THEN\n            errors = errors + 1\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "parallel",
                            "private",
                            "reduction",
                            "combined-constructs",
                            "loop"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "parallel_loop_reduction_min_vector_loop.c": {
                "num tests": 2,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:parallel,loop,reduction,combined-constructs,V:1.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(10 * n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(10 * n * sizeof(real_t));\n    real_t * min = (real_t *)malloc(10 * sizeof(real_t));\n    real_t temp = 100;\n    real_t temp_min;\n\n    for (int x = 0; x < 10 * n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX/10);\n        b[x] = rand() / (real_t)(RAND_MAX/10);\n    }\n\n    #pragma acc data copyin(a[0:10*n], b[0:10*n]) copy(min[0:10])\n    {\n        #pragma acc parallel loop gang private(temp)\n        for (int x = 0; x < 10; ++x){\n            temp = 100;\n            #pragma acc loop vector reduction(min:temp)\n            for (int y = 0; y < n; ++y){\n                temp = fmin(a[x * n + y] * b[x * n + y], temp);\n            }\n            min[x] = temp;\n        }\n    }\n    for (int x = 0; x < 10; ++x){\n        temp_min = 100;\n        for (int y = 0; y < n; ++y){\n            if (temp_min > a[x * n + y] * b[x * n + y]){\n                temp_min = a[x * n + y] * b[x * n + y];\n            }\n        }\n        if (fabs(temp_min - min[x]) > PRECISION){\n            err = 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "parallel",
                            "loop",
                            "reduction",
                            "combined-constructs"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "2": {
                        "content": "#ifndef T2\n//T2:parallel,private,reduction,combined-constructs,loop,V:2.7-2.7\nint test2(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(25 * n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(25 * n * sizeof(real_t));\n    real_t * minimums = (real_t *)malloc(25 * sizeof(real_t));\n    real_t reduced[5];\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n    }\n\n    #pragma acc data copyin(a[0:25*n], b[0:25*n]) copy(minimums[0:25])\n    {\n        #pragma acc parallel loop gang private(reduced)\n        for (int x = 0; x < 5; ++x) {\n            for (int y = 0; y < 5; ++y) {\n                reduced[y] = 1000;\n            }\n            #pragma acc loop vector reduction(min:reduced)\n            for (int y = 0; y < 5 * n; ++y) {\n                reduced[y%5] = fmin(a[x * 5 * n + y] * b[x * 5 * n + y], reduced[y % 5]);\n            }\n            for (int y = 0; y < 5; ++y) {\n                minimums[x * 5 + y] = reduced[y];\n            }\n        }\n    }\n\n    for (int x = 0; x < 5; ++x) {\n        for (int y = 0; y < 5; ++y) {\n            reduced[y] = 1000;\n        }\n        for (int y = 0; y < 5 * n; ++y) {\n            reduced[y%5] = fmin(a[x * 5 * n + y] * b[x * 5 * n + y], reduced[y % 5]);\n        }\n        for (int y = 0; y < 5; ++y) {\n            if (fabs(reduced[y] - minimums[x * 5 + y]) > PRECISION) {\n                err += 1;\n            }\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T2\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test2();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 1);\n    }\n#endif\n",
                        "tags": [
                            "parallel",
                            "private",
                            "reduction",
                            "combined-constructs",
                            "loop"
                        ],
                        "versions": [
                            "2.7"
                        ]
                    }
                }
            },
            "parallel_loop_reduction_multiply_general.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:parallel,reduction,combined-constructs,loop,V:1.0-2.7\n      LOGICAL FUNCTION test1()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT):: a, b !Data\n        INTEGER :: errors = 0\n        REAL(8) :: temp = 1\n        REAL(8) :: multiplied_total = 1\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(a)\n        CALL RANDOM_NUMBER(b)\n        a = (999.4 + a)/1000\n        b = (999.4 + b)/1000\n\n        !$acc data copyin(a(1:LOOPCOUNT))\n          !$acc parallel loop reduction(*:multiplied_total)\n          DO x = 1, LOOPCOUNT\n            multiplied_total = multiplied_total * (a(x) + b(x))\n          END DO\n        !$acc end data\n\n        DO x = 1, LOOPCOUNT\n          temp = temp * (a(x) + b(x))\n        END DO\n        IF (abs(temp - multiplied_total) .gt. ((temp / 2) + (multiplied_total / 2)) * PRECISION) THEN\n          WRITE(*, *) temp\n          WRITE(*, *) multiplied_total\n          errors = errors + 1\n        END IF\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "parallel",
                            "reduction",
                            "combined-constructs",
                            "loop"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "parallel_loop_reduction_multiply_general.c": {
                "num tests": 2,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:parallel,loop,reduction,combined-constructs,V:1.0-2.7\nint test1(){\n    int err = 0;\n    int multiplicitive_n = 128;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(multiplicitive_n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(multiplicitive_n * sizeof(real_t));\n\n    real_t multiplied_total = 1.0;\n\n    for (int x = 0; x < multiplicitive_n; ++x){\n        a[x] = rand() / (real_t) RAND_MAX;\n        b[x] = rand() / (real_t) RAND_MAX;\n    }\n\n    #pragma acc data copyin(a[0:multiplicitive_n], b[0:multiplicitive_n]) copy(multiplied_total)\n    {\n        #pragma acc parallel loop reduction(*:multiplied_total)\n        for (int x = 0; x < multiplicitive_n; ++x){\n            multiplied_total *= a[x] + b[x];\n        }\n    }\n\n    for (int x = 0; x < multiplicitive_n; ++x){\n        multiplied_total /= (a[x] + b[x]);\n    }\n    if (fabs(multiplied_total - 1) > PRECISION * (2 * multiplicitive_n - 1)){\n        err = 1;\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "parallel",
                            "loop",
                            "reduction",
                            "combined-constructs"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "2": {
                        "content": "#ifndef T2\n//T2:parallel,reduction,combined-constructs,loop,V:2.7-2.7\nint test2(){\n    int err = 0;\n    int m_n = 128;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(10 * m_n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(10 * m_n * sizeof(real_t));\n\n    real_t multiplicitive_total[10];\n\n    for (int x = 0; x < m_n; ++x){\n        a[x] = rand() / (real_t) RAND_MAX;\n        b[x] = rand() / (real_t) RAND_MAX;\n    }\n\n    for (int x = 0; x < 10; ++x) {\n        multiplicitive_total[x] = 1.0;\n    }\n\n    #pragma acc data copyin(a[0:10*m_n], b[0:10*m_n])\n    {\n        #pragma acc parallel loop reduction(*:multiplicitive_total)\n        for (int x = 0; x < 10 * m_n; ++x) {\n            multiplicitive_total[x%10] = multiplicitive_total[x%10] * (a[x] + b[x]);\n        }\n    }\n\n    for (int x = 0; x < 10 * m_n; ++x) {\n        multiplicitive_total[x%10] /= (a[x] + b[x]);\n    }\n\n    for (int x = 0; x < 10; ++x) {\n        if (fabs(multiplicitive_total[x]) > PRECISION) {\n            err += 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T2\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test2();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 1);\n    }\n#endif\n",
                        "tags": [
                            "parallel",
                            "reduction",
                            "combined-constructs",
                            "loop"
                        ],
                        "versions": [
                            "2.7"
                        ]
                    }
                }
            },
            "parallel_loop_reduction_multiply_loop.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:parallel,private,reduction,combined-constructs,loop,V:1.0-2.7\n      LOGICAL FUNCTION test1()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x, y !Iterators\n        REAL(8),DIMENSION(10*LOOPCOUNT):: a, b, c !Data\n        REAL(8),DIMENSION(10):: totals\n        REAL(8) :: temp\n        INTEGER :: errors = 0\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(a)\n        CALL RANDOM_NUMBER(b)\n        c = 0\n        a = (999.4 + a) / 2000\n        b = (999.4 + b) / 2000\n\n        !$acc data copyin(a(1:10*LOOPCOUNT), b(1:10*LOOPCOUNT)) copy(c(1:10*LOOPCOUNT), totals(1:10))\n          !$acc parallel loop gang private(temp)\n          DO x = 0, 9\n            temp = 1\n            !$acc loop worker reduction(*:temp)\n            DO y = 1, LOOPCOUNT\n              temp = temp * (a(x * LOOPCOUNT + y) + b(x * LOOPCOUNT + y))\n            END DO\n            totals(x + 1) = temp\n            !$acc loop worker\n            DO y = 1, LOOPCOUNT\n              c(x * LOOPCOUNT + y) = (a(x * LOOPCOUNT + y) + b(x * LOOPCOUNT + y)) / totals(x + 1)\n            END DO\n          END DO\n        !$acc end data\n\n        DO x = 0, 9\n          temp = 1\n          DO y = 1, LOOPCOUNT\n            temp = temp * (a(x * LOOPCOUNT + y) + b(x * LOOPCOUNT + y))\n          END DO\n          IF (abs(temp - totals(x + 1)) .gt. ((temp / 2) + (totals(x + 1) / 2)) * PRECISION) THEN\n            errors = errors + 1\n            WRITE(*, *) temp\n            WRITE(*, *) totals(x + 1)\n            WRITE(*, *) \" \"\n          END IF\n          DO y = 1, LOOPCOUNT \n            IF (abs(c(x * LOOPCOUNT + y) - ((a(x * LOOPCOUNT + y) + b(x * LOOPCOUNT + y)) / totals(x + 1))) .gt. c(x * LOOPCOUNT + y) * PRECISION) THEN\n              errors = errors + 1\n              WRITE(*, *) c(x * LOOPCOUNT + y)\n              WRITE(*, *) a(x * LOOPCOUNT + y) + b(x * LOOPCOUNT + y)\n              WRITE(*, *) \" \"\n            END IF\n          END DO\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "parallel",
                            "private",
                            "reduction",
                            "combined-constructs",
                            "loop"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "parallel_loop_reduction_multiply_loop.c": {
                "num tests": 2,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:parallel,loop,reduction,combined-constructs,V:1.0-2.7\nint test1(){\n    int err = 0;\n    int m_n = 128;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(10 * m_n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(10 * m_n * sizeof(real_t));\n    real_t * c = (real_t *)malloc(10 * m_n * sizeof(real_t));\n    real_t * totals = (real_t *)malloc(10 * sizeof(real_t));\n    real_t temp;\n\n    for (int x = 0; x < 10 * m_n; ++x){\n        a[x] = .05 + rand() / (real_t)(RAND_MAX);\n        b[x] = .05 + rand() / (real_t)(RAND_MAX);\n        c[x] = 0.0;\n    }\n\n\n    #pragma acc data copyin(a[0:10*m_n], b[0:10*m_n]) copyout(c[0:10*m_n], totals[0:10])\n    {\n        #pragma acc parallel loop gang private(temp)\n        for (int x = 0; x < 10; ++x){\n            temp = 1;\n            #pragma acc loop worker reduction(*:temp)\n            for (int y = 0; y < m_n; ++y){\n                temp *= a[x * m_n + y] + b[x * m_n + y];\n            }\n            totals[x] = temp;\n            #pragma acc loop worker\n            for (int y = 0; y < m_n; ++y){\n                c[x * m_n + y] = (a[x * m_n + y] + b[x * m_n + y]) / totals[x];\n            }\n        }\n    }\n\n    for (int x = 0; x < 10; ++x){\n        temp = 1;\n        for (int y = 0; y < m_n; ++y){\n            temp *= a[x * m_n + y] + b[x * m_n + y];\n        }\n        if (fabs(temp - totals[x]) > (temp / 2 + totals[x] / 2) * PRECISION){\n            err += 1;\n        }\n        for (int y = 0; y < m_n; ++y){\n            if (fabs(c[x * m_n + y] - ((a[x * m_n + y] + b[x * m_n + y]) / totals[x])) > PRECISION){\n                err += 1;\n            }\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "parallel",
                            "loop",
                            "reduction",
                            "combined-constructs"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "2": {
                        "content": "#ifndef T2\n//T2:parallel,private,reduction,combined-constructs,loop,V:2.7-2.7\nint test2(){\n    int err = 0;\n    int m_n = 128;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(25 * m_n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(25 * m_n * sizeof(real_t));\n    real_t * c = (real_t *)malloc(25 * m_n * sizeof(real_t));\n\n    real_t * totals = (real_t *)malloc(25 * sizeof(real_t));\n    real_t reduced[5];\n\n    for (int x = 0; x < n; ++x){\n        a[x] = .05 + rand() / (real_t)(RAND_MAX / 10);\n        b[x] = .05 + rand() / (real_t)(RAND_MAX / 10);\n        c[x] = 0;\n    }\n\n    #pragma acc data copyin(a[0:25*m_n], b[0:25*m_n]) copyout(c[0:25*m_n], totals[0:25])\n    {\n        #pragma acc parallel loop gang private(reduced)\n        for (int x = 0; x < 5; ++x) {\n            for (int y = 0; y < 5; ++y) {\n                reduced[y] = 1.0;\n            }\n            #pragma acc loop worker reduction(*:reduced)\n            for (int y = 0; y < 5 * m_n; ++y) {\n                reduced[y%5] *= a[x * 5 * m_n + y] + b[x * 5 * m_n + y];\n            }\n            for (int y = 0; y < 5; ++y) {\n                totals[x * 5 + y] = reduced[y];\n            }\n            for (int y = 0; y < 5 * m_n; ++y) {\n                c[x * 5 * m_n + y] = (a[x * 5 * m_n + y] + b[x * 5 * m_n + y]) / totals[x * 5 + (y%5)];\n            }\n        }\n    }\n\n    for (int x = 0; x < 5; ++x) {\n        for (int y = 0; y < 5; ++y) {\n            reduced[y] = 1;\n        }\n        for (int y = 0; y < 5 * m_n; ++y) {\n            reduced[y%5] *= a[x * 5 * m_n + y] + b[x * 5 * m_n + y];\n        }\n        for (int y = 0; y < 5; ++y) {\n            if (fabs(totals[x * 5 + y] - reduced[y]) > PRECISION) {\n                err += 1;\n            }\n        }\n        for (int y = 0; y < 5 * m_n; ++y) {\n            if (fabs(c[x * 5 * m_n + y] - ((a[x * 5 * m_n + y] + b[x * 5 * m_n + y]) / totals[x * 5 + (y % 5)])) > PRECISION) {\n                err += 1;\n            }\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T2\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test2();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 1);\n    }\n#endif\n",
                        "tags": [
                            "parallel",
                            "private",
                            "reduction",
                            "combined-constructs",
                            "loop"
                        ],
                        "versions": [
                            "2.7"
                        ]
                    }
                }
            },
            "parallel_loop_reduction_multiply_vector_loop.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:parallel,private,reduction,combined-constructs,loop,V:1.0-2.7\n      LOGICAL FUNCTION test1()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x, y !Iterators\n        REAL(8),DIMENSION(10 * LOOPCOUNT):: a, b !Data\n        REAL(8),DIMENSION(10) :: c\n        REAL(8) :: temp\n        INTEGER :: errors = 0\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(a)\n        CALL RANDOM_NUMBER(b)\n        a = (999.4 + a) / 1000\n        b = (999.4 + b) / 1000\n\n        !$acc data copyin(a(1:10*LOOPCOUNT), b(1:10*LOOPCOUNT)) copyout(c(1:10))\n          !$acc parallel loop private(temp)\n          DO x = 0, 9\n            temp = 1\n            !$acc loop vector reduction(*:temp)\n            DO y = 1, LOOPCOUNT\n              temp = temp * (a(x * LOOPCOUNT + y) + b(x * LOOPCOUNT + y))\n            END DO\n            c(x + 1) = temp\n          END DO\n        !$acc end data\n\n        DO x = 0, 9\n          temp = 1\n          DO y = 1, LOOPCOUNT\n            temp = temp * (a(x * LOOPCOUNT + y) + b(x * LOOPCOUNT + y))\n          END DO\n          IF (abs(temp - c(x + 1)) .gt. ((temp / 2) + (c(x + 1) / 2)) * PRECISION) THEN\n            errors = errors + 1\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "parallel",
                            "private",
                            "reduction",
                            "combined-constructs",
                            "loop"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "parallel_loop_reduction_multiply_vector_loop.c": {
                "num tests": 3,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:parallel,loop,reduction,combined-constructs,V:1.0-2.7\nint test1() {\n    int err = 0;\n    int multiplicitive_n = 128;\n    srand(SEED);\n    real_t* a = (real_t*)malloc(10 * multiplicitive_n * sizeof(real_t));\n    real_t* b = (real_t*)malloc(10 * multiplicitive_n * sizeof(real_t));\n    real_t* c = (real_t*)malloc(10 * sizeof(real_t));\n    real_t temp;\n\n    for (int x = 0; x < 10 * multiplicitive_n; ++x) {\n        a[x] = rand() / (real_t)RAND_MAX;\n        b[x] = rand() / (real_t)RAND_MAX;\n    }\n\n#pragma acc data copyin(a[0:10*multiplicitive_n], b[0:10*multiplicitive_n]) copyout(c[0:10])\n    {\n#pragma acc parallel loop private(temp)\n        for (int x = 0; x < 10; ++x) {\n            temp = 1.0;\n#pragma acc loop vector reduction(*:temp)\n            for (int y = 0; y < multiplicitive_n; ++y) {\n                temp *= a[(x * multiplicitive_n) + y] + b[(x * multiplicitive_n) + y];\n            }\n            c[x] = temp;\n        }\n    }\n\n    for (int x = 0; x < 10; ++x) {\n        for (int y = 0; y < multiplicitive_n; ++y) {\n            c[x] /= a[(x * multiplicitive_n) + y] + b[(x * multiplicitive_n) + y];\n        }\n    }\n\n    for (int x = 0; x < 10; ++x) {\n        if (fabs(c[x] - 1) > PRECISION* (4 * multiplicitive_n - 1)) {\n            err = 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "parallel",
                            "loop",
                            "reduction",
                            "combined-constructs"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "2": {
                        "content": "#ifndef T2\n//T2:parallel,private,reduction,combined-constructs,loop,V:2.7-2.7\nint test2() {\n    int err = 0;\n    int m_n = 128;\n    srand(SEED);\n    real_t* a = (real_t*)malloc(25 * m_n * sizeof(real_t));\n    real_t* b = (real_t*)malloc(25 * m_n * sizeof(real_t));\n    real_t* c = (real_t*)malloc(25 * m_n * sizeof(real_t));\n    real_t* totals = (real_t*)malloc(25 * sizeof(real_t));\n    real_t reduced[5];\n\n    for (int x = 0; x < n; ++x) {\n        a[x] = .05 + rand() / (real_t)(RAND_MAX / 10);\n        b[x] = .05 + rand() / (real_t)(RAND_MAX / 10);\n        c[x] = 0;\n    }\n\n    #pragma acc data copyin(a[0:25*m_n], b[0:25*m_n]) copyout(c[0:25*m_n], totals[0:25])\n    {\n        #pragma acc parallel loop gang private(reduced)\n        for (int x = 0; x < 5; ++x) {\n            for (int y = 0; y < 5; ++y) {\n                reduced[y] = 1.0;\n            }\n            #pragma acc loop worker reduction(*:reduced)\n            for (int y = 0; y < 5 * m_n; ++y) {\n                reduced[y % 5] *= a[x * 5 * m_n + y] + b[x * 5 * m_n + y];\n            }\n            for (int y = 0; y < 5; ++y) {\n                totals[x * 5 + y] = reduced[y];\n            }\n            #pragma acc loop worker\n            for (int y = 0; y < 5 * m_n; ++y) {\n                c[x * 5 * m_n + y] = (a[x * 5 * m_n + y] + b[x * 5 * m_n + y]) / totals[(x * 5) + (y % 5)];\n            }\n        }\n    }\n\n    for (int x = 0; x < 5; ++x) {\n        for (int y = 0; y < 5; ++y) {\n            reduced[y] = 1;\n        }\n        for (int y = 0; y < 5 * m_n; ++y) {\n            reduced[y % 5] *= a[x * 5 * m_n + y] + b[x * 5 * m_n + y];\n        }\n        for (int y = 0; y < 5; ++y) {\n            if (fabs(totals[x * 5 + y] - reduced[y]) > PRECISION) {\n                err += 1;\n            }\n        }\n        for (int y = 0; y < 5 * m_n; ++y) {\n            if (fabs(c[x * 5 * m_n + y] - ((a[x * 5 * m_n + y] + b[x * 5 * m_n + y]) / totals[x * 5 + (y % 5)])) > PRECISION){\n                err += 1;\n            }   \n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T2\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test2();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 1);\n    }\n#endif\n",
                        "tags": [
                            "parallel",
                            "private",
                            "reduction",
                            "combined-constructs",
                            "loop"
                        ],
                        "versions": [
                            "2.7"
                        ]
                    },
                    "3": {
                        "content": "#ifndef T3\n//T3:\nint test3(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n    real_t * c = (real_t *)malloc(n * sizeof(real_t));\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n        c[x] = 0;\n    }\n\n    return err;\n}\n#endif\n#ifndef T3\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test3();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 2);\n    }\n#endif\n",
                        "tags": [
                            ""
                        ],
                        "versions": []
                    }
                }
            },
            "parallel_loop_reduction_or_general.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:parallel,reduction,combined-constructs,loop,V:1.0-2.7\n      LOGICAL FUNCTION test1()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x !Iterators\n        LOGICAL,DIMENSION(LOOPCOUNT):: a !Data\n        LOGICAL :: results = .FALSE.\n        LOGICAL :: temp = .FALSE.\n        REAL(8) :: false_margin = exp(log(.5) / n)\n        REAL(8),DIMENSION(LOOPCOUNT):: random\n        INTEGER :: errors = 0\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(random)\n        DO x = 1, LOOPCOUNT\n          IF (random(x) > false_margin) THEN\n            a(x) = .TRUE.\n          ELSE\n            a(x) = .FALSE.\n          END IF\n        END DO\n\n        !$acc data copyin(a(1:LOOPCOUNT))\n          !$acc parallel loop reduction(.OR.:results)\n          DO x = 1, LOOPCOUNT\n            results = results .OR. a(x)\n          END DO\n        !$acc end data\n\n        DO x = 1, LOOPCOUNT\n          temp = temp .OR. a(x)\n        END DO\n        IF (temp .neqv. results) THEN\n          errors = errors + 1\n        END IF\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "parallel",
                            "reduction",
                            "combined-constructs",
                            "loop"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "parallel_loop_reduction_or_general.c": {
                "num tests": 2,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:parallel,loop,reduction,combined-constructs,V:1.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    char * a = (char *)malloc(n * sizeof(char));\n    real_t false_margin = pow(exp(1), log(.5)/n);\n    char result = 0;\n    char found = 0;\n\n    for (int x = 0; x < n; ++x){\n        if(rand() / (real_t)(RAND_MAX) > false_margin){\n            a[x] = 1;\n        }\n        else{\n            a[x] = 0;\n        }\n    }\n\n\n    #pragma acc data copyin(a[0:n])\n    {\n        #pragma acc parallel loop reduction(||:result)\n        for (int x = 0; x < n; ++x){\n            result = result || a[x];\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        if (a[x] == 1){\n            found = 1;\n        }\n    }\n    if (found != result){\n        err = 1;\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "parallel",
                            "loop",
                            "reduction",
                            "combined-constructs"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "2": {
                        "content": "#ifndef T2\n//T2:parallel,reduction,combined-constructs,loop,V:2.7-2.7\nint test2(){\n    int err = 0;\n    srand(SEED);\n    char* a = (char *)malloc(5 * n * sizeof(char));\n    char result[5];\n    char host_result[5];\n    real_t false_margin = pow(exp(1), log(.5)/n);\n\n    for (int x = 0; x < 5; ++x) {\n        result[x] = 0;\n        host_result[x] = 0;\n    }\n\n    for (int x = 0; x < 5 * n; ++x) {\n        if (rand() / (real_t)(RAND_MAX) > false_margin) {\n            a[x] = 1;\n        }\n        else {\n            a[x] = 0;\n        }\n    }\n\n    #pragma acc data copyin(a[0:5*n])\n    {\n        #pragma acc parallel loop reduction(||:result)\n        for (int x = 0; x < 5 * n; ++x) {\n            result[x%5] = result[x%5] || a[x];\n        }\n    }\n\n    for (int x = 0; x < 5 * n; ++x) {\n        host_result[x%5] = host_result[x%5] || a[x];\n    }\n    \n    for (int x = 0; x < 5; ++x) {\n        if (host_result[x] != result[x]) {\n            err += 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T2\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test2();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 1);\n    }\n#endif\n",
                        "tags": [
                            "parallel",
                            "reduction",
                            "combined-constructs",
                            "loop"
                        ],
                        "versions": [
                            "2.7"
                        ]
                    }
                }
            },
            "parallel_loop_reduction_or_loop.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:parallel,private,reduction,combined-constructs,loop,V:1.0-2.7\n      LOGICAL FUNCTION test1()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x, y !Iterators\n        LOGICAL,DIMENSION(10*LOOPCOUNT):: a, a_copy !Data\n        LOGICAL,DIMENSION(10) :: results\n        LOGICAL :: temp = .FALSE.\n        REAL(8),DIMENSION(10 * LOOPCOUNT) :: random\n        REAL(8) :: false_margin = exp(log(.5) / n)\n        INTEGER :: errors = 0\n\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(random)\n\n        !Initilization\n        DO x = 1, 10 * LOOPCOUNT\n          IF (random(x) .gt. false_margin) THEN\n            a(x) = .TRUE.\n          ELSE\n            a(x) = .FALSE.\n          END IF\n          a_copy(x) = a(x)\n        END DO\n\n        DO x = 1, 10\n          results(x) = .FALSE.\n        END DO\n\n        !$acc data copy(a(1:10*LOOPCOUNT), results(1:10))\n          !$acc parallel loop gang private(temp)\n          DO x = 0, 9\n            temp = .FALSE.\n            !$acc loop worker reduction(.OR.:temp)\n            DO y = 1, LOOPCOUNT\n              temp = temp .OR. a(x * LOOPCOUNT + y)\n            END DO\n            results(x + 1) = temp\n            !$acc loop worker\n            DO y = 1, LOOPCOUNT\n              IF (results(x + 1) .eqv. .TRUE.) THEN\n                IF(a(x * LOOPCOUNT + y) .eqv. .TRUE.) THEN\n                  a(x * LOOPCOUNT + y) = .FALSE.\n                ELSE\n                  a(x * LOOPCOUNT + y) = .TRUE.\n                END IF\n              END IF\n            END DO\n          END DO\n        !$acc end data\n\n        DO x = 0, 9\n          temp = .FALSE.\n          DO y = 1, LOOPCOUNT\n            temp = temp .OR. a_copy(x * LOOPCOUNT + y)\n          END DO\n          IF (temp .neqv. results(x + 1)) THEN\n            errors = errors + 1\n          END IF\n          DO y = 1, LOOPCOUNT\n            IF (temp .eqv. .FALSE.) THEN\n              IF (a(x * LOOPCOUNT + y) .neqv. a_copy(x * LOOPCOUNT + y)) THEN\n                errors = errors + 1\n              END IF\n            ELSE\n              IF (a(x * LOOPCOUNT + y) .eqv. a_copy(x * LOOPCOUNT + y)) THEN\n                errors = errors + 1\n              END IF\n            END IF\n          END DO\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "parallel",
                            "private",
                            "reduction",
                            "combined-constructs",
                            "loop"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "parallel_loop_reduction_or_loop.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:parallel,loop,reduction,combined-constructs,V:1.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    char * a = (char *)malloc(10 * n * sizeof(char));\n    char * a_copy = (char *)malloc(10 * n * sizeof(char));\n    char * results = (char *)malloc(10 * sizeof(char));\n    char temp = 0;\n    real_t false_margin = pow(exp(1), log(.5)/n);\n\n    for (int x = 0; x < 10 * n; ++x){\n        if (rand() / (real_t)(RAND_MAX) > false_margin){\n            a[x] = 1;\n            a_copy[x] = 1;\n        }\n        else{\n            a[x] = 0;\n            a_copy[x] = 0;\n        }\n    }\n    #pragma acc data copy(a[0:10*n])\n    {\n        #pragma acc parallel loop gang private(temp)\n        for (int x = 0; x < 10; ++x){\n            temp = 0;\n            #pragma acc loop worker reduction(||:temp)\n            for (int y = 0; y < n; ++y){\n                temp = temp || a[x * n + y];\n            }\n            results[x] = temp;\n            #pragma acc loop worker\n            for (int y = 0; y < n; ++y){\n                if(results[x] == 1){\n                    if (a[x * n + y] == 1){\n                        a[x * n + y] = 0;\n                    }\n                    else{\n                        a[x * n + y] = 1;\n                    }\n                }\n            }\n        }\n    }\n    for (int x = 0; x < 10; ++x){\n        temp = 0;\n        for (int y = 0; y < n; ++y){\n            temp = temp || a_copy[x * n + y];\n        }\n        if (temp != results[x]) {\n            err += 1;\n        }\n        for (int y = 0; y < n; ++y){\n            if (temp == 1){\n                if (a[x * n + y] == a_copy[x * n + y]){\n                    err += 1;\n                }\n            }\n            else {\n                if (a[x * n + y] != a_copy[x * n + y]){\n                    err += 1;\n                }\n            }\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "parallel",
                            "loop",
                            "reduction",
                            "combined-constructs"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "parallel_loop_reduction_or_vector_loop.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:parallel,private,reduction,combined-constructs,loop,V:1.0-2.7\n      LOGICAL FUNCTION test1()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x, y !Iterators\n        LOGICAL,DIMENSION(10*LOOPCOUNT):: a !Data\n        LOGICAL,DIMENSION(10) :: b\n        LOGICAL :: temp\n        REAL(8),DIMENSION(10*LOOPCOUNT):: randoms\n        REAL(8) :: false_margin = exp(log(.5) / 2)\n        INTEGER :: errors = 0\n\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(randoms)\n\n        !Initilization\n        DO x = 1, 10 * LOOPCOUNT\n          IF (randoms(x) > false_margin) THEN\n            a(x) = .TRUE.\n          ELSE\n            a(x) = .FALSE.\n          END IF\n        END DO\n\n        !$acc data copyin(a(1:10*LOOPCOUNT)), copy(b(1:10))\n          !$acc parallel loop private(temp)\n          DO x = 0, 9\n            temp = .FALSE.\n            !$acc loop vector reduction(.OR.:temp)\n            DO y = 1, LOOPCOUNT\n              temp = temp .OR. a(x * LOOPCOUNT + y)\n            END DO\n            b(x + 1) = temp\n          END DO\n        !$acc end data\n\n        DO x = 0, 9\n          temp = .FALSE.\n          DO y = 1, LOOPCOUNT\n            temp = temp .OR. a(x * LOOPCOUNT + y)\n          END DO\n          IF (temp .neqv. b(x + 1)) THEN\n            errors = errors + 1\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "parallel",
                            "private",
                            "reduction",
                            "combined-constructs",
                            "loop"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "parallel_loop_reduction_or_vector_loop.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:parallel,loop,reduction,combined-constructs,V:1.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    char * a = (char *)malloc(10 * n * sizeof(char));\n    char * b = (char *)malloc(10 * sizeof(char));\n    real_t false_margin = pow(exp(1), log(.5)/n);\n    char temp = 0;\n    char found;\n\n    for (int x = 0; x < 10 * n; ++x){\n        if(rand() / (real_t)(RAND_MAX) > false_margin){\n            a[x] = 1;\n        }\n        else{\n            a[x] = 0;\n        }\n    }\n    #pragma acc data copyin(a[0:10*n]) copy(b[0:10])\n    {\n        #pragma acc parallel loop private(temp)\n        for (int x = 0; x < 10; ++x){\n            temp = 0;\n            #pragma acc loop vector reduction(||:temp)\n            for (int y = 0; y < n; ++y){\n                temp = temp || a[x * n + y];\n            }\n            b[x] = temp;\n        }\n    }\n    for (int x = 0; x < 10; ++x){\n        found = 0;\n        for (int y = 0; y < n; ++y){\n            if (a[x * n + y] &! 0){\n                found = 1;\n            }\n        }\n        if (found != b[x]){\n            err = 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "parallel",
                            "loop",
                            "reduction",
                            "combined-constructs"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "parallel_loop_seq.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:parallel,combined-constructs,loop,V:1.0-2.7\n      LOGICAL FUNCTION test1()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT):: a, b !Data\n        INTEGER :: errors = 0\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(a)\n        b = 0\n\n        !$acc data copyin(a(1:LOOPCOUNT)) copy(b(1:LOOPCOUNT))\n          !$acc parallel loop seq\n          DO x = 2, LOOPCOUNT\n            b(x) = b(x - 1) + a(x)\n          END DO\n        !$acc end data\n        \n        DO x = 2, LOOPCOUNT\n          IF (abs(b(x) - (b(x - 1) + a(x))) .gt. PRECISION) THEN\n            errors = errors + 1\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "parallel",
                            "combined-constructs",
                            "loop"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "parallel_loop_seq.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:parallel,loop,combined-constructs,V:1.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n    real_t temp = 0.0;\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = 0.0;\n    }\n\n    #pragma acc data copyin(a[0:n]) copy(b[0:n])\n    {\n        #pragma acc parallel loop seq\n        for (int x = 1; x < n; ++x){\n            b[x] = b[x-1] + a[x];\n        }\n    }\n\n    for (int x = 1; x < n; ++x){\n        temp += a[x];\n        if (fabs(b[x] - temp) > PRECISION){\n            err = 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "parallel",
                            "loop",
                            "combined-constructs"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "parallel_loop_tile.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:parallel,reduction,combined-constructs,loop,tile,V:2.0-2.7\n      LOGICAL FUNCTION test1()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x, y, z !Iterators\n        REAL(8),DIMENSION(SMALL_LOOPCOUNT):: a, b, c !Data\n        REAL(8),DIMENSION(SMALL_LOOPCOUNT,SMALL_LOOPCOUNT)::d\n        REAL(8) :: temp\n        INTEGER :: errors = 0\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(a)\n        CALL RANDOM_NUMBER(b)\n        CALL RANDOM_NUMBER(c)\n\n        !$acc data copyin(a(1:SMALL_LOOPCOUNT), b(1:SMALL_LOOPCOUNT), c(1:SMALL_LOOPCOUNT)) copyout(d(1:SMALL_LOOPCOUNT,1:SMALL_LOOPCOUNT))\n          !$acc parallel loop tile(*, *) reduction(+:temp)\n          DO x = 1, SMALL_LOOPCOUNT\n            DO y = 1, SMALL_LOOPCOUNT \n              temp = 0\n              DO z = 1, SMALL_LOOPCOUNT\n                temp = temp + a(z) + b(z) + c(z)\n              END DO\n              d(x,y) = temp\n            END DO\n          END DO\n        !$acc end data\n        \n        DO x = 1, SMALL_LOOPCOUNT \n          DO y = 1, SMALL_LOOPCOUNT \n            temp = 0\n            DO z = 1, SMALL_LOOPCOUNT\n              temp = temp + a(z) + b(z) + c(z) \n            END DO\n            IF (abs(d(x,y) - temp) .gt. PRECISION) THEN\n              errors = errors + 1\n            END IF\n          END DO\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "parallel",
                            "reduction",
                            "combined-constructs",
                            "loop",
                            "tile"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "parallel_loop_tile.c": {
                "num tests": 2,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:parallel,loop,tile,reduction,combined-constructs,V:2.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n    real_t * c = (real_t *)malloc(n * sizeof(real_t));\n    real_t * d2 = (real_t *)malloc(n * n * sizeof(real_t));\n    real_t * d3 = (real_t *)malloc(n * n * n * sizeof(real_t));\n    real_t temp = 0.0;\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n        c[x] = rand() / (real_t)(RAND_MAX / 10);\n    }\n    #pragma acc data copy(a[0:n], b[0:n], c[0:n], d2[0:n*n])\n    {\n        #pragma acc parallel loop tile(*, *) reduction(+:temp)\n        for (int x = 0; x < n; ++x){\n            for (int y = 0; y < n; ++y){\n                temp = 0;\n                for (int z = 0; z < n; ++z){\n                    temp += a[x] + b[y] + c[z];\n                }\n                d2[x * n + y] = temp;\n            }\n        }\n    }\n    for (int x = 0; x < n; ++x){\n        for (int y = 0; y < n; ++y){\n            temp = 0.0;\n            for (int z = 0; z < n; ++z){\n                temp += a[x] + b[y] + c[z];\n            }\n            if (fabs(temp - d2[x * n + y]) > PRECISION * n){\n                err += 1;\n            }\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "parallel",
                            "loop",
                            "tile",
                            "reduction",
                            "combined-constructs"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "2": {
                        "content": "#ifndef T2\n//T2:parallel,loop,tile,combined-constructs,V:2.0-2.7\nint test2(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n    real_t * c = (real_t *)malloc(n * sizeof(real_t));\n    real_t * d2 = (real_t *)malloc(n * n * sizeof(real_t));\n    real_t * d3 = (real_t *)malloc(n * n * n * sizeof(real_t));\n    real_t temp = 0.0;\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n        c[x] = rand() / (real_t)(RAND_MAX / 10);\n    }\n\n    #pragma acc data copyin(a[0:n], b[0:n], c[0:n]) copyout(d3[0:n*n*n])\n    {\n        #pragma acc parallel loop tile(2, 4, 8)\n        for (int x = 0; x < n; ++x){\n            for (int y = 0; y < n; ++y){\n                for (int z = 0; z < n; ++z){\n                    d3[(n * n * x) + (n * y) + z] = a[x] + b[x] + c[x];\n                }\n            }\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        for (int y = 0; y < n; ++y){\n            for (int z = 0; z < n; ++z){\n                if (fabs(d3[(n * n * x) + (n * y) + z] - a[x] - b[x] - c[x]) > PRECISION * 2){\n                    err = 1;\n                }\n            }\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T2\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test2();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 1);\n    }\n#endif\n",
                        "tags": [
                            "parallel",
                            "loop",
                            "tile",
                            "combined-constructs"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "parallel_loop_vector.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:parallel,combined-constructs,loop,V:1.0-2.7\n      LOGICAL FUNCTION test1()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT):: a, b, c !Data\n        INTEGER :: errors = 0\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(a)\n        CALL RANDOM_NUMBER(b)\n        c = 0\n\n        !$acc data copyin(a(1:LOOPCOUNT), b(1:LOOPCOUNT)) copy(c(1:LOOPCOUNT))\n          !$acc parallel loop vector\n          DO x = 1, LOOPCOUNT\n            c(x) = a(x) + b(x)\n          END DO\n        !$acc end data\n        \n        DO x = 1, LOOPCOUNT\n          IF (abs(c(x) - (a(x) + b(x))) .gt. PRECISION) THEN\n            errors = errors + 1\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "parallel",
                            "combined-constructs",
                            "loop"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "parallel_loop_vector.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:parallel,loop,vector,combined-constructs,V:1.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n    real_t * c = (real_t *)malloc(n * sizeof(real_t));\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n        c[x] = 0.0;\n    }\n\n    #pragma acc data copyin(a[0:n], b[0:n]) copy(c[0:n])\n    {\n        #pragma acc parallel loop vector\n        for (int x = 0; x < n; ++x){\n            c[x] = a[x] + b[x];\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        if(fabs(c[x] - (a[x] + b[x])) > PRECISION){\n            err = 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "parallel",
                            "loop",
                            "vector",
                            "combined-constructs"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "parallel_loop_vector_blocking.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:parallel,loop,V:1.0-2.7\n      LOGICAL FUNCTION test1()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT):: a, b, c !Data\n        REAL(8) :: multiplyer\n        INTEGER :: errors = 0\n\n        multiplyer = 1\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(a)\n        CALL RANDOM_NUMBER(b)\n        c = 0\n\n        !$acc data copyin(a(1:LOOPCOUNT), b(1:LOOPCOUNT)) copyout(c(1:LOOPCOUNT))\n          !$acc parallel\n            !$acc loop vector\n            DO x = 1, LOOPCOUNT\n              c(x) = (a(x) + b(x)) * multiplyer\n            END DO\n            multiplyer = multiplyer + 1\n            !$acc loop vector\n            DO x = 1, LOOPCOUNT\n              c(x) = c(x) + ((a(x) + b(x)) * multiplyer)\n            END DO\n          !$acc end parallel\n        !$acc end data\n\n        DO x = 1, LOOPCOUNT\n          IF (abs(c(x) - (3 * (a(x) + b(x)))) .gt. PRECISION) THEN\n            errors = errors + 1\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "parallel",
                            "loop"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "parallel_loop_vector_blocking.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:parallel,loop,V:1.0-2.7\nint test1(){\n  int err = 0;\n  srand(SEED);\n  real_t * a = (real_t *)malloc(n * sizeof(real_t));\n  real_t * b = (real_t *)malloc(n * sizeof(real_t));\n  real_t * c = (real_t *)malloc(n * sizeof(real_t));\n  real_t multiplyer = 1;\n\n  for (int x = 0; x < n; ++x){\n      a[x] = rand() / (real_t)(RAND_MAX / 10);\n      b[x] = rand() / (real_t)(RAND_MAX / 10);\n      c[x] = 0.0;\n  }\n\n  #pragma acc data copyin(a[0:n], b[0:n]) copyout(c[0:n])\n  {\n    #pragma acc parallel\n    {\n      #pragma acc loop vector\n      for (int x = 0; x < n; ++x){\n        c[x] = (a[x] + b[x]) * multiplyer;\n      }\n      multiplyer += 1;\n      #pragma acc loop vector\n      for (int x = 0; x < n; ++x){\n        c[x] += (a[x] + b[x]) * multiplyer;\n      }\n    }\n  }\n\n  for (int x = 0; x < n; ++x){\n    if (fabs(c[x] - 3 * (a[x] + b[x])) > PRECISION){\n      err + 1;\n      break;\n    }\n  }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "parallel",
                            "loop"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "parallel_loop_worker.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:parallel,combined-constructs,loop,V:1.0-2.7\n      LOGICAL FUNCTION test1()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT):: a, b, c !Data\n        INTEGER :: errors = 0\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(a)\n        CALL RANDOM_NUMBER(b)\n        c = 0\n\n        !$acc data copyin(a(1:LOOPCOUNT), b(1:LOOPCOUNT)) copyout(c(1:LOOPCOUNT))\n          !$acc parallel loop worker\n          DO x = 1, LOOPCOUNT\n            c(x) = a(x) + b(x)\n          END DO\n        !$acc end data\n\n        DO x = 1, LOOPCOUNT\n          IF (abs(c(x) - (a(x) + b(x))) .gt. PRECISION) THEN\n            errors = errors + 1\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "parallel",
                            "combined-constructs",
                            "loop"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "parallel_loop_worker.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:parallel,loop,combined-constructs,V:1.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n    real_t * c = (real_t *)malloc(n * sizeof(real_t));\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n        c[x] = 0.0;\n    }\n\n    #pragma acc data copyin(a[0:n], b[0:n]) copy(c[0:n])\n    {\n        #pragma acc parallel loop worker\n        for (int x = 0; x < n; ++x){\n            c[x] = a[x] + b[x];\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        if (fabs(c[x] - (a[x] + b[x])) > PRECISION){\n            err = 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "parallel",
                            "loop",
                            "combined-constructs"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "parallel_loop_worker_blocking.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:parallel,loop,V:1.0-2.7\n      LOGICAL FUNCTION test1()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT):: a, b, c !Data\n        REAL(8) :: multiplyer\n        INTEGER :: errors = 0\n\n        multiplyer = 1\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(a)\n        CALL RANDOM_NUMBER(b)\n\n        !$acc data copyin(a(1:LOOPCOUNT), b(1:LOOPCOUNT)) copyout(c(1:LOOPCOUNT))\n          !$acc parallel\n            !$acc loop worker\n            DO x = 1, LOOPCOUNT\n              c(x) = (a(x) + b(x)) * multiplyer\n            END DO\n            multiplyer = multiplyer + 1\n            !$acc loop worker\n            DO x = 1, LOOPCOUNT\n              c(x) = c(x) + (a(x) + b(x)) * multiplyer\n            END DO\n          !$acc end parallel\n        !$acc end data\n\n        DO x = 1, LOOPCOUNT\n          IF (abs(c(x) - (3 * (a(x) + b(x)))) .gt. PRECISION) THEN\n            errors = errors + 1\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "parallel",
                            "loop"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "parallel_loop_worker_blocking.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:parallel,loop,V:1.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n    real_t * c = (real_t *)malloc(n * sizeof(real_t));\n    real_t multiplyer = 1;\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n        c[x] = 0.0;\n    }\n\n    #pragma acc data copyin(a[0:n], b[0:n]) copyout(c[0:n])\n    {\n      #pragma acc parallel\n      {\n        #pragma acc loop worker\n        for (int x = 0; x < n; ++x){\n          c[x] = (a[x] + b[x]) * multiplyer;\n        }\n        multiplyer += 1;\n        #pragma acc loop worker\n        for (int x = 0; x < n; ++x){\n          c[x] += (a[x] + b[x]) * multiplyer;\n        }\n      }\n    }\n\n    for (int x = 0; x < n; ++x){\n      if (fabs(c[x] - 3 * (a[x] + b[x])) > PRECISION){\n        err + 1;\n        break;\n      }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "parallel",
                            "loop"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "parallel_present.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:parallel,V:2.0-2.7\n      LOGICAL FUNCTION test1()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT):: a, b, c !Data\n        INTEGER :: errors = 0\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(a)\n        CALL RANDOM_NUMBER(b)\n        c = 0\n\n        !$acc enter data copyin(a(1:LOOPCOUNT), b(1:LOOPCOUNT))\n        !$acc parallel present(a(1:LOOPCOUNT), b(1:LOOPCOUNT)) copy(c(1:LOOPCOUNT))\n          !$acc loop\n          DO x = 1, LOOPCOUNT\n            c(x) = a(x) + b(x)\n          END DO\n        !$acc end parallel\n        !$acc exit data delete(a(1:LOOPCOUNT), b(1:LOOPCOUNT))\n\n        DO x = 1, LOOPCOUNT\n          IF (abs(c(x) - (a(x) + b(x))) .gt. PRECISION) THEN\n            errors = errors + 1\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "parallel"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "parallel_present.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:parallel,present,V:2.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n    real_t * c = (real_t *)malloc(n * sizeof(real_t));\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n        c[x] = 0.0;\n    }\n\n    #pragma acc enter data copyin(a[0:n], b[0:n])\n    #pragma acc parallel present(a[0:n], b[0:n]) copy(c[0:n])\n    {\n        #pragma acc loop\n        for (int x = 0; x < n; ++x){\n            c[x] = a[x] + b[x];\n        }\n    }\n    #pragma acc exit data delete(a[0:n], b[0:n])\n\n    for (int x = 0; x < n; ++x){\n        if (fabs(c[x] - (a[x] + b[x])) > PRECISION){\n            err += 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "parallel",
                            "present"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "parallel_private.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:parallel,private,V:2.0-2.7\n      LOGICAL FUNCTION test1()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x, y !Iterators\n        REAL(8),DIMENSION(10 * LOOPCOUNT):: a, b !Data\n        REAL(8),DIMENSION(LOOPCOUNT):: c\n        REAL(8),DIMENSION(10)::d\n        REAL(8) :: temp\n        INTEGER :: errors = 0\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(a)\n        CALL RANDOM_NUMBER(b)\n        c = 0\n        d = 0\n\n        !$acc enter data copyin(a(1:10*LOOPCOUNT), b(1:10*LOOPCOUNT), d(1:10)) \n        !$acc parallel num_gangs(10) private(c(1:LOOPCOUNT))\n          !$acc loop gang\n          DO x = 1, 10\n            !$acc loop worker\n            DO y = 1, LOOPCOUNT\n              c(y) = a((x - 1) * LOOPCOUNT + y) + b((x - 1) * LOOPCOUNT + y)\n            END DO\n            !$acc loop seq\n            DO y = 1, LOOPCOUNT\n              d(x) = d(x) + c(y)\n            END DO\n          END DO\n        !$acc end parallel\n        !$acc exit data copyout(d(1:10)) delete(a(1:10*LOOPCOUNT), b(1:10*LOOPCOUNT))\n\n        DO x = 0, 9\n          temp = 0\n          DO y = 1, LOOPCOUNT\n            temp = temp + a(x * LOOPCOUNT + y) + b(x * LOOPCOUNT + y)\n          END DO\n          IF (abs(temp - d(x + 1)) .gt. 2 * PRECISION * LOOPCOUNT) THEN\n            errors = errors + 1\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "parallel",
                            "private"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "parallel_private.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:parallel,private,V:2.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(10 * n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(10 * n * sizeof(real_t));\n    real_t * c = (real_t *)malloc(n * sizeof(real_t));\n    real_t * d = (real_t *)malloc(10 * sizeof(real_t));\n\n    for (int x = 0; x < 10; ++x){\n        for (int y = 0; y < n; ++y){\n            a[x * n + y] = rand() / (real_t)(RAND_MAX / 10);\n            b[x * n + y] = rand() / (real_t)(RAND_MAX / 10);\n            c[y] = 0.0;\n        }\n        d[x] = 0.0;\n    }\n\n    #pragma acc enter data copyin(a[0:10*n], b[0:10*n], d[0:10])\n    #pragma acc parallel num_gangs(10) private(c[0:n])\n    {\n        #pragma acc loop gang\n        for (int x = 0; x < 10; ++x){\n            #pragma acc loop worker\n            for (int y = 0; y < n; ++y){\n                c[y] = a[x * n + y] + b[x * n + y];\n            }\n            #pragma acc loop seq\n            for (int y = 0; y < n; ++y){\n                d[x] += c[y];\n            }\n        }\n    }\n    #pragma acc exit data copyout(d[0:10]) delete(a[0:10*n], b[0:10*n])\n\n    real_t temp;\n    for (int x = 0; x < 10; ++x){\n        temp = 0.0;\n        for (int y = 0; y < n; ++y){\n            temp += a[x * n + y] + b[x * n + y];\n        }\n        if (fabs(temp - d[x]) > (2 * PRECISION * n)){\n            err = 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "parallel",
                            "private"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "parallel_reduction.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:parallel,reduction,V:1.0-2.7\n      LOGICAL FUNCTION test1()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT):: a !Data\n        REAL(8) :: results = 0\n        INTEGER :: errors = 0\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(a)\n\n        !$acc data copyin(a(1:LOOPCOUNT))\n          !$acc parallel reduction(+:results)\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              results = results + a(x)\n            END DO\n          !$acc end parallel\n        !$acc end data\n        DO x = 1, LOOPCOUNT\n          results = results - a(x)\n        END DO\n        IF (abs(results) .gt. PRECISION) THEN\n          errors = errors + 1\n        END IF\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "parallel",
                            "reduction"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "parallel_reduction.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:parallel,reduction,V:1.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(n * sizeof(real_t));\n    real_t reduction;\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n    }\n\n    #pragma acc parallel copyin(a[0:n]) reduction(+:reduction)\n    {\n        #pragma acc loop\n        for (int x = 0; x < n; ++x){\n            reduction = reduction + a[x];\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        reduction = reduction - a[x];\n    }\n    if (fabs(reduction) > PRECISION){\n        err += 1;\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "parallel",
                            "reduction"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "parallel_scalar_default_firstprivate.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:parallel,V:1.0-2.7\n      LOGICAL FUNCTION test1()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT):: a, b !Data\n        REAL(8),DIMENSION(1):: random\n        INTEGER :: errors = 0\n        REAL(8) :: scalar\n        REAL(8) :: scalar_copy\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(random)\n        scalar = random(1)\n        scalar_copy = scalar\n        CALL RANDOM_NUMBER(a)\n        b = 0\n\n        !$acc data copyin(a(1:LOOPCOUNT)) copyout(b(1:LOOPCOUNT))\n          !$acc parallel\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              b(x) = a(x) + scalar\n            END DO\n          !$acc end parallel\n        !$acc end data\n        DO x = 1, LOOPCOUNT\n          IF (abs(b(x) - (a(x) + scalar_copy)) .gt. PRECISION) THEN\n            errors = errors + 1\n          END IF\n        END DO\n        IF (abs(scalar_copy - scalar) .gt. PRECISION) THEN\n          errors = errors + 1\n        END IF\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "parallel"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "parallel_scalar_default_firstprivate.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:parallel,data,data-region,default-mapping,V:2.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n    real_t scalar = rand() / (real_t)(RAND_MAX / 10);\n    real_t scalar_copy = scalar;\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = 0.0;\n    }\n\n    #pragma acc data copyin(a[0:n]) copyout(b[0:n])\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                b[x] = a[x] + scalar;\n            }\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        if (fabs(b[x] - (a[x] + scalar_copy)) > PRECISION){\n            err += 1;\n        }\n    }\n    if (fabs(scalar_copy - scalar) > PRECISION){\n        err += 1;\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "parallel",
                            "data",
                            "data-region",
                            "default-mapping"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "parallel_switch.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:parallel,V:2.0-2.7\n      LOGICAL FUNCTION test1()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x !Iterators\n        INTEGER,DIMENSION(LOOPCOUNT):: a\n        REAL(8),DIMENSION(LOOPCOUNT):: b, c, randoms!Data\n        INTEGER :: errors = 0\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(b)\n        c = 0\n        CALL RANDOM_NUMBER(randoms)\n        a = floor(randoms * 3)\n\n        !$acc enter data copyin(a(1:LOOPCOUNT), b(1:LOOPCOUNT), c(1:LOOPCOUNT))\n        !$acc parallel present(a(1:LOOPCOUNT), b(1:LOOPCOUNT), c(1:LOOPCOUNT))\n          !$acc loop\n          DO x = 1, LOOPCOUNT\n            SELECT CASE (a(x))\n              CASE (0)\n                c(x) = b(x) * b(x)\n              CASE (1)\n                c(x) = b(x) / b(x)\n              CASE (2)\n                c(x) = b(x) / 2\n            END SELECT\n          END DO\n        !$acc end parallel\n        !$acc exit data delete(a(1:LOOPCOUNT), b(1:LOOPCOUNT)) copyout(c(1:LOOPCOUNT))\n\n        DO x = 1, LOOPCOUNT\n          SELECT CASE (a(x))\n            CASE (0)\n              IF (abs(c(x) - (b(x) * b(x))) .gt. PRECISION) THEN\n                errors = errors + 1\n              END IF\n            CASE (1)\n              IF (abs(c(x) - (b(x) / b(x))) .gt. PRECISION) THEN\n                errors = errors + 1\n              END IF\n            CASE (2)\n              IF (abs(c(x) - (b(x) / 2)) .gt. PRECISION) THEN\n                errors = errors + 1\n              END IF\n          END SELECT\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "parallel"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "parallel_switch.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:parallel,syntactic,V:2.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    int * a = (int *)malloc(n * sizeof(int));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n    real_t * b_host = (real_t *)malloc(n * sizeof(real_t));\n    real_t * c = (real_t *)malloc(n * sizeof(real_t));\n    real_t tempc = 0.0;\n\n    for (int x = 0; x < n; ++x){\n        a[x] = floor(rand() / (real_t)(RAND_MAX / 10));\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n        b_host[x] = b[x];\n        c[x] = 0.0;\n    }\n    #pragma acc enter data copyin(a[0:n], b[0:n], c[0:n])\n    #pragma acc parallel present(a[0:n], b[0:n], c[0:n])\n    {\n        #pragma acc loop\n        for (int x = 0; x < n; ++x){\n            switch(a[x]){\n                case 0:\n                    c[x] = b[x] * b[x];\n                    break;\n                case 1:\n                    c[x] = b[x] / b[x];\n                    break;\n                case 2:\n                    b[x] = b[x] / 2;\n                default:\n                    c[x] = a[x] + b[x];\n\n\n            }\n        }\n    }\n    #pragma acc exit data delete(a[0:n], b[0:n]) copyout(c[0:n])\n\n    for (int x = 0; x < n; ++x){\n        switch(a[x]){\n            case 0:\n                tempc = b_host[x] * b_host[x];\n                break;\n            case 1:\n                tempc = b_host[x] / b_host[x];\n                break;\n            case 2:\n                b_host[x] = b_host[x] / 2;\n            default:\n                tempc = a[x] + b_host[x];\n        }\n        if (fabs(c[x] - tempc) > PRECISION){\n            err = 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "parallel",
                            "syntactic"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "parallel_wait.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:async,parallel,update,V:2.0-2.7\n      LOGICAL FUNCTION test1()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT):: a, b !Data\n        INTEGER :: errors = 0\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(a)\n        b = a\n\n        !$acc enter data create(a(1:LOOPCOUNT))\n        !$acc update device(a(1:LOOPCOUNT)) async(1)\n        !$acc parallel present(a(1:LOOPCOUNT)) wait(1)\n          !$acc loop\n          DO x = 1, LOOPCOUNT\n            a(x) = a(x) + 1\n          END DO\n        !$acc end parallel\n        !$acc exit data copyout(a(1:LOOPCOUNT))\n\n        DO x = 1, LOOPCOUNT\n          IF (abs(a(x) - (b(x) + 1)) .gt. PRECISION) THEN\n            errors = errors + 1\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "async",
                            "parallel",
                            "update"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "parallel_wait.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:parallel,wait,async,V:2.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t *a = (real_t *)malloc(n * sizeof(real_t));\n    real_t *b = (real_t *)malloc(n * sizeof(real_t));\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = a[x];\n    }\n\n    #pragma acc enter data create(a[0:n])\n    #pragma acc update device(a[0:n]) async(1)\n    #pragma acc parallel present(a[0:n]) wait(1)\n    {\n        #pragma acc loop\n        for (int x = 0; x < n; ++x){\n            a[x] += 1;\n        }\n    }\n    #pragma acc exit data copyout(a[0:n])\n    for (int x = 0; x < n; ++x){\n        if (fabs(a[x] - (b[x] + 1)) > PRECISION){\n            err = 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "parallel",
                            "wait",
                            "async"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "parallel_while_loop.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:parallel,reduction,loop,V:1.0-2.7\n      LOGICAL FUNCTION test1()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x, y !Iterators\n        REAL(8),DIMENSION(10, LOOPCOUNT):: a !Data\n        REAL(8) :: avg\n        INTEGER :: errors = 0\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(a)\n \n        !$acc data copy(a(1:10, 1:LOOPCOUNT))\n          !$acc parallel\n            !$acc loop\n            DO x = 1, 10\n              avg = 0.0\n              DO WHILE (avg - 1000 .lt. PRECISION * LOOPCOUNT)\n                avg = 0.0\n                !$acc loop\n                DO y = 1, LOOPCOUNT\n                  a(x, y) = a(x, y) * 1.5\n                END DO\n                !$acc loop reduction(+:avg)\n                DO y = 1, LOOPCOUNT\n                  avg = avg + (a(x, y) / LOOPCOUNT)\n                END DO\n              END DO\n            END DO\n          !$acc end parallel\n        !$acc end data\n\n        DO x = 1, 10\n          avg = 0.0\n          DO y = 1, LOOPCOUNT\n            avg = avg + (a(x, y) / LOOPCOUNT)\n          END DO\n          IF (avg < 1000 .OR. avg > 1600) THEN\n            errors = errors + 1\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "parallel",
                            "reduction",
                            "loop"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "parallel_while_loop.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:parallel,syntactic,V:1.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(10 * n * sizeof(real_t));\n    real_t avg = 0.0;\n\n    for (int x = 0; x < 10 * n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        avg += a[x]/(n * 10);\n    }\n\n    #pragma acc data copy(a[0:10*n])\n    {\n        #pragma acc parallel\n        {\n            real_t avg = 0.0;\n            #pragma acc loop\n            for (int y = 0; y < 10; ++y){\n                avg = 0.0;\n                while (avg - 1000 < PRECISION * n){\n                    avg = 0.0;\n                    #pragma acc loop reduction(+:avg)\n                    for (int x = 0; x < n; ++x){\n                        a[n * y + x] *= 1.5;\n                        avg += a[n * y + x] / n;\n                    }\n                }\n            }\n        }\n    }\n\n    avg = 0.0;\n    for (int x = 0; x < n; ++x){\n        avg += a[x]/n;\n    }\n\n    if (avg < 1000 || avg > 1600){\n        err = 1;\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "parallel",
                            "syntactic"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "routine_bind.c": {
                "num tests": 4,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:routine,construct-independent,V:2.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t **a = (real_t **)malloc(n * sizeof(real_t *));\n    real_t *b = (real_t *)malloc(n * sizeof(real_t));\n    int on_host = (acc_get_device_type() == acc_device_none);\n    for (int x = 0; x < n; ++x){\n        a[x] = (real_t *)malloc(n * sizeof(real_t));\n    }\n\n    for (int x = 0; x < n; ++x){\n        for (int y = 0; y < n; ++y){\n            a[x][y] = rand() / (real_t)(RAND_MAX / 10);\n        }\n        b[x] = 0;\n    }\n\n    #pragma acc data copyin(a[0:n][0:n]) copyout(b[0:n])\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop gang worker vector\n            for (int x = 0; x < n; ++x){\n                b[x] = host_function_identifier_unnamed(a[x], n);\n            }\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        if ((!on_host) && (fabs(host_function_identifier_unnamed(a[x], n) + b[x]) > PRECISION)){\n            err += 1;\n            return 1;\n        }\n        else if ((on_host) && (fabs(host_function_identifier_unnamed(a[x], n) - b[x]) > PRECISION)){\n            err += 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "routine",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "2": {
                        "content": "#ifndef T2\n//T2:routine,construct-independent,V:2.0-2.7\nint test2(){\n    int err = 0;\n    srand(SEED);\n    real_t **a = (real_t **)malloc(n * sizeof(real_t *));\n    real_t *b = (real_t *)malloc(n * sizeof(real_t));\n    int on_host = (acc_get_device_type() == acc_device_none);\n    for (int x = 0; x < n; ++x){\n        a[x] = (real_t *)malloc(n * sizeof(real_t));\n    }\n\n    for (int x = 0; x < n; ++x){\n        for (int y = 0; y < n; ++y){\n            a[x][y] = rand() / (real_t)(RAND_MAX / 10);\n        }\n    }\n\n    #pragma acc data copyin(a[0:n][0:n]) copyout(b[0:n])\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop gang worker vector\n            for (int x = 0; x < n; ++x){\n                b[x] = host_function_string_unnamed(a[x], n);\n            }\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        if (!on_host && fabs(host_function_string_unnamed(a[x], n) + b[x]) > PRECISION){\n            err += 1;\n        }\n        else if (on_host && fabs(host_function_string_unnamed(a[x], n) - b[x]) > PRECISION){\n            err += 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T2\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test2();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 1);\n    }\n#endif\n",
                        "tags": [
                            "routine",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "3": {
                        "content": "#ifndef T3\n//T3:routine,construct-independent,V:2.0-2.7\nint test3(){\n    int err = 0;\n    srand(SEED);\n    real_t **a = (real_t **)malloc(n * sizeof(real_t *));\n    real_t *b = (real_t *)malloc(n * sizeof(real_t));\n    int on_host = (acc_get_device_type() == acc_device_none);\n    for (int x = 0; x < n; ++x){\n        a[x] = (real_t *)malloc(n * sizeof(real_t));\n    }\n\n    for (int x = 0; x < n; ++x){\n        for (int y = 0; y < n; ++y){\n            a[x][y] = rand() / (real_t)(RAND_MAX / 10);\n        }\n    }\n\n    #pragma acc data copyin(a[0:n][0:n]) copyout(b[0:n])\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop gang worker vector\n            for (int x = 0; x < n; ++x){\n                b[x] = host_function_identifier_named(a[x], n);\n            }\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        if (!on_host && fabs(host_function_identifier_named(a[x], n) + b[x]) > PRECISION){\n            err += 1;\n        }\n        else if (on_host && fabs(host_function_identifier_named(a[x], n) - b[x]) > PRECISION){\n            err += 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T3\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test3();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 2);\n    }\n#endif\n",
                        "tags": [
                            "routine",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "4": {
                        "content": "#ifndef T4\n//T4:routine,construct-independent,V:2.0-2.7\nint test4(){\n    int err = 0;\n    srand(SEED);\n    real_t **a = (real_t **)malloc(n * sizeof(real_t *));\n    real_t *b = (real_t *)malloc(n * sizeof(real_t));\n    int on_host = (acc_get_device_type() == acc_device_none);\n    for (int x = 0; x < n; ++x){\n        a[x] = (real_t *)malloc(n * sizeof(real_t));\n    }\n\n    for (int x = 0; x < n; ++x){\n        for (int y = 0; y < n; ++y){\n            a[x][y] = rand() / (real_t)(RAND_MAX / 10);\n        }\n    }\n\n    #pragma acc data copyin(a[0:n][0:n]) copyout(b[0:n])\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop gang worker vector\n            for (int x = 0; x < n; ++x){\n                b[x] = host_function_string_named(a[x], n);\n            }\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        if (!on_host && fabs(host_function_string_named(a[x], n) + b[x]) > PRECISION){\n            err += 1;\n        }\n        else if (on_host && fabs(host_function_string_named(a[x], n) - b[x]) > PRECISION){\n            err += 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T4\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test4();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 3);\n    }\n#endif\n",
                        "tags": [
                            "routine",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "routine_gang.c": {
                "num tests": 10,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:routine,construct-independent,V:2.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t ** a = (real_t **)malloc(n * sizeof(real_t *));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n    for (int x = 0; x < n; ++x){\n        a[x] = (real_t *)malloc(n * sizeof(real_t));\n    }\n\n    for (int x = 0; x < n; ++x)\n        for (int y = 0; y < n; ++y){\n            a[x][y] = rand() / (real_t)(RAND_MAX / 10);\n        }\n        b[x] = 0;\n    }\n\n    #pragma acc data copyin(a[0:n][0:n]) copy(b[0:n])\n    {\n        #pragma acc parallel\n        {\n              test_routine_gang_loop_unnamed(a, b, n);\n        }\n    }\n\n    if (validate_data(a, b)){\n        err += 1;\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "routine",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "10": {
                        "content": "#ifndef T10\n//T10:routine,construct-independent,V:2.0-2.7\nint test10(){\n    int err = 0;\n    srand(SEED);\n    real_t ** a = (real_t **)malloc(n * sizeof(real_t *));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n    for (int x = 0; x < n; ++x){\n        a[x] = (real_t *)malloc(n * sizeof(real_t));\n    }\n\n    for (int x = 0; x < n; ++x){\n        for (int y = 0; y < n; ++y){\n            a[x][y] = rand() / (real_t)(RAND_MAX / 10);\n        }\n        b[x] = 0;\n    }\n\n    #pragma acc data copyin(a[0:n][0:n]) copy(b[0:n])\n    {\n        #pragma acc parallel\n        {\n            test_routine_gang_seq_named(a, b, n);\n        }\n    }\n\n    if (validate_data(a, b)){\n        err += 1;\n    }\n\n    return err;\n}\n#endif\n#ifndef T10\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test10();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 9);\n    }\n#endif\n",
                        "tags": [
                            "routine",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "2": {
                        "content": "#ifndef T2\n//T2:routine,construct-independent,V:2.0-2.7\nint test2(){\n    int err = 0;\n    srand(SEED);\n    real_t ** a = (real_t **)malloc(n * sizeof(real_t *));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n    for (int x = 0; x < n; ++x){\n        a[x] = (real_t *)malloc(n * sizeof(real_t));\n    }\n\n    for (int x = 0; x < n; ++x){\n        for (int y = 0; y < n; ++y){\n            a[x][y] = rand() / (real_t)(RAND_MAX / 10);\n        }\n        b[x] = 0;\n    }\n\n    #pragma acc data copyin(a[0:n][0:n]) copy(b[0:n])\n    {\n        #pragma acc parallel\n        {\n            test_routine_gang_loop_named(a, b, n);\n        }\n    }\n\n    if (validate_data(a, b)){\n        err += 1;\n    }\n\n    return err;\n}\n#endif\n#ifndef T2\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test2();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 1);\n    }\n#endif\n",
                        "tags": [
                            "routine",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "3": {
                        "content": "#ifndef T3\n//T3:routine,construct-independent,V:2.0-2.7\nint test3(){\n    int err = 0;\n    srand(SEED);\n    real_t ** a = (real_t **)malloc(n * sizeof(real_t *));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n    for (int x = 0; x < n; ++x){\n        a[x] = (real_t *)malloc(n * sizeof(real_t));\n    }\n\n    for (int x = 0; x < n; ++x){\n        for (int y = 0; y < n; ++y){\n            a[x][y] = rand() / (real_t)(RAND_MAX / 10);\n        }\n        b[x] = 0;\n    }\n\n    #pragma acc data copyin(a[0:n][0:n]) copy(b[0:n])\n    {\n        #pragma acc parallel\n        {\n            test_routine_gang_gang_unnamed(a, b, n);\n        }\n    }\n\n    if (validate_data(a, b)){\n        err += 1;\n    }\n\n    return err;\n}\n#endif\n#ifndef T3\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test3();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 2);\n    }\n#endif\n",
                        "tags": [
                            "routine",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "4": {
                        "content": "#ifndef T4\n//T4:routine,construct-independent,V:2.0-2.7\nint test4(){\n    int err = 0;\n    srand(SEED);\n    real_t ** a = (real_t **)malloc(n * sizeof(real_t *));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n    for (int x = 0; x < n; ++x){\n        a[x] = (real_t *)malloc(n * sizeof(real_t));\n    }\n\n    for (int x = 0; x < n; ++x){\n        for (int y = 0; y < n; ++y){\n            a[x][y] = rand() / (real_t)(RAND_MAX / 10);\n        }\n        b[x] = 0;\n    }\n\n    #pragma acc data copyin(a[0:n][0:n]) copy(b[0:n])\n    {\n        #pragma acc parallel\n        {\n            test_routine_gang_gang_named(a, b, n);\n        }\n    }\n\n    if (validate_data(a, b)){\n        err += 1;\n    }\n\n    return err;\n}\n#endif\n#ifndef T4\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test4();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 3);\n    }\n#endif\n",
                        "tags": [
                            "routine",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "5": {
                        "content": "#ifndef T5\n//T5:routine,construct-independent,V:2.0-2.7\nint test5(){\n    int err = 0;\n    srand(SEED);\n    real_t ** a = (real_t **)malloc(n * sizeof(real_t *));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n    for (int x = 0; x < n; ++x){\n        a[x] = (real_t *)malloc(n * sizeof(real_t));\n    }\n\n    for (int x = 0; x < n; ++x){\n        for (int y = 0; y < n; ++y){\n            a[x][y] = rand() / (real_t)(RAND_MAX / 10);\n        }\n        b[x] = 0;\n    }\n\n    #pragma acc data copyin(a[0:n][0:n]) copy(b[0:n])\n    {\n        #pragma acc parallel\n        {\n            test_routine_gang_worker_unnamed(a, b, n);\n        }\n    }\n\n    if (validate_data(a, b)){\n        err += 1;\n    }\n\n    return err;\n}\n#endif\n#ifndef T5\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test5();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 4);\n    }\n#endif\n",
                        "tags": [
                            "routine",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "6": {
                        "content": "#ifndef T6\n//T6:routine,construct-independent,V:2.0-2.7\nint test6(){\n    int err = 0;\n    srand(SEED);\n    real_t ** a = (real_t **)malloc(n * sizeof(real_t *));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n    for (int x = 0; x < n; ++x){\n        a[x] = (real_t *)malloc(n * sizeof(real_t));\n    }\n\n    for (int x = 0; x < n; ++x){\n        for (int y = 0; y < n; ++y){\n            a[x][y] = rand() / (real_t)(RAND_MAX / 10);\n        }\n        b[x] = 0;\n    }\n\n    #pragma acc data copyin(a[0:n][0:n]) copy(b[0:n])\n    {\n        #pragma acc parallel\n        {\n            test_routine_gang_worker_named(a, b, n);\n        }\n    }\n\n    if (validate_data(a, b)){\n        err += 1;\n    }\n\n    return err;\n}\n#endif\n#ifndef T6\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test6();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 5);\n    }\n#endif\n",
                        "tags": [
                            "routine",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "7": {
                        "content": "#ifndef T7\n//T7:routine,construct-independent,V:2.0-2.7\nint test7(){\n    int err = 0;\n    srand(SEED);\n    real_t ** a = (real_t **)malloc(n * sizeof(real_t *));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n    for (int x = 0; x < n; ++x){\n        a[x] = (real_t *)malloc(n * sizeof(real_t));\n    }\n\n    for (int x = 0; x < n; ++x){\n        for (int y = 0; y < n; ++y){\n            a[x][y] = rand() / (real_t)(RAND_MAX / 10);\n        }\n        b[x] = 0;\n    }\n\n    #pragma acc data copyin(a[0:n][0:n]) copy(b[0:n])\n    {\n        #pragma acc parallel\n        {\n            test_routine_gang_vector_unnamed(a, b, n);\n        }\n    }\n\n    if (validate_data(a, b)){\n        err += 1;\n    }\n\n    return err;\n}\n#endif\n#ifndef T7\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test7();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 6);\n    }\n#endif\n",
                        "tags": [
                            "routine",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "8": {
                        "content": "#ifndef T8\n//T8:routine,construct-independent,V:2.0-2.7\nint test8(){\n    int err = 0;\n    srand(SEED);\n    real_t ** a = (real_t **)malloc(n * sizeof(real_t *));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n    for (int x = 0; x < n; ++x){\n        a[x] = (real_t *)malloc(n * sizeof(real_t));\n    }\n\n    for (int x = 0; x < n; ++x){\n        for (int y = 0; y < n; ++y){\n            a[x][y] = rand() / (real_t)(RAND_MAX / 10);\n        }\n        b[x] = 0;\n    }\n\n    #pragma acc data copyin(a[0:n][0:n]) copy(b[0:n])\n    {\n        #pragma acc parallel\n        {\n            test_routine_gang_vector_named(a, b, n);\n        }\n    }\n\n    if (validate_data(a, b)){\n        err += 1;\n    }\n\n    return err;\n}\n#endif\n#ifndef T8\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test8();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 7);\n    }\n#endif\n",
                        "tags": [
                            "routine",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "9": {
                        "content": "#ifndef T9\n//T9:routine,construct-independent,V:2.0-2.7\nint test9(){\n    int err = 0;\n    srand(SEED);\n    real_t ** a = (real_t **)malloc(n * sizeof(real_t *));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n    for (int x = 0; x < n; ++x){\n        a[x] = (real_t *)malloc(n * sizeof(real_t));\n    }\n\n    for (int x = 0; x < n; ++x){\n        for (int y = 0; y < n; ++y){\n            a[x][y] = rand() / (real_t)(RAND_MAX / 10);\n        }\n        b[x] = 0;\n    }\n\n    #pragma acc data copyin(a[0:n][0:n]) copy(b[0:n])\n    {\n        #pragma acc parallel\n        {\n            test_routine_gang_seq_unnamed(a, b, n);\n        }\n    }\n\n    if (validate_data(a, b)){\n        err += 1;\n    }\n\n    return err;\n}\n#endif\n#ifndef T9\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test9();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 8);\n    }\n#endif\n",
                        "tags": [
                            "routine",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "routine_nohost.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:routine,construct-independent,V:2.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t ** a = (real_t **)malloc(n * sizeof(real_t *));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n    real_t summation;\n\n    for (int x = 0; x < n; ++x){\n        a[x] = (real_t *)malloc(n * sizeof(real_t));\n        for (int y = 0; y < n; ++y){\n            a[x][y] = rand() / (real_t)(RAND_MAX / 10);\n        }\n        b[x] = 0;\n    }\n\n    #pragma acc data copyin(a[0:n][0:n]) copyout(b[0:n])\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop gang\n            for (int x = 0; x < n; ++x){\n                b[x] = function(a[x], n);\n            }\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        summation = 0;\n        for (int y = 0; y < n; ++y){\n            summation += a[x][y];\n        }\n        if (fabs(summation - b[x]) > PRECISION){\n            err += 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "routine",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "routine_seq.c": {
                "num tests": 4,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:routine,construct-independent,V:2.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t ** a = (real_t **)malloc(n * sizeof(real_t *));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n\n    for (int x = 0; x < n; ++x){\n        a[x] = (real_t *)malloc(n * sizeof(real_t));\n    }\n\n    for (int x = 0; x < n; ++x){\n        for (int y = 0; y < n; ++y){\n            a[x][y] = rand() / (real_t)(RAND_MAX / 10);\n        }\n        b[x] = 0;\n    }\n\n    #pragma acc data copyin(a[0:n][0:n]) copy(b[0:n])\n    {\n        #pragma acc parallel\n        {\n              test_routine_seq_loop_unnamed(a, b, n);\n        }\n    }\n\n    if (validate_data(a, b)){\n        err += 1;\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "routine",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "2": {
                        "content": "#ifndef T2\n//T2:routine,construct-independent,V:2.0-2.7\nint test2(){\n    int err = 0;\n    srand(SEED);\n    real_t ** a = (real_t **)malloc(n * sizeof(real_t *));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n\n    for (int x = 0; x < n; ++x){\n        a[x] = (real_t *)malloc(n * sizeof(real_t));\n    }\n\n    for (int x = 0; x < n; ++x){\n        for (int y = 0; y < n; ++y){\n            a[x][y] = rand() / (real_t)(RAND_MAX / 10);\n        }\n        b[x] = 0;\n    }\n\n    #pragma acc data copyin(a[0:n][0:n]) copy(b[0:n])\n    {\n        #pragma acc parallel\n        {\n            test_routine_seq_loop_named(a, b, n);\n        }\n    }\n\n    if (validate_data(a, b)){\n        err += 1;\n    }\n\n    return err;\n}\n#endif\n#ifndef T2\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test2();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 1);\n    }\n#endif\n",
                        "tags": [
                            "routine",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "3": {
                        "content": "#ifndef T3\n//T3:routine,construct-independent,V:2.0-2.7\nint test3(){\n    int err = 0;\n    srand(SEED);\n    real_t ** a = (real_t **)malloc(n * sizeof(real_t *));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n\n    for (int x = 0; x < n; ++x){\n        a[x] = (real_t *)malloc(n * sizeof(real_t));\n    }\n\n    for (int x = 0; x < n; ++x){\n        for (int y = 0; y < n; ++y){\n            a[x][y] = rand() / (real_t)(RAND_MAX / 10);\n        }\n        b[x] = 0;\n    }\n\n    #pragma acc data copyin(a[0:n][0:n]) copy(b[0:n])\n    {\n        #pragma acc parallel\n        {\n            test_routine_seq_seq_unnamed(a, b, n);\n        }\n    }\n\n    if (validate_data(a, b)){\n        err += 1;\n    }\n\n    return err;\n}\n#endif\n#ifndef T3\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test3();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 2);\n    }\n#endif\n",
                        "tags": [
                            "routine",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "4": {
                        "content": "#ifndef T4\n//T4:routine,construct-independent,V:2.0-2.7\nint test4(){\n    int err = 0;\n    srand(SEED);\n    real_t ** a = (real_t **)malloc(n * sizeof(real_t *));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n\n    for (int x = 0; x < n; ++x){\n        a[x] = (real_t *)malloc(n * sizeof(real_t));\n    }\n\n    for (int x = 0; x < n; ++x){\n        for (int y = 0; y < n; ++y){\n            a[x][y] = rand() / (real_t)(RAND_MAX / 10);\n        }\n        b[x] = 0;\n    }\n\n    #pragma acc data copyin(a[0:n][0:n]) copy(b[0:n])\n    {\n        #pragma acc parallel\n        {\n            test_routine_seq_seq_named(a, b, n);\n        }\n    }\n\n    if (validate_data(a, b)){\n        err += 1;\n    }\n\n    return err;\n}\n#endif\n#ifndef T4\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test4();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 3);\n    }\n#endif\n",
                        "tags": [
                            "routine",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "routine_vector.c": {
                "num tests": 6,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:routine,construct-independent,V:2.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t ** a = (real_t **)malloc(n * sizeof(real_t *));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n\n    for (int x = 0; x < n; ++x){\n        a[x] = (real_t *)malloc(n * sizeof(real_t));\n    }\n\n    for (int x = 0; x < n; ++x){\n        for (int y = 0; y < n; ++y){\n            a[x][y] = rand() / (real_t)(RAND_MAX / 10);\n        }\n        b[x] = 0;\n    }\n\n    #pragma acc data copyin(a[0:n][0:n]) copy(b[0:n])\n    {\n        #pragma acc parallel\n        {\n              test_routine_vector_loop_unnamed(a, b, n);\n        }\n    }\n\n    if (validate_data(a, b)){\n        err += 1;\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "routine",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "2": {
                        "content": "#ifndef T2\n//T2:routine,construct-independent,V:2.0-2.7\nint test2(){\n    int err = 0;\n    srand(SEED);\n    real_t ** a = (real_t **)malloc(n * sizeof(real_t *));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n\n    for (int x = 0; x < n; ++x){\n        a[x] = (real_t *)malloc(n * sizeof(real_t));\n    }\n\n    for (int x = 0; x < n; ++x){\n        for (int y = 0; y < n; ++y){\n            a[x][y] = rand() / (real_t)(RAND_MAX / 10);\n        }\n        b[x] = 0;\n    }\n\n    #pragma acc data copyin(a[0:n][0:n]) copy(b[0:n])\n    {\n        #pragma acc parallel\n        {\n            test_routine_vector_loop_named(a, b, n);\n        }\n    }\n\n    if (validate_data(a, b)){\n        err += 1;\n    }\n\n    return err;\n}\n#endif\n#ifndef T2\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test2();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 1);\n    }\n#endif\n",
                        "tags": [
                            "routine",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "3": {
                        "content": "#ifndef T3\n//T3:routine,construct-independent,V:2.0-2.7\nint test3(){\n    int err = 0;\n    srand(SEED);\n    real_t ** a = (real_t **)malloc(n * sizeof(real_t *));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n\n    for (int x = 0; x < n; ++x){\n        a[x] = (real_t *)malloc(n * sizeof(real_t));\n    }\n\n    for (int x = 0; x < n; ++x){\n        for (int y = 0; y < n; ++y){\n            a[x][y] = rand() / (real_t)(RAND_MAX / 10);\n        }\n        b[x] = 0;\n    }\n\n    #pragma acc data copyin(a[0:n][0:n]) copy(b[0:n])\n    {\n        #pragma acc parallel\n        {\n            test_routine_vector_vector_unnamed(a, b, n);\n        }\n    }\n\n    if (validate_data(a, b)){\n        err += 1;\n    }\n\n    return err;\n}\n#endif\n#ifndef T3\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test3();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 2);\n    }\n#endif\n",
                        "tags": [
                            "routine",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "4": {
                        "content": "#ifndef T4\n//T4:routine,construct-independent,V:2.0-2.7\nint test4(){\n    int err = 0;\n    srand(SEED);\n    real_t ** a = (real_t **)malloc(n * sizeof(real_t *));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n\n    for (int x = 0; x < n; ++x){\n        a[x] = (real_t *)malloc(n * sizeof(real_t));\n    }\n\n    for (int x = 0; x < n; ++x){\n        for (int y = 0; y < n; ++y){\n            a[x][y] = rand() / (real_t)(RAND_MAX / 10);\n        }\n        b[x] = 0;\n    }\n\n    #pragma acc data copyin(a[0:n][0:n]) copy(b[0:n])\n    {\n        #pragma acc parallel\n        {\n            test_routine_vector_vector_named(a, b, n);\n        }\n    }\n\n    if (validate_data(a, b)){\n        err += 1;\n    }\n\n    return err;\n}\n#endif\n#ifndef T4\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test4();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 3);\n    }\n#endif\n",
                        "tags": [
                            "routine",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "5": {
                        "content": "#ifndef T5\n//T5:routine,construct-independent,V:2.0-2.7\nint test5(){\n    int err = 0;\n    srand(SEED);\n    real_t ** a = (real_t **)malloc(n * sizeof(real_t *));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n\n    for (int x = 0; x < n; ++x){\n        a[x] = (real_t *)malloc(n * sizeof(real_t));\n    }\n\n    for (int x = 0; x < n; ++x){\n        for (int y = 0; y < n; ++y){\n            a[x][y] = rand() / (real_t)(RAND_MAX / 10);\n        }\n        b[x] = 0;\n    }\n\n    #pragma acc data copyin(a[0:n][0:n]) copy(b[0:n])\n    {\n        #pragma acc parallel\n        {\n            test_routine_vector_seq_unnamed(a, b, n);\n        }\n    }\n\n    if (validate_data(a, b)){\n        err += 1;\n    }\n\n    return err;\n}\n#endif\n#ifndef T5\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test5();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 4);\n    }\n#endif\n",
                        "tags": [
                            "routine",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "6": {
                        "content": "#ifndef T6\n//T6:routine,construct-independent,V:2.0-2.7\nint test6(){\n    int err = 0;\n    srand(SEED);\n    real_t ** a = (real_t **)malloc(n * sizeof(real_t *));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n\n    for (int x = 0; x < n; ++x){\n        a[x] = (real_t *)malloc(n * sizeof(real_t));\n    }\n\n    for (int x = 0; x < n; ++x){\n        for (int y = 0; y < n; ++y){\n            a[x][y] = rand() / (real_t)(RAND_MAX / 10);\n        }\n        b[x] = 0;\n    }\n\n    #pragma acc data copyin(a[0:n][0:n]) copy(b[0:n])\n    {\n        #pragma acc parallel\n        {\n            test_routine_vector_seq_named(a, b, n);\n        }\n    }\n\n    if (validate_data(a, b)){\n        err += 1;\n    }\n\n    return err;\n}\n#endif\n#ifndef T6\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test6();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 5);\n    }\n#endif\n",
                        "tags": [
                            "routine",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "routine_worker.c": {
                "num tests": 8,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:routine,construct-independent,V:2.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t ** a = (real_t **)malloc(n * sizeof(real_t *));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n\n    for (int x = 0; x < n; ++x){\n        a[x] = (real_t *)malloc(n * sizeof(real_t));\n    }\n\n    for (int x = 0; x < n; ++x){\n        for (int y = 0; y < n; ++y){\n            a[x][y] = rand() / (real_t)(RAND_MAX / 10);\n        }\n        b[x] = 0;\n    }\n\n    #pragma acc data copyin(a[0:n][0:n]) copy(b[0:n])\n    {\n        #pragma acc parallel\n        {\n              test_routine_worker_loop_unnamed(a, b, n);\n        }\n    }\n\n    if (validate_data(a, b)){\n        err += 1;\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "routine",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "2": {
                        "content": "#ifndef T2\n//T2:routine,construct-independent,V:2.0-2.7\nint test2(){\n    int err = 0;\n    srand(SEED);\n    real_t ** a = (real_t **)malloc(n * sizeof(real_t *));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n\n    for (int x = 0; x < n; ++x){\n        a[x] = (real_t *)malloc(n * sizeof(real_t));\n    }\n\n    for (int x = 0; x < n; ++x){\n        for (int y = 0; y < n; ++y){\n            a[x][y] = rand() / (real_t)(RAND_MAX / 10);\n        }\n        b[x] = 0;\n    }\n\n    #pragma acc data copyin(a[0:n][0:n]) copy(b[0:n])\n    {\n        #pragma acc parallel\n        {\n            test_routine_worker_loop_named(a, b, n);\n        }\n    }\n\n    if (validate_data(a, b)){\n        err += 1;\n    }\n\n    return err;\n}\n#endif\n#ifndef T2\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test2();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 1);\n    }\n#endif\n",
                        "tags": [
                            "routine",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "3": {
                        "content": "#ifndef T3\n//T3:routine,construct-independent,V:2.0-2.7\nint test3(){\n    int err = 0;\n    srand(SEED);\n    real_t ** a = (real_t **)malloc(n * sizeof(real_t *));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n\n    for (int x = 0; x < n; ++x){\n        a[x] = (real_t *)malloc(n * sizeof(real_t));\n    }\n\n    for (int x = 0; x < n; ++x){\n        for (int y = 0; y < n; ++y){\n            a[x][y] = rand() / (real_t)(RAND_MAX / 10);\n        }\n        b[x] = 0;\n    }\n\n    #pragma acc data copyin(a[0:n][0:n]) copy(b[0:n])\n    {\n        #pragma acc parallel\n        {\n            test_routine_worker_worker_unnamed(a, b, n);\n        }\n    }\n\n    if (validate_data(a, b)){\n        err += 1;\n    }\n\n    return err;\n}\n#endif\n#ifndef T3\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test3();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 2);\n    }\n#endif\n",
                        "tags": [
                            "routine",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "4": {
                        "content": "#ifndef T4\n//T4:routine,construct-independent,V:2.0-2.7\nint test4(){\n    int err = 0;\n    srand(SEED);\n    real_t ** a = (real_t **)malloc(n * sizeof(real_t *));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n\n    for (int x = 0; x < n; ++x){\n        a[x] = (real_t *)malloc(n * sizeof(real_t));\n    }\n\n    for (int x = 0; x < n; ++x){\n        for (int y = 0; y < n; ++y){\n            a[x][y] = rand() / (real_t)(RAND_MAX / 10);\n        }\n        b[x] = 0;\n    }\n\n    #pragma acc data copyin(a[0:n][0:n]) copy(b[0:n])\n    {\n        #pragma acc parallel\n        {\n            test_routine_worker_worker_named(a, b, n);\n        }\n    }\n\n    if (validate_data(a, b)){\n        err += 1;\n    }\n\n    return err;\n}\n#endif\n#ifndef T4\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test4();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 3);\n    }\n#endif\n",
                        "tags": [
                            "routine",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "5": {
                        "content": "#ifndef T5\n//T5:routine,construct-independent,V:2.0-2.7\nint test5(){\n    int err = 0;\n    srand(SEED);\n    real_t ** a = (real_t **)malloc(n * sizeof(real_t *));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n\n    for (int x = 0; x < n; ++x){\n        a[x] = (real_t *)malloc(n * sizeof(real_t));\n    }\n\n    for (int x = 0; x < n; ++x){\n        for (int y = 0; y < n; ++y){\n            a[x][y] = rand() / (real_t)(RAND_MAX / 10);\n        }\n        b[x] = 0;\n    }\n\n    #pragma acc data copyin(a[0:n][0:n]) copy(b[0:n])\n    {\n        #pragma acc parallel\n        {\n            test_routine_worker_vector_unnamed(a, b, n);\n        }\n    }\n\n    if (validate_data(a, b)){\n        err += 1;\n    }\n\n    return err;\n}\n#endif\n#ifndef T5\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test5();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 4);\n    }\n#endif\n",
                        "tags": [
                            "routine",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "6": {
                        "content": "#ifndef T6\n//T6:routine,construct-independent,V:2.0-2.7\nint test6(){\n    int err = 0;\n    srand(SEED);\n    real_t ** a = (real_t **)malloc(n * sizeof(real_t *));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n\n    for (int x = 0; x < n; ++x){\n        a[x] = (real_t *)malloc(n * sizeof(real_t));\n    }\n\n    for (int x = 0; x < n; ++x){\n        for (int y = 0; y < n; ++y){\n            a[x][y] = rand() / (real_t)(RAND_MAX / 10);\n        }\n        b[x] = 0;\n    }\n\n    #pragma acc data copyin(a[0:n][0:n]) copy(b[0:n])\n    {\n        #pragma acc parallel\n        {\n            test_routine_worker_vector_named(a, b, n);\n        }\n    }\n\n    if (validate_data(a, b)){\n        err += 1;\n    }\n\n    return err;\n}\n#endif\n#ifndef T6\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test6();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 5);\n    }\n#endif\n",
                        "tags": [
                            "routine",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "7": {
                        "content": "#ifndef T7\n//T7:routine,construct-independent,V:2.0-2.7\nint test7(){\n    int err = 0;\n    srand(SEED);\n    real_t ** a = (real_t **)malloc(n * sizeof(real_t *));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n\n    for (int x = 0; x < n; ++x){\n        a[x] = (real_t *)malloc(n * sizeof(real_t));\n    }\n\n    for (int x = 0; x < n; ++x){\n        for (int y = 0; y < n; ++y){\n            a[x][y] = rand() / (real_t)(RAND_MAX / 10);\n        }\n        b[x] = 0;\n    }\n\n    #pragma acc data copyin(a[0:n][0:n]) copy(b[0:n])\n    {\n        #pragma acc parallel\n        {\n            test_routine_worker_seq_unnamed(a, b, n);\n        }\n    }\n\n    if (validate_data(a, b)){\n        err += 1;\n    }\n\n    return err;\n}\n#endif\n#ifndef T7\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test7();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 6);\n    }\n#endif\n",
                        "tags": [
                            "routine",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "8": {
                        "content": "#ifndef T8\n//T8:routine,construct-independent,V:2.0-2.7\nint test8(){\n    int err = 0;\n    srand(SEED);\n    real_t ** a = (real_t **)malloc(n * sizeof(real_t *));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n\n    for (int x = 0; x < n; ++x){\n        a[x] = (real_t *)malloc(n * sizeof(real_t));\n    }\n\n    for (int x = 0; x < n; ++x){\n        for (int y = 0; y < n; ++y){\n            a[x][y] = rand() / (real_t)(RAND_MAX / 10);\n        }\n        b[x] = 0;\n    }\n\n    #pragma acc data copyin(a[0:n][0:n]) copy(b[0:n])\n    {\n        #pragma acc parallel\n        {\n            test_routine_worker_seq_named(a, b, n);\n        }\n    }\n\n    if (validate_data(a, b)){\n        err += 1;\n    }\n\n    return err;\n}\n#endif\n#ifndef T8\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test8();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 7);\n    }\n#endif\n",
                        "tags": [
                            "routine",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "serial.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:,V:2.6-2.7\n      LOGICAL FUNCTION test1()\n  IMPLICIT NONE\n  INCLUDE \"acc_testsuite.Fh\"\n  INTEGER :: x, i_a, i_b, i_c, i_d, i_e, i_f, i_g, i_h, i_i, i_j !Iterators\n  INTEGER, PARAMETER :: PRIVATE_LOOPCOUNT = 1024\n  REAL(8),DIMENSION(PRIVATE_LOOPCOUNT):: a, b, c !Data\n  INTEGER :: errors\n  errors = 0\n\n  !Initilization\n  SEEDDIM(1) = 1\n# ifdef SEED\n  SEEDDIM(1) = SEED\n# endif\n  CALL RANDOM_SEED(PUT=SEEDDIM)\n\n  CALL RANDOM_NUMBER(a)\n  CALL RANDOM_NUMBER(b)\n  c = 0\n\n  !$acc data copyin(a(1:PRIVATE_LOOPCOUNT), b(1:PRIVATE_LOOPCOUNT)) copy(c(1:PRIVATE_LOOPCOUNT))\n    !$acc serial\n      !$acc loop\n      DO i_a = 0, 1\n        !$acc loop\n        DO i_b = 0, 1\n          !$acc loop\n          DO i_c = 0, 1\n            !$acc loop\n            DO i_d = 0, 1\n              !$acc loop\n              DO i_e = 0, 1\n                !$acc loop\n                DO i_f = 0, 1\n                  !$acc loop\n                  DO i_g = 0, 1\n                    !$acc loop\n                    DO i_h = 0, 1\n                      !$acc loop\n                      DO i_i = 0, 1\n                        !$acc loop\n                        DO i_j = 0, 1\n                          c(i_a*512 + i_b*256 + i_c*128 + i_d*64 + i_e*32 + i_f*16 + i_g*8 + i_h*4 + i_i*2 + i_j + 1) = &\n                          a(i_a*512 + i_b*256 + i_c*128 + i_d*64 + i_e*32 + i_f*16 + i_g*8 + i_h*4 + i_i*2 + i_j + 1) + &\n                          b(i_a*512 + i_b*256 + i_c*128 + i_d*64 + i_e*32 + i_f*16 + i_g*8 + i_h*4 + i_i*2 + i_j + 1)\n                        END DO\n                      END DO\n                    END DO\n                  END DO\n                END DO\n              END DO\n            END DO\n          END DO\n        END DO\n      END DO\n    !$acc end serial\n  !$acc end data\n\n  DO x = 1, PRIVATE_LOOPCOUNT\n    IF (abs(c(x) - (a(x) + b(x))) .gt. PRECISION) THEN\n      errors = errors + 1\n    END IF\n  END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            ""
                        ],
                        "versions": [
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "serial.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:serial,V:2.6-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t* a = (real_t *) malloc(1024 * sizeof(real_t));\n    real_t* b = (real_t *) malloc(1024 * sizeof(real_t));\n    real_t* c = (real_t *) malloc(1024 * sizeof(real_t));\n\n    for(int x = 0; x < 1024; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n        c[x] = 0.0;\n    }\n\n    #pragma acc data copyin(a[0:1024], b[0:1024]) copy(c[0:1024])\n    {\n        #pragma acc serial\n        {\n            #pragma acc loop\n            for (int _0 = 0; _0 < 2; ++_0){\n                #pragma acc loop\n                for (int _1 = 0; _1 < 2; ++_1){\n                    #pragma acc loop\n                    for (int _2 = 0; _2 < 2; ++_2){\n                        #pragma acc loop\n                        for (int _3 = 0; _3 < 2; ++_3){\n                            #pragma acc loop\n                            for (int _4 = 0; _4 < 2; ++_4){\n                                #pragma acc loop\n                                for (int _5 = 0; _5 < 2; ++_5){\n                                    #pragma acc loop\n                                    for (int _6 = 0; _6 < 2; ++_6){\n                                        #pragma acc loop\n                                        for (int _7 = 0; _7 < 2; ++_7){\n                                            #pragma acc loop\n                                            for (int _8 = 0; _8 < 2; ++_8){\n                                                #pragma acc loop\n                                                for (int _9 = 0; _9 < 2; ++_9){\n                                                    c[_0*512 + _1*256 + _2*128 + _3*64 + _4*32 + _5*16 + _6*8+ _7*4 + _8*2 + _9] =\n                                                    a[_0*512 + _1*256 + _2*128 + _3*64 + _4*32 + _5*16 + _6*8+ _7*4 + _8*2 + _9] +\n                                                    b[_0*512 + _1*256 + _2*128 + _3*64 + _4*32 + _5*16 + _6*8+ _7*4 + _8*2 + _9];\n                                                }\n                                            }\n                                        }\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    for (int x = 0; x < 1024; ++x){\n        if(fabs(c[x] - (a[x] +b[x])) > PRECISION){\n            err = 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "serial"
                        ],
                        "versions": [
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "serial_async.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:async,serial,update,V:2.6-2.7\n      LOGICAL FUNCTION test1()\n  IMPLICIT NONE\n  INCLUDE \"acc_testsuite.Fh\"\n  INTEGER:: errors\n  REAL(8),DIMENSION(LOOPCOUNT):: a, b, c, d, e, f, g\n  INTEGER:: x\n\n  errors = 0\n\n  SEEDDIM(1) = 1\n# ifdef SEED\n  SEEDDIM(1) = SEED\n# endif\n  CALL RANDOM_SEED(PUT=SEEDDIM)\n\n  CALL RANDOM_NUMBER(a)\n  CALL RANDOM_NUMBER(b)\n  c = 0\n  CALL RANDOM_NUMBER(d)\n  CALL RANDOM_NUMBER(e)\n  f = 0\n  g = 0\n\n  !$acc data copyin(a(1:LOOPCOUNT), b(1:LOOPCOUNT), c(1:LOOPCOUNT), d(1:LOOPCOUNT), e(1:LOOPCOUNT), f(1:LOOPCOUNT), g(1:LOOPCOUNT))\n    !$acc serial async(1)\n      !$acc loop\n      DO x = 1, LOOPCOUNT\n        c(x) = a(x) + b(x)\n      END DO\n    !$acc end serial\n    !$acc serial async(2)\n      !$acc loop\n      DO x = 1, LOOPCOUNT\n        f(x) = d(x) + e(x)\n      END DO\n    !$acc end serial\n    !$acc serial wait(1, 2) async(3)\n      !$acc loop\n      DO x = 1, LOOPCOUNT\n        g(x) = c(x) + f(x)\n      END DO\n    !$acc end serial\n\n    !$acc update host(c(1:LOOPCOUNT)) async(1)\n    !$acc update host(f(1:LOOPCOUNT)) async(2)\n    !$acc update host(g(1:LOOPCOUNT)) async(3)\n\n    !$acc wait(1)\n    DO x = 1, LOOPCOUNT\n      IF (abs(c(x) - (a(x) + b(x))) .gt. PRECISION) THEN\n        errors = errors + 1\n      END IF\n    END DO\n\n    !$acc wait(2)\n    DO x = 1, LOOPCOUNT\n      IF (abs(f(x) - (d(x) + e(x))) .gt. PRECISION) THEN\n        errors = errors + 1\n      END IF\n    END DO\n\n    !$acc wait(3)\n    DO x = 1, LOOPCOUNT\n      IF (abs(g(x) - (a(x) + b(x) + d(x) + e(x))) .gt. 4 * PRECISION) THEN\n        errors = errors + 1\n      END IF\n    END DO\n  !$acc end data\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "async",
                            "serial",
                            "update"
                        ],
                        "versions": [
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "serial_async.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:serial,async,wait,V:2.6-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n    real_t * c = (real_t *)malloc(n * sizeof(real_t));\n    real_t * d = (real_t *)malloc(n * sizeof(real_t));\n    real_t * e = (real_t *)malloc(n * sizeof(real_t));\n    real_t * f = (real_t *)malloc(n * sizeof(real_t));\n    real_t * g = (real_t *)malloc(n * sizeof(real_t));\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n        c[x] = 0.0;\n        d[x] = rand() / (real_t)(RAND_MAX / 10);\n        e[x] = rand() / (real_t)(RAND_MAX / 10);\n        f[x] = 0.0;\n        g[x] = 0.0;\n    }\n\n    #pragma acc data copyin(a[0:n], b[0:n], d[0:n], e[0:n], c[0:n], f[0:n], g[0:n])\n    {\n        #pragma acc serial async(1)\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                c[x] = a[x] + b[x];\n            }\n        }\n        #pragma acc serial async(2)\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                f[x] = d[x] + e[x];\n            }\n        }\n        #pragma acc serial wait(1, 2) async(3)\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                g[x] = c[x] + f[x];\n            }\n        }\n        #pragma acc update host(c[0:n]) async(1)\n        #pragma acc update host(f[0:n]) async(2)\n        #pragma acc update host(g[0:n]) async(3)\n\n        #pragma acc wait(1)\n        for (int x = 0; x < n; ++x){\n            if (fabs(c[x] - (a[x] + b[x])) > PRECISION){\n                err += 1;\n            }\n        }\n        #pragma acc wait(2)\n        for (int x = 0; x < n; ++x){\n            if (fabs(f[x] - (d[x] + e[x])) > PRECISION){\n                err += 1;\n            }\n        }\n        #pragma acc wait(3)\n        for (int x = 0; x < n; ++x){\n            if (fabs(g[x] - (a[x] + b[x] + d[x] + e[x])) > PRECISION){\n                err += 1;\n            }\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "serial",
                            "async",
                            "wait"
                        ],
                        "versions": [
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "serial_copy.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:serial,V:2.6-2.7\n      LOGICAL FUNCTION test1()\n  IMPLICIT NONE\n  INCLUDE \"acc_testsuite.Fh\"\n  INTEGER:: errors\n  REAL(8),DIMENSION(LOOPCOUNT):: a, a_host\n  INTEGER:: x\n  errors = 0\n\n  SEEDDIM(1) = 1\n# ifdef SEED\n  SEEDDIM(1) = SEED\n# endif\n  CALL RANDOM_SEED(PUT=SEEDDIM)\n\n  CALL RANDOM_NUMBER(a)\n  a_host = a\n\n  !$acc serial copy(a(1:LOOPCOUNT))\n    !$acc loop\n    DO x = 1, N\n      a(x) = 2 * a(x)\n    END DO\n  !$acc end serial\n\n  DO x = 1, N\n    IF (abs(a(x) - (2 * a_host(x))) .gt. PRECISION) THEN\n      errors = errors + 1\n    END IF\n  END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "serial"
                        ],
                        "versions": [
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "serial_copy.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:serial,data,data-region,V:2.6-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(n * sizeof(real_t));\n    real_t * a_host = (real_t *)malloc(n * sizeof(real_t));\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        a_host[x] = a[x];\n    }\n\n    #pragma acc serial copy(a[0:n])\n    {\n        #pragma acc loop\n        for (int x = 0; x < n; ++x){\n            a[x] = 2 * a[x];\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        if (fabs(a[x] - (2 * a_host[x])) > PRECISION){\n            err = 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "serial",
                            "data",
                            "data-region"
                        ],
                        "versions": [
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "serial_copyin.F90": {
                "num tests": 2,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:serial,V:2.6-2.7\n      LOGICAL FUNCTION test1()\n  IMPLICIT NONE\n  INCLUDE \"acc_testsuite.Fh\"\n  INTEGER:: errors\n  REAL(8),DIMENSION(LOOPCOUNT):: a, a_copy, b\n  INTEGER,DIMENSION(1):: hasDevice\n  INTEGER:: x\n  errors = 0\n\n  SEEDDIM(1) = 1\n# ifdef SEED\n  SEEDDIM(1) = SEED\n# endif\n  CALL RANDOM_SEED(PUT=SEEDDIM)\n\n  CALL RANDOM_NUMBER(a)\n  a_copy = a\n  b = 0\n\n  hasDevice(1) = 1\n  !$acc enter data copyin(hasDevice(1:1))\n  !$acc parallel present(hasDevice(1:1))\n    hasDevice(1) = 0\n  !$acc end parallel\n\n  !$acc serial copyin(a(1:LOOPCOUNT))\n    !$acc loop\n    DO x = 1, LOOPCOUNT\n      a(x) = 0\n    END DO\n  !$acc end serial\n\n  DO x = 1, LOOPCOUNT\n    IF (hasDevice(1) .eq. 1) THEN\n      IF (abs(a(x) - a_copy(x)) .gt. PRECISION) THEN\n        errors = errors + 1\n      END IF\n    ELSE\n      IF (abs(a(x)) .gt. PRECISION) THEN\n        errors = errors + 1\n      END IF\n    END IF\n  END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "serial"
                        ],
                        "versions": [
                            "2.6",
                            "2.7"
                        ]
                    },
                    "2": {
                        "content": "#ifndef T2\n!T2:serial,V:2.6-2.7\n      LOGICAL FUNCTION test2()\n  IMPLICIT NONE\n  INCLUDE \"acc_testsuite.Fh\"\n  INTEGER:: errors\n  REAL(8),DIMENSION(LOOPCOUNT):: a, a_copy, b\n  INTEGER,DIMENSION(1):: hasDevice\n  INTEGER:: x\n  errors = 0\n\n  SEEDDIM(1) = 1\n# ifdef SEED\n  SEEDDIM(1) = SEED\n# endif\n  CALL RANDOM_SEED(PUT=SEEDDIM)\n\n  CALL RANDOM_NUMBER(a)\n\n  !$acc data copy(b(1:LOOPCOUNT))\n    !$acc serial copyin(a(1:LOOPCOUNT))\n      !$acc loop\n      DO x = 1, LOOPCOUNT\n        b(x) = a(x)\n      END DO\n    !$acc end serial\n  !$acc end data\n\n  DO x = 1, LOOPCOUNT\n    IF (abs(a(x) - b(x)) .gt. PRECISION) THEN\n      errors = errors + 1\n    END IF\n  END DO\n\n        IF (errors .eq. 0) THEN\n          test2 = .FALSE.\n        ELSE\n          test2 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T2\n        LOGICAL :: test2\n#endif\n#ifndef T2\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test2()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 1\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "serial"
                        ],
                        "versions": [
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "serial_copyin.c": {
                "num tests": 2,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:serial,data,data-region,V:2.6-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(n * sizeof(real_t));\n    real_t * a_copy = (real_t *)malloc(n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n    int* hasDevice = (int *) malloc(sizeof(int));\n    hasDevice[0] = 1;\n    #pragma acc enter data copyin(hasDevice[0:1])\n    #pragma acc parallel present(hasDevice[0:1])\n    {\n      hasDevice[0] = 0;\n    }\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        a_copy[x] = a[x];\n        b[x] = 0.0;\n    }\n\n    #pragma acc serial copyin(a[0:n])\n    {\n        #pragma acc loop\n        for (int x = 0; x < n; ++x){\n            a[x] = 0.0;\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        if (((fabs(a[x] - a_copy[x]) > PRECISION) && (hasDevice[0] == 1)) || ((hasDevice[0] == 0) && (fabs(a[x]) > PRECISION))){\n            err = 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "serial",
                            "data",
                            "data-region"
                        ],
                        "versions": [
                            "2.6",
                            "2.7"
                        ]
                    },
                    "2": {
                        "content": "#ifndef T2\n//T2:serial,data,data-region,V:2.6-2.7\nint test2(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(n * sizeof(real_t));\n    real_t * a_copy = (real_t *)malloc(n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n    }\n\n    #pragma acc data copy(b[0:n])\n    {\n        #pragma acc serial copyin(a[0:n])\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                b[x] = a[x];\n            }\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        if (fabs(a[x] - b[x]) > PRECISION){\n            err = 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T2\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test2();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 1);\n    }\n#endif\n",
                        "tags": [
                            "serial",
                            "data",
                            "data-region"
                        ],
                        "versions": [
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "serial_copyout.F90": {
                "num tests": 3,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:serial,V:2.6-2.7\n      LOGICAL FUNCTION test1()\n  IMPLICIT NONE\n  INCLUDE \"acc_testsuite.Fh\"\n  INTEGER:: errors\n  REAL(8),DIMENSION(LOOPCOUNT):: a, b\n  INTEGER:: x\n  INTEGER,DIMENSION(1):: hasDevice\n  errors = 0\n\n  hasDevice(1) = 1\n  !$acc enter data copyin(hasDevice(1:1))\n  !$acc parallel present(hasDevice(1:1))\n  hasDevice(1) = 0\n  !$acc end parallel\n  \n  SEEDDIM(1) = 1\n# ifdef SEED\n  SEEDDIM(1) = SEED\n# endif\n  CALL RANDOM_SEED(PUT=SEEDDIM)\n\n  CALL RANDOM_NUMBER(a)\n  b = 0\n\n\n  !$acc data copyin(a(1:LOOPCOUNT))\n    !$acc serial copyout(b(1:LOOPCOUNT))\n      !$acc loop\n      DO x = 1, LOOPCOUNT\n        b(x) = a(x)\n      END DO\n    !$acc end serial\n  !$acc end data\n\n  DO x = 1, LOOPCOUNT\n    IF (abs(a(x) - b(x)) .gt. PRECISION) THEN\n      errors = errors + 1\n    END IF\n  END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "serial"
                        ],
                        "versions": [
                            "2.6",
                            "2.7"
                        ]
                    },
                    "2": {
                        "content": "#ifndef T2\n!T2:serial,V:2.6-2.7\n      LOGICAL FUNCTION test2()\n  IMPLICIT NONE\n  INCLUDE \"acc_testsuite.Fh\"\n  INTEGER:: errors\n  REAL(8),DIMENSION(LOOPCOUNT):: a, b\n  INTEGER:: x\n  INTEGER,DIMENSION(1):: hasDevice\n  errors = 0\n\n  hasDevice(1) = 1\n  !$acc enter data copyin(hasDevice(1:1))\n  !$acc parallel present(hasDevice(1:1))\n  hasDevice(1) = 0\n  !$acc end parallel\n  \n  SEEDDIM(1) = 1\n# ifdef SEED\n  SEEDDIM(1) = SEED\n# endif\n  CALL RANDOM_SEED(PUT=SEEDDIM)\n\n  IF (hasDevice(1) .eq. 1) THEN\n    !$acc data copyin(a(1:LOOPCOUNT), b(1:LOOPCOUNT))\n      !$acc serial copyout(b(1:LOOPCOUNT))\n        !$acc loop\n        DO x = 1, LOOPCOUNT\n          b(x) = b(x) - a(x)\n        END DO\n      !$acc end serial\n    !$acc end data\n\n    DO x = 1, LOOPCOUNT\n      IF (abs(a(x) - b(x)) .gt. PRECISION) THEN\n        errors = errors + 1\n      END IF\n    END DO\n  END IF\n\n        IF (errors .eq. 0) THEN\n          test2 = .FALSE.\n        ELSE\n          test2 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T2\n        LOGICAL :: test2\n#endif\n#ifndef T2\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test2()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 1\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "serial"
                        ],
                        "versions": [
                            "2.6",
                            "2.7"
                        ]
                    },
                    "3": {
                        "content": "#ifndef T3\n!T3:serial,update,V:2.6-2.7\n      LOGICAL FUNCTION test3()\n  IMPLICIT NONE\n  INCLUDE \"acc_testsuite.Fh\"\n  INTEGER:: errors\n  REAL(8),DIMENSION(LOOPCOUNT):: a, b\n  INTEGER:: x\n  INTEGER,DIMENSION(1):: hasDevice\n  errors = 0\n\n  hasDevice(1) = 1\n  !$acc enter data copyin(hasDevice(1:1))\n  !$acc parallel present(hasDevice(1:1))\n  hasDevice(1) = 0\n  !$acc end parallel\n  \n  SEEDDIM(1) = 1\n# ifdef SEED\n  SEEDDIM(1) = SEED\n# endif\n  CALL RANDOM_SEED(PUT=SEEDDIM)\n\n  !$acc data copyin(a(1:LOOPCOUNT), b(1:LOOPCOUNT))\n    !$acc serial copyout(b(1:LOOPCOUNT))\n      !$acc loop\n      DO x = 1, LOOPCOUNT\n        b(x) = b(x) - a(x)\n      END DO\n    !$acc end serial\n    !$acc update host(b(1:LOOPCOUNT))\n  !$acc end data\n\n  DO x = 1, LOOPCOUNT\n    IF (abs(b(x)) .gt. 2 * PRECISION) THEN\n      errors = errors + 1\n    END IF\n  END DO\n\n        IF (errors .eq. 0) THEN\n          test3 = .FALSE.\n        ELSE\n          test3 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T3\n        LOGICAL :: test3\n#endif\n#ifndef T3\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test3()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 2\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "serial",
                            "update"
                        ],
                        "versions": [
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "serial_copyout.c": {
                "num tests": 3,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:serial,data,data-region,V:2.6-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n\n    real_t * a = (real_t *)malloc(n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n    int* hasDevice = (int *) malloc(sizeof(int));\n    hasDevice[0] = 1;\n    #pragma acc enter data copyin(hasDevice[0:1])\n    #pragma acc serial present(hasDevice[0:1])\n    {\n      hasDevice[0] = 0;\n    }\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = 0.0;\n    }\n\n    #pragma acc data copyin(a[0:n])\n    {\n        #pragma acc serial copyout(b[0:n])\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                b[x] = a[x];\n            }\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        if (fabs(a[x] - b[x]) > PRECISION){\n            err += 1;\n            break;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "serial",
                            "data",
                            "data-region"
                        ],
                        "versions": [
                            "2.6",
                            "2.7"
                        ]
                    },
                    "2": {
                        "content": "#ifndef T2\n//T2:serial,data,data-region,reference-counting,devonly,V:2.6-2.7\nint test2(){\n    int err = 0;\n    srand(SEED);\n\n    real_t * a = (real_t *)malloc(n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n    int* hasDevice = (int *) malloc(sizeof(int));\n    hasDevice[0] = 1;\n    #pragma acc enter data copyin(hasDevice[0:1])\n    #pragma acc serial present(hasDevice[0:1])\n    {\n      hasDevice[0] = 0;\n    }\n\n    if (hasDevice[0] == 1){\n        for (int x = 0; x < n; ++x){\n            a[x] = rand() / (real_t)(RAND_MAX / 10);\n            b[x] = 0;\n        }\n        #pragma acc data copyin(a[0:n], b[0:n])\n        {\n            #pragma acc serial copyout(b[0:n])\n            {\n                #pragma acc loop\n                for (int x = 0; x < n; ++x){\n                    b[x] = a[x];\n                }\n            }\n        }\n        for (int x = 0; x < n; ++x){\n            if (fabs(b[x]) > PRECISION){\n                err += 2;\n                break;\n            }\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T2\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test2();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 1);\n    }\n#endif\n",
                        "tags": [
                            "serial",
                            "data",
                            "data-region",
                            "reference-counting",
                            "devonly"
                        ],
                        "versions": [
                            "2.6",
                            "2.7"
                        ]
                    },
                    "3": {
                        "content": "#ifndef T3\n//T3:serial,data,data-region,reference-counting,V:2.6-2.7\nint test3(){\n    int err = 0;\n    srand(SEED);\n\n    real_t * a = (real_t *)malloc(n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n    int* hasDevice = (int *) malloc(sizeof(int));\n    hasDevice[0] = 1;\n    #pragma acc enter data copyin(hasDevice[0:1])\n    #pragma acc serial present(hasDevice[0:1])\n    {\n      hasDevice[0] = 0;\n    }\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = 0;\n    }\n\n    #pragma acc data copyin(a[0:n], b[0:n])\n    {\n        #pragma acc serial copyout(b[0:n])\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                b[x] = a[x];\n            }\n        }\n        #pragma acc update host(b[0:n])\n    }\n\n    for (int x = 0; x < n; ++x){\n        if (fabs(b[x] - a[x]) > PRECISION){\n            err += 4;\n            break;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T3\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test3();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 2);\n    }\n#endif\n",
                        "tags": [
                            "serial",
                            "data",
                            "data-region",
                            "reference-counting"
                        ],
                        "versions": [
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "serial_create.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:serial,V:2.6-2.7\n      LOGICAL FUNCTION test1()\n  IMPLICIT NONE\n  INCLUDE \"acc_testsuite.Fh\"\n  INTEGER:: errors\n  REAL(8),DIMENSION(LOOPCOUNT):: a, b, c\n  INTEGER:: x\n  errors = 0\n\n  SEEDDIM(1) = 1\n# ifdef SEED\n  SEEDDIM(1) = SEED\n# endif\n  CALL RANDOM_SEED(PUT=SEEDDIM)\n\n  CALL RANDOM_NUMBER(a)\n  b = 0\n  c = 0\n\n  !$acc data copyin(a(1:LOOPCOUNT)) copy(c(1:LOOPCOUNT))\n    !$acc serial create(b(1:LOOPCOUNT))\n      !$acc loop\n      DO x = 1, LOOPCOUNT\n        b(x) = a(x)\n      END DO\n      !$acc loop\n      DO x = 1, LOOPCOUNT\n        c(x) = b(x)\n      END DO\n    !$acc end serial\n  !$acc end data\n\n  DO x = 1, LOOPCOUNT\n    IF (abs(a(x) - c(x)) .gt. PRECISION) THEN\n      errors = errors + 1\n    END IF\n  END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "serial"
                        ],
                        "versions": [
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "serial_create.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:serial,data,data-region,V:2.6-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n    real_t * c = (real_t *)malloc(n * sizeof(real_t));\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = 0.0;\n        c[x] = 0.0;\n    }\n\n    #pragma acc data copyin(a[0:n]) copy(c[0:n])\n    {\n        #pragma acc serial create(b[0:n])\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                b[x] = a[x];\n            }\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                c[x] = b[x];\n            }\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        if (fabs(a[x] - c[x]) > PRECISION){\n            err = 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "serial",
                            "data",
                            "data-region"
                        ],
                        "versions": [
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "serial_default_copy.F90": {
                "num tests": 2,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:devonly,V:2.6-2.7\n      LOGICAL FUNCTION test1()\n  IMPLICIT NONE\n  INCLUDE \"acc_testsuite.Fh\"\n  INTEGER:: errors\n  REAL(8),DIMENSION(LOOPCOUNT):: a, b, c\n  INTEGER,DIMENSION(1):: devtest\n  INTEGER:: x\n  errors = 0\n\n  devtest(1) = 1\n  !$acc enter data copyin(devtest(1:1))\n  !$acc parallel present(devtest(1:1))\n    devtest(1) = 0\n  !$acc end parallel\n\n  SEEDDIM(1) = 1\n# ifdef SEED\n  SEEDDIM(1) = SEED\n# endif\n  CALL RANDOM_SEED(PUT=SEEDDIM)\n\n  CALL RANDOM_NUMBER(a)\n  CALL RANDOM_NUMBER(b)\n  c = 0\n\n  !$acc data copyin(a(1:LOOPCOUNT), b(1:LOOPCOUNT))\n    !$acc serial\n      !$acc loop\n      DO x = 1, LOOPCOUNT\n        c(x) = c(x) + b(x) + a(x)\n      END DO\n    !$acc end serial\n  !$acc end data\n\n  DO x = 1, LOOPCOUNT\n    IF (abs(c(x) - (a(x) + b(x))) .gt. PRECISION) THEN\n      errors = errors + 1\n    END IF\n  END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "devonly"
                        ],
                        "versions": [
                            "2.6",
                            "2.7"
                        ]
                    },
                    "2": {
                        "content": "#ifndef T2\n!T2:devonly,V:2.6-2.7\n      LOGICAL FUNCTION test2()\n  IMPLICIT NONE\n  INCLUDE \"acc_testsuite.Fh\"\n  INTEGER:: errors\n  REAL(8),DIMENSION(LOOPCOUNT):: a, b, c\n  INTEGER,DIMENSION(1):: devtest\n  INTEGER:: x\n  errors = 0\n\n  devtest(1) = 1\n  !$acc enter data copyin(devtest(1:1))\n  !$acc parallel present(devtest(1:1))\n    devtest(1) = 0\n  !$acc end parallel\n\n  SEEDDIM(1) = 1\n# ifdef SEED\n  SEEDDIM(1) = SEED\n# endif\n  CALL RANDOM_SEED(PUT=SEEDDIM)\n\n  IF (devtest(1) .eq. 1) THEN\n    CALL RANDOM_NUMBER(a)\n    CALL RANDOM_NUMBER(b)\n    c = 1\n\n    !$acc enter data copyin(c(1:LOOPCOUNT))\n    DO x = 1, LOOPCOUNT\n      c(x) = 0\n    END DO\n\n    !$acc data copyin(a(1:LOOPCOUNT), b(1:LOOPCOUNT))\n      !$acc serial\n        !$acc loop\n        DO x = 1, LOOPCOUNT\n          c(x) = c(x) + a(x) + b(x)\n        END DO\n      !$acc end serial\n    !$acc end data\n\n    DO x = 1, LOOPCOUNT\n      if (abs(c(x)) .gt. PRECISION) THEN\n        errors = errors + 1\n      END IF\n    END DO\n\n    !$acc exit data copyout(c(1:LOOPCOUNT))\n\n    DO x = 1, LOOPCOUNT\n      IF (abs(c(x) - (a(x) + b(x) + 1)) .gt. PRECISION) THEN\n        errors = errors + 1\n      END IF\n    END DO\n  END IF\n\n        IF (errors .eq. 0) THEN\n          test2 = .FALSE.\n        ELSE\n          test2 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T2\n        LOGICAL :: test2\n#endif\n#ifndef T2\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test2()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 1\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "devonly"
                        ],
                        "versions": [
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "serial_default_copy.c": {
                "num tests": 2,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:serial,data,data-region,default-mapping,V:2.6-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n    real_t * c = (real_t *)malloc(n * sizeof(real_t));\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n        c[x] = 0.0;\n    }\n\n    #pragma acc data copyin(a[0:n], b[0:n])\n    {\n        #pragma acc serial\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                c[x] += a[x] + b[x];\n            }\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        if (fabs(c[x] - (a[x] + b[x])) > PRECISION){\n            err += 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "serial",
                            "data",
                            "data-region",
                            "default-mapping"
                        ],
                        "versions": [
                            "2.6",
                            "2.7"
                        ]
                    },
                    "2": {
                        "content": "#ifndef T2\n//T2:serial,data,data-region,default-mapping,devonly,V:2.6-2.7\nint test2(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n    real_t * c = (real_t *)malloc(n * sizeof(real_t));\n    int * devtest = (int *)malloc(sizeof(real_t));\n\n    devtest[0] = 1;\n    #pragma acc enter data copyin(devtest[0:1])\n    #pragma acc parallel present(devtest[0:1])\n    {\n        devtest[0] = 0;\n    }\n\n    if (devtest[0] == 1){\n        for (int x = 0; x < n; ++x){\n            a[x] = rand() / (real_t)(RAND_MAX / 10);\n            b[x] = rand() / (real_t)(RAND_MAX / 10);\n            c[x] = 1;\n        }\n\n        #pragma acc enter data copyin(c[0:n])\n        for (int x = 0; x < n; ++x){\n            c[x] = 0.0;\n        }\n        #pragma acc data copyin(a[0:n], b[0:n])\n        {\n            #pragma acc serial\n            {\n                #pragma acc loop\n                for (int x = 0; x < n; ++x){\n                    c[x] += a[x] + b[x];\n                }\n            }\n        }\n\n        for (int x = 0; x < n; ++x){\n            if (fabs(c[x]) > PRECISION){\n                err += 1;\n            }\n        }\n\n        #pragma acc exit data copyout(c[0:n])\n\n        for (int x = 0; x < n; ++x){\n            if (fabs(c[x] - (a[x] + b[x] + 1)) > PRECISION){\n                err += 1;\n            }\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T2\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test2();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 1);\n    }\n#endif\n",
                        "tags": [
                            "serial",
                            "data",
                            "data-region",
                            "default-mapping",
                            "devonly"
                        ],
                        "versions": [
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "serial_default_present.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:serial,default,V:2.6-2.7\n      LOGICAL FUNCTION test1()\n  IMPLICIT NONE\n  INCLUDE \"acc_testsuite.Fh\"\n  INTEGER:: errors\n  REAL(8),DIMENSION(LOOPCOUNT):: a\n  INTEGER:: x\n  errors = 0\n\n  a = 0\n\n  !$acc enter data copyin(a(1:LOOPCOUNT))\n  !$acc serial default(present)\n    !$acc loop\n    DO x = 1, LOOPCOUNT\n      a(x) = 1\n    END DO\n  !$acc end serial\n  !$acc exit data copyout(a(1:LOOPCOUNT))\n\n  DO x = 1, LOOPCOUNT\n    IF (abs(a(x) - 1) .gt. PRECISION) THEN\n      errors = errors + 1\n    END IF\n  END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "serial",
                            "default"
                        ],
                        "versions": [
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "serial_default_present.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:serial,data,data-region,default,V:2.6-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(n * sizeof(real_t));\n\n    for (int x = 0; x < n; ++x){\n        a[x] = 0.0;\n    }\n    #pragma acc enter data copyin(a[0:n])\n    #pragma acc serial default(present)\n    {\n        #pragma acc loop\n        for (int x = 0; x < n; ++x){\n            a[x] = 1.0;\n        }\n    }\n    #pragma acc exit data copyout(a[0:n])\n\n    for (int x = 0; x < n; ++x){\n        if (fabs(a[x] - 1.0) > PRECISION){\n            err = 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "serial",
                            "data",
                            "data-region",
                            "default"
                        ],
                        "versions": [
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "serial_deviceptr.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:serial,data,data-region,V:2.6-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(n * sizeof(real_t));\n    real_t * b;\n\n    for (int x = 0; x < n; ++x){\n        a[x] = 0;\n    }\n\n    #pragma acc enter data copyin(a[0:n])\n    b = (real_t *) acc_deviceptr(a);\n    if (b == NULL){\n        err = 1;\n    }\n    else{\n        #pragma acc serial deviceptr(b)\n        {\n            #pragma acc loop\n            for (int x = 0; x < (int) n/2; ++x){\n                b[x] = 1;\n            }\n        }\n        #pragma acc exit data copyout(a[0:n])\n    }\n    for (int x = 0; x < n; ++x){\n        if (x < (int) n/2){\n            if (fabs(a[x] - 1) > PRECISION){\n                err = 1;\n            }\n        }\n        else {\n            if (fabs(a[x]) > PRECISION){\n                err = 1;\n            }\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "serial",
                            "data",
                            "data-region"
                        ],
                        "versions": [
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "serial_firstprivate.F90": {
                "num tests": 2,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:serial,firstprivate,V:2.6-2.7\n      LOGICAL FUNCTION test1()\n  IMPLICIT NONE\n  INCLUDE \"acc_testsuite.Fh\"\n  INTEGER:: errors\n  REAL(8),DIMENSION(10, LOOPCOUNT):: a, b, d\n  REAL(8),DIMENSION(10):: c, c_copy\n  INTEGER:: x, y\n\n  errors = 0\n\n  SEEDDIM(1) = 1\n# ifdef SEED\n  SEEDDIM(1) = SEED\n# endif\n  CALL RANDOM_SEED(PUT=SEEDDIM)\n\n  CALL RANDOM_NUMBER(a)\n  CALL RANDOM_NUMBER(b)\n  CALL RANDOM_NUMBER(c)\n  c_copy = c\n  d = 0\n  !$acc data copyin(a(1:10, 1:LOOPCOUNT), b(1:10, 1:LOOPCOUNT)) copy(d(1:10, 1:LOOPCOUNT))\n    !$acc serial firstprivate(c(1:10))\n      !$acc loop gang\n      DO y = 1, LOOPCOUNT\n        !$acc loop worker\n        DO x = 1, 10\n          d(x, y) = a(x, y) + b(x, y) + c(x)\n        END DO\n      END DO\n    !$acc end serial\n  !$acc end data\n\n  DO y = 1, LOOPCOUNT\n    DO x = 1, 10\n      IF (abs(d(x, y) - (a(x, y) + b(x, y) + c_copy(x))) .gt. PRECISION) THEN\n        errors = errors + 1\n      END IF\n    END DO\n  END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "serial",
                            "firstprivate"
                        ],
                        "versions": [
                            "2.6",
                            "2.7"
                        ]
                    },
                    "2": {
                        "content": "#ifndef T2\n!T2:serial,firstprivate,V:2.6-2.7\n      LOGICAL FUNCTION test2()\n  IMPLICIT NONE\n  INCLUDE \"acc_testsuite.Fh\"\n  INTEGER:: errors\n  REAL(8),DIMENSION(10, LOOPCOUNT):: a, b, d\n  REAL(8),DIMENSION(10):: c, c_copy\n  INTEGER:: x, y\n\n  errors = 0\n\n  SEEDDIM(1) = 1\n# ifdef SEED\n  SEEDDIM(1) = SEED\n# endif\n  CALL RANDOM_SEED(PUT=SEEDDIM)\n\n  CALL RANDOM_NUMBER(a)\n  CALL RANDOM_NUMBER(b)\n  d = 0\n  c = 0\n\n  !$acc data copyin(a(1:10, 1:LOOPCOUNT), b(1:10, 1:LOOPCOUNT)) copy(d(1:10, 1:LOOPCOUNT))\n    !$acc serial firstprivate(c(1:10))\n      !$acc loop gang independent\n      DO y = 1, LOOPCOUNT\n        !$acc loop worker independent\n        DO x = 1, 10\n          c(x) = a(x, y) - b(x, y)\n        END DO\n        !$acc loop worker independent\n        DO x = 1, 10\n          d(x, y) = a(x, y) + b(x, y) + c(x)\n        END DO\n      END DO\n    !$acc end serial\n  !$acc end data\n\n  DO y = 1, LOOPCOUNT\n    DO x = 1, 10\n      IF (abs(d(x, y) - (2 * a(x, y))) .gt. PRECISION) THEN\n        errors = errors + 1\n      END IF\n    END DO\n  END DO\n\n        IF (errors .eq. 0) THEN\n          test2 = .FALSE.\n        ELSE\n          test2 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T2\n        LOGICAL :: test2\n#endif\n#ifndef T2\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test2()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 1\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "serial",
                            "firstprivate"
                        ],
                        "versions": [
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "serial_firstprivate.c": {
                "num tests": 2,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:serial,firstprivate,V:2.6-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(10 * n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(10 * n * sizeof(real_t));\n    real_t * c = (real_t *)malloc(10 * sizeof(real_t));\n    real_t * c_copy = (real_t *)malloc(10 * sizeof(real_t));\n    real_t * d = (real_t *)malloc(10 * n * sizeof(real_t));\n\n    for (int x = 0; x < 10*n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n        d[x] = 0.0;\n    }\n    for (int x = 0; x < 10; ++x){\n        c[x] = rand() / (real_t)(RAND_MAX / 10);\n        c_copy[x] = c[x];\n    }\n    #pragma acc data copyin(a[0:10*n], b[0:10*n]) copy(d[0:10*n])\n    {\n        #pragma acc serial firstprivate(c[0:n])\n        {\n            #pragma acc loop gang\n            for (int x = 0; x < n; ++x){\n                #pragma acc loop worker\n                for (int y = 0; y < 10; ++y){\n                    d[x * 10 + y] = a[x * 10 + y] + b[x * 10 + y] + c[y];\n                }\n            }\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        for (int y = 0; y < 10; ++y){\n            if (fabs(d[x * 10 + y] - (a[x * 10 + y] + b[x * 10 + y] + c_copy[y])) > PRECISION){\n                err += 1;\n            }\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "serial",
                            "firstprivate"
                        ],
                        "versions": [
                            "2.6",
                            "2.7"
                        ]
                    },
                    "2": {
                        "content": "#ifndef T2\n//T2:serial,firstprivate,V:2.6-2.7\nint test2(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(10 * n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(10 * n * sizeof(real_t));\n    real_t * c = (real_t *)malloc(10 * sizeof(real_t));\n    real_t * c_copy = (real_t *)malloc(10 * sizeof(real_t));\n    real_t * d = (real_t *)malloc(10 * n * sizeof(real_t));\n\n    for (int x = 0; x < 10*n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n        d[x] = 0.0;\n    }\n    for (int x = 0; x < 10; ++x){\n        c[x] = 0.0;\n    }\n\n    #pragma acc data copyin(a[0:10*n], b[0:10*n]) copy(d[0:10*n])\n    {\n        #pragma acc serial firstprivate(c[0:n])\n        {\n            #pragma acc loop gang independent\n            for (int x = 0; x < n; ++x){\n                #pragma acc loop worker independent\n                for (int y = 0; y < 10; ++y){\n                    c[y] = a[x * 10 + y] - b[x * 10 + y];\n                }\n                #pragma acc loop worker independent\n                for (int y = 0; y < 10; ++y){\n                    d[x * 10 + y] = a[x * 10 + y] + b[x * 10 + y] + c[y];\n                }\n            }\n        }\n    }\n\n    for (int x = 0; x < 10 * n; ++x){\n        if (fabs(d[x] - 2 * a[x]) > PRECISION){\n            err += 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T2\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test2();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 1);\n    }\n#endif\n",
                        "tags": [
                            "serial",
                            "firstprivate"
                        ],
                        "versions": [
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "serial_if.F90": {
                "num tests": 3,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:devonly,serial,if,V:2.6-2.7\n      LOGICAL FUNCTION test1()\n  IMPLICIT NONE\n  INCLUDE \"acc_testsuite.Fh\"\n  INTEGER:: errors\n  REAL(8),DIMENSION(LOOPCOUNT):: a, b, c\n  LOGICAL,DIMENSION(1):: devtest\n  LOGICAL:: host, device\n  INTEGER:: x\n  host = .FALSE.\n  device = .TRUE.\n  errors = 0\n\n  devtest(1) = .TRUE.\n  !$acc enter data copyin(devtest(1:1))\n  !$acc parallel present(devtest(1:1))\n    devtest(1) = .FALSE.\n  !$acc end parallel\n\n  SEEDDIM(1) = 1\n# ifdef SEED\n  SEEDDIM(1) = SEED\n# endif\n  CALL RANDOM_SEED(PUT=SEEDDIM)\n\n  CALL RANDOM_NUMBER(a)\n  CALL RANDOM_NUMBER(b)\n  c = 0\n\n  !$acc serial if(host)\n    !$acc loop\n    DO x = 1, LOOPCOUNT\n      c(x) = a(x) + b(x)\n    END DO\n  !$acc end serial\n\n  DO x = 1, N\n    IF (abs(c(x) - (a(x) + b(x))) .gt. PRECISION) THEN\n      errors = errors + 1\n    END IF\n  END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "devonly",
                            "serial",
                            "if"
                        ],
                        "versions": [
                            "2.6",
                            "2.7"
                        ]
                    },
                    "2": {
                        "content": "#ifndef T2\n!T2:devonly,serial,if,V:2.6-2.7\n      LOGICAL FUNCTION test2()\n  IMPLICIT NONE\n  INCLUDE \"acc_testsuite.Fh\"\n  INTEGER:: errors\n  REAL(8),DIMENSION(LOOPCOUNT):: a, b, c\n  LOGICAL,DIMENSION(1):: devtest\n  LOGICAL:: host, device\n  INTEGER:: x\n  host = .FALSE.\n  device = .TRUE.\n  errors = 0\n\n  devtest(1) = .TRUE.\n  !$acc enter data copyin(devtest(1:1))\n  !$acc parallel present(devtest(1:1))\n    devtest(1) = .FALSE.\n  !$acc end parallel\n\n  SEEDDIM(1) = 1\n# ifdef SEED\n  SEEDDIM(1) = SEED\n# endif\n  CALL RANDOM_SEED(PUT=SEEDDIM)\n\n  IF (devtest(1)) THEN\n    CALL RANDOM_NUMBER(a)\n    CALL RANDOM_NUMBER(b)\n    c = a + b\n\n    !$acc enter data copyin(a(1:LOOPCOUNT), b(1:LOOPCOUNT), c(1:LOOPCOUNT))\n    !$acc serial if(host) present(a(1:LOOPCOUNT), b(1:LOOPCOUNT), c(1:LOOPCOUNT))\n      !$acc loop\n      DO x = 1, LOOPCOUNT\n        c(x) = c(x) + a(x) + b(x)\n      END DO\n    !$acc end serial\n    !$acc exit data delete(a(1:LOOPCOUNT), b(1:LOOPCOUNT)) copyout(c(1:LOOPCOUNT))\n\n    DO x = 1, LOOPCOUNT\n      IF (abs(c(x) - (a(x) + b(x))) .gt. PRECISION) THEN\n        errors = errors + 1\n      END IF\n    END DO\n  END IF\n\n        IF (errors .eq. 0) THEN\n          test2 = .FALSE.\n        ELSE\n          test2 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T2\n        LOGICAL :: test2\n#endif\n#ifndef T2\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test2()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 1\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "devonly",
                            "serial",
                            "if"
                        ],
                        "versions": [
                            "2.6",
                            "2.7"
                        ]
                    },
                    "3": {
                        "content": "#ifndef T3\n!T3:devonly,serial,if,V:2.6-2.7\n      LOGICAL FUNCTION test3()\n  IMPLICIT NONE\n  INCLUDE \"acc_testsuite.Fh\"\n  INTEGER:: errors\n  REAL(8),DIMENSION(LOOPCOUNT):: a, b, c\n  LOGICAL,DIMENSION(1):: devtest\n  LOGICAL:: host, device\n  INTEGER:: x\n  host = .FALSE.\n  device = .TRUE.\n  errors = 0\n\n  devtest(1) = .TRUE.\n  !$acc enter data copyin(devtest(1:1))\n  !$acc parallel present(devtest(1:1))\n    devtest(1) = .FALSE.\n  !$acc end parallel\n\n  SEEDDIM(1) = 1\n# ifdef SEED\n  SEEDDIM(1) = SEED\n# endif\n  CALL RANDOM_SEED(PUT=SEEDDIM)\n\n  CALL RANDOM_NUMBER(a)\n  CALL RANDOM_NUMBER(b)\n  c = a + b\n  \n  !$acc enter data copyin(a(1:LOOPCOUNT), b(1:LOOPCOUNT), c(1:LOOPCOUNT))\n  !$acc serial if(device) present(a(1:LOOPCOUNT), b(1:LOOPCOUNT), c(1:LOOPCOUNT))\n    !$acc loop\n    DO x = 1, LOOPCOUNT\n      c(x) = c(x) + a(x) + b(x)\n    END DO\n  !$acc end serial\n  !$acc exit data delete(a(1:LOOPCOUNT), b(1:LOOPCOUNT)) copyout(c(1:LOOPCOUNT))\n\n  DO x = 1, LOOPCOUNT\n    IF (abs(c(x) - (2 * (a(x) + b(x)))) .gt. PRECISION * 2) THEN\n      errors = errors + 1\n    END IF\n  END DO\n\n        IF (errors .eq. 0) THEN\n          test3 = .FALSE.\n        ELSE\n          test3 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T3\n        LOGICAL :: test3\n#endif\n#ifndef T3\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test3()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 2\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "devonly",
                            "serial",
                            "if"
                        ],
                        "versions": [
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "serial_if.c": {
                "num tests": 3,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:serial,if,V:2.6-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n    real_t * c = (real_t *)malloc(n * sizeof(real_t));\n    int accel = 1;\n    int host = 0;\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n        c[x] = 0.0;\n    }\n    #pragma acc serial if(host)\n    {\n        #pragma acc loop\n        for (int x = 0; x < n; ++x){\n            c[x] = a[x] + b[x];\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        if (fabs(c[x] - (a[x] + b[x])) > PRECISION){\n            err = 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "serial",
                            "if"
                        ],
                        "versions": [
                            "2.6",
                            "2.7"
                        ]
                    },
                    "2": {
                        "content": "#ifndef T2\n//T2:serial,if,devonly,V:2.6-2.7\nint test2(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n    real_t * c = (real_t *)malloc(n * sizeof(real_t));\n    int accel = 1;\n    int host = 0;\n    int * devtest = (int *)malloc(sizeof(int));\n    devtest[0] = 1;\n    #pragma acc data copyin(devtest[0:1])\n    #pragma acc parallel present(devtest[0:1])\n    {\n      devtest[0] = 0;\n    }\n\n    if (devtest[0] == 1){\n        for (int x = 0; x < n; ++x){\n            a[x] = rand() / (real_t)(RAND_MAX / 10);\n            b[x] = rand() / (real_t)(RAND_MAX / 10);\n            c[x] = 0;\n        }\n        #pragma acc enter data copyin(a[0:n], b[0:n], c[0:n])\n        #pragma acc serial if(host) present(a[0:n], b[0:n], c[0:n])\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                c[x] += a[x] + b[x];\n            }\n        }\n        #pragma acc exit data delete(a[0:n], b[0:n]) copyout(c[0:n])\n\n        for (int x = 0; x < n; ++x){\n            if (fabs(c[x]) > PRECISION){\n                err = 1;\n            }\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T2\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test2();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 1);\n    }\n#endif\n",
                        "tags": [
                            "serial",
                            "if",
                            "devonly"
                        ],
                        "versions": [
                            "2.6",
                            "2.7"
                        ]
                    },
                    "3": {
                        "content": "#ifndef T3\n//T3:serial,if,V:2.6-2.7\nint test3(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n    real_t * c = (real_t *)malloc(n * sizeof(real_t));\n    int accel = 1;\n    int host = 0;\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n        c[x] = 0;\n    }\n    #pragma acc enter data copyin(a[0:n], b[0:n], c[0:n])\n    #pragma acc serial if(accel) present(a[0:n], b[0:n], c[0:n])\n    {\n        #pragma acc loop\n        for (int x = 0; x < n; ++x){\n            c[x] += a[x] + b[x];\n        }\n    }\n\n    #pragma acc exit data delete(a[0:n], b[0:n]) copyout(c[0:n])\n\n    for (int x = 0; x < n; ++x){\n        if (fabs(c[x] - (a[x] + b[x])) > PRECISION * 2){\n            err = 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T3\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test3();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 2);\n    }\n#endif\n",
                        "tags": [
                            "serial",
                            "if"
                        ],
                        "versions": [
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "serial_loop.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:serial,loop,V:2.6-2.7\n      LOGICAL FUNCTION test1()\n  IMPLICIT NONE\n  INCLUDE \"acc_testsuite.Fh\"\n  REAL(8),DIMENSION(LOOPCOUNT):: a, b, c\n  INTEGER:: x\n  INTEGER:: errors\n\n  errors = 0\n\n  SEEDDIM(1) = 1\n# ifdef SEED\n  SEEDDIM(1) = SEED\n# endif\n  CALL RANDOM_SEED(PUT=SEEDDIM)\n\n  CALL RANDOM_NUMBER(a)\n  CALL RANDOM_NUMBER(b)\n  c = 0\n\n  !$acc data copy(c(1:LOOPCOUNT))\n    !$acc serial loop\n    DO x = 1, LOOPCOUNT\n      c(x) = 1\n    END DO\n  !$acc end data\n\n  DO x = 1, LOOPCOUNT\n    IF (abs(c(x) - 1) .gt. PRECISION) THEN\n      errors = errors + 1\n    END IF\n  END DO\n\n  !$acc data copy(a(1:LOOPCOUNT), b(1:LOOPCOUNT), c(1:LOOPCOUNT))\n    !$acc serial\n      !$acc loop\n      DO x = 1, LOOPCOUNT\n        c(x) = b(x)\n      END DO\n      !$acc loop\n      DO x = 1, LOOPCOUNT\n        c(x) = c(x) + a(x)\n      END DO\n    !$acc end serial\n  !$acc end data\n\n  DO x = 1, LOOPCOUNT\n    IF (abs(c(x) - (a(x) + b(x))) .gt. PRECISION) THEN\n      errors = errors + 1\n    END IF\n  END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "serial",
                            "loop"
                        ],
                        "versions": [
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "serial_loop.c": {
                "num tests": 2,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:serial,loop,combined-constructs,V:2.6-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n    real_t * c = (real_t *)malloc(n * sizeof(real_t));\n\n    for (int x = 0; x < n; ++x){\n        a[x] = 0;\n    }\n\n    #pragma acc data copy(a[0:n])\n    {\n        #pragma acc serial loop\n        for (int x = 0; x < n; ++x){\n            a[x] = 1.0;\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        if (fabs(a[x] - 1.0) > PRECISION){\n            err = 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "serial",
                            "loop",
                            "combined-constructs"
                        ],
                        "versions": [
                            "2.6",
                            "2.7"
                        ]
                    },
                    "2": {
                        "content": "#ifndef T2\n//T2:serial,loop,V:2.6-2.7\nint test2(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n    real_t * c = (real_t *)malloc(n * sizeof(real_t));\n\n    for (int x = 0; x < n; ++x){\n      a[x] = 0.0;\n      b[x] = rand() / (real_t)(RAND_MAX / 10);\n      c[x] = rand() / (real_t)(RAND_MAX / 10);\n    }\n    #pragma acc data copy(a[0:n], b[0:n], c[0:n])\n    {\n        #pragma acc serial\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                a[x] = b[x];\n            }\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                a[x] += c[x];\n            }\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        if (fabs(a[x] - (b[x] + c[x])) > PRECISION * 2){\n            err = 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T2\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test2();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 1);\n    }\n#endif\n",
                        "tags": [
                            "serial",
                            "loop"
                        ],
                        "versions": [
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "serial_loop_async.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:async,serial,combined-constructs,loop,V:2.6-2.7\n      LOGICAL FUNCTION test1()\n  IMPLICIT NONE\n  INCLUDE \"acc_testsuite.Fh\"\n  INTEGER:: errors\n  REAL(8),DIMENSION(LOOPCOUNT, 10):: a, b, c, d\n  INTEGER,DIMENSION(10):: error_array\n  INTEGER:: x, y\n\n  errors = 0\n  SEEDDIM(1) = 1\n# ifdef SEED\n  SEEDDIM(1) = SEED\n# endif\n  CALL RANDOM_SEED(PUT=SEEDDIM)\n\n  CALL RANDOM_NUMBER(a)\n  CALL RANDOM_NUMBER(b)\n  c = 0\n\n  DO y = 1, 10\n    DO x = 1, LOOPCOUNT\n      d(x, y) = a(x, y) + b(x, y)\n    END DO\n  END DO\n\n  error_array = 0\n\n  !$acc data copyin(a(1:LOOPCOUNT, 1:10), b(1:LOOPCOUNT, 1:10), c(1:LOOPCOUNT, 1:10), d(1:LOOPCOUNT, 1:10)) copy(error_array(1:10))\n    DO y = 1, 10\n      !$acc serial loop async(y)\n      DO x = 1, LOOPCOUNT\n        c(x, y) = a(x, y) + b(x, y)\n      END DO\n      !$acc serial loop async(y)\n      DO x = 1, LOOPCOUNT\n        IF (((c(x, y) - d(x, y)) .gt. PRECISION) .OR. ((d(x, y) - c(x, y)) .gt. PRECISION)) THEN\n          error_array(y) = error_array(y) + 1\n        END IF\n      END DO\n    END DO\n  !$acc end data\n\n  DO x = 1, 10\n    errors = errors + error_array(x)\n  END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "async",
                            "serial",
                            "combined-constructs",
                            "loop"
                        ],
                        "versions": [
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "serial_loop_async.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:serial,loop,async,combined-constructs,V:2.6-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(10 * n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(10 * n * sizeof(real_t));\n    real_t * c = (real_t *)malloc(10 * n * sizeof(real_t));\n    real_t * d = (real_t *)malloc(10 * n * sizeof(real_t));\n\t\tint * errors = (int *)malloc(10 * sizeof(int));\n\n\t\tfor (int x = 0; x < 10; ++x){\n\t\t\terrors[x] = 0;\n\t\t}\n\n    for (int x = 0; x < 10 * n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n        c[x] = 0.0;\n        d[x] = a[x] + b[x];\n    }\n\n    #pragma acc data copyin(a[0:10*n], b[0:10*n], c[0:10*n], d[0:10*n]) copy(errors[0:10])\n    {\n        for (int x = 0; x < 10; ++x){\n            #pragma acc serial loop async(x)\n            for (int y = 0; y < n; ++y){\n                c[x * n + y] = a[x * n + y] + b[x * n + y];\n            }\n            #pragma acc serial loop async(x)\n            for (int y = 0; y < n; ++y){\n                if(c[x * n + y] - d[x * n + y] > PRECISION || d[x * n + y] - c[x * n + y] > PRECISION){\n                    errors[x] += 1;\n                }\n            }\n        }\n\t\t\t\t#pragma acc wait\n    }\n\n    for (int x = 0; x < 10; ++x){\n        err += errors[x];\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "serial",
                            "loop",
                            "async",
                            "combined-constructs"
                        ],
                        "versions": [
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "serial_loop_auto.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:serial,combined-constructs,loop,auto,V:2.6-2.7\n      LOGICAL FUNCTION test1()\n  IMPLICIT NONE\n  INCLUDE \"acc_testsuite.Fh\"\n  INTEGER:: errors\n  REAL(8),DIMENSION(LOOPCOUNT):: a, a_copy, b\n  INTEGER:: x\n  REAL(8):: temp\n  errors = 0\n\n  SEEDDIM(1) = 1\n# ifdef SEED\n  SEEDDIM(1) = SEED\n# endif\n  CALL RANDOM_SEED(PUT=SEEDDIM)\n\n  CALL RANDOM_NUMBER(a)\n  a_copy = a\n  b = 0\n\n  !$acc data copyin(a(1:LOOPCOUNT)) copyout(b(1:LOOPCOUNT))\n    !$acc serial loop auto\n    DO x = 1, LOOPCOUNT\n      b(x) = a(x)\n    END DO\n  !$acc end data\n\n  DO x = 1, LOOPCOUNT\n    IF (abs(b(x) - a(x)) .gt. PRECISION) THEN\n      errors = errors + 1\n    END IF\n  END DO\n\n  !$acc data copy(a(1:LOOPCOUNT))\n    !$acc serial loop auto\n    DO x = 2, LOOPCOUNT\n      a(x) = a(x - 1) + a(x)\n    END DO\n  !$acc end data\n\n  temp = 0\n  DO x = 1, LOOPCOUNT\n    temp = temp + a_copy(x)\n    IF (abs(temp - a(x)) .gt. PRECISION) THEN\n      errors = errors + 1\n    END IF\n  END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "serial",
                            "combined-constructs",
                            "loop",
                            "auto"
                        ],
                        "versions": [
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "serial_loop_auto.c": {
                "num tests": 2,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:serial,loop,auto,V:2.6-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(n * sizeof(real_t));\n    real_t * a_copy = (real_t *)malloc(n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n    real_t rolling_total = 0.0;\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = 0;\n    }\n\n    #pragma acc data copyin(a[0:n]) copyout(b[0:n])\n    {\n      #pragma acc serial loop auto\n      for (int x = 0; x < n; ++x){\n        b[x] = a[x];\n      }\n    }\n\n    for (int x = 0; x < n; ++x){\n      if (fabs(b[x] - a[x]) > PRECISION){\n        err = 1;\n      }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "serial",
                            "loop",
                            "auto"
                        ],
                        "versions": [
                            "2.6",
                            "2.7"
                        ]
                    },
                    "2": {
                        "content": "#ifndef T2\n//T2:serial,loop,combined-constructs,V:2.6-2.7\nint test2(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(n * sizeof(real_t));\n    real_t * a_copy = (real_t *)malloc(n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n    real_t rolling_total = 0.0;\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        a_copy[x] = a[x];\n    }\n\n    #pragma acc data copy(a[0:n])\n    {\n      #pragma acc serial loop auto\n      for (int x = 1; x < n; ++x){\n        a[x] = a[x - 1] + a[x];\n      }\n    }\n\n    for (int x = 0; x < n; ++x){\n      rolling_total += a_copy[x];\n      if (fabs(rolling_total - a[x]) > PRECISION){\n        err = 1;\n      }\n    }\n\n    return err;\n}\n#endif\n#ifndef T2\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test2();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 1);\n    }\n#endif\n",
                        "tags": [
                            "serial",
                            "loop",
                            "combined-constructs"
                        ],
                        "versions": [
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "serial_loop_gang.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:serial,combined-constructs,loop,V:2.6-2.7\n      LOGICAL FUNCTION test1()\n  IMPLICIT NONE\n  INCLUDE \"acc_testsuite.Fh\"\n  INTEGER:: errors\n  REAL(8),DIMENSION(LOOPCOUNT):: a, b, c\n  INTEGER:: x\n\n  errors = 0\n\n  SEEDDIM(1) = 1\n# ifdef SEED\n  SEEDDIM(1) = SEED\n# endif\n  CALL RANDOM_SEED(PUT=SEEDDIM)\n\n  CALL RANDOM_NUMBER(a)\n  CALL RANDOM_NUMBER(b)\n  c = 0\n\n  !$acc data copyin(a(1:LOOPCOUNT), b(1:LOOPCOUNT)) copy(c(1:LOOPCOUNT))\n    !$acc serial loop gang\n    DO x = 1, LOOPCOUNT\n      c(x) = a(x) + b(x)\n    END DO\n  !$acc end data\n\n  DO x = 1, LOOPCOUNT\n    IF (abs(c(x) - (a(x) + b(x))) .gt. PRECISION) THEN\n      errors = errors + 1\n    END IF\n  END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "serial",
                            "combined-constructs",
                            "loop"
                        ],
                        "versions": [
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "serial_loop_gang.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:serial,loop,combined-constructs,V:2.6-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n    real_t * c = (real_t *)malloc(n * sizeof(real_t));\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n        c[x] = 0.0;\n    }\n\n    #pragma acc data copyin(a[0:n], b[0:n]) copy(c[0:n])\n    {\n        #pragma acc serial loop gang\n        for (int x = 0; x < n; ++x){\n            c[x] = a[x] + b[x];\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        if (fabs(c[x] - (a[x] + b[x])) > PRECISION){\n            err = 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "serial",
                            "loop",
                            "combined-constructs"
                        ],
                        "versions": [
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "serial_loop_reduction_add_general.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:serial,reduction,combined-constructs,loop,V:2.6-2.7\n      LOGICAL FUNCTION test1()\n  IMPLICIT NONE\n  INCLUDE \"acc_testsuite.Fh\"\n  INTEGER:: errors\n  REAL(8),DIMENSION(LOOPCOUNT):: a, b\n  REAL(8):: total\n  INTEGER:: x\n  errors = 0\n\n  SEEDDIM(1) = 1\n# ifdef SEED\n  SEEDDIM(1) = SEED\n# endif\n  CALL RANDOM_SEED(PUT=SEEDDIM)\n\n  CALL RANDOM_NUMBER(a)\n  CALL RANDOM_NUMBER(b)\n\n  total = 10\n  !$acc data copyin(a(1:LOOPCOUNT), b(1:LOOPCOUNT))\n    !$acc serial loop reduction(+:total)\n    DO x = 1, LOOPCOUNT\n      total = total + a(x) + b(x)\n    END DO\n  !$acc end data\n\n  DO x = 1, LOOPCOUNT\n    total = total - (a(x) + b(x))\n  END DO\n\n  IF (abs(total - 10) .gt. PRECISION) THEN\n    errors = errors + 1\n  END IF\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "serial",
                            "reduction",
                            "combined-constructs",
                            "loop"
                        ],
                        "versions": [
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "serial_loop_reduction_add_general.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:serial,loop,reduction,combined-constructs,V:2.6-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n    real_t total = 10;\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n    }\n\n    #pragma acc data copyin(a[0:n], b[0:n])\n    {\n        #pragma acc serial loop reduction(+:total)\n        for (int x = 0; x < n; ++x){\n            total += a[x] + b[x];\n        }\n    }\n    for (int x = 0; x < n; ++x){\n        total -= a[x] + b[x];\n    }\n    if (fabs(total - 10) > PRECISION * (2 * n - 1)){ //199 = # of mathematical operations necessary\n        err = 1;\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "serial",
                            "loop",
                            "reduction",
                            "combined-constructs"
                        ],
                        "versions": [
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "serial_loop_reduction_add_loop.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:serial,private,reduction,combined-constructs,loop,V:2.6-2.7\n      LOGICAL FUNCTION test1()\n  IMPLICIT NONE\n  INCLUDE \"acc_testsuite.Fh\"\n  INTEGER:: errors\n  REAL(8),DIMENSION(LOOPCOUNT, 10):: a, b, c, d\n  REAL(8):: avg, temp\n  INTEGER:: x, y\n  avg = 0\n  errors = 0\n\n  SEEDDIM(1) = 1\n# ifdef SEED\n  SEEDDIM(1) = SEED\n# endif\n  CALL RANDOM_SEED(PUT=SEEDDIM)\n\n  CALL RANDOM_NUMBER(a)\n  CALL RANDOM_NUMBER(b)\n\n  !$acc data copyin(a(1:LOOPCOUNT, 1:10), b(1:LOOPCOUNT, 1:10)) create(c(1:LOOPCOUNT, 1:10)) copyout(d(1:LOOPCOUNT, 1:10))\n    !$acc serial loop gang private(avg)\n    DO y = 1, 10\n      avg = 0\n      !$acc loop worker reduction(+:avg)\n      DO x = 1, LOOPCOUNT\n        c(x, y) = a(x, y) + b(x, y)\n        avg = avg + c(x, y)\n      END DO\n      avg = avg / LOOPCOUNT\n      !$acc loop worker\n      DO x = 1, LOOPCOUNT\n        d(x, y) = c(x, y) - avg\n      END DO\n    END DO\n  !$acc end data\n\n  DO y = 1, 10\n    temp = 0\n    DO x = 1, LOOPCOUNT\n      temp = temp + (a(x, y) + b(x, y))\n    END DO\n    temp = temp / LOOPCOUNT\n    DO x = 1, LOOPCOUNT\n      IF (abs(d(x, y) - ((a(x, y) + b(x, y)) - temp)) .gt. PRECISION) THEN\n        errors = errors + 1\n      END IF\n    END DO\n  END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "serial",
                            "private",
                            "reduction",
                            "combined-constructs",
                            "loop"
                        ],
                        "versions": [
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "serial_loop_reduction_add_loop.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:serial,loop,reduction,combined-constructs,V:2.6-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(10 * n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(10 * n * sizeof(real_t));\n    real_t * c = (real_t *)malloc(10 * n * sizeof(real_t));\n    real_t * d = (real_t *)malloc(10 * n * sizeof(real_t));\n    real_t avg = 0.0;\n    real_t rolling_total = 0;\n\n    for (int x = 0; x < 10 * n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n    }\n\n    #pragma acc data copyin(a[0:10*n], b[0:10*n]) create(c[0:10*n]) copyout(d[0:10*n])\n    {\n        #pragma acc serial loop gang private(avg)\n        for (int x = 0; x < 10; ++x){\n            avg = 0;\n            #pragma acc loop worker reduction(+:avg)\n            for (int y = 0; y < n; ++y){\n                avg += c[x * n + y] = a[x * n + y] + b[x * n + y];\n            }\n            avg = avg / n;\n            #pragma acc loop worker\n            for (int y = 0; y < n; ++y){\n                d[x * n + y] = c[x * n + y] - avg;\n            }\n        }\n    }\n\n\n    for (int x = 0; x < 10; ++x){\n        rolling_total = 0;\n        for (int y = 0; y < n; ++y){\n            rolling_total += a[x * n + y] + b[x * n + y];\n        }\n        rolling_total = rolling_total / n;\n        for (int y = 0; y < n; ++y){\n            if (fabs(d[x * n + y] - ((a[x * n + y] + b[x * n + y]) - rolling_total)) > PRECISION){\n                err += 1;\n            }\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "serial",
                            "loop",
                            "reduction",
                            "combined-constructs"
                        ],
                        "versions": [
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "serial_loop_reduction_add_vector_loop.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:serial,private,reduction,combined-constructs,loop,V:2.6-2.7\n      LOGICAL FUNCTION test1()\n  IMPLICIT NONE\n  INCLUDE \"acc_testsuite.Fh\"\n  INTEGER:: errors\n  REAL(8),DIMENSION(LOOPCOUNT, 10):: a, b\n  REAL(8),DIMENSION(10):: c\n  REAL(8):: temp\n  INTEGER:: x, y\n\n  errors = 0\n\n  SEEDDIM(1) = 1\n# ifdef SEED\n  SEEDDIM(1) = SEED\n# endif\n  CALL RANDOM_SEED(PUT=SEEDDIM)\n\n  CALL RANDOM_NUMBER(a)\n  CALL RANDOM_NUMBER(b)\n\n  !$acc data copyin(a(1:LOOPCOUNT,1:10), b(1:LOOPCOUNT,1:10)) copyout(c(1:10))\n    !$acc serial loop private(temp)\n    DO y = 1, 10\n      temp = 0\n      !$acc loop vector reduction(+:temp)\n      DO x = 1, LOOPCOUNT\n        temp = temp + (a(x, y) + b(x, y))\n      END DO\n      c(y) = temp\n    END DO\n  !$acc end data\n\n  DO y = 1, 10\n    DO x = 1, LOOPCOUNT\n      c(y) = c(y) - (a(x, y) + b(x, y))\n    END DO\n    IF (abs(c(y)) .gt. PRECISION) THEN\n      errors = errors + 1\n    END IF\n  END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "serial",
                            "private",
                            "reduction",
                            "combined-constructs",
                            "loop"
                        ],
                        "versions": [
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "serial_loop_reduction_add_vector_loop.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:serial,loop,reduction,combined-constructs,V:2.6-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(10 * n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(10 * n * sizeof(real_t));\n    real_t * c = (real_t *)malloc(10 * sizeof(real_t));\n    real_t temp = 0.0;\n\n    for(int x = 0; x < 10 * n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n    }\n    #pragma acc data copyin(a[0:10*n], b[0:10*n]) copyout(c[0:10])\n    {\n        #pragma acc serial loop private(temp)\n        for (int x = 0; x < 10; ++x){\n            temp = 0.0;\n            #pragma acc loop vector reduction(+:temp)\n            for (int y = 0; y < n; ++y){\n                temp += a[(x * n) + y] + b[(x * n) + y];\n            }\n            c[x] = temp;\n        }\n    }\n    for (int x = 0; x < 10; ++x){\n        for (int y = 0; y < n; ++y){\n            c[x] -= a[(x * n) + y] + b[(x * n) + y];\n        }\n        if (fabs(c[x]) > PRECISION * (2 * n - 1)){\n            err = 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "serial",
                            "loop",
                            "reduction",
                            "combined-constructs"
                        ],
                        "versions": [
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "serial_loop_reduction_and_general.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:serial,reduction,combined-constructs,loop,V:2.6-2.7\n      LOGICAL FUNCTION test1()\n  IMPLICIT NONE\n  INCLUDE \"acc_testsuite.Fh\"\n  INTEGER:: errors\n  INTEGER:: x\n  LOGICAL,DIMENSION(LOOPCOUNT):: a\n  LOGICAL:: result, host_result\n  REAL(8),DIMENSION(LOOPCOUNT):: randoms\n  REAL(8):: false_margin = EXP(LOG(.5) / LOOPCOUNT)\n\n  errors = 0\n  SEEDDIM(1) = 1\n# ifdef SEED\n  SEEDDIM(1) = SEED\n# endif\n  CALL RANDOM_SEED(PUT=SEEDDIM)\n\n  CALL RANDOM_NUMBER(randoms)\n\n  DO x = 1, LOOPCOUNT\n    IF (randoms(x) .lt. false_margin) THEN\n      a(x) = .TRUE.\n    ELSE\n      a(x) = .FALSE.\n    END IF\n  END DO\n\n  result = .TRUE.\n  !$acc data copyin(a(1:LOOPCOUNT))\n    !$acc serial loop reduction(.AND.:result)\n    DO x = 1, LOOPCOUNT\n      result = result .AND. a(x)\n    END DO\n  !$acc end data\n\n  host_result = .TRUE.\n  DO x = 1, LOOPCOUNT\n    host_result = host_result .AND. a(x)\n  END DO\n\n  IF (host_result .NEQV. result) THEN\n    errors = errors + 1\n  END IF\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "serial",
                            "reduction",
                            "combined-constructs",
                            "loop"
                        ],
                        "versions": [
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "serial_loop_reduction_and_general.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:serial,loop,reduction,combined-constructs,V:2.6-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    char * a = (char *)malloc(n * sizeof(char));\n    real_t false_margin = pow(exp(1), log(.5)/n);\n    char result = 1;\n    char found = 0;\n\n    for (int x = 0; x < n; ++x){\n        if(rand() / (real_t)(RAND_MAX) < false_margin){\n            a[x] = 1;\n        }\n        else{\n            a[x] = 0;\n        }\n    }\n\n    #pragma acc data copyin(a[0:n])\n    {\n        #pragma acc serial loop reduction(&&:result)\n        for (int x = 0; x < n; ++x){\n            result = result && a[x];\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        if (a[x] == 0){\n            found = 1;\n            break;\n        }\n    }\n    if (found == result){\n        err = 1;\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "serial",
                            "loop",
                            "reduction",
                            "combined-constructs"
                        ],
                        "versions": [
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "serial_loop_reduction_and_loop.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:serial,private,reduction,combined-constructs,loop,V:2.6-2.7\n      LOGICAL FUNCTION test1()\n  IMPLICIT NONE\n  INCLUDE \"acc_testsuite.Fh\"\n  INTEGER:: errors\n  REAL(8):: false_margin\n  REAL(8),DIMENSION(LOOPCOUNT, 10):: randoms\n  LOGICAL,DIMENSION(LOOPCOUNT, 10):: a, a_copy\n  LOGICAL,DIMENSIOn(10):: has_false\n  LOGICAL:: temp\n  INTEGER:: x, y\n  errors = 0\n  false_margin = EXP(LOG(.5) / LOOPCOUNT)\n\n  SEEDDIM(1) = 1\n# ifdef SEED\n  SEEDDIM(1) = SEED\n# endif\n  CALL RANDOM_SEED(PUT=SEEDDIM)\n\n  CALL RANDOM_NUMBER(randoms)\n\n  has_false = .FALSE.\n  a = .TRUE.\n  DO y = 1, 10\n    DO x = 1, LOOPCOUNT\n      IF (randoms(x, y) .gt. false_margin) THEN\n        a(x, y) = .FALSE.\n        has_false(y) = .TRUE.\n      END IF\n    END DO\n  END DO\n  a_copy = a\n\n  !$acc data copy(a(1:LOOPCOUNT, 1:10))\n    !$acc serial loop gang private(temp)\n    DO y = 1, 10\n      temp = .TRUE.\n      !$acc loop worker reduction(.AND.:temp)\n      DO x = 1, LOOPCOUNT\n        temp = temp .AND. a(x, y)\n      END DO\n      !$acc loop worker\n      DO x = 1, LOOPCOUNT\n        IF (temp) THEN\n          IF (a(x, y) .eq. 1) THEN\n            a(x, y) = .FALSE.\n          ELSE\n            a(x, y) = .TRUE.\n          END IF\n        END IF\n      END DO\n    END DO\n  !$acc end data\n\n  DO y = 1, 10\n    DO x = 1, LOOPCOUNT\n      IF ((has_false(y) .eqv. .TRUE.) .AND. (a(x, y) .neqv. a_copy(x, y))) THEN\n        errors = errors + 1\n      ELSEIF ((has_false(y) .eqv. .FALSE.) .AND. (a(x, y) .eqv. a_copy(x, y))) THEN\n        errors = errors + 1\n      END IF\n    END DO\n  END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "serial",
                            "private",
                            "reduction",
                            "combined-constructs",
                            "loop"
                        ],
                        "versions": [
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "serial_loop_reduction_and_loop.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:serial,loop,reduction,combined-constructs,V:2.6-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    char * a = (char *)malloc(10 * n * sizeof(char));\n    char * a_copy = (char *)malloc(10 * n * sizeof(char));\n    char * has_false = (char *)malloc(10 * sizeof(char));\n    real_t false_margin = pow(exp(1), log(.5)/n);\n    char temp = 1;\n\n    for (int x = 0; x < 10; ++x){\n        has_false[x] = 0;\n    }\n\n    for (int x = 0; x < 10; ++x){\n        for (int y = 0; y < n; ++y){\n            if (rand() / (real_t)(RAND_MAX) < false_margin){\n                a[x * n + y] = 1;\n                a_copy[x * n + y] = 1;\n            }\n            else {\n                a[x * n + y] = 0;\n                a_copy[x * n + y] = 0;\n                has_false[x] = 1;\n            }\n        }\n    }\n\n    #pragma acc data copy(a[0:10*n])\n    {\n        #pragma acc serial loop gang private(temp)\n        for (int x = 0; x < 10; ++x){\n            temp = 1;\n            #pragma acc loop worker reduction(&&:temp)\n            for (int y = 0; y < n; ++y){\n                temp = temp && a[x * n + y];\n            }\n            #pragma acc loop worker\n            for (int y = 0; y < n; ++y){\n                if(temp == 1){\n                    if  (a[x * n + y] == 1){\n                        a[x * n + y] = 0;\n                    }\n                    else {\n                        a[x * n + y] = 1;\n                    }\n                }\n            }\n        }\n    }\n\n\n    for (int x = 0; x < 10; ++x){\n        for (int y = 0; y < n; ++y){\n            if (has_false[x] == 1 && a[x * n + y] != a_copy[x * n + y]){\n                err = 1;\n            }\n            else if (has_false[x] == 0 && a[x * n + y] == a_copy[x * n + y]){\n                err = 1;\n            }\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "serial",
                            "loop",
                            "reduction",
                            "combined-constructs"
                        ],
                        "versions": [
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "serial_loop_reduction_and_vector_loop.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:serial,private,reduction,combined-constructs,loop,V:2.6-2.7\n      LOGICAL FUNCTION test1()\n  IMPLICIT NONE\n  INCLUDE \"acc_testsuite.Fh\"\n  LOGICAL,DIMENSION(LOOPCOUNT, 10):: a\n  LOGICAL,DIMENSION(10):: b, has_false\n  LOGICAL:: temp\n  REAL(8),DIMENSION(LOOPCOUNT, 10):: randoms\n  REAL(8):: false_margin\n  INTEGER:: errors, x, y\n\n  errors = 0\n  false_margin = exp(log(.5) / LOOPCOUNT)\n\n  SEEDDIM(1) = 1\n# ifdef SEED\n  SEEDDIM(1) = SEED\n# endif\n  CALL RANDOM_SEED(PUT=SEEDDIM)\n\n  CALL RANDOM_NUMBER(randoms)\n\n  has_false = .FALSE.\n  DO y = 1, 10\n    DO x = 1, LOOPCOUNT\n      IF (randoms(x, y) .lt. false_margin) THEN\n        a(x, y) = .TRUE.\n      ELSE\n        a(x, y) = .FALSE.\n        has_false(y) = .TRUE.\n      END IF\n    END DO\n  END DO\n\n  !$acc data copyin(a(1:LOOPCOUNT, 1:10)) copy(b(1:10))\n    !$acc serial loop private(temp)\n    DO y = 1, 10\n      temp = .TRUE.\n      !$acc loop vector reduction(.AND.:temp)\n      DO x = 1, LOOPCOUNT\n        temp = temp .AND. a(x, y)\n      END DO\n      b(y) = temp\n    END DO\n  !$acc end data\n\n  DO x = 1, 10\n    IF (has_false(x) .eqv. b(x)) THEN\n      errors = errors + 1\n    END IF\n  END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "serial",
                            "private",
                            "reduction",
                            "combined-constructs",
                            "loop"
                        ],
                        "versions": [
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "serial_loop_reduction_and_vector_loop.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:serial,loop,reduction,combined-constructs,V:2.6-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    char * a = (char *)malloc(10 * n * sizeof(char));\n    char * b = (char *)malloc(10 * sizeof(char));\n    char * has_false = (char *)malloc(10 * sizeof(char));\n    char temp = 1;\n    real_t false_margin = pow(exp(1), log(.5)/n);\n\n    for (int x = 0; x < 10; ++x){\n        has_false[x] = 0;\n    }\n    for (int x = 0; x < 10 * n; ++x){\n        if(rand() / (real_t)(RAND_MAX) < false_margin){\n            a[x] = 1;\n        }\n        else{\n            a[x] = 0;\n            has_false[x/n] = 1;\n        }\n    }\n    #pragma acc data copyin(a[0:10*n]) copy(b[0:10])\n    {\n        #pragma acc serial loop private(temp)\n        for (int x = 0; x < 10; ++x){\n            temp = 1;\n            #pragma acc loop vector reduction(&&:temp)\n            for (int y = 0; y < n; ++y){\n                temp = temp && a[x * n + y];\n            }\n            b[x] = temp;\n        }\n    }\n    for (int x = 0; x < 10; ++x){\n        if (has_false[x] == b[x]){\n            err = 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "serial",
                            "loop",
                            "reduction",
                            "combined-constructs"
                        ],
                        "versions": [
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "serial_loop_reduction_bitand_general.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:serial,reduction,combined-constructs,loop,V:2.6-2.7\n      LOGICAL FUNCTION test1()\n  IMPLICIT NONE\n  INCLUDE \"acc_testsuite.Fh\"\n  INTEGER,DIMENSION(N):: a\n  INTEGER:: b, host_b\n  REAL(8):: false_margin\n  REAL(8),DIMENSION(LOOPCOUNT, 16):: randoms\n  INTEGER:: x, y\n  INTEGER:: errors\n\n  errors = 0\n  false_margin = exp(log(.5)/LOOPCOUNT)\n\n  SEEDDIM(1) = 1\n# ifdef SEED\n  SEEDDIM(1) = SEED\n# endif\n  CALL RANDOM_SEED(PUT=SEEDDIM)\n\n  CALL RANDOM_NUMBER(randoms)\n\n  DO x = 1, LOOPCOUNT\n    DO y = 1, 16\n      IF (randoms(x, y) .lt. false_margin) THEN\n        a(x) = a(x) + 2**(y - 1)\n      END IF\n    END DO\n  END DO\n\n  b = a(1)\n  host_b = a(1)\n  DO x = 2, LOOPCOUNT\n    host_b = iand(host_b, a(x))\n  END DO\n\n  !$acc data copyin(a(1:LOOPCOUNT))\n    !$acc serial loop reduction(iand: b)\n    DO x = 1, LOOPCOUNT\n      b = iand(b, a(x))\n    END DO\n  !$acc end data\n\n  IF (b .ne. host_b) THEN\n    errors = errors + 1\n  END IF\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "serial",
                            "reduction",
                            "combined-constructs",
                            "loop"
                        ],
                        "versions": [
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "serial_loop_reduction_bitand_general.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:serial,loop,reduction,combined-constructs,V:2.6-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    n = 10;\n    unsigned int * a = (unsigned int *)malloc(n * sizeof(unsigned int));\n    real_t false_margin = pow(exp(1), log(.5)/n);\n    unsigned int temp = 1;\n    unsigned int b = 0;\n    unsigned int host_b;\n\n    for (int x = 0; x < n; ++x){\n        for (int y = 0; y < 16; ++y){\n            if (rand() / (real_t) RAND_MAX < false_margin){\n                for (int z = 0; z < y; ++z){\n                    temp *= 2;\n                }\n                a[x] += temp;\n                temp = 1;\n            }\n        }\n    }\n    for (int x = 0; x < 16; ++x){\n        temp = 1;\n        for (int y = 0; y < x; ++y){\n            temp *= 2;\n        }\n        b += temp;\n    }\n    #pragma acc data copyin(a[0:n])\n    {\n        #pragma acc serial loop reduction(&:b)\n        for (int x = 0; x < n; ++x){\n            b = b & a[x];\n        }\n    }\n\n    host_b = a[0];\n    for (int x = 1; x < n; ++x){\n        host_b = host_b & a[x];\n    }\n    if (b != host_b){\n        err = 1;\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "serial",
                            "loop",
                            "reduction",
                            "combined-constructs"
                        ],
                        "versions": [
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "serial_loop_reduction_bitand_loop.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:serial,private,reduction,combined-constructs,loop,V:2.6-2.7\n      LOGICAL FUNCTION test1()\n  IMPLICIT NONE\n  INCLUDE \"acc_testsuite.Fh\"\n  INTEGER,DIMENSION(LOOPCOUNT, 10):: a, b, b_copy\n  INTEGER,DIMENSION(10):: c, host_c\n  INTEGER:: errors, x, y, z, temp\n  REAL(8):: false_margin\n  REAL(8),DIMENSION(LOOPCOUNT, 10, 17):: randoms\n\n  errors = 0\n  false_margin = exp(log(.5) / LOOPCOUNT)\n\n  SEEDDIM(1) = 1\n# ifdef SEED\n  SEEDDIM(1) = SEED\n# endif\n  CALL RANDOM_SEED(PUT=SEEDDIM)\n\n  CALL RANDOM_NUMBER(randoms)\n\n  DO y = 1, 10\n    DO x = 1, LOOPCOUNT\n      b(x) = INT(10 * randoms(x, y, 17))\n      DO z = 1, 16\n        IF (randoms(x, y, z) .lt. false_margin) THEN\n          a(x) = a(x) + 2**(z - 1)\n        END IF\n      END DO\n    END DO\n  END DO\n\n  b_copy = b\n\n  DO y = 1, 10\n    temp = a(1, y)\n    DO x = 1, LOOPCOUNT\n      temp = iand(temp, a(x, y))\n    END DO\n    host_c(y) = temp\n  END DO\n\n  !$acc data copyin(a(1:LOOPCOUNT, 1:10)) copy(b(1:LOOPCOUNT, 1:10), c(1:10))\n    !$acc serial loop gang private(temp)\n    DO y = 1, 10\n      temp = a(1, y)\n      !$acc loop worker reduction(iand:temp)\n      DO x = 1, LOOPCOUNT\n        temp = iand(temp, a(x, y))\n      END DO\n      c(y) = temp\n      !$acc loop worker\n      DO x = 1, LOOPCOUNT\n        b(x, y) = b(x, y) + c(y)\n      END DO\n    END DO\n  !$acc end data\n\n  DO y = 1, 10\n    IF (host_c(y) .ne. c(y)) THEN\n      errors = errors + 1\n    END IF\n    DO x = 1, LOOPCOUNT\n      IF (b(x, y) .ne. b_copy(x, y) + c(y)) THEN\n        errors = errors + 1\n      END IF\n    END DO\n  END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "serial",
                            "private",
                            "reduction",
                            "combined-constructs",
                            "loop"
                        ],
                        "versions": [
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "serial_loop_reduction_bitand_loop.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:serial,loop,reduction,combined-constructs,V:2.6-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    unsigned int * a = (unsigned int *)malloc(10 * n * sizeof(unsigned int));\n    unsigned int * b = (unsigned int *)malloc(10 * n * sizeof(unsigned int));\n    unsigned int * b_copy = (unsigned int *)malloc(10 * n * sizeof(unsigned int));\n    unsigned int * c = (unsigned int *)malloc(10 * sizeof(unsigned int));\n    unsigned int* host_c = (unsigned int *)malloc(10 * sizeof(unsigned int));\n\n    real_t false_margin = pow(exp(1), log(.5)/n);\n    unsigned int temp = 1;\n\n    for (int x = 0; x < 10 * n; ++x){\n        b[x] = (unsigned int) rand() / (real_t)(RAND_MAX / 1000);\n        b_copy[x] = b[x];\n        for (int y = 0; y < 16; ++y){\n            if (rand() / (real_t) RAND_MAX < false_margin){\n                for (int z = 0; z < y; ++z){\n                    temp *= 2;\n                }\n                a[x] += temp;\n                temp = 1;\n            }\n        }\n    }\n    #pragma acc data copyin(a[0:10 * n]) copy(b[0:10 * n], c[0:10])\n    {\n        #pragma acc serial loop gang private(temp)\n        for (int y = 0; y < 10; ++y){\n            temp = a[y * n];\n            #pragma acc loop worker reduction(&:temp)\n            for (int x = 1; x < n; ++x){\n                temp = temp & a[y * n + x];\n            }\n            c[y] = temp;\n            #pragma acc loop worker\n            for (int x = 0; x < n; ++x){\n                b[y * n + x] = b[y * n + x] + c[y];\n            }\n        }\n    }\n    for (int x = 0; x < 10; ++x){\n        host_c[x] = a[x * n];\n        for (int y = 1; y < n; ++y){\n            host_c[x] = host_c[x] & a[x * n + y];\n        }\n        if (host_c[x] != c[x]){\n          err += 1;\n        }\n    }\n\n    for (int x = 0; x < 10; ++x){\n        for (int y = 0; y < n; ++y){\n            if (b[x * n + y] != b_copy[x * n + y] + c[x]){\n                err += 1;\n            }\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "serial",
                            "loop",
                            "reduction",
                            "combined-constructs"
                        ],
                        "versions": [
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "serial_loop_reduction_bitand_vector_loop.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:serial,private,reduction,combined-constructs,loop,V:2.6-2.7\n      LOGICAL FUNCTION test1()\n  IMPLICIT NONE\n  INCLUDE \"acc_testsuite.Fh\"\n  INTEGER,DIMENSION(LOOPCOUNT, 10):: a\n  INTEGER,DIMENSION(10):: b, b_host\n  REAL(8),DIMENSION(LOOPCOUNT, 10, 16):: randoms\n  REAL(8):: false_margin\n  INTEGER:: x, y, temp, c\n  INTEGER:: errors\n\n  errors = 0\n  false_margin = exp(log(.5) / LOOPCOUNT)\n  SEEDDIM(1) = 1\n# ifdef SEED\n  SEEDDIM(1) = SEED\n# endif\n  CALL RANDOM_SEED(PUT=SEEDDIM)\n\n  CALL RANDOM_NUMBER(randoms)\n\n  DO y = 1, 10\n    DO x = 1, LOOPCOUNT\n      DO z = 1, 16\n        IF (randoms(x, y, z) .lt. false_margin) THEN\n          a(x, y) = a(x, y) + 2**(z - 1)\n        END IF\n      END DO\n    END DO\n  END DO\n\n  DO y = 1, 10\n    b_host(y) = a(1, y)\n    DO x = 1, LOOPCOUNT\n      b_host(y) = iand(b_host(y), a(x, y))\n    END DO\n  END DO\n\n  !$acc data copyin(a(1:LOOPCOUNT, 1:10)) copy(b(1:10))\n    !$acc serial loop private(c)\n    DO y = 1, 10\n      c = a(1, y)\n      !$acc loop vector reduction(iand:c)\n      DO x = 1, LOOPCOUNT\n        c = iand(c, a(x, y))\n      END DO\n      b(y) = c\n    END DO\n  !$acc end data\n\n  DO x = 1, 10\n    IF (b(x) .ne. b_host(x)) THEN\n      errors = errors + 1\n    END IF\n  END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "serial",
                            "private",
                            "reduction",
                            "combined-constructs",
                            "loop"
                        ],
                        "versions": [
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "serial_loop_reduction_bitand_vector_loop.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:serial,loop,reduction,combined-constructs,V:2.6-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    unsigned int* a = (unsigned int *)malloc(10 * n * sizeof(unsigned int));\n    unsigned int* b = (unsigned int *)malloc(10 * sizeof(unsigned int));\n    unsigned int b_host;\n    unsigned int c = 0;\n\n    real_t false_margin = pow(exp(1), log(.5)/n);\n    unsigned int temp = 1;\n\n    for (int x = 0; x < 10 * n; ++x){\n        for (int y = 0; y < 16; ++y){\n            if (rand() / (real_t) RAND_MAX < false_margin){\n                for (int z = 0; z < y; ++z){\n                    temp *= 2;\n                }\n                a[x] += temp;\n                temp = 1;\n            }\n        }\n    }\n\n    #pragma acc data copyin(a[0:10*n]) copy(b[0:10])\n    {\n        #pragma acc serial loop private(c)\n        for (int x = 0; x < 10; ++x){\n            c = a[x * n];\n            #pragma acc loop vector reduction(&:c)\n            for (int y = 1; y < n; ++y){\n                c = c & a[x * n + y];\n            }\n            b[x] = c;\n        }\n    }\n    for (int x = 0; x < 10; ++x){\n        b_host = a[x * n];\n        for (int y = 1; y < n; ++y){\n            b_host = b_host & a[x * n + y];\n        }\n        if (b_host != b[x]){\n            err = 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "serial",
                            "loop",
                            "reduction",
                            "combined-constructs"
                        ],
                        "versions": [
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "serial_loop_reduction_bitor_general.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:serial,reduction,combined-constructs,loop,V:2.6-2.7\n      LOGICAL FUNCTION test1()\n  IMPLICIT NONE\n  INCLUDE \"acc_testsuite.Fh\"\n  INTEGER:: errors, temp, x, y, b, host_b\n  INTEGER,DIMENSION(LOOPCOUNT):: a\n  REAL(8):: false_margin\n  REAL(8),DIMENSION(LOOPCOUNT, 16):: randoms\n  errors = 0\n  false_margin = exp(log(.5) / LOOPCOUNT)\n\n  SEEDDIM(1) = 1\n# ifdef SEED\n  SEEDDIM(1) = SEED\n# endif\n  CALL RANDOM_SEED(PUT=SEEDDIM)\n\n  CALL RANDOM_NUMBER(randoms)\n\n  DO x = 1, LOOPCOUNT\n    DO y = 1, 16\n      IF (randoms(x, y) .gt. false_margin) THEN\n        a(x) = a(x) + 2**(y - 1)\n      END IF\n    END DO\n  END DO\n\n  DO x = 1, LOOPCOUNT\n    host_b = ior(host_b, a(x))\n  END DO\n\n  !$acc data copyin(a(1:LOOPCOUNT))\n    !$acc serial loop reduction(ior:b)\n    DO x = 1, LOOPCOUNT\n      b = ior(b, a(x))\n    END DO\n  !$acc end data\n\n  IF (b .ne. host_b) THEN\n    errors = errors + 1\n  END IF\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "serial",
                            "reduction",
                            "combined-constructs",
                            "loop"
                        ],
                        "versions": [
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "serial_loop_reduction_bitor_general.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:serial,loop,reduction,combined-constructs,V:2.6-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    unsigned int * a = (unsigned int *)malloc(n * sizeof(unsigned int));\n    unsigned int b = 0;\n    unsigned int host_b;\n    real_t false_margin = pow(exp(1), log(.5)/n);\n    unsigned int temp = 1;\n\n    for (int x = 0; x < n; ++x){\n        for (int y = 0; y < 16; ++y){\n            if (rand() / (real_t) RAND_MAX > false_margin){\n                for (int z = 0; z < y; ++z){\n                    temp *= 2;\n                }\n                a[x] += temp;\n                temp = 1;\n            }\n        }\n    }\n\n    #pragma acc data copyin(a[0:n])\n    {\n        #pragma acc serial loop reduction(|:b)\n        for (int x = 0; x < n; ++x){\n            b = b | a[x];\n        }\n    }\n\n    host_b = a[0];\n    for (int x = 1; x < n; ++x){\n        host_b = host_b | a[x];\n    }\n    if (b != host_b){\n        err = 1;\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "serial",
                            "loop",
                            "reduction",
                            "combined-constructs"
                        ],
                        "versions": [
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "serial_loop_reduction_bitor_loop.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:serial,private,reduction,combined-constructs,loop,V:2.6-2.7\n      LOGICAL FUNCTION test1()\n  IMPLICIT NONE\n  INCLUDE \"acc_testsuite.Fh\"\n  INTEGER:: errors, x, y, z, temp\n  INTEGER,DIMENSION(LOOPCOUNT, 10):: a, b, b_copy\n  INTEGER,DIMENSION(10):: c\n  REAL(8):: false_margin\n  REAL(8),DIMENSION(LOOPCOUNT, 10, 17):: randoms\n\n  errors = 0\n  false_margin = exp(log(.5) / LOOPCOUNT)\n\n  SEEDDIM(1) = 1\n# ifdef SEED\n  SEEDDIM(1) = SEED\n# endif\n  CALL RANDOM_SEED(PUT=SEEDDIM)\n\n  CALL RANDOM_NUMBER(randoms)\n\n  DO x = 1, LOOPCOUNT\n    DO y = 1, 10\n      b(x, y) = INT(randoms(x, y, 17) * 1000)\n      DO z = 1, 16\n        IF (randoms(x, y, z) .gt. false_margin) THEN\n          a(x, y) = a(x, y) + 2**(z-1)\n        END IF\n      END DO\n    END DO\n  END DO\n\n  b_copy = b\n\n  !$acc data copyin(a(1:LOOPCOUNT, 1:10)) copy(b(1:LOOPCOUNT, 1:10), c(1:10))\n    !$acc serial loop gang private(temp)\n    DO y = 1, 10\n      temp = 0\n      !$acc loop worker reduction(ior:temp)\n      DO x = 1, LOOPCOUNT\n        temp = ior(temp, a(x, y))\n      END DO\n      c(y) = temp\n      !$acc loop worker\n      DO x = 1, LOOPCOUNT\n        b(x, y) = b(x, y) + c(y)\n      END DO\n    END DO\n  !$acc end data\n\n  DO y = 1, 10\n    temp = a(1, y)\n    DO x = 2, LOOPCOUNT\n      temp = ior(temp, a(x, y))\n    END DO\n    IF (temp .ne. c(y)) THEN\n      errors = errors + 1\n    END IF\n    DO x = 1, LOOPCOUNT\n      IF (b(x, y) .ne. (b_copy(x, y) + temp)) THEN\n        errors = errors + 1\n      END IF\n    END DO\n  END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "serial",
                            "private",
                            "reduction",
                            "combined-constructs",
                            "loop"
                        ],
                        "versions": [
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "serial_loop_reduction_bitor_loop.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:serial,loop,reduction,combined-constructs,V:2.6-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    unsigned int * a = (unsigned int *)malloc(10 * n * sizeof(unsigned int));\n    unsigned int * b = (unsigned int *)malloc(10 * n * sizeof(unsigned int));\n    unsigned int * b_copy = (unsigned int *)malloc(10 * n * sizeof(unsigned int));\n    unsigned int * c = (unsigned int *)malloc(10 * sizeof(unsigned int));\n    unsigned int host_c;\n\n    real_t false_margin = pow(exp(1), log(.5)/n);\n    unsigned int temp = 1;\n\n    for (int x = 0; x < 10; ++x){\n        for (int y = 0; y < n; ++y){\n            b[x * n + y] = (unsigned int) rand() / (real_t)(RAND_MAX / 1000);\n            b_copy[x * n + y] = b[x * n + y];\n            for (int z = 0; z < 16; ++z){\n                if (rand() / (real_t) RAND_MAX > false_margin){\n                    temp = 1;\n                    for (int i = 0; i < z; ++i){\n                        temp = temp * 2;\n                    }\n                    a[x * n + y] += temp;\n                }\n            }\n        }\n    }\n\n    #pragma acc data copyin(a[0:10*n]) copy(b[0:10*n], c[0:10])\n    {\n        #pragma acc serial loop gang private(temp)\n        for (int x = 0; x < 10; ++x){\n            temp = 0;\n            #pragma acc loop worker reduction(|:temp)\n            for (int y = 0; y < n; ++y){\n                temp = temp | a[x * n + y];\n            }\n            c[x] = temp;\n            #pragma acc loop worker\n            for (int y = 0; y < n; ++y){\n                b[x * n + y] = b[x * n + y] + c[x];\n            }\n        }\n    }\n    for (int x = 0; x < 10; ++x){\n        host_c = a[x * n];\n        for (int y = 1; y < n; ++y){\n            host_c = host_c | a[x * n + y];\n        }\n        if (host_c != c[x]){\n            err += 1;\n        }\n        for (int y = 0; y < n; ++y){\n            if (b[x * n + y] != b_copy[x * n + y] + host_c){\n                err += 1;\n            }\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "serial",
                            "loop",
                            "reduction",
                            "combined-constructs"
                        ],
                        "versions": [
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "serial_loop_reduction_bitor_vector_loop.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:serial,private,reduction,combined-constructs,loop,V:2.6-2.7\n      LOGICAL FUNCTION test1()\n  IMPLICIT NONE\n  INCLUDE \"acc_testsuite.Fh\"\n  INTEGER:: errors, x, y, z, temp\n  INTEGER,DIMENSION(LOOPCOUNT, 10):: a\n  INTEGER,DIMENSION(10):: b\n  REAL(8):: false_margin\n  REAL(8),DIMENSION(LOOPCOUNT, 10, 16):: randoms\n\n  errors = 0\n  false_margin = exp(log(.5) / LOOPCOUNT)\n  SEEDDIM(1) = 1\n# ifdef SEED\n  SEEDDIM(1) = SEED\n# endif\n  CALL RANDOM_SEED(PUT=SEEDDIM)\n\n  CALL RANDOM_NUMBERs(randoms)\n\n  DO x = 1, LOOPCOUNT\n    DO y = 1, 10\n      DO z = 1, 16\n        IF (randoms(x, y, z) .gt. false_margin) THEN\n          a(x, y) = a(x, y) + 2**(z - 1)\n        END IF\n      END DO\n    END DO\n  END DO\n\n  !$acc data copyin(a(1:LOOPCOUNT,1:10)) copy(b(1:10))\n    !$acc serial loop private(temp)\n    DO y = 1, 10\n      temp = 0\n      !$acc loop vector reduction(ior:temp)\n      DO x = 1, LOOPCOUNT\n        temp = ior(temp, a(x, y))\n      END DO\n      b(y) = temp\n    END DO\n  !$acc end data\n\n  DO y = 1, 10\n    temp = a(1, y)\n    DO x = 2, LOOPCOUNT\n      temp = ior(temp, a(x, y))\n    END DO\n    IF (temp .ne. b(y)) THEN\n      errors = errors + 1\n    END IF\n  END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "serial",
                            "private",
                            "reduction",
                            "combined-constructs",
                            "loop"
                        ],
                        "versions": [
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "serial_loop_reduction_bitor_vector_loop.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:serial,loop,reduction,combined-constructs,V:2.6-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    unsigned int* a = (unsigned int *)malloc(10 * n * sizeof(unsigned int));\n    unsigned int* b = (unsigned int *)malloc(10 * sizeof(unsigned int));\n    unsigned int b_host;\n\n    real_t false_margin = pow(exp(1), log(.5)/n);\n    unsigned int temp = 1;\n\n    for (int x = 0; x < 10 * n; ++x){\n        for (int y = 0; y < 16; ++y){\n            if (rand() / (real_t) RAND_MAX > false_margin){\n                for (int z = 0; z < y; ++z){\n                    temp *= 2;\n                }\n                a[x] += temp;\n                temp = 1;\n            }\n        }\n    }\n    temp = 0;\n    #pragma acc data copyin(a[0:10*n]) copy(b[0:10])\n    {\n        #pragma acc serial loop private(temp)\n        for (int x = 0; x < 10; ++x){\n            temp = 0;\n            #pragma acc loop vector reduction(|:temp)\n            for (int y = 0; y < n; ++y){\n                temp = temp | a[x * n + y];\n            }\n            b[x] = temp;\n        }\n    }\n\n    for (int x = 0; x < 10; ++x){\n        b_host = a[x * n];\n        for (int y = 1; y < n; ++y){\n            b_host = b_host | a[x * n + y];\n        }\n        if (b_host != b[x]){\n            err = 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "serial",
                            "loop",
                            "reduction",
                            "combined-constructs"
                        ],
                        "versions": [
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "serial_loop_reduction_bitxor_general.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:serial,reduction,combined-constructs,loop,V:2.6-2.7\n      LOGICAL FUNCTION test1()\n  IMPLICIT NONE\n  INCLUDE \"acc_testsuite.Fh\"\n  INTEGER,DIMENSION(LOOPCOUNT):: a\n  REAL(8),DIMENSION(LOOPCOUNT):: randoms\n  INTEGER:: errors, b, host_b, x\n\n  errors = 0\n  SEEDDIM(1) = 1\n# ifdef SEED\n  SEEDDIM(1) = SEED\n# endif\n  CALL RANDOM_SEED(PUT=SEEDDIM)\n\n  CALL RANDOM_NUMBER(randoms)\n\n  DO x = 1, LOOPCOUNT\n    a(x) = INT(randoms(x) * 100000)\n  END DO\n\n  b = 0\n  host_b = 0\n\n  DO x = 1, LOOPCOUNT\n    host_b = ieor(host_b, a(x))\n  END DO\n\n  !$acc data copyin(a(1:LOOPCOUNT))\n    !$acc serial loop reduction(ieor:b)\n    DO x = 1, LOOPCOUNT\n      b = ieor(b, a(x))\n    END DO\n  !$acc end data\n\n  IF (b .ne. host_b) THEN\n    errors = errors + 1\n  END IF\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "serial",
                            "reduction",
                            "combined-constructs",
                            "loop"
                        ],
                        "versions": [
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "serial_loop_reduction_bitxor_general.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:serial,loop,reduction,combined-constructs,V:2.6-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    unsigned int * a = (unsigned int *)malloc(n * sizeof(unsigned int));\n    unsigned int host_b;\n    unsigned int b = 0;\n\n    for (int x = 0; x < n; ++x){\n        a[x] = (unsigned int) rand() / (real_t) (RAND_MAX / 2);\n    }\n\n    #pragma acc data copyin(a[0:n])\n    {\n        #pragma acc serial loop reduction(^:b)\n        for (int x = 0; x < n; ++x){\n            b = b ^ a[x];\n        }\n    }\n\n    host_b = a[0];\n\n    for (int x = 1; x < n; ++x){\n        host_b = host_b ^ a[x];\n    }\n    if (b != host_b){\n        err = 1;\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "serial",
                            "loop",
                            "reduction",
                            "combined-constructs"
                        ],
                        "versions": [
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "serial_loop_reduction_bitxor_loop.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:serial,private,reduction,combined-constructs,loop,V:2.6-2.7\n      LOGICAL FUNCTION test1()\n  IMPLICIT NONE\n  INCLUDE \"acc_testsuite.Fh\"\n  INTEGER,DIMENSION(LOOPCOUNT, 10):: a, b, host_b\n  INTEGER,DIMENSION(10):: c, host_c\n  REAL(8),DIMENSION(LOOPCOUNT, 10, 2):: randoms\n  INTEGER:: errors, x, y, temp\n\n  errors = 0\n  SEEDDIM(1) = 1\n# ifdef SEED\n  SEEDDIM(1) = SEED\n# endif\n  CALL RANDOM_SEED(PUT=SEEDDIM)\n\n  CALL RANDOM_NUMBER(randoms)\n\n  c = 0\n  host_c = 0\n  DO x = 1, LOOPCOUNT\n    DO y = 1, 10\n      b(x, y) = INT(randoms(x, y, 1) * 1000)\n      a(x, y) = INT(randoms(x, y, 2) * 1000)\n    END DO\n  END DO\n  host_b = b\n\n  DO y = 1, 10\n    DO x = 1, LOOPCOUNT\n      host_c(y) = ieor(host_c(y), a(x, y))\n    END DO\n    DO x = 1, LOOPCOUNT\n      host_b(x, y) = host_b(x, y) + host_c(y)\n    END DO\n  END DO\n\n  !$acc data copyin(a(1:LOOPCOUNT, 1:10)) copy(b(1:LOOPCOUNT, 1:10), c(1:10))\n    !$acc serial loop gang private(temp)\n    DO y = 1, 10\n      temp = 0\n      !$acc loop worker reduction(ieor:temp)\n      DO x = 1, LOOPCOUNT\n        temp = ieor(temp, a(x, y))\n      END DO\n      c(y) = temp\n      DO x = 1, LOOPCOUNT\n        b(x, y) = b(x, y) + c(y)\n      END DO\n    END DO\n  !$acc end data\n\n  DO y = 1, 10\n    IF (c(y) .ne. host_c(y)) THEN\n      errors = errors + 1\n    END IF\n    DO x = 1, LOOPCOUNT\n      IF (host_b(x, y) .ne. b(x, y)) THEN\n        errors = errors + 1\n      END IF\n    END DO\n  END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "serial",
                            "private",
                            "reduction",
                            "combined-constructs",
                            "loop"
                        ],
                        "versions": [
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "serial_loop_reduction_bitxor_loop.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:serial,loop,reduction,combined-constructs,V:2.6-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    unsigned int * a = (unsigned int *)malloc(10 * n * sizeof(unsigned int));\n    unsigned int * b = (unsigned int *)malloc(10 * n * sizeof(unsigned int));\n    unsigned int * b_copy = (unsigned int *)malloc(10 * n * sizeof(unsigned int));\n    unsigned int * c = (unsigned int *)malloc(10 * sizeof(unsigned int));\n    unsigned int temp = 0;\n\n    for (int x = 0; x < 10*n; ++x){\n        b[x] = (unsigned int) rand() / (real_t)(RAND_MAX / 1000);\n        b_copy[x] = b[x];\n        a[x] = (unsigned int) rand() / (real_t)(RAND_MAX / 1000);\n    }\n    for (int x = 0; x < 10; ++x){\n        c[x] = 0;\n    }\n\n    #pragma acc data copyin(a[0:10*n]) copy(b[0:10*n], c[0:10])\n    {\n        #pragma acc serial loop gang private(temp)\n        for (int x = 0; x < 10; ++x){\n            temp = 0;\n            #pragma acc loop worker reduction(^:temp)\n            for (int y = 0; y < n; ++y){\n                temp = temp ^ a[x * n + y];\n            }\n            c[x] = temp;\n            #pragma acc loop worker\n            for (int y = 0; y < n; ++y){\n                b[x * n + y] = b[x * n + y] + c[x];\n            }\n        }\n    }\n\n    for (int x = 0; x < 10; ++x){\n        temp = 0;\n        for (int y = 0; y < n; ++y){\n            temp = temp ^ a[x * n + y];\n        }\n        if (temp != c[x]){\n            err += 1;\n        }\n        for (int y = 0; y < n; ++y){\n            if (b[x * n + y] != b_copy[x * n + y] + c[x]){\n                err += 1;\n            }\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "serial",
                            "loop",
                            "reduction",
                            "combined-constructs"
                        ],
                        "versions": [
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "serial_loop_reduction_bitxor_vector_loop.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:serial,private,reduction,combined-constructs,loop,V:2.6-2.7\n      LOGICAL FUNCTION test1()\n  IMPLICIT NONE\n  INCLUDE \"acc_testsuite.Fh\"\n  INTEGER,DIMENSION(LOOPCOUNT, 10):: a\n  INTEGER,DIMENSION(10):: b, host_b\n  REAL(8),DIMENSION(LOOPCOUNT, 10):: randoms\n  INTEGER:: errors, x, y, temp\n\n  errors = 0\n  SEEDDIM(1) = 1\n# ifdef SEED\n  SEEDDIM(1) = SEED\n# endif\n  CALL RANDOM_SEED(PUT=SEEDDIM)\n\n  CALL RANDOM_NUMBER(randoms)\n\n  DO y = 1, 10\n    DO x = 1, LOOPCOUNT\n      a(x, y) = INT(randoms(x, y) * 10000)\n    END DO\n  END DO\n\n  DO y = 1, 10\n    DO x = 1, LOOPCOUNT\n      host_b(y) = ieor(host_b(y), a(x, y))\n    END DO\n  END DO\n\n  !$acc data copyin(a(1:LOOPCOUNT, 1:10))\n    !$acc serial loop private(temp)\n    DO y = 1, 10\n      temp = 0\n      !$acc loop vector reduction(ieor:temp)\n      DO x = 1, LOOPCOUNT\n        temp = ieor(temp, a(x, y))\n      END DO\n      b(y) = temp\n    END DO\n  !$acc end data\n\n  DO y = 1, 10\n    IF (b(y) .ne. host_b(y)) THEN\n      errors = errors + 1\n    END IF\n  END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "serial",
                            "private",
                            "reduction",
                            "combined-constructs",
                            "loop"
                        ],
                        "versions": [
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "serial_loop_reduction_bitxor_vector_loop.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:serial,loop,reduction,combined-constructs,V:2.6-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    unsigned int* a = (unsigned int *)malloc(10 * n * sizeof(unsigned int));\n    unsigned int* b = (unsigned int *)malloc(10 * sizeof(unsigned int));\n    unsigned int temp = 0;\n    unsigned int b_host;\n\n    for (int x = 0; x < 10 * n; ++x){\n        a[x] = (unsigned int) rand() / (real_t) (RAND_MAX / 2);\n    }\n\n    #pragma acc data copyin(a[0:10*n]) copy(b[0:10])\n    {\n        #pragma acc serial loop private(temp)\n        for (int x = 0; x < 10; ++x){\n            temp = 0;\n            #pragma acc loop vector reduction(^:temp)\n            for (int y = 0; y < n; ++y){\n                temp = temp ^ a[x * n + y];\n            }\n            b[x] = temp;\n        }\n    }\n\n    for (int x = 0; x < 10; ++x){\n        b_host = a[x * n];\n        for (int y = 1; y < n; ++y){\n            b_host = b_host ^ a[x * n + y];\n        }\n        if (b_host != b[x]){\n            err = 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "serial",
                            "loop",
                            "reduction",
                            "combined-constructs"
                        ],
                        "versions": [
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "serial_loop_reduction_max_general.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:serial,reduction,combined-constructs,loop,V:2.6-2.7\n      LOGICAL FUNCTION test1()\n  IMPLICIT NONE\n  INCLUDE \"acc_testsuite.Fh\"\n  REAL(8),DIMENSION(LOOPCOUNT):: a, b\n  REAL(8):: maxval, host_max\n  INTEGER:: errors, x\n\n  SEEDDIM(1) = 1\n# ifdef SEED\n  SEEDDIM(1) = SEED\n# endif\n  CALL RANDOM_SEED(PUT=SEEDDIM)\n\n  CALL RANDOM_NUMBER(a)\n  CALL RANDOM_NUMBER(b)\n\n  errors = 0\n\n  DO x = 1, LOOPCOUNT\n    host_max = max(host_max, a(x) * b(x))\n  END DO\n\n  !$acc data copyin(a(1:LOOPCOUNT), b(1:LOOPCOUNT))\n    !$acc serial loop reduction(max:maxval)\n    DO x = 1, LOOPCOUNT\n      maxval = max(maxval, a(x) * b(x))\n    END DO\n  !$acc end data\n\n  IF (abs(host_max - max) .gt. PRECISION) THEN\n    errors = errors + 1\n  END IF\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "serial",
                            "reduction",
                            "combined-constructs",
                            "loop"
                        ],
                        "versions": [
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "serial_loop_reduction_max_general.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:serial,loop,reduction,combined-constructs,V:2.6-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n    real_t max = 0.0;\n    int found = 0;\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX/10);\n        b[x] = rand() / (real_t)(RAND_MAX/10);\n    }\n    #pragma acc data copyin(a[0:n], b[0:n]) copy(max)\n    {\n        #pragma acc serial loop reduction(max:max)\n        for (int x = 0; x < n; ++x){\n            max = fmax(a[x] * b[x], max);\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        if (fabs(max - (a[x] * b[x] + PRECISION)) < 0){\n            err = 1;\n        }\n        if (fabs(max - (a[x] * b[x] - PRECISION)) > 0){\n            found = 1;\n        }\n    }\n    if (found = 0){\n        err = 1;\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "serial",
                            "loop",
                            "reduction",
                            "combined-constructs"
                        ],
                        "versions": [
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "serial_loop_reduction_max_loop.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:serial,private,reduction,combined-constructs,loop,V:2.6-2.7\n      LOGICAL FUNCTION test1()\n  IMPLICIT NONE\n  INCLUDE \"acc_testsuite.Fh\"\n  REAL(8),DIMENSION(LOOPCOUNT, 10):: a, b, c\n  REAL(8),DIMENSIOn(10):: host_maximums, maximums\n  REAL(8):: temp\n  INTEGER:: errors, x, y\n\n  errors = 0\n  SEEDDIM(1) = 1\n# ifdef SEED\n  SEEDDIM(1) = SEED\n# endif\n  CALL RANDOM_SEED(PUT=SEEDDIM)\n\n  CALL RANDOM_NUMBER(a)\n  CALL RANDOM_NUMBER(b)\n  c = 0\n  maximums = 0\n  host_maximums = 0\n\n  DO y = 1, 10\n    DO x = 1, LOOPCOUNT\n      host_maximums(y) = max(host_maximums(y), a(x, y) * b(x, y))\n    ENDDO\n  END DO\n\n  !$acc data copyin(a(1:LOOPCOUNT, 1:10), b(1:LOOPCOUNT, 1:10)) copy(c(1:LOOPCOUNT, 1:10), maximums(1:10))\n    !$acc serial loop gang private(temp)\n    DO y = 1, 10\n      temp = 0\n      !$acc loop worker reduction(max:temp)\n      DO x = 1, LOOPCOUNT\n        temp = max(temp, a(x, y) * b(x, y))\n      END DO\n      maximums(y) = temp\n      !$acc loop worker\n      DO x = 1, LOOPCOUNT\n        c(x, y) = (a(x, y) * b(x, y)) / maximums(y)\n      END DO\n    END DO\n  !$acc end data\n\n  DO y = 1, 10\n    IF (maximums(y) .ne. host_maximums(y)) THEN\n      errors = errors + 1\n    END IF\n    DO x = 1, LOOPCOUNT\n      IF (abs(c(x, y) - ((a(x, y) * b(x, y)) / maximums(y))) .gt. PRECISION) THEN\n        errors = errors + 1\n      END IF\n    END DO\n  END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "serial",
                            "private",
                            "reduction",
                            "combined-constructs",
                            "loop"
                        ],
                        "versions": [
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "serial_loop_reduction_max_loop.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:serial,loop,reduction,combined-constructs,V:2.6-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(10 * n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(10 * n * sizeof(real_t));\n    real_t * c = (real_t *)malloc(10 * n * sizeof(real_t));\n    real_t * maximum = (real_t *)malloc(10 * sizeof(real_t));\n    real_t temp = 0;\n    real_t max = 0.0;\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX/10);\n        b[x] = rand() / (real_t)(RAND_MAX/10);\n        c[x] = 0.0;\n    }\n    for (int x = 0; x < 10; ++x){\n        maximum[x] = 0;\n    }\n\n    #pragma acc data copyin(a[0:10*n], b[0:10*n]) copy(c[0:10*n], maximum[0:10])\n    {\n        #pragma acc serial loop gang private(temp)\n        for (int x = 0; x < 10; ++x){\n            temp = 0;\n            #pragma acc loop worker reduction(max:temp)\n            for (int y = 0; y < n; ++y){\n                temp = fmax(a[x * n + y] * b[x * n + y], temp);\n            }\n            maximum[x] = temp;\n            #pragma acc loop worker\n            for (int y = 0; y < n; ++y){\n                c[x * n + y] = (a[x * n + y] * b[x * n + y]) / maximum[x];\n            }\n        }\n    }\n    for (int x = 0; x < 10; ++x){\n        temp = 0;\n        for (int y = 0; y < n; ++y){\n            temp = fmax(temp, a[x * n + y] * b[x * n + y]);\n        }\n        if (fabs(temp - maximum[x]) > PRECISION){\n            err += 1;\n        }\n        for (int y = 0; y < n; ++y){\n            if (c[x * n + y] > 1){\n                err += 1;\n            }\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "serial",
                            "loop",
                            "reduction",
                            "combined-constructs"
                        ],
                        "versions": [
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "serial_loop_reduction_max_vector_loop.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:serial,private,reduction,combined-constructs,loop,V:2.6-2.7\n      LOGICAL FUNCTION test1()\n  IMPLICIT NONE\n  INCLUDE \"acc_testsuite.Fh\"\n  REAL(8),DIMENSION(LOOPCOUNT, 10):: a, b\n  REAL(8),DIMENSION(10):: maximums, host_maximums\n  REAL(8):: temp\n  INTEGER:: errors, x, y\n\n  errors = 0\n\n  SEEDDIM(1) = 1\n# ifdef SEED\n  SEEDDIM(1) = SEED\n# endif\n  CALL RANDOM_SEED(PUT=SEEDDIM)\n\n  CALL RANDOM_NUMBER(a)\n  CALL RANDOM_NUMBER(b)\n\n  host_maximums = 0\n  DO y = 1, 10\n    DO x = 1, LOOPCOUNT\n      host_maximums(y) = max(host_maximums(y), a(x, y) * b(x, y))\n    END DO\n  END DO\n\n  !$acc data copyin(a(1:LOOPCOUNT, 1:10), b(1:LOOPCOUNT, 1:10)) copy(maximums(1:10))\n    !$acc serial loop private(temp)\n    DO y = 1, 10\n      temp = 0\n      !$acc loop vector reduction(max:temp)\n      DO x = 1, LOOPCOUNT\n        temp = max(temp, a(x, y) * b(x, y))\n      END DO\n      maximums(y) = temp\n    END DO\n  !$acc end data\n\n  DO x = 1, 10\n    IF (abs(host_maximums(x) - maximums(x)) .gt. PRECISION) THEN\n      errors = errors + 1\n    END IF\n  END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "serial",
                            "private",
                            "reduction",
                            "combined-constructs",
                            "loop"
                        ],
                        "versions": [
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "serial_loop_reduction_max_vector_loop.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:serial,loop,reduction,combined-constructs,V:2.6-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(10 * n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(10 * n * sizeof(real_t));\n    real_t * max = (real_t *)malloc(10 * sizeof(real_t));\n    real_t temp = 0;\n    real_t temp_max;\n\n    for (int x = 0; x < 10 * n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX/10);\n        b[x] = rand() / (real_t)(RAND_MAX/10);\n    }\n    #pragma acc data copyin(a[0:10*n], b[0:10*n]) copy(max[0:10])\n    {\n        #pragma acc serial loop private(temp)\n        for (int x = 0; x < 10; ++x){\n            temp = 0;\n            #pragma acc loop vector reduction(max:temp)\n            for (int y = 0; y < n; ++y){\n                temp = fmax(a[x * n + y] * b[x * n + y], temp);\n            }\n            max[x] = temp;\n        }\n    }\n    for (int x = 0; x < 10; ++x){\n        temp_max = 0;\n        for (int y = 0; y < n; ++y){\n            if (temp_max < a[x * n + y] * b[x * n + y]){\n                temp_max = a[x * n + y] * b[x * n + y];\n            }\n        }\n        if (fabs(temp_max - max[x]) > PRECISION){\n            err = 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "serial",
                            "loop",
                            "reduction",
                            "combined-constructs"
                        ],
                        "versions": [
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "serial_loop_reduction_min_general.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:serial,reduction,combined-constructs,loop,V:2.6-2.7\n      LOGICAL FUNCTION test1()\n  IMPLICIT NONE\n  INCLUDE \"acc_testsuite.Fh\"\n  INTEGER:: errors, x\n  REAL(8),DIMENSION(LOOPCOUNT):: a, b\n  REAL(8):: minimum, host_minimum\n\n  errors = 0\n\n  SEEDDIM(1) = 1\n# ifdef SEED\n  SEEDDIM(1) = SEED\n# endif\n  CALL RANDOM_SEED(PUT=SEEDDIM)\n\n  CALL RANDOM_NUMBER(a)\n  CALL RANDOM_NUMBER(b)\n\n  minimum = a(1) * b(1)\n  host_minimum = minimum\n\n  DO x = 2, LOOPCOUNT\n    host_minimum = min(host_minimum, a(x) * b(x))\n  END DO\n\n  !$acc data copyin(a(1:LOOPCOUNT), b(1:LOOPCOUNT))\n    !$acc serial loop reduction(min:minimum)\n    DO x = 1, LOOPCOUNT\n      minimum = min(minimum, a(x) * b(x))\n    END DO\n  !$acc end data\n\n  IF (abs(host_minimum - minimum) .gt. PRECISION) THEN\n    errors = errors + 1\n  END IF\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "serial",
                            "reduction",
                            "combined-constructs",
                            "loop"
                        ],
                        "versions": [
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "serial_loop_reduction_min_general.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:serial,loop,reduction,combined-constructs,V:2.6-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n    real_t min = 1000.0;\n    int found = 0;\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX/10);\n        b[x] = rand() / (real_t)(RAND_MAX/10);\n    }\n    #pragma acc data copyin(a[0:n], b[0:n]) copy(min)\n    {\n        #pragma acc serial loop reduction(min:min)\n        for (int x = 0; x < n; ++x){\n            min = fmin(a[x] * b[x], min);\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        if (fabs((a[x] * b[x]) - (min + PRECISION)) < 0){\n            err = 1;\n        }\n        if (fabs(min - (a[x] * b[x])) < PRECISION){\n            found = 1;\n        }\n    }\n    if (found == 0){\n        err = 1;\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "serial",
                            "loop",
                            "reduction",
                            "combined-constructs"
                        ],
                        "versions": [
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "serial_loop_reduction_min_loop.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:serial,private,reduction,combined-constructs,loop,V:2.6-2.7\n      LOGICAL FUNCTION test1()\n  IMPLICIT NONE\n  INCLUDE \"acc_testsuite.Fh\"\n  REAL(8),DIMENSION(LOOPCOUNT, 10):: a, b, c\n  REAL(8),DIMENSION(10):: minimums, host_minimums\n  REAL(8):: temp\n  INTEGER:: errors, x, y\n\n  errors = 0\n\n  SEEDDIM(1) = 1\n# ifdef SEED\n  SEEDDIM(1) = SEED\n# endif\n  CALL RANDOM_SEED(PUT=SEEDDIM)\n\n  CALL RANDOM_NUMBER(a)\n  CALL RANDOM_NUMBER(b)\n  c = 0\n  mimimums = 0\n  host_minimums = 0\n\n  DO y = 1, 10\n    DO x = 1, LOOPCOUNT\n      host_minimums(y) = min(host_minimums(y), a(x, y) * b(x, y))\n    END DO\n  END DO\n\n  !$acc data copyin(a(1:LOOPCOUNT, 1:10), b(1:LOOPCOUNT, 1:10)) copy(c(1:LOOPCOUNT, 1:10), minimums(1:10))\n    !$acc serial loop gang private(temp)\n    DO y = 1, 10\n      temp = 1\n      !$acc loop reduction(min: temp)\n      DO x = 1, LOOPCOUNT\n        temp = min(temp, a(x, y) * b(x, y))\n      END DO\n      minimums(y) = temp\n      !$acc loop\n      DO x = 1, LOOPCOUNT\n        c(x, y) = (a(x, y) * b(x, y)) / minimums(y)\n      END DO\n    END DO\n  !$acc end data\n\n  DO y = 1, 10\n    IF (abs(minimums(y) - host_minimums(y)) .gt. PRECISION) THEN\n      errors = errors + 1\n    END IF\n    DO x = 1, LOOPCOUNT\n      IF (abs(c(x, y) - ((a(x, y) * b(x, y)) / minimums(y))) .gt. PRECISION) THEN\n        errors = errors + 1\n      END IF\n    END DO\n  END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "serial",
                            "private",
                            "reduction",
                            "combined-constructs",
                            "loop"
                        ],
                        "versions": [
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "serial_loop_reduction_min_loop.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:serial,loop,reduction,combined-constructs,V:2.6-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(10 * n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(10 * n * sizeof(real_t));\n    real_t * c = (real_t *)malloc(10 * n * sizeof(real_t));\n    real_t * minimum = (real_t *)malloc(10 * sizeof(real_t));\n    real_t temp = 0;\n\n    for (int x = 0; x < 10 * n; ++x){\n        a[x] = 1 + rand() / (real_t)(RAND_MAX/10);\n        b[x] = 1 + rand() / (real_t)(RAND_MAX/10);\n        c[x] = 0.0;\n    }\n\n    #pragma acc data copyin(a[0:10*n], b[0:10*n]) copy(c[0:10*n], minimum[0:10])\n    {\n        #pragma acc serial loop gang private(temp)\n        for (int x = 0; x < 10; ++x){\n            temp = 1000;\n            #pragma acc loop reduction(min:temp)\n            for (int y = 0; y < n; ++y){\n                temp = fmin(a[x * n + y] * b[x * n + y], temp);\n            }\n            minimum[x] = temp;\n            #pragma acc loop\n            for (int y = 0; y < n; ++y){\n                c[x * n + y] = (a[x * n + y] * b[x * n + y]) / minimum[x];\n            }\n        }\n    }\n\n    for (int x = 0; x < 10; ++x){\n        temp = 1000;\n        for (int y = 0; y < n; ++y){\n            temp = fmin(temp, a[x * n + y] * b[x * n + y]);\n        }\n        if (fabs(temp - minimum[x]) > PRECISION){\n            err += 1;\n        }\n        for (int y = 0; y < n; ++y){\n            if (fabs(c[x * n + y] - (a[x * n + y] * b[x * n + y] / minimum[x])) > PRECISION){\n                err += 1;\n            }\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "serial",
                            "loop",
                            "reduction",
                            "combined-constructs"
                        ],
                        "versions": [
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "serial_loop_reduction_min_vector_loop.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:serial,private,reduction,combined-constructs,loop,V:2.6-2.7\n      LOGICAL FUNCTION test1()\n  IMPLICIT NONE\n  INCLUDE \"acc_testsuite.Fh\"\n  REAL(8),DIMENSION(LOOPCOUNT, 10):: a, b\n  REAL(8),DIMENSION(10):: minimums, host_minimums\n  REAL(8):: temp\n  INTEGER:: errors, x, y\n\n  errors = 0\n  minimums = 1\n  host_minimums = 1\n\n  SEEDDIM(1) = 1\n# ifdef SEED\n  SEEDDIM(1) = SEED\n# endif\n  CALL RANDOM_SEED(PUT=SEEDDIM)\n\n  CALL RANDOM_NUMBER(a)\n  CALL RANDOM_NUMBER(b)\n\n  DO y = 1, 10\n    DO x = 1, LOOPCOUNT\n      host_minimums(y) = min(host_minimums(y), a(x, y) * b(x, y))\n    END DO\n  END DO\n\n  !$acc data copyin(a(1:LOOPCOUNT, 1:10), b(1:LOOPCOUNT, 1:10)) copy(minimums(1:10))\n    !$acc serial loop gang private(temp)\n    DO y = 1, 10\n      temp = 1\n      !$acc loop vector reduction(min:temp)\n      DO x = 1, LOOPCOUNT\n        temp = min(temp, a(x, y) * b(x, y))\n      END DO\n      minimums(y) = temp\n    END DO\n  !$acc end data\n\n  DO x = 1, 10\n    IF (abs(host_minimums(x) - minimums(x)) .gt. PRECISION) THEN\n      errors = errors + 1\n    END IF\n  END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "serial",
                            "private",
                            "reduction",
                            "combined-constructs",
                            "loop"
                        ],
                        "versions": [
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "serial_loop_reduction_min_vector_loop.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:serial,loop,reduction,combined-constructs,V:2.6-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(10 * n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(10 * n * sizeof(real_t));\n    real_t * min = (real_t *)malloc(10 * sizeof(real_t));\n    real_t temp = 100;\n    real_t temp_min;\n\n    for (int x = 0; x < 10 * n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX/10);\n        b[x] = rand() / (real_t)(RAND_MAX/10);\n    }\n\n    #pragma acc data copyin(a[0:10*n], b[0:10*n]) copy(min[0:10])\n    {\n        #pragma acc serial loop gang private(temp)\n        for (int x = 0; x < 10; ++x){\n            temp = 100;\n            #pragma acc loop vector reduction(min:temp)\n            for (int y = 0; y < n; ++y){\n                temp = fmin(a[x * n + y] * b[x * n + y], temp);\n            }\n            min[x] = temp;\n        }\n    }\n    for (int x = 0; x < 10; ++x){\n        temp_min = 100;\n        for (int y = 0; y < n; ++y){\n            if (temp_min > a[x * n + y] * b[x * n + y]){\n                temp_min = a[x * n + y] * b[x * n + y];\n            }\n        }\n        if (fabs(temp_min - min[x]) > PRECISION){\n            err = 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "serial",
                            "loop",
                            "reduction",
                            "combined-constructs"
                        ],
                        "versions": [
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "serial_loop_reduction_multiply_general.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:serial,reduction,combined-constructs,loop,V:2.6-2.7\n      LOGICAL FUNCTION test1()\n  IMPLICIT NONE\n  INCLUDE \"acc_testsuite.Fh\"\n  REAL(8),DIMENSION(10):: a, b\n  REAL(8):: reduced, host_reduced\n  INTEGER:: errors, x, y\n\n  errors = 0\n  SEEDDIM(1) = 1\n# ifdef SEED\n  SEEDDIM(1) = SEED\n# endif\n  CALL RANDOM_SEED(PUT=SEEDDIM)\n\n  DO y = 1, LOOPCOUNT\n    CALL RANDOM_NUMBER(a)\n    CALL RANDOM_NUMBER(b)\n    reduced = 1\n    host_reduced = 1\n\n    DO x = 1, 10\n      host_reduced = host_reduced * (a(x) + b(x))\n    END DO\n\n    !$acc data copyin(a(1:10), b(1:10))\n      !$acc serial loop reduction(*:reduced)\n      DO x = 1, 10\n        reduced = reduced * (a(x) + b(x))\n      END DO\n    !$acc end data\n\n    IF (abs(host_reduced - reduced) .gt. PRECISION) THEN\n      errors = errors + 1\n    END IF\n  END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "serial",
                            "reduction",
                            "combined-constructs",
                            "loop"
                        ],
                        "versions": [
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "serial_loop_reduction_multiply_general.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:serial,loop,reduction,combined-constructs,V:2.6-2.7\nint test1(){\n    int err = 0;\n    int multiplicitive_n = 128;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(multiplicitive_n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(multiplicitive_n * sizeof(real_t));\n\n    real_t multiplied_total = 1.0;\n\n    for (int x = 0; x < multiplicitive_n; ++x){\n        a[x] = rand() / (real_t) RAND_MAX;\n        b[x] = rand() / (real_t) RAND_MAX;\n    }\n\n    #pragma acc data copyin(a[0:multiplicitive_n], b[0:multiplicitive_n]) copy(multiplied_total)\n    {\n        #pragma acc serial loop reduction (*:multiplied_total)\n        for (int x = 0; x < multiplicitive_n; ++x){\n            multiplied_total *= a[x] + b[x];\n        }\n    }\n\n    for (int x = 0; x < multiplicitive_n; ++x){\n        multiplied_total /= (a[x] + b[x]);\n    }\n    if (fabs(multiplied_total - 1) > PRECISION * (2 * multiplicitive_n - 1)){\n        err = 1;\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "serial",
                            "loop",
                            "reduction",
                            "combined-constructs"
                        ],
                        "versions": [
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "serial_loop_reduction_multiply_loop.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:serial,private,reduction,combined-constructs,loop,V:2.6-2.7\n      LOGICAL FUNCTION test1()\n  IMPLICIT NONE\n  INCLUDE \"acc_testsuite.Fh\"\n  REAL(8),DIMENSION(10, LOOPCOUNT):: a, b, c\n  REAL(8),DIMENSION(LOOPCOUNT):: totals, host_totals\n  REAL(8):: temp\n  INTEGER:: errors, x, y\n\n  errors = 0\n\n  SEEDDIM(1) = 1\n# ifdef SEED\n  SEEDDIM(1) = SEED\n# endif\n  CALL RANDOM_SEED(PUT=SEEDDIM)\n\n  CALL RANDOM_NUMBER(a)\n  CALL RANDOM_NUMBER(b)\n  c = 0\n\n\n  host_totals = 1\n  DO y = 1, LOOPCOUNT\n    DO x = 1, 10\n      host_totals(y) = host_totals(y) * (a(x, y) + b(x, y))\n    END DO\n  END DO\n\n  !$acc data copyin(a(1:10, 1:LOOPCOUNT), b(1:10, 1:LOOPCOUNT)) copyout(c(1:10, 1:LOOPCOUNT)) copy(totals(1:LOOPCOUNT))\n    !$acc serial loop gang private(temp)\n    DO y = 1, LOOPCOUNT\n      temp = 1\n      !$acc loop worker reduction(*:temp)\n      DO x = 1, 10\n        temp = temp * (a(x, y) + b(x, y))\n      END DO\n      totals(y) = temp\n      !$acc loop worker\n      DO x = 1, 10\n        c(x, y) = (a(x, y) + b(x, y)) / totals(y)\n      END DO\n    END DO\n  !$acc end data\n\n  DO y = 1, LOOPCOUNT\n    IF (abs(host_totals(y) - totals(y)) .gt. PRECISION) THEN\n      errors = errors + 1\n    END IF\n    DO x = 1, 10\n      IF (c(x, y) - ((a(x, y) + b(x, y)) / totals(y)) .gt. PRECISION) THEN\n        errors = errors + 1\n      END IF\n    END DO\n  END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "serial",
                            "private",
                            "reduction",
                            "combined-constructs",
                            "loop"
                        ],
                        "versions": [
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "serial_loop_reduction_multiply_loop.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:serial,loop,reduction,combined-constructs,V:2.6-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(10 * n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(10 * n * sizeof(real_t));\n    real_t * c = (real_t *)malloc(10 * n * sizeof(real_t));\n    real_t * totals = (real_t *)malloc(10 * sizeof(real_t));\n    real_t temp;\n\n    for (int x = 0; x < n; ++x){\n        a[x] = (999.4 + rand() / (real_t)(RAND_MAX)) / 1000;\n        b[x] = (999.4 + rand() / (real_t)(RAND_MAX)) / 1000;\n        c[x] = 0.0;\n    }\n\n\n    #pragma acc data copyin(a[0:10*n], b[0:10*n]) copyout(c[0:10*n]) copy(totals[0:10])\n    {\n        #pragma acc serial loop gang private(temp)\n        for (int x = 0; x < 10; ++x){\n            temp = 1;\n            #pragma acc loop worker reduction(*:temp)\n            for (int y = 0; y < n; ++y){\n                temp *= a[x * n + y] + b[x * n + y];\n            }\n            totals[x] = temp;\n            #pragma acc loop worker\n            for (int y = 0; y < n; ++y){\n                c[x * n + y] = (a[x * n + y] + b[x * n + y]) / totals[x];\n            }\n        }\n    }\n\n    for (int x = 0; x < 10; ++x){\n        temp = 1;\n        for (int y = 0; y < n; ++y){\n            temp *= a[x * n + y] + b[x * n + y];\n        }\n        if (fabs(temp - totals[x]) > (temp / 2 + totals[x] / 2) * PRECISION){\n            err += 1;\n        }\n        for (int y = 0; y < n; ++y){\n            if (fabs(c[x * n + y] - ((a[x * n + y] + b[x * n + y]) / totals[x])) > PRECISION){\n                err += 1;\n            }\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "serial",
                            "loop",
                            "reduction",
                            "combined-constructs"
                        ],
                        "versions": [
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "serial_loop_reduction_multiply_vector_loop.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:serial,private,reduction,combined-constructs,loop,V:2.6-2.7\n      LOGICAL FUNCTION test1()\n  IMPLICIT NONE\n  INCLUDE \"acc_testsuite.Fh\"\n  REAL(8),DIMENSION(10, LOOPCOUNT):: a, b\n  REAL(8),DIMENSION(LOOPCOUNT):: totals, host_totals\n  REAL(8):: temp\n  INTEGER:: errors\n\n  errors = 0\n\n  SEEDDIM(1) = 1\n# ifdef SEED\n  SEEDDIM(1) = SEED\n# endif\n  CALL RANDOM_SEED(PUT=SEEDDIM)\n\n  CALL RANDOM_NUMBER(a)\n  CALL RANDOM_NUMBER(b)\n\n  host_totals = 1\n  DO y = 1, LOOPCOUNT\n    DO x = 1, 10\n      host_totals(y) = host_totals(y) * (a(x, y) + b(x, y))\n    END DO\n  END DO\n\n  !$acc data copyin(a(1:10, 1:LOOPCOUNT), b(1:10, 1:LOOPCOUNT)) copyout(totals(1:LOOPCOUNT))\n    !$acc serial loop private(temp)\n    DO y = 1, LOOPCOUNT\n      temp = 1\n      !$acc loop vector reduction(*:temp)\n      DO x = 1, 10\n        temp = temp * (a(x, y) + b(x, y))\n      END DO\n      totals(y) = temp\n    END DO\n  !$acc end data\n\n  DO y = 1, LOOPCOUNT\n    IF (abs(host_totals(y) - totals(y)) .gt. PRECISION) THEN\n      errors = errors + 1\n    END IF\n  END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "serial",
                            "private",
                            "reduction",
                            "combined-constructs",
                            "loop"
                        ],
                        "versions": [
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "serial_loop_reduction_multiply_vector_loop.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:serial,loop,reduction,combined-constructs,V:2.6-2.7\nint test1(){\n    int err = 0;\n    int multiplicitive_n = 128;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(10 * multiplicitive_n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(10 * multiplicitive_n * sizeof(real_t));\n    real_t * c = (real_t *)malloc(10 * sizeof(real_t));\n    real_t temp;\n\n    for (int x = 0; x < 10 * multiplicitive_n; ++x){\n        a[x] = rand() / (real_t) RAND_MAX;\n        b[x] = rand() / (real_t) RAND_MAX;\n    }\n\n    #pragma acc data copyin(a[0:10*multiplicitive_n], b[0:10*multiplicitive_n]) copyout(c[0:10])\n    {\n        #pragma acc serial loop private(temp)\n        for (int x = 0; x < 10; ++x){\n            temp = 1.0;\n            #pragma acc loop vector reduction(*:temp)\n            for (int y = 0; y < multiplicitive_n; ++y){\n                temp *= a[(x * multiplicitive_n) + y] + b[(x * multiplicitive_n) + y];\n            }\n            c[x] = temp;\n        }\n    }\n\n    for (int x = 0; x < 10; ++x){\n        for (int y = 0; y < multiplicitive_n; ++y){\n            c[x] /= a[(x * multiplicitive_n) + y] + b[(x * multiplicitive_n) + y];\n        }\n    }\n\n    for (int x = 0; x < 10; ++x){\n        if (fabs(c[x] - 1) > PRECISION * (4 * multiplicitive_n - 1)){\n            err = 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "serial",
                            "loop",
                            "reduction",
                            "combined-constructs"
                        ],
                        "versions": [
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "serial_loop_reduction_or_general.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:serial,reduction,combined-constructs,loop,V:2.6-2.7\n      LOGICAL FUNCTION test1()\n  IMPLICIT NONE\n  INCLUDE \"acc_testsuite.Fh\"\n  LOGICAL,DIMENSION(LOOPCOUNT):: a\n  LOGICAL:: result, host_result\n  REAL(8),DIMENSION(LOOPCOUNT):: randoms\n  REAL(8):: false_margin\n  INTEGER:: errors, x\n\n  errors = 0\n  false_margin = exp(log(.5) / LOOPCOUNT)\n\n  SEEDDIM(1) = 1\n# ifdef SEED\n  SEEDDIM(1) = SEED\n# endif\n  CALL RANDOM_SEED(PUT=SEEDDIM)\n\n  CALL RANDOM_NUMBER(randoms)\n\n  DO x = 1, LOOPCOUNT\n    IF (randoms(x) .gt. false_margin) THEN\n      a(x) = .TRUE.\n    ELSE\n      a(x) = .FALSE.\n    END IF\n  END DO\n\n  host_result = .FALSE.\n  result = .FALSE.\n\n  DO x = 1, LOOPCOUNT\n    host_result = host_result .OR. a(x)\n  END DO\n\n  !$acc data copyin(a(1:LOOPCOUNT))\n    !$acc serial loop reduction(.OR.: result)\n    DO x = 1, LOOPCOUNT\n      result = result .OR. a(x)\n    END DO\n  !$acc end data\n\n  IF (host_result .neqv. result) THEN\n    errors = errors + 1\n  END IF\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "serial",
                            "reduction",
                            "combined-constructs",
                            "loop"
                        ],
                        "versions": [
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "serial_loop_reduction_or_general.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:serial,loop,reduction,combined-constructs,V:2.6-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    char * a = (char *)malloc(n * sizeof(char));\n    real_t false_margin = pow(exp(1), log(.5)/n);\n    char result = 0;\n    char found = 0;\n\n    for (int x = 0; x < n; ++x){\n        if(rand() / (real_t)(RAND_MAX) > false_margin){\n            a[x] = 1;\n        }\n        else{\n            a[x] = 0;\n        }\n    }\n\n\n    #pragma acc data copyin(a[0:n])\n    {\n        #pragma acc serial loop reduction(||:result)\n        for (int x = 0; x < n; ++x){\n            result = result || a[x];\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        if (a[x] == 1){\n            found = 1;\n        }\n    }\n    if (found != result){\n        err = 1;\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "serial",
                            "loop",
                            "reduction",
                            "combined-constructs"
                        ],
                        "versions": [
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "serial_loop_reduction_or_loop.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:serial,private,reduction,combined-constructs,loop,V:2.6-2.7\n      LOGICAL FUNCTION test1()\n  IMPLICIT NONE\n  INCLUDE \"acc_testsuite.Fh\"\n  LOGICAL,DIMENSION(LOOPCOUNT, 10):: a, a_copy\n  LOGICAL,DIMENSION(10):: results\n  LOGICAL:: temp\n  REAL(8):: false_margin\n  REAL(8),DIMENSION(LOOPCOUNT, 10):: randoms\n  INTEGER:: errors\n  INTEGER:: x, y\n\n  errors = 0\n  SEEDDIM(1) = 1\n# ifdef SEED\n  SEEDDIM(1) = SEED\n# endif\n  CALL RANDOM_SEED(PUT=SEEDDIM)\n\n  CALL RANDOM_NUMBER(randoms)\n\n  DO y = 1, 10\n    DO x = 1, LOOPCOUNT\n      IF (randoms(x, y) .gt. false_margin) THEN\n        a(x, y) = .TRUE.\n      ELSE\n        a(x, y) = .FALSE.\n      END IF\n    END DO\n  END DO\n\n  a_copy = a\n\n  !$acc data copy(a(1:LOOPCOUNT, 1:10))\n    !$acc serial loop gang private(temp)\n    DO y = 1, 10\n      temp = .FALSE.\n      !$acc loop worker reduction(.OR.:temp)\n      DO x = 1, LOOPCOUNT\n        temp = temp .OR. a(x, y)\n      END DO\n      results(y) = temp\n      !$acc loop worker\n      DO x = 1, LOOPCOUNT\n        IF (results(y)) THEN\n          IF (a(x, y)) THEN\n            a(x, y) = .FALSE.\n          ELSE\n            a(x, y) = .TRUE.\n          END IF\n        END IF\n      END DO\n    END DO\n  !$acc data\n\n  DO y = 1, 10\n    temp = .FALSE.\n    DO x = 1, LOOPCOUNT\n      temp = temp .OR. a(x, y)\n    END DO\n    IF (temp .neqv. results(y)) THEN\n      errors = errors + 1\n    END IF\n    DO x = 1, LOOPCOUNT\n      IF (temp) THEN\n        IF (a(x, y) .eqv. a_copy(x, y)) THEN\n          errors = errors + 1\n        END IF\n      ELSE\n        IF (a(x, y) .neqv. a_copy(x, y)) THEN\n          errors = errors + 1\n        END IF\n      END IF\n    END DO\n  END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "serial",
                            "private",
                            "reduction",
                            "combined-constructs",
                            "loop"
                        ],
                        "versions": [
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "serial_loop_reduction_or_loop.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:serial,loop,reduction,combined-constructs,V:2.6-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    char * a = (char *)malloc(10 * n * sizeof(char));\n    char * a_copy = (char *)malloc(10 * n * sizeof(char));\n    char * results = (char *)malloc(10 * sizeof(char));\n    char temp = 0;\n    real_t false_margin = pow(exp(1), log(.5)/n);\n\n    for (int x = 0; x < 10 * n; ++x){\n        if (rand() / (real_t)(RAND_MAX) > false_margin){\n            a[x] = 1;\n            a_copy[x] = 1;\n        }\n        else{\n            a[x] = 0;\n            a_copy[x] = 0;\n        }\n    }\n    #pragma acc data copy(a[0:10*n]) copyout(results[0:10])\n    {\n        #pragma acc serial loop gang private(temp)\n        for (int x = 0; x < 10; ++x){\n            temp = 0;\n            #pragma acc loop worker reduction(||:temp)\n            for (int y = 0; y < n; ++y){\n                temp = temp || a[x * n + y];\n            }\n            results[x] = temp;\n            #pragma acc loop worker\n            for (int y = 0; y < n; ++y){\n                if(results[x] == 1){\n                    if (a[x * n + y] == 1){\n                        a[x * n + y] = 0;\n                    }\n                    else{\n                        a[x * n + y] = 1;\n                    }\n                }\n            }\n        }\n    }\n    for (int x = 0; x < 10; ++x){\n        temp = 0;\n        for (int y = 0; y < n; ++y){\n            temp = temp || a_copy[x * n + y];\n        }\n        if (temp != results[x]) {\n            err += 1;\n        }\n        for (int y = 0; y < n; ++y){\n            if (temp == 1){\n                if (a[x * n + y] == a_copy[x * n + y]){\n                    err += 1;\n                }\n            }\n            else {\n                if (a[x * n + y] != a_copy[x * n + y]){\n                    err += 1;\n                }\n            }\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "serial",
                            "loop",
                            "reduction",
                            "combined-constructs"
                        ],
                        "versions": [
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "serial_loop_reduction_or_vector_loop.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:serial,private,reduction,combined-constructs,loop,V:2.6-2.7\n      LOGICAL FUNCTION test1()\n  IMPLICIT NONE\n  INCLUDE \"acc_testsuite.Fh\"\n  LOGICAL,DIMENSION(LOOPCOUNT, 10):: a\n  LOGICAL,DIMENSION(10):: b\n  LOGICAL:: temp\n  REAL(8):: false_margin\n  REAL(8),DIMENSION(LOOPCOUNT, 10):: randoms\n  INTEGER:: errors\n  INTEGER:: x, y\n\n  errors = 0\n  SEEDDIM(1) = 1\n# ifdef SEED\n  SEEDDIM(1) = SEED\n# endif\n  CALL RANDOM_SEED(PUT=SEEDDIM)\n\n  CALL RANDOM_NUMBER(randoms)\n\n  DO y = 1, 10\n    DO x = 1, LOOPCOUNT\n      IF (randoms(x, y) .gt. false_margin) THEN\n        a(x, y) = .TRUE.\n      ELSE\n        a(x, y) = .FALSE.\n      END IF\n    END DO\n  END DO\n\n  !$acc data copyin(a(1:LOOPCOUNT, 1:10)) copy(b(1:10))\n    !$acc serial loop private(temp)\n    DO y = 1, 10\n      temp = .FALSE.\n      !$acc loop vector reduction(.OR.:temp)\n      DO x = 1, LOOPCOUNT\n        temp = temp .OR. a(x, y)\n      END DO\n      b(y) = temp\n    END DO\n  !$acc end data\n\n  DO y = 1, 10\n    temp = .FALSE.\n    DO x = 1, LOOPCOUNT\n      temp = temp .OR. a(x, y)\n    END DO\n    IF (temp .neqv. b(y)) THEN\n      errors = errors + 1\n    END IF\n  END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "serial",
                            "private",
                            "reduction",
                            "combined-constructs",
                            "loop"
                        ],
                        "versions": [
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "serial_loop_reduction_or_vector_loop.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:serial,loop,reduction,combined-constructs,V:2.6-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    char * a = (char *)malloc(10 * n * sizeof(char));\n    char * b = (char *)malloc(10 * sizeof(char));\n    real_t false_margin = pow(exp(1), log(.5)/n);\n    char temp = 0;\n    char found;\n\n    for (int x = 0; x < 10 * n; ++x){\n        if(rand() / (real_t)(RAND_MAX) > false_margin){\n            a[x] = 1;\n        }\n        else{\n            a[x] = 0;\n        }\n    }\n    #pragma acc data copyin(a[0:10*n]) copy(b[0:10])\n    {\n        #pragma acc serial loop private(temp)\n        for (int x = 0; x < 10; ++x){\n            temp = 0;\n            #pragma acc loop vector reduction(||:temp)\n            for (int y = 0; y < n; ++y){\n                temp = temp || a[x * n + y];\n            }\n            b[x] = temp;\n        }\n    }\n    for (int x = 0; x < 10; ++x){\n        found = 0;\n        for (int y = 0; y < n; ++y){\n            if (a[x * n + y] &! 0){\n                found = 1;\n            }\n        }\n        if (found != b[x]){\n            err = 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "serial",
                            "loop",
                            "reduction",
                            "combined-constructs"
                        ],
                        "versions": [
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "serial_loop_seq.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:serial,combined-constructs,loop,V:2.6-2.7\n      LOGICAL FUNCTION test1()\n  IMPLICIT NONE\n  INCLUDE \"acc_testsuite.Fh\"\n  REAL(8),DIMENSION(LOOPCOUNT):: a, b\n  REAL(8):: temp\n  INTEGER:: errors, x\n\n  errors = 0\n  SEEDDIM(1) = 1\n# ifdef SEED\n  SEEDDIM(1) = SEED\n# endif\n  CALL RANDOM_SEED(PUT=SEEDDIM)\n\n  CALL RANDOM_NUMBER(a)\n  b = 0\n\n  !$acc data copyin(a(1:LOOPCOUNT)) copy(b(1:LOOPCOUNT))\n    !$acc serial loop seq\n    DO x = 2, LOOPCOUNT\n      b(x) = b(x - 1) + a(x)\n    END DO\n  !$acc end data\n\n  temp = 0\n  DO x = 2, LOOPCOUNT\n    temp = temp + a(x)\n    IF (abs(b(x) - temp) .gt. PRECISION) THEN\n      errors = errors + 1\n    END IF\n  END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "serial",
                            "combined-constructs",
                            "loop"
                        ],
                        "versions": [
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "serial_loop_seq.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:serial,loop,combined-constructs,V:2.6-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n    real_t temp = 0.0;\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = 0.0;\n    }\n\n    #pragma acc data copyin(a[0:n]) copy(b[0:n])\n    {\n        #pragma acc serial loop seq\n        for (int x = 1; x < n; ++x){\n            b[x] = b[x-1] + a[x];\n        }\n    }\n\n    for (int x = 1; x < n; ++x){\n        temp += a[x];\n        if (fabs(b[x] - temp) > PRECISION){\n            err = 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "serial",
                            "loop",
                            "combined-constructs"
                        ],
                        "versions": [
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "serial_loop_tile.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:serial,combined-constructs,loop,tile,V:2.6-2.7\n      LOGICAL FUNCTION test1()\n  IMPLICIT NONE\n  INCLUDE \"acc_testsuite.Fh\"\n  INTEGER:: errors\n  REAL(8),DIMENSION(100):: a, b, c\n  REAL(8),DIMENSION(100, 100):: d2\n  REAL(8),DIMENSION(100, 100, 100):: d3\n  INTEGER:: x, y, z\n  errors = 0\n\n  SEEDDIM(1) = 1\n# ifdef SEED\n  SEEDDIM(1) = SEED\n# endif\n  CALL RANDOM_SEED(PUT=SEEDDIM)\n\n  CALL RANDOM_NUMBER(a)\n  CALL RANDOM_NUMBER(b)\n  CALL RANDOM_NUMBER(c)\n  d2 = 0\n  d3 = 0\n\n  !$acc data copyin(a(1:100), b(1:100), c(1:100)) copyout(d2(1:100, 1:100))\n    !$acc serial loop tile(*, *)\n    DO x = 1, 100\n      DO y = 1, 100\n        DO z = 1, 100\n          d2(x, y) = d2(x, y) + (a(x) * b(y) * c(z))\n        END DO\n      END DO\n    END DO\n  !$acc end data\n\n  DO x = 1, 100\n    DO y = 1, 100\n      DO z = 1, 100\n        d2(x, y) = d2(x, y) - (a(x) * b(y) * c(z))\n      END DO\n      IF (abs(d2(x, y)) .gt. 10*PRECISION) THEN\n        errors = errors + 1\n      END IF\n    END DO\n  END DO\n\n  !$acc data copyin(a(1:100), b(1:100), c(1:100)) copyout(d3(1:100, 1:100, 1:100))\n    !$acc serial loop tile(*, *, *)\n    DO x = 1, 100\n      DO y = 1, 100\n        DO z = 1, 100\n          d3(x, y, z) = a(x) * b(y) * c(z)\n        END DO\n      END DO\n    END DO\n  !$acc end data\n\n  DO x = 1, 100\n    DO y = 1, 100\n      DO z = 1, 100\n        IF (abs(d3(x, y, z) - (a(x) * b(y) * c(z))) .gt. PRECISION) THEN\n          errors = errors + 1\n        END IF\n      END DO\n    END DO\n  END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "serial",
                            "combined-constructs",
                            "loop",
                            "tile"
                        ],
                        "versions": [
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "serial_loop_tile.c": {
                "num tests": 2,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:serial,loop,tile,combined-constructs,syntactic,V:2.6-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n    real_t * c = (real_t *)malloc(n * sizeof(real_t));\n    real_t * d2 = (real_t *)malloc(n * n * sizeof(real_t));\n    real_t * d3 = (real_t *)malloc(n * n * n * sizeof(real_t));\n    real_t temp = 0.0;\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n        c[x] = rand() / (real_t)(RAND_MAX / 10);\n    }\n    #pragma acc data copy(a[0:n], b[0:n], c[0:n], d2[0:n*n])\n    {\n        #pragma acc serial loop tile(*, *) reduction(+:temp)\n        for (int x = 0; x < n; ++x){\n            for (int y = 0; y < n; ++y){\n                temp = 0;\n                for (int z = 0; z < n; ++z){\n                    temp += a[x] + b[y] + c[z];\n                }\n                d2[x * n + y] = temp;\n            }\n        }\n    }\n    for (int x = 0; x < n; ++x){\n        for (int y = 0; y < n; ++y){\n            temp = 0.0;\n            for (int z = 0; z < n; ++z){\n                temp += a[x] + b[y] + c[z];\n            }\n            if (fabs(temp - d2[x * n + y]) > PRECISION * n){\n                err += 1;\n            }\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "serial",
                            "loop",
                            "tile",
                            "combined-constructs",
                            "syntactic"
                        ],
                        "versions": [
                            "2.6",
                            "2.7"
                        ]
                    },
                    "2": {
                        "content": "#ifndef T2\n//T2:serial,loop,combined-constructs,tile,V:2.6-2.7\nint test2(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n    real_t * c = (real_t *)malloc(n * sizeof(real_t));\n    real_t * d2 = (real_t *)malloc(n * n * sizeof(real_t));\n    real_t * d3 = (real_t *)malloc(n * n * n * sizeof(real_t));\n    real_t temp = 0.0;\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n        c[x] = rand() / (real_t)(RAND_MAX / 10);\n    }\n\n    #pragma acc data copyin(a[0:n], b[0:n], c[0:n]) copyout(d3[0:n*n*n])\n    {\n        #pragma acc serial loop tile(2, 4, 8)\n        for (int x = 0; x < n; ++x){\n            for (int y = 0; y < n; ++y){\n                for (int z = 0; z < n; ++z){\n                    d3[(n * n * x) + (n * y) + z] = a[x] + b[x] + c[x];\n                }\n            }\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        for (int y = 0; y < n; ++y){\n            for (int z = 0; z < n; ++z){\n                if (fabs(d3[(n * n * x) + (n * y) + z] - a[x] - b[x] - c[x]) > PRECISION * 2){\n                    err = 1;\n                }\n            }\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T2\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test2();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 1);\n    }\n#endif\n",
                        "tags": [
                            "serial",
                            "loop",
                            "combined-constructs",
                            "tile"
                        ],
                        "versions": [
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "serial_loop_vector.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:serial,combined-constructs,loop,V:2.6-2.7\n      LOGICAL FUNCTION test1()\n  IMPLICIT NONE\n  INCLUDE \"acc_testsuite.Fh\"\n  REAL(8),DIMENSION(LOOPCOUNT):: a, b, c\n  INTEGER:: x\n  INTEGER:: errors\n\n  errors = 0\n\n  SEEDDIM(1) = 1\n# ifdef SEED\n  SEEDDIM(1) = SEED\n# endif\n  CALL RANDOM_SEED(PUT=SEEDDIM)\n\n  CALL RANDOM_NUMBER(a)\n  CALL RANDOM_NUMBER(b)\n  c = 0\n\n  !$acc data copyin(a(1:LOOPCOUNT), b(1:LOOPCOUNT)) copy(c(1:LOOPCOUNT))\n    !$acc serial loop vector\n    DO x = 1, LOOPCOUNT\n      c(x) = a(x) + b(x)\n    END DO\n  !$acc end data\n\n  DO x = 1, LOOPCOUNT\n    IF (abs(c(x) - (a(x) + b(x))) .gt. PRECISION) THEN\n      errors = errors + 1\n    END IF\n  END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "serial",
                            "combined-constructs",
                            "loop"
                        ],
                        "versions": [
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "serial_loop_vector.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:serial,loop,combined-constructs,V:2.6-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n    real_t * c = (real_t *)malloc(n * sizeof(real_t));\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n        c[x] = 0.0;\n    }\n\n    #pragma acc data copyin(a[0:n], b[0:n]) copy(c[0:n])\n    {\n        #pragma acc serial loop vector\n        for (int x = 0; x < n; ++x){\n            c[x] = a[x] + b[x];\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        if(fabs(c[x] - (a[x] + b[x])) > PRECISION){\n            err = 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "serial",
                            "loop",
                            "combined-constructs"
                        ],
                        "versions": [
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "serial_loop_vector_blocking.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:loop,V:2.6-2.7\n      LOGICAL FUNCTION test1()\n  IMPLICIT NONE\n  INCLUDE \"acc_testsuite.Fh\"\n  INTEGER:: errors\n  REAL(8),DIMENSION(LOOPCOUNT):: a, b, c\n  INTEGER:: multiplier, x\n  errors = 0\n\n  SEEDDIM(1) = 1\n# ifdef SEED\n  SEEDDIM(1) = SEED\n# endif\n  CALL RANDOM_SEED(PUT=SEEDDIM)\n\n  CALL RANDOM_NUMBER(a)\n  CALL RANDOM_NUMBER(b)\n  c = 0\n\n  !$acc data copyin(a(1:LOOPCOUNT), b(1:LOOPCOUNT)) copyout(c(1:LOOPCOUNT))\n    !$acc serial\n      !$acc loop vector\n      DO x = 1, LOOPCOUNT\n        c(x) = (a(x) + b(x)) * multiplier\n      END DO\n      multiplier = multiplier + 1\n      !$acc loop vector\n      DO x = 1, LOOPCOUNT\n        c(x) = c(x) + ((a(x) + b(x)) * multiplier)\n      END DO\n    !$acc end serial\n  !$acc end data\n\n  DO x = 1, LOOPCOUNT\n    IF (abs(c(x) - ((a(x) + b(x)) * 3)) .gt. PRECISION) THEN\n      errors = errors + 1\n    END IF\n  END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "loop"
                        ],
                        "versions": [
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "serial_loop_vector_blocking.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:serial,loop,V:2.6-2.7\nint test1(){\n  int err = 0;\n  srand(SEED);\n  real_t * a = (real_t *)malloc(n * sizeof(real_t));\n  real_t * b = (real_t *)malloc(n * sizeof(real_t));\n  real_t * c = (real_t *)malloc(n * sizeof(real_t));\n  real_t multiplyer = 1;\n\n  for (int x = 0; x < n; ++x){\n      a[x] = rand() / (real_t)(RAND_MAX / 10);\n      b[x] = rand() / (real_t)(RAND_MAX / 10);\n      c[x] = 0.0;\n  }\n\n  #pragma acc data copyin(a[0:n], b[0:n]) copyout(c[0:n])\n  {\n    #pragma acc serial\n    {\n      #pragma acc loop vector\n      for (int x = 0; x < n; ++x){\n        c[x] = (a[x] + b[x]) * multiplyer;\n      }\n      multiplyer += 1;\n      #pragma acc loop vector\n      for (int x = 0; x < n; ++x){\n        c[x] += (a[x] + b[x]) * multiplyer;\n      }\n    }\n  }\n\n  for (int x = 0; x < n; ++x){\n    if (fabs(c[x] - 3 * (a[x] + b[x])) > PRECISION){\n      err + 1;\n      break;\n    }\n  }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "serial",
                            "loop"
                        ],
                        "versions": [
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "serial_loop_worker.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:serial,combined-constructs,loop,V:2.6-2.7\n      LOGICAL FUNCTION test1()\n  IMPLICIT NONE\n  INCLUDE \"acc_testsuite.Fh\"\n  REAL(8),DIMENSION(LOOPCOUNT):: a, b, c\n  INTEGER:: x\n  INTEGER:: errors\n\n  errors = 0\n\n  SEEDDIM(1) = 1\n# ifdef SEED\n  SEEDDIM(1) = SEED\n# endif\n  CALL RANDOM_SEED(PUT=SEEDDIM)\n\n  CALL RANDOM_NUMBER(a)\n  CALL RANDOM_NUMBER(b)\n  c = 0\n\n  !$acc data copyin(a(1:LOOPCOUNT), b(1:LOOPCOUNT)) copy(c(1:LOOPCOUNT))\n    !$acc serial loop worker\n    DO x = 1, LOOPCOUNT\n      c(x) = a(x) + b(x)\n    END DO\n  !$acc end data\n\n  DO x = 1, LOOPCOUNT\n    IF (abs(c(x) - (a(x) + b(x))) .gt. PRECISION) THEN\n      errors = errors + 1\n    END IF\n  END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "serial",
                            "combined-constructs",
                            "loop"
                        ],
                        "versions": [
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "serial_loop_worker.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:serial,loop,combined-constructs,V:2.6-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n    real_t * c = (real_t *)malloc(n * sizeof(real_t));\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n        c[x] = 0.0;\n    }\n\n    #pragma acc data copyin(a[0:n], b[0:n]) copy(c[0:n])\n    {\n        #pragma acc serial loop worker\n        for (int x = 0; x < n; ++x){\n            c[x] = a[x] + b[x];\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        if (fabs(c[x] - (a[x] + b[x])) > PRECISION){\n            err = 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "serial",
                            "loop",
                            "combined-constructs"
                        ],
                        "versions": [
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "serial_loop_worker_blocking.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:loop,V:2.6-2.7\n      LOGICAL FUNCTION test1()\n  IMPLICIT NONE\n  INCLUDE \"acc_testsuite.Fh\"\n  REAL(8),DIMENSION(LOOPCOUNT):: a, b, c\n  INTEGER:: multiplier\n  INTEGER:: x\n  INTEGER:: errors\n\n  errors = 0\n\n  SEEDDIM(1) = 1\n# ifdef SEED\n  SEEDDIM(1) = SEED\n# endif\n  CALL RANDOM_SEED(PUT=SEEDDIM)\n\n  CALL RANDOM_NUMBER(a)\n  CALL RANDOM_NUMBER(b)\n  c = 0\n\n  !$acc data copyin(a(1:LOOPCOUNT), b(1:LOOPCOUNT)) copyout(c(1:LOOPCOUNT))\n    !$acc serial\n      !$acc loop worker\n      DO x = 1, LOOPCOUNT\n        c(x) = (a(x) + b(x)) * multiplier\n      END DO\n      multiplier = multiplier + 1\n      !$acc loop worker\n      DO x = 1, LOOPCOUNT\n        c(x) = c(x) + ((a(x) + b(x)) * multiplier)\n      END DO\n    !$acc end serial\n  !$acc end data\n\n  DO x = 1, LOOPCOUNT\n    IF (abs(c(x) - (3 * (a(x) + b(x)))) .gt. PRECISION) THEN\n      errors = errors + 1\n    END IF\n  END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "loop"
                        ],
                        "versions": [
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "serial_loop_worker_blocking.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:serial,loop,V:2.6-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n    real_t * c = (real_t *)malloc(n * sizeof(real_t));\n    real_t multiplyer = 1;\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n        c[x] = 0.0;\n    }\n\n    #pragma acc data copyin(a[0:n], b[0:n]) copyout(c[0:n])\n    {\n      #pragma acc serial\n      {\n        #pragma acc loop worker\n        for (int x = 0; x < n; ++x){\n          c[x] = (a[x] + b[x]) * multiplyer;\n        }\n        multiplyer += 1;\n        #pragma acc loop worker\n        for (int x = 0; x < n; ++x){\n          c[x] += (a[x] + b[x]) * multiplyer;\n        }\n      }\n    }\n\n    for (int x = 0; x < n; ++x){\n      if (fabs(c[x] - 3 * (a[x] + b[x])) > PRECISION){\n        err + 1;\n        break;\n      }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "serial",
                            "loop"
                        ],
                        "versions": [
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "serial_present.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:serial,V:2.6-2.7\n      LOGICAL FUNCTION test1()\n  IMPLICIT NONE\n  INCLUDE \"acc_testsuite.Fh\"\n  REAL(8),DIMENSION(LOOPCOUNT):: a, b, c\n  INTEGER:: x\n  INTEGER:: errors\n\n  errors = 0\n\n  SEEDDIM(1) = 1\n# ifdef SEED\n  SEEDDIM(1) = SEED\n# endif\n  CALL RANDOM_SEED(PUT=SEEDDIM)\n\n  CALL RANDOM_NUMBER(a)\n  CALL RANDOM_NUMBER(b)\n  c = 0\n\n  !$acc enter data copyin(a(1:LOOPCOUNT), b(1:LOOPCOUNT)) create(c(1:LOOPCOUNT))\n  !$acc serial present(a(1:LOOPCOUNT), b(1:LOOPCOUNT), c(1:LOOPCOUNT))\n    !$acc loop\n    DO x = 1, LOOPCOUNT\n      c(x) = a(x) + b(x)\n    END DO\n  !$acc end serial\n  !$acc exit data delete(a(1:LOOPCOUNT), b(1:LOOPCOUNT)) copyout(c(1:LOOPCOUNT))\n\n  DO x = 1, LOOPCOUNT\n    IF (abs(c(x) - (a(x) + b(x))) .gt. PRECISION) THEN\n      errors = errors + 1\n    END IF\n  END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "serial"
                        ],
                        "versions": [
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "serial_present.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:serial,present,V:2.6-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n    real_t * c = (real_t *)malloc(n * sizeof(real_t));\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n        c[x] = 0.0;\n    }\n\n    #pragma acc enter data copyin(a[0:n], b[0:n])\n    #pragma acc serial present(a[0:n], b[0:n]) copy(c[0:n])\n    {\n        #pragma acc loop\n        for (int x = 0; x < n; ++x){\n            c[x] = a[x] + b[x];\n        }\n    }\n    #pragma acc exit data delete(a[0:n], b[0:n])\n\n    for (int x = 0; x < n; ++x){\n        if (fabs(c[x] - (a[x] + b[x])) > PRECISION){\n            err += 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "serial",
                            "present"
                        ],
                        "versions": [
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "serial_private.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:serial,private,V:2.6-2.7\n      LOGICAL FUNCTION test1()\n  IMPLICIT NONE\n  INCLUDE \"acc_testsuite.Fh\"\n  REAL(8),DIMENSION(LOOPCOUNT, 10):: a, b\n  REAL(8),DIMENSION(LOOPCOUNT):: c\n  REAL(8),DIMENSION(10):: d\n  REAL(8):: temp\n  INTEGER:: x, y\n  INTEGER:: errors\n\n  errors = 0\n\n  SEEDDIM(1) = 1\n# ifdef SEED\n  SEEDDIM(1) = SEED\n# endif\n  CALL RANDOM_SEED(PUT=SEEDDIM)\n\n  CALL RANDOM_NUMBER(a)\n  CALL RANDOM_NUMBER(b)\n  c = 0\n  d = 0\n\n  !$acc data copyin(a(1:LOOPCOUNT, 1:10), b(1:LOOPCOUNT, 1:10)) copy(d(1:10))\n    !$acc serial private(c(1:LOOPCOUNT))\n      !$acc loop gang\n      DO y = 1, 10\n        !$acc loop worker\n        DO x = 1, LOOPCOUNT\n          c(x) = a(x, y) + b(x, y)\n        END DO\n        !$acc loop seq\n        DO x = 1, LOOPCOUNT\n          d(y) = d(y) + c(x)\n        END DO\n      END DO\n    !$acc end serial\n  !$acc end data\n\n  DO y = 1, 10\n    temp = 0\n    DO x = 1, LOOPCOUNT\n      temp = temp + (a(x, y) + b(x, y))\n    END DO\n    IF (abs(d(x) - temp) .gt. (2 * PRECISION * LOOPCOUNT)) THEN\n      errors = errors + 1\n    END IF\n  END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "serial",
                            "private"
                        ],
                        "versions": [
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "serial_private.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:serial,private,V:2.6-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    n = 10;\n    real_t * a = (real_t *)malloc(10 * n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(10 * n * sizeof(real_t));\n    real_t * c = (real_t *)malloc(n * sizeof(real_t));\n    real_t * d = (real_t *)malloc(10 * sizeof(real_t));\n    real_t temp;\n\n    for (int x = 0; x < 10; ++x){\n        for (int y = 0; y < n; ++y){\n            a[x * n + y] = rand() / (real_t)(RAND_MAX / 10);\n            b[x * n + y] = rand() / (real_t)(RAND_MAX / 10);\n            c[y] = 0.0;\n        }\n        d[x] = 0.0;\n    }\n\n    #pragma acc enter data copyin(a[0:10*n], b[0:10*n], d[0:10])\n    #pragma acc serial private(c[0:n])\n    {\n        #pragma acc loop gang\n        for (int x = 0; x < 10; ++x){\n            #pragma acc loop worker\n            for (int y = 0; y < n; ++y){\n                c[y] = a[x * n + y] + b[x * n + y];\n            }\n            #pragma acc loop seq\n            for (int y = 0; y < n; ++y){\n                d[x] += c[y];\n            }\n        }\n    }\n    #pragma acc exit data copyout(d[0:10]) delete(a[0:10*n], b[0:10*n])\n\n    for (int x = 0; x < 10; ++x){\n        temp = 0.0;\n        for (int y = 0; y < n; ++y){\n            temp += a[x * n + y] + b[x * n + y];\n        }\n        if (fabs(temp - d[x]) > (2 * PRECISION * n)){\n            err = 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "serial",
                            "private"
                        ],
                        "versions": [
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "serial_reduction.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:serial,reduction,V:2.6-2.7\n      LOGICAL FUNCTION test1()\n  IMPLICIT NONE\n  INCLUDE \"acc_testsuite.Fh\"\n  REAL(8),DIMENSION(LOOPCOUNT):: a\n  REAL(8):: reduction\n  INTEGER:: errors, x\n\n  errors = 0\n\n  SEEDDIM(1) = 1\n# ifdef SEED\n  SEEDDIM(1) = SEED\n# endif\n  CALL RANDOM_SEED(PUT=SEEDDIM)\n\n  CALL RANDOM_NUMBER(a)\n\n  !$acc serial copyin(a(1:LOOPCOUNT)) reduction(+:reduction)\n    !$acc loop\n    DO x = 1, LOOPCOUNT\n      reduction = reduction + a(x)\n    END DO\n  !$acc end serial\n\n  DO x = 1, LOOPCOUNT\n    reduction = reduction - a(x)\n  END DO\n\n  IF (abs(reduction) .gt. PRECISION) THEN\n    errors = errors + 1\n  END IF\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "serial",
                            "reduction"
                        ],
                        "versions": [
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "serial_reduction.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:serial,reduction,V:2.6-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(n * sizeof(real_t));\n    real_t reduction;\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n    }\n\n    #pragma acc serial copyin(a[0:n]) reduction(+:reduction)\n    {\n        #pragma acc loop\n        for (int x = 0; x < n; ++x){\n            reduction = reduction + a[x];\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        reduction = reduction - a[x];\n    }\n    if (fabs(reduction) > PRECISION){\n        err += 1;\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "serial",
                            "reduction"
                        ],
                        "versions": [
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "serial_scalar_default_firstprivate.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:,V:2.6-2.7\n      LOGICAL FUNCTION test1()\n  IMPLICIT NONE\n  INCLUDE \"acc_testsuite.Fh\"\n  REAL(8),DIMENSION(LOOPCOUNT):: a, b\n  REAL(8):: scalar, scalar_copy\n  INTEGER:: x\n  INTEGER:: errors\n\n  errors = 0\n\n  SEEDDIM(1) = 1\n# ifdef SEED\n  SEEDDIM(1) = SEED\n# endif\n  CALL RANDOM_SEED(PUT=SEEDDIM)\n\n  CALL RANDOM_NUMBER(a)\n  b = 0\n  scalar = 5.5\n  scalar_copy = scalar\n\n  !$acc data copyin(a(1:LOOPCOUNT)) copyout(b(1:LOOPCOUNT))\n    !$acc serial\n      !$acc loop\n      DO x = 1, LOOPCOUNT\n        b(x) = a(x) + scalar\n      END DO\n    !$acc end serial\n  !$acc end data\n\n  DO x = 1, LOOPCOUNT\n    IF (abs(b(x) - (a(x) + scalar_copy)) .gt. PRECISION) THEN\n      errors = errors + 1\n    END IF\n  END DO\n\n  IF (abs(scalar_copy - scalar) .gt. PRECISION) THEN\n    errors = errors + 1\n  END IF\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            ""
                        ],
                        "versions": [
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "serial_scalar_default_firstprivate.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:data,default-mapping,serial,firstprivate,V:2.6-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n    real_t scalar = rand() / (real_t)(RAND_MAX / 10);\n    real_t scalar_copy = scalar;\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = 0.0;\n    }\n\n    #pragma acc data copyin(a[0:n]) copyout(b[0:n])\n    {\n        #pragma acc serial\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                b[x] = a[x] + scalar;\n            }\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        if (fabs(b[x] - (a[x] + scalar_copy)) > PRECISION){\n            err += 1;\n        }\n    }\n    if (fabs(scalar_copy - scalar) > PRECISION){\n        err += 1;\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "data",
                            "default-mapping",
                            "serial",
                            "firstprivate"
                        ],
                        "versions": [
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "serial_switch.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:,V:2.6-2.7\n      LOGICAL FUNCTION test1()\n  IMPLICIT NONE\n  INCLUDE \"acc_testsuite.Fh\"\n  INTEGER,DIMENSION(LOOPCOUNT):: a\n  REAL(8),DIMENSION(LOOPCOUNT):: a_randoms, b, b_host, c\n  INTEGER:: errors, x\n\n  errors = 0\n\n  SEEDDIM(1) = 1\n# ifdef SEED\n  SEEDDIM(1) = SEED\n# endif\n  CALL RANDOM_SEED(PUT=SEEDDIM)\n\n  CALL RANDOM_NUMBER(a_randoms)\n  CALL RANDOM_NUMBER(b)\n  c = 0\n  b_host = b\n\n  DO x = 1, LOOPCOUNT\n    a(x) = INT(a_randoms(x) * 4)\n  END DO\n\n  !$acc data copyin(a(1:LOOPCOUNT)) copy(b(1:LOOPCOUNT), c(1:LOOPCOUNT))\n    !$acc serial\n      !$acc loop\n      DO x = 1, LOOPCOUNT\n        SELECT CASE(a(x))\n        CASE (0)\n          c(x) = b(x) * b(x)\n        CASE (1)\n          c(x) = b(x) / b(x)\n        CASE (2)\n          b(x) = b(x) / 2\n        CASE DEFAULT\n          c(x) = a(x) + b(x)\n        END SELECT\n      END DO\n    !$acc end serial\n  !$acc end data\n\n  DO x = 1, LOOPCOUNT\n    SELECT CASE(a(x))\n    CASE(0)\n      IF (abs(c(x) - (b_host(x) * b_host(x))) .gt. PRECISION) THEN\n        errors = errors + 1\n      END IF\n    CASE(1)\n      IF (abs(c(x) - 1) .gt. PRECISION) THEN\n        errors = errors + 1\n      END IF\n    CASE(2)\n      IF (abs(c(x)) .gt. PRECISION) THEN\n        errors = errors + 1\n      END IF\n      IF (abs(b(x) - (b_host(x) / 2)) .gt. PRECISION) THEN\n        errors = errors + 1\n      END IF\n    CASE DEFAULT\n      IF (abs(c(x) - (b_host(x) + a(x))) .gt. PRECISION) THEN\n        errors = errors + 1\n      END IF\n    END SELECT\n  END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            ""
                        ],
                        "versions": [
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "serial_switch.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:serial,V:2.6-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    int * a = (int *)malloc(n * sizeof(int));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n    real_t * b_host = (real_t *)malloc(n * sizeof(real_t));\n    real_t * c = (real_t *)malloc(n * sizeof(real_t));\n\n    for (int x = 0; x < n; ++x){\n        a[x] = floor(rand() / (real_t)(RAND_MAX / 10));\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n        b_host[x] = b[x];\n        c[x] = 0.0;\n    }\n    #pragma acc enter data copyin(a[0:n], b[0:n], c[0:n])\n    #pragma acc serial present(a[0:n], b[0:n], c[0:n])\n    {\n        #pragma acc loop\n        for (int x = 0; x < n; ++x){\n            switch(a[x]){\n                case 0:\n                    c[x] = b[x] * b[x];\n                    break;\n                case 1:\n                    c[x] = b[x] / b[x];\n                    break;\n                case 2:\n                    b[x] = b[x] / 2;\n                default:\n                    c[x] = a[x] + b[x];\n\n\n            }\n        }\n    }\n    #pragma acc exit data delete(a[0:n], b[0:n]) copyout(c[0:n])\n\n    real_t tempc = 0.0;\n    for (int x = 0; x < n; ++x){\n        switch(a[x]){\n            case 0:\n                tempc = b_host[x] * b_host[x];\n                break;\n            case 1:\n                tempc = b_host[x] / b_host[x];\n                break;\n            case 2:\n                b_host[x] = b_host[x] / 2;\n            default:\n                tempc = a[x] + b_host[x];\n        }\n        if (fabs(c[x] - tempc) > PRECISION){\n            err = 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "serial"
                        ],
                        "versions": [
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "serial_wait.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:async,serial,update,V:2.6-2.7\n      LOGICAL FUNCTION test1()\n  IMPLICIT NONE\n  INCLUDE \"acc_testsuite.Fh\"\n  REAL(8),DIMENSION(LOOPCOUNT):: a, a_copy\n  INTEGER:: errors, x\n\n  errors = 0\n\n  SEEDDIM(1) = 1\n# ifdef SEED\n  SEEDDIM(1) = SEED\n# endif\n  CALL RANDOM_SEED(PUT=SEEDDIM)\n\n  CALL RANDOM_NUMBER(a)\n  a_copy = a\n\n  !$acc enter data create(a(1:LOOPCOUNT))\n  !$acc update device(a(1:LOOPCOUNT)) async(1)\n  !$acc serial present(a(1:lOOPCOUNT)) wait(1)\n    !$acc loop\n    DO x = 1, LOOPCOUNT\n      a(x) = a(x) + 1\n    END DO\n  !$acc end serial\n  !$acc exit data copyout(a(1:LOOPCOUNT))\n\n  DO x = 1, LOOPCOUNT\n    IF (abs(a(x) - (a_copy(x) + 1)) .gt. PRECISION) THEN\n      errors = errors + 1\n    END IF\n  END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "async",
                            "serial",
                            "update"
                        ],
                        "versions": [
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "serial_wait.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:serial,data,executable-data,async,wait,V:2.6-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t *a = (real_t *)malloc(n * sizeof(real_t));\n    real_t *b = (real_t *)malloc(n * sizeof(real_t));\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = a[x];\n    }\n\n    #pragma acc enter data create(a[0:n])\n    #pragma acc update device(a[0:n]) async(1)\n    #pragma acc serial present(a[0:n]) wait(1)\n    {\n        #pragma acc loop\n        for (int x = 0; x < n; ++x){\n            a[x] += 1;\n        }\n    }\n    #pragma acc exit data copyout(a[0:n])\n    for (int x = 0; x < n; ++x){\n        if (fabs(a[x] - (b[x] + 1)) > PRECISION){\n            err = 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "serial",
                            "data",
                            "executable-data",
                            "async",
                            "wait"
                        ],
                        "versions": [
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "serial_while_loop.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:reduction,loop,V:2.6-2.7\n      LOGICAL FUNCTION test1()\n  IMPLICIT NONE\n  INCLUDE \"acc_testsuite.Fh\"\n  REAL(8),DIMENSION(LOOPCOUNT, 10):: a\n  REAL(8):: avg\n  INTEGER:: errors, x, y\n\n  errors = 0\n\n  SEEDDIM(1) = 1\n# ifdef SEED\n  SEEDDIM(1) = SEED\n# endif\n  CALL RANDOM_SEED(PUT=SEEDDIM)\n\n  CALL RANDOM_NUMBER(a)\n\n  !$acc data copy(a(1:LOOPCOUNT, 1:10))\n    !$acc serial\n      !$acc loop\n      DO y = 1, 10\n        avg = 0\n        DO WHILE (avg .lt. 1000)\n          avg = 0\n          !$acc loop reduction(+:avg)\n          DO x = 1, LOOPCOUNT\n            a(x, y) = a(x, y) * 1.5\n            avg = avg + (a(x, y) / LOOPCOUNT)\n          END DO\n        END DO\n      END DO\n    !$acc end serial\n  !$acc end data\n\n  DO y = 1, 10\n    avg = 0\n    DO x = 1, LOOPCOUNT\n      avg = avg + (a(x, y) / LOOPCOUNT)\n    END DO\n    IF ((avg .lt. 1000) .or. (avg .gt. 1500)) THEN\n      errors = errors + 1\n    END IF\n  END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "reduction",
                            "loop"
                        ],
                        "versions": [
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "serial_while_loop.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:serial,reduction,V:2.6-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(10 * n * sizeof(real_t));\n    real_t avg = 0.0;\n\n    for (int x = 0; x < 10 * n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n    }\n\n    #pragma acc data copy(a[0:10*n])\n    {\n        #pragma acc serial\n        {\n            #pragma acc loop\n            for (int y = 0; y < 10; ++y){\n                avg = 0.0;\n                while (avg - 1000 < PRECISION * n){\n                    avg = 0.0;\n                    #pragma acc loop reduction(+:avg)\n                    for (int x = 0; x < n; ++x){\n                        a[n * y + x] *= 1.5;\n                        avg += a[n * y + x] / n;\n                    }\n                }\n            }\n        }\n    }\n\n    for (int y = 0 y < 10; ++y){\n        avg = 0.0;\n        for (int x = 0; x < n; ++x){\n            avg += a[y * n + x]/n;\n        }\n\n        if (avg < 1000 || avg > 1500){\n            err = 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "serial",
                            "reduction"
                        ],
                        "versions": [
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "set_default_async.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:async,construct-independent,internal-control-values,set,V:2.5-2.7\n      LOGICAL FUNCTION test1()\n        USE OPENACC\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT):: a, b, c, a_host, b_host !Data\n        REAL(8) :: RAND\n        INTEGER :: errors = 0\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(a)\n        CALL RANDOM_NUMBER(b)\n        a_host = a\n        b_host = b\n        c = 0\n\n        !$acc data copyin(a(1:LOOPCOUNT), b(1:LOOPCOUNT)) copyout(c(1:LOOPCOUNT))\n          !$acc set default_async(1)\n          !$acc parallel async\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              a(x) = a(x) * a(x)\n            END DO\n          !$acc end parallel\n          !$acc set default_async(2)\n          !$acc parallel async\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              b(x) = b(x) * b(x)\n            END DO\n          !$acc end parallel\n          !$acc parallel async(1) wait(2)\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              c(x) = a(x) + b(x)\n            END DO\n          !$acc end parallel\n          !$acc wait(1)\n        !$acc end data\n\n        DO x = 1, LOOPCOUNT\n          IF (abs(c(x) - (a_host(x) * a_host(x) + b_host(x) * b_host(x))) .gt. 4 * PRECISION) THEN\n            errors = errors + 1\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "async",
                            "construct-independent",
                            "internal-control-values",
                            "set"
                        ],
                        "versions": [
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "set_default_async.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:async,set,construct-independent,V:2.5-2.7\nint test1(){\n    int err = 0;\n    real_t *a = (real_t *)malloc(n * sizeof(real_t));\n    real_t *b = (real_t *)malloc(n * sizeof(real_t));\n    real_t *c = (real_t *)malloc(n * sizeof(real_t));\n    real_t *a_host = (real_t *)malloc(n * sizeof(real_t));\n    real_t *b_host = (real_t *)malloc(n * sizeof(real_t));\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n        c[x] = 0;\n        a_host[x] = a[x];\n        b_host[x] = b[x];\n    }\n\n    #pragma acc data copyin(a[0:n], b[0:n]) copyout(c[0:n])\n    {\n        #pragma acc set default_async(1)\n        #pragma acc parallel async\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                a[x] = a[x] * a[x];\n            }\n        }\n        #pragma acc set default_async(2)\n        #pragma acc parallel async\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                b[x] = b[x] * b[x];\n            }\n        }\n        #pragma acc parallel async(1) wait(2)\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                c[x] = a[x] + b[x];\n            }\n        }\n        #pragma acc wait(1)\n    }\n\n    for (int x = 0; x < n; ++x){\n        if (fabs(c[x] - (a_host[x] * a_host[x] + b_host[x] * b_host[x])) > 4*PRECISION){\n            err += 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "async",
                            "set",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "set_device_num.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:runtime,construct-independent,internal-control-values,set,V:2.5-2.7\n      LOGICAL FUNCTION test1()\n        USE OPENACC\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x, y !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT):: a !Data\n        REAL(8),DIMENSION(:, :),ALLOCATABLE :: host_copy\n        REAL(8) :: RAND\n        INTEGER :: errors = 0\n        INTEGER :: temp\n\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        ALLOCATE(host_copy(acc_get_num_devices(acc_get_device_type()), LOOPCOUNT))\n\n        IF (acc_get_device_type() .ne. acc_device_none) THEN\n          !host_copy(acc_get_num_devices(acc_get_device_type()), LOOPCOUNT)\n          DO x = 1, acc_get_num_devices(acc_get_device_type())\n            CALL RANDOM_NUMBER(a)\n            host_copy(x, :) = a\n            !$acc set device_num(x)\n            !$acc enter data copyin(a(1:LOOPCOUNT))\n          END DO\n\n          DO x = 1, acc_get_num_devices(acc_get_device_type())\n            !$acc set device_num(x)\n            !$acc data present(a(1:LOOPCOUNT))\n              !$acc parallel\n                !$acc loop\n                DO y = 1, LOOPCOUNT\n                  a(y) = a(y) + 1\n                END DO\n              !$acc end parallel\n            !$acc end data\n          END DO\n\n          DO x = 1, acc_get_num_devices(acc_get_device_type())\n            !$acc set device_num(x)\n            !$acc exit data copyout(a(1:LOOPCOUNT))\n            temp = errors\n            DO y = 1, LOOPCOUNT\n              IF (abs(a(y) - (host_copy(x, y) + 1)) .gt. PRECISION) THEN\n                PRINT*, a(y)\n                PRINT*, host_copy(x, y)\n                errors = errors + 1\n              END IF\n            END DO\n            IF (temp .ne. errors) THEN\n              PRINT*, x\n            END IF\n          END DO\n        END IF\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "runtime",
                            "construct-independent",
                            "internal-control-values",
                            "set"
                        ],
                        "versions": [
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "set_device_num.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:set,devonly,runtime,construct-independent,V:2.5-2.7\nint test1(){\n    int err = 0;\n\n    if (acc_get_device_type() != acc_device_none){\n        real_t **host_copy = (real_t **)malloc(acc_get_num_devices(acc_get_device_type()) * sizeof(real_t *));\n        for (int x = 0; x < acc_get_num_devices(acc_get_device_type()); ++x){\n            host_copy[x] = (real_t *)malloc(n * sizeof(real_t));\n        }\n        real_t *a = (real_t *)malloc(n * sizeof(real_t));\n        for (int x = 0; x < acc_get_num_devices(acc_get_device_type()); ++x){\n            for (int y = 0; y < n; ++y){\n                a[y] = rand() / (real_t)(RAND_MAX / 10);\n                host_copy[x][y] = a[y];\n            }\n            #pragma acc set device_num(x)\n            #pragma acc enter data copyin(a[0:n])\n        }\n        for (int x = 0; x < acc_get_num_devices(acc_get_device_type()); ++x){\n            #pragma acc set device_num(x)\n            #pragma acc data present(a[0:n])\n            {\n                #pragma acc parallel\n                {\n                    #pragma acc loop\n                    for (int y = 0; y < n; ++y){\n                        a[y] = a[y] + 1;\n                    }\n                }\n            }\n        }\n        for (int x = 0; x < acc_get_num_devices(acc_get_device_type()); ++x){\n            #pragma acc set device_num(x)\n            #pragma acc exit data copyout(a[0:n])\n            for (int y = 0; y < n; ++y){\n                if (fabs(a[y] - (host_copy[x][y] + 1)) > PRECISION){\n                    err += 1;\n                }\n            }\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "set",
                            "devonly",
                            "runtime",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "set_device_type.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:runtime,construct-independent,internal-control-values,set,V:2.5-2.7\n      LOGICAL FUNCTION test1()\n        USE OPENACC\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: errors = 0\n        INTEGER :: device_type\n\n        device_type = acc_get_device_type()\n        !$acc set device_type(device_type)\n        IF (acc_get_device_type() .ne. device_type) THEN\n          errors = errors + 1\n        END IF\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "runtime",
                            "construct-independent",
                            "internal-control-values",
                            "set"
                        ],
                        "versions": [
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "set_device_type.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:set,runtime,syntactic,V:2.5-2.7\nint test1(){\n    int err = 0;\n\n    int device_type = acc_get_device_type();\n\n    #pragma acc set device_type(device_type)\n    if (acc_get_device_type() != device_type){\n        err += 1;\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "set",
                            "runtime",
                            "syntactic"
                        ],
                        "versions": [
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "shutdown.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:construct-independent,shutdown,nonvalidating,V:2.5-2.7\n      LOGICAL FUNCTION test1()\n        USE OPENACC\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: errors = 0\n\n        !$acc shutdown\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "construct-independent",
                            "shutdown",
                            "nonvalidating"
                        ],
                        "versions": [
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "shutdown.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:shutdown,V:2.5-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n\n    #pragma acc shutdown\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "shutdown"
                        ],
                        "versions": [
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "shutdown_device_num.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:runtime,construct-independent,internal-control-values,shutdown,nonvalidating,V:2.5-2.7\n      LOGICAL FUNCTION test1()\n        USE OPENACC\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: device_num\n        INTEGER :: device_type\n        INTEGER :: errors = 0\n\n        device_num = acc_get_device_num(acc_get_device_type())\n        !$acc shutdown device_num(device_num)\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "runtime",
                            "construct-independent",
                            "internal-control-values",
                            "shutdown",
                            "nonvalidating"
                        ],
                        "versions": [
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "shutdown_device_num.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:shutdown,runtime,syntactic,V:2.5-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    int device_num;\n\n    device_num = acc_get_device_num(acc_get_device_type());\n    #pragma acc shutdown device_num(device_num)\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "shutdown",
                            "runtime",
                            "syntactic"
                        ],
                        "versions": [
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "shutdown_device_type.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:runtime,construct-independent,internal-control-values,shutdown,nonvalidating,V:2.5-2.7\n      LOGICAL FUNCTION test1()\n        USE OPENACC\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: device_type\n        INTEGER :: errors = 0\n\n        device_type = acc_get_device_type()\n        !$acc shutdown device_type(device_type)\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "runtime",
                            "construct-independent",
                            "internal-control-values",
                            "shutdown",
                            "nonvalidating"
                        ],
                        "versions": [
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "shutdown_device_type.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:shutdown,runtime,syntactic,V:2.5-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    int device_type; \n\n    device_type = acc_get_device_type();\n    #pragma acc shutdown device_type(device_type)\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "shutdown",
                            "runtime",
                            "syntactic"
                        ],
                        "versions": [
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "shutdown_device_type_num.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:runtime,construct-independent,internal-control-values,shutdown,nonvalidating,V:2.5-2.7\n      LOGICAL FUNCTION test1()\n        USE OPENACC\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: device_num\n        INTEGER :: device_type\n        INTEGER :: errors = 0\n\n        device_type = acc_get_device_type()\n        device_num = acc_get_device_num(device_type)\n        !$acc shutdown device_type(device_num) device_num(device_num)\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "runtime",
                            "construct-independent",
                            "internal-control-values",
                            "shutdown",
                            "nonvalidating"
                        ],
                        "versions": [
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "shutdown_device_type_num.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:shutdown,runtime,syntactic,V:2.5-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    int device_type\n    int device_num\n\n    device_type = acc_get_device_type();\n    device_num = acc_get_device_num(device_type);\n    #pragma acc shutdown device_type(device_type) device_num(device_num)\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "shutdown",
                            "runtime",
                            "syntactic"
                        ],
                        "versions": [
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "shutdown_if.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:shutdown,V:3.0-3.1\nint test1(){\n    int err = 0;\n    srand(SEED);\n\n    #pragma acc shutdown if(1 == 1)\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "shutdown"
                        ],
                        "versions": []
                    }
                }
            },
            "template.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:construct-independent,V:1.0-2.7\n      LOGICAL FUNCTION test1()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT):: a, b, c !Data\n        REAL(8) :: RAND\n        INTEGER :: errors = 0\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(a)\n        CALL RANDOM_NUMBER(b)\n        c = 0\n\n        !$acc data copyin(a(1:LOOPCOUNT))\n          !$acc parallel\n\n          !$acc end parallel\n        !$acc end data\n        DO x = 1, LOOPCOUNT\n          IF (abs(a(x)) .gt. PRECISION) THEN\n            errors = errors + 1\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "construct-independent"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "wait.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:shutdown,V:3.0-3.1\nint test1(){\n    int err = 0;\n    srand(SEED);\n\n    #pragma acc wait(1)\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "shutdown"
                        ],
                        "versions": []
                    }
                }
            },
            "wait_async.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:shutdown,V:3.0-3.1\nint test1(){\n    int err = 0;\n    srand(SEED);\n\n    #pragma acc wait(1) async(1)\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "shutdown"
                        ],
                        "versions": []
                    }
                }
            },
            "wait_if.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:shutdown,V:3.0-3.1\nint test1(){\n    int err = 0;\n    srand(SEED);\n\n    #pragma acc wait(1) if(1 == 1)\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "shutdown"
                        ],
                        "versions": []
                    }
                }
            }
        }
    ]
};