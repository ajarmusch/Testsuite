var jsonResults = {
    "configs": [
        {
            "CC": "nvc",
            "CCFlags": [
                "-fast",
                "-acc",
                "-ta=tesla"
            ],
            "CC_ACC_Version": "2.7",
            "CPP": "nvcc",
            "CPPFlags": [
                "-fast",
                "-acc",
                "-ta=tesla"
            ],
            "CPP_ACC_Version": "2.7",
            "FC": "nvfortran",
            "FCFlags": [
                "-fast",
                "-acc",
                "-ta=tesla"
            ],
            "FC_ACC_Version": "2.7",
            "PostCompileCommands": [],
            "PostRunCommands": [],
            "PreCompileCommands": [],
            "PreRunCommands": [],
            "build_dir": "/host_pwd/OpenACCV-V/build",
            "config_id": -1,
            "config_name": "init_config.txt",
            "env": null,
            "exclude_tags": [],
            "exclude_tests": [
                "acc_testsuite.Fh",
                "acc_testsuite.h",
                "acc_testsuite_declare.h"
            ],
            "export_format": "html",
            "fast": false,
            "id": 1,
            "include_by_default": false,
            "include_tags": [],
            "include_tests": [],
            "keep_build_dir": false,
            "keep_mutated_tests": false,
            "keep_partial_results": false,
            "keep_policy": "on-error",
            "mutated_test_dir": "/host_pwd/OpenACCV-V/build/mutated_tests",
            "mutators": [],
            "partial": false,
            "partial_results_dir": "/host_pwd/OpenACCV-V/build/partial_results",
            "runtime_prefix": "",
            "seed": null,
            "system_name": null,
            "tag_evaluation": null,
            "test_dir": "/host_pwd/OpenACCV-V/Tests",
            "timeout": 10
        }
    ],
    "runs": {},
    "summary": {},
    "systems": [
        {
            "id": 1,
            "machine": "x86_64",
            "name": null,
            "node": "611973e638d5",
            "processor": "x86_64",
            "release": "5.4.0-77-generic",
            "version": "#86-Ubuntu SMP Thu Jun 17 02:35:03 UTC 2021"
        }
    ],
    "testsuites": [
        {
            "acc_async_test.F90": {
                "num tests": 3,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:runtime,async,construct-independent,V:2.0-2.7\n      LOGICAL FUNCTION test1()\n        USE OPENACC\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x, y !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT):: a, b, c, d, e !Data\n        INTEGER :: errors\n        errors = 0\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n        CALL RANDOM_NUMBER(a)\n        CALL RANDOM_NUMBER(b)\n        CALL RANDOM_NUMBER(d)\n        c = 0\n        e = 0\n        \n        !$acc enter data copyin(a(1:LOOPCOUNT), b(1:LOOPCOUNT)) create(c(1:LOOPCOUNT)) async(1)\n        !$acc enter data copyin(d(1:LOOPCOUNT)) create(e(1:LOOPCOUNT)) async(2)\n        !$acc parallel present(a(1:LOOPCOUNT), b(1:LOOPCOUNT), c(1:LOOPCOUNT)) async(1)\n          !$acc loop\n          DO x = 1, LOOPCOUNT\n            c(x) = a(x) + b(x)\n          END DO\n        !$acc end parallel\n        !$acc parallel present(c(1:LOOPCOUNT), d(1:LOOPCOUNT), e(1:LOOPCOUNT)) async(1) wait(2)\n          !$acc loop\n          DO x = 1, LOOPCOUNT\n            e(x) = c(x) + d(x)\n          END DO\n        !$acc end parallel\n        !$acc exit data copyout(e(1:LOOPCOUNT)) async(1)\n\n\n        DO WHILE (acc_async_test(1) .eqv. .FALSE.)\n          CONTINUE\n        END DO\n\n        DO x = 1, LOOPCOUNT\n          IF (abs(e(x) - (a(x) + b(x) + d(x))) .GT. PRECISION) THEN\n            errors = errors + 1\n          END IF\n        END DO\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n      LOGICAL :: test1\n#endif\n#ifndef T1\n      DO testrun = 1, NUM_TEST_CALLS\n        failed = failed .or. test1()\n      END DO\n      IF (failed) THEN\n        failcode = failcode + 2 ** 0\n        failed = .FALSE.\n      END IF\n#endif\n",
                        "tags": [
                            "runtime",
                            "async",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "2": {
                        "content": "#ifndef T2\n!T2:async,runtime,construct-independent,V:1.0-2.7\n      LOGICAL FUNCTION test2()\n        USE OPENACC\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x, y\n        REAL(8),DIMENSION(LOOPCOUNT):: a, b, c, d, e\n        INTEGER :: errors\n        errors = 0\n        \n        !Initialization\n        CALL RANDOM_SEED()\n        CALL RANDOM_NUMBER(a)\n        CALL RANDOM_NUMBER(b)\n        CALL RANDOM_NUMBER(d)\n        c = 0\n        e = 0\n\n        !$acc data copyin(a(1:LOOPCOUNT), b(1:LOOPCOUNT), d(1:LOOPCOUNT)) copyout(c(1:LOOPCOUNT), e(1:LOOPCOUNT))\n          !$acc parallel present(a(1:LOOPCOUNT), b(1:LOOPCOUNT), c(1:LOOPCOUNT)) async(1)\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              c(x) = a(x) + b(x)\n            END DO\n          !$acc end parallel\n          !$acc parallel present(c(1:LOOPCOUNT), d(1:LOOPCOUNT), e(1:LOOPCOUNT)) async(1)\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              e(x) = c(x) + d(x)\n            END DO\n          !$acc end parallel\n          DO WHILE (acc_async_test(1) .eqv. .FALSE.)\n            CONTINUE\n          END DO\n        !$acc end data\n\n        DO x = 1, LOOPCOUNT\n          IF (abs(e(x) - (a(x) + b(x) + d(x))) .GT. PRECISION) THEN\n            errors = errors + 1\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test2 = .FALSE.\n        ELSE\n          test2 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T2\n      LOGICAL :: test2\n#endif\n#ifndef T2\n      DO testrun = 1, NUM_TEST_CALLS\n        failed = failed .or. test2()\n      END DO\n      IF (failed) THEN\n        failcode = failcode + 2 ** 1\n        failed = .FALSE.\n      END IF\n#endif\n",
                        "tags": [
                            "async",
                            "runtime",
                            "construct-independent"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "3": {
                        "content": "#ifndef T3\n!T3:runtime,async,construct-independent,V:2.5-2.7\n      LOGICAL FUNCTION test3()\n        USE OPENACC\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x, y\n        REAL(8),DIMENSION(LOOPCOUNT):: a, b, c, d, e\n        INTEGER :: errors, async_val\n        INTEGER :: acc_get_default_async\n        async_val = acc_get_default_async()\n        errors = 0\n\n        !Initialization\n        CALL RANDOM_SEED()\n        CALL RANDOM_NUMBER(a)\n        CALL RANDOM_NUMBER(b)\n        CALL RANDOM_NUMBER(d)\n        c = 0\n        e = 0\n\n        !$acc data copyin(a(1:LOOPCOUNT), b(1:LOOPCOUNT), d(1:LOOPCOUNT)) copyout(c(1:LOOPCOUNT), e(1:LOOPCOUNT))\n          !$acc parallel present(a(1:LOOPCOUNT), b(1:LOOPCOUNT), c(1:LOOPCOUNT)) async\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              c(x) = a(x) + b(x)\n            END DO\n          !$acc end parallel\n          !$acc parallel present(c(1:LOOPCOUNT), d(1:LOOPCOUNT), e(1:LOOPCOUNT)) async\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              e(x) = c(x) + d(x)\n            END DO\n          !$acc end parallel\n          DO WHILE (acc_async_test(async_val) .eqv. .FALSE.)\n            CONTINUE\n          END DO\n        !$acc end data\n\n        DO x = 1, LOOPCOUNT\n          IF (abs(e(x) - (a(x) + b(x) + d(x))) .gt. PRECISION) THEN\n            errors = errors + 1\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test3 = .FALSE.\n        ELSE\n          test3 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T3\n      LOGICAL :: test3\n#endif\n#ifndef T3\n      DO testrun = 1, NUM_TEST_CALLS\n        failed = failed .or. test3()\n      END DO\n      IF (failed) THEN\n        failcode = failcode + 2 ** 2\n        failed = .FALSE.\n      END IF\n#endif\n",
                        "tags": [
                            "runtime",
                            "async",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "acc_async_test.c": {
                "num tests": 3,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:async,runtime,construct-independent,V:2.0-2.7\nint test1(){\n    int err = 0;\n    real_t *a = (real_t *)malloc(n * sizeof(real_t));\n    real_t *b = (real_t *)malloc(n * sizeof(real_t));\n    real_t *c = (real_t *)malloc(n * sizeof(real_t));\n    real_t *d = (real_t *)malloc(n * sizeof(real_t));\n    real_t *e = (real_t *)malloc(n * sizeof(real_t));\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n        c[x] = 0;\n        d[x] = rand() / (real_t)(RAND_MAX / 10);\n        e[x] = 0;\n    }\n\n    #pragma acc enter data copyin(a[0:n], b[0:n]) create(c[0:n]) async(1)\n    #pragma acc enter data copyin(d[0:n]) create(e[0:n]) async(2)\n    #pragma acc parallel present(a[0:n], b[0:n], c[0:n]) async(1)\n    {\n        #pragma acc loop\n        for (int x = 0; x < n; ++x){\n            c[x] = a[x] + b[x];\n        }\n    }\n    #pragma acc parallel present(c[0:n], d[0:n], e[0:n]) async(1) wait(2)\n    {\n        #pragma acc loop\n        for (int x = 0; x < n; ++x){\n            e[x] = c[x] + d[x];\n        }\n    }\n    #pragma acc exit data copyout(e[0:n]) async(1)\n\n    while (!acc_async_test(1));\n    for (int x = 0; x < n; ++x){\n        if (fabs(e[x] - (a[x] + b[x] + d[x])) > PRECISION){\n            err += 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "async",
                            "runtime",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "2": {
                        "content": "#ifndef T2\n//T2:async,runtime,construct-independent,V:1.0-2.7\nint test2(){\n    int err = 0;\n    real_t *a = (real_t *)malloc(n * sizeof(real_t));\n    real_t *b = (real_t *)malloc(n * sizeof(real_t));\n    real_t *c = (real_t *)malloc(n * sizeof(real_t));\n    real_t *d = (real_t *)malloc(n * sizeof(real_t));\n    real_t *e = (real_t *)malloc(n * sizeof(real_t));\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n        c[x] = 0;\n        d[x] = rand() / (real_t)(RAND_MAX / 10);\n        e[x] = 0;\n    }\n    #pragma acc data copyin(a[0:n], b[0:n], d[0:n]) create(c[0:n]) copyout(e[0:n])\n    {\n        #pragma acc parallel present(a[0:n], b[0:n], c[0:n]) async(1)\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x) {\n                c[x] = a[x] + b[x];\n            }\n        }\n        #pragma acc parallel present(c[0:n], d[0:n], e[0:n]) async(1)\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x) {\n                e[x] = c[x] + d[x];\n            }\n        }\n        while (!acc_async_test(1));\n    }\n\n    for (int x = 0; x < n; ++x) {\n        if (fabs(e[x] - (a[x] + b[x] + d[x])) > PRECISION) {\n            err += 1;\n        }\n    }\n    return err;\n}\n#endif\n#ifndef T2\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test2();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 1);\n    }\n#endif\n",
                        "tags": [
                            "async",
                            "runtime",
                            "construct-independent"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "3": {
                        "content": "#ifndef T3\n//T3:async,runtime,construct-independent,V:2.5-2.7\nint test3() {\n    int err = 0;\n    real_t* a = (real_t*)malloc(n * sizeof(real_t));\n    real_t* b = (real_t*)malloc(n * sizeof(real_t));\n    real_t* c = (real_t*)malloc(n * sizeof(real_t));\n    real_t* d = (real_t*)malloc(n * sizeof(real_t));\n    real_t* e = (real_t*)malloc(n * sizeof(real_t));\n    int async_val = acc_get_default_async();\n\n    for (int x = 0; x < n; ++x) {\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n        c[x] = 0;\n        d[x] = rand() / (real_t)(RAND_MAX / 10);\n        e[x] = 0;\n    }\n    #pragma acc data copyin(a[0:n], b[0:n], d[0:n]) create(c[0:n]) copyout(e[0:n])\n    {\n        #pragma acc parallel present(a[0:n], b[0:n], c[0:n]) async\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x) {\n                c[x] = a[x] + b[x];\n            }\n        }\n        #pragma acc parallel present(c[0:n], d[0:n], e[0:n]) async\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x) {\n                e[x] = c[x] + d[x];\n            }\n        }\n        while (!acc_async_test(async_val));\n    }\n\n    for (int x = 0; x < n; ++x) {\n        if (fabs(e[x] - (a[x] + b[x] + d[x])) > PRECISION) {\n            err += 1;\n        }\n    }\n    return err;\n}\n#endif\n#ifndef T3\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x) {\n        failed = failed + test3();\n    }\n    if (failed != 0) {\n        failcode = failcode + (1 << 2);\n    }\n#endif\n",
                        "tags": [
                            "async",
                            "runtime",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "acc_async_test_all.F90": {
                "num tests": 3,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:runtime,async,construct-independent,update,V:2.0-2.7\n      LOGICAL FUNCTION test1()\n        USE OPENACC\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x, y !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT, 10):: a, b, c, d, e !Data\n        INTEGER :: errors\n        errors = 0\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n        CALL RANDOM_NUMBER(a)\n        CALL RANDOM_NUMBER(b)\n        CALL RANDOM_NUMBER(d)\n        c = 0\n        e = 0\n\n        !$acc enter data create(a(1:LOOPCOUNT,1:10), b(1:LOOPCOUNT,1:10), c(1:LOOPCOUNT,1:10), d(1:LOOPCOUNT,1:10), e(1:LOOPCOUNT,1:10))\n        DO y = 1, 10\n          !$acc update device(a(1:LOOPCOUNT,y:y), b(1:LOOPCOUNT,y:y), d(1:LOOPCOUNT,y:y)) async(y)\n          !$acc parallel present(a(1:LOOPCOUNT,y:y), b(1:LOOPCOUNT,y:y), c(1:LOOPCOUNT,y:y)) async(y)\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              c(x, y) = a(x, y) + b(x, y)\n            END DO\n          !$acc end parallel\n          !$acc parallel present(c(1:LOOPCOUNT,y:y), d(1:LOOPCOUNT,y:y),e(1:LOOPCOUNT,y:y)) async(y)\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              e(x, y) = c(x, y) + d(x, y)\n            END DO\n          !$acc end parallel\n          !$acc update host(e(1:LOOPCOUNT,y:y)) async(y)\n        END DO\n\n        DO WHILE (acc_async_test_all() .eqv. .FALSE.)\n          CONTINUE\n        END DO\n\n        DO y = 1, 10\n          DO x = 1, LOOPCOUNT\n            IF (abs(e(x, y) - (a(x, y) + b(x, y) + d(x, y))) .GT. PRECISION) THEN\n              errors = errors + 1\n            END IF\n          END DO\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n      LOGICAL :: test1\n#endif\n#ifndef T1\n      DO testrun = 1, NUM_TEST_CALLS\n        failed = failed .or. test1()\n      END DO\n      IF (failed) THEN\n        failcode = failcode + 2 ** 0\n        failed = .FALSE.\n      END IF\n#endif\n",
                        "tags": [
                            "runtime",
                            "async",
                            "construct-independent",
                            "update"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "2": {
                        "content": "#ifndef T2\n!T2:async,runtime,construct-independent,V:1.0-2.7\n      LOGICAL FUNCTION test2()\n        USE OPENACC\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x, y !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT, 10):: a, b, c, d, e !Data\n        INTEGER :: errors\n        errors = 0\n\n        !Initialization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n        CALL RANDOM_NUMBER(a)\n        CALL RANDOM_NUMBER(b)\n        CALL RANDOM_NUMBER(d)\n        c = 0\n        e = 0\n\n        !$acc data copyin(a(1:LOOPCOUNT, 1:10), b(1:LOOPCOUNT,1:10), d(1:LOOPCOUNT, 1:10)) copyout(c(1:LOOPCOUNT, 1:10), e(1:LOOPCOUNT, 1:10))\n          DO x = 1, 10\n            !$acc parallel present(a(1:LOOPCOUNT, 1:10), b(1:LOOPCOUNT, 1:10), c(1:LOOPCOUNT, 1:10)) async(x)\n              !$acc loop\n              DO y = 1, LOOPCOUNT\n                c(y, x) = a(y, x) + b(y, x)\n              END DO\n            !$acc end parallel\n            !$acc parallel present(c(1:LOOPCOUNT, 1:10), d(1:LOOPCOUNT, 1:10), e(1:LOOPCOUNT, 1:10)) async(x)\n              !$acc loop\n              DO y = 1, LOOPCOUNT\n                e(y, x) = c(y, x) + d(y, x)\n              END DO\n            !$acc end parallel\n          END DO\n          DO WHILE (acc_async_test_all() .eqv. .FALSE.)\n            CONTINUE\n          END DO\n        !$acc end data\n\n        DO x = 1, 10\n          DO y = 1, LOOPCOUNT\n            IF (abs(e(y, x) - (a(y, x) + b(y, x) + d(y, x))) .gt. PRECISION) THEN\n              errors = errors + 1\n            END IF\n          END DO\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test2 = .FALSE.\n        ELSE\n          test2 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T2\n      LOGICAL :: test2\n#endif\n#ifndef T2\n      DO testrun = 1, NUM_TEST_CALLS\n        failed = failed .or. test2()\n      END DO\n      IF (failed) THEN\n        failcode = failcode + 2 ** 1\n        failed = .FALSE.\n      END IF\n#endif\n",
                        "tags": [
                            "async",
                            "runtime",
                            "construct-independent"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "3": {
                        "content": "#ifndef T3\n!T3:async,runtime,construct-independent,V:2.5-2.7\n      LOGICAL FUNCTION test3()\n        USE OPENACC\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x, y !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT, 10):: a, b, c, d, e !Data\n        INTEGER :: errors\n        errors = 0\n\n        !Initialization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n        CALL RANDOM_NUMBER(a)\n        CALL RANDOM_NUMBER(b)\n        CALL RANDOM_NUMBER(d)\n        c = 0\n        e = 0\n\n        !$acc data copyin(a(1:LOOPCOUNT, 1:10), b(1:LOOPCOUNT, 1:10), d(1:LOOPCOUNT, 1:10)) copyout(c(1:LOOPCOUNT, 1:10), e(1:LOOPCOUNT, 1:10))\n          DO x = 1, 10\n            CALL acc_set_default_async(x)\n            !$acc parallel present(a(1:LOOPCOUNT, 1:10), b(1:LOOPCOUNT, 1:10), c(1:LOOPCOUNT, 1:10)) async\n              !$acc loop\n              DO y = 1, LOOPCOUNT\n                c(y, x) = a(y, x) + b(y, x)\n              END DO\n            !$acc end parallel\n            !$acc parallel present(c(1:LOOPCOUNT, 1:10), d(1:LOOPCOUNT, 1:10), e(1:LOOPCOUNT, 1:10)) async\n              !$acc loop\n              DO y = 1, LOOPCOUNT\n                e(y, x) = c(y, x) + d(y, x)\n              END DO\n            !$acc end parallel\n          END DO\n          DO WHILE (acc_async_test_all() .eqv. .FALSE.)\n            CONTINUE\n          END DO\n        !$acc end data\n\n        DO x = 1, 10\n          DO y = 1, LOOPCOUNT\n            IF (abs(e(y, x) - (a(y, x) + b(y, x) + d(y, x))) .gt. PRECISION) THEN\n              errors = errors + 1\n            END IF\n          END DO\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test3 = .FALSE.\n        ELSE\n          test3 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T3\n      LOGICAL :: test3\n#endif\n#ifndef T3\n      DO testrun = 1, NUM_TEST_CALLS\n        failed = failed .or. test3()\n      END DO\n      IF (failed) THEN\n        failcode = failcode + 2 ** 2\n        failed = .FALSE.\n      END IF\n#endif\n",
                        "tags": [
                            "async",
                            "runtime",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "acc_async_test_all.c": {
                "num tests": 3,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:async,runtime,construct-independent,V:2.0-2.7\nint test1(){\n    int err = 0;\n    real_t **a = (real_t **)malloc(10 * sizeof(real_t*));\n    real_t **b = (real_t **)malloc(10 * sizeof(real_t*));\n    real_t **c = (real_t **)malloc(10 * sizeof(real_t*));\n    real_t **d = (real_t **)malloc(10 * sizeof(real_t*));\n    real_t **e = (real_t **)malloc(10 * sizeof(real_t*));\n\n    for (int x = 0; x < 10; ++x){\n        a[x] = (real_t *)malloc(n * sizeof(real_t));\n        b[x] = (real_t *)malloc(n * sizeof(real_t));\n        c[x] = (real_t *)malloc(n * sizeof(real_t));\n        d[x] = (real_t *)malloc(n * sizeof(real_t));\n        e[x] = (real_t *)malloc(n * sizeof(real_t));\n        for (int y = 0; y < n; ++y){\n            a[x][y] = rand() / (real_t)(RAND_MAX / 10);\n            b[x][y] = rand() / (real_t)(RAND_MAX / 10);\n            c[x][y] = 0;\n            d[x][y] = rand() / (real_t)(RAND_MAX / 10);\n            e[x][y] = 0;\n        }\n    }\n\n    #pragma acc enter data create(a[0:10][0:n], b[0:10][0:n], c[0:10][0:n], d[0:10][0:n], e[0:10][0:n])\n    for (int x = 0; x < 10; ++x){\n        #pragma acc update device(a[x:1][0:n], b[x:1][0:n], d[x:1][0:n]) async(x)\n        #pragma acc parallel present(a[x:1][0:n], b[x:1][0:n], c[x:1][0:n]) async(x)\n        {\n            #pragma acc loop\n            for (int y = 0; y < n; ++y){\n                c[x][y] = a[x][y] + b[x][y];\n            }\n        }\n        #pragma acc parallel present(c[x:1][0:n], d[x:1][0:n], e[x:1][0:n]) async(x)\n        {\n            #pragma acc loop\n            for (int y = 0; y < n; ++y){\n                e[x][y] = c[x][y] + d[x][y];\n            }\n        }\n        #pragma acc update host(e[x:1][0:n]) async(x)\n    }\n   \n    while(!acc_async_test_all());\n    for (int x = 0; x < 10; ++x){\n        for (int y = 0; y < n; ++y){\n            if (fabs(e[x][y] - (a[x][y] + b[x][y] + d[x][y])) > PRECISION){\n                err += 1;\n            }\n        }\n    }\n    #pragma acc exit data delete(a[0:10][0:n], b[0:10][0:n], c[0:10][0:n], d[0:10][0:n], e[0:10][0:n])\n    for (int x = 0; x < 10; ++x){\n        free(a[x]);\n        free(b[x]);\n        free(c[x]);\n        free(d[x]);\n        free(e[x]);\n    }\n    free(a);\n    free(b);\n    free(c);\n    free(d);\n    free(e);\n    \n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "async",
                            "runtime",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "2": {
                        "content": "#ifndef T2\n//T2:async,runtime,construct-independent,V:1.0-2.7\nint test2(){\n    int err = 0;\n    real_t *a = (real_t *)malloc(10 * n * sizeof(real_t));\n    real_t *b = (real_t *)malloc(10 * n * sizeof(real_t));\n    real_t *c = (real_t *)malloc(10 * n * sizeof(real_t));\n    real_t *d = (real_t *)malloc(10 * n * sizeof(real_t));\n    real_t *e = (real_t *)malloc(10 * n * sizeof(real_t));\n\n    for (int x = 0; x < 10*n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n        c[x] = 0;\n        d[x] = rand() / (real_t)(RAND_MAX / 10);\n        e[x] = 0;\n    }\n\n    #pragma acc data copyin(a[0:10*n], b[0:10*n], d[0:10*n]) copyout(c[0:10*n], e[0:10*n])\n    {\n        for (int x = 0; x < 10; ++x){\n            #pragma acc parallel present(a[0:10*n], b[0:10*n], c[0:10*n]) async(x)\n            {\n                #pragma acc loop\n                for (int y = 0; y < n; ++y){\n                    c[x * n + y] = a[x * n + y] + b[x * n + y];\n                }\n            }\n            #pragma acc parallel present(c[0:10*n], d[0:10*n], e[0:10*n]) async(x)\n            {\n                #pragma acc loop\n                for (int y = 0; y < n; ++y){\n                    e[x * n + y] = c[x * n + y] + d[x * n + y];\n                }\n            }\n        }\n        while(!acc_async_test_all());\n    }\n\n    for (int x = 0; x < 10*n; ++x){\n        if (fabs(e[x] - (a[x] + b[x] + d[x])) > PRECISION){\n            err += 1;\n        }\n    }\n    \n    free(a);\n    free(b);\n    free(c);\n    free(d);\n    free(e);\n    \n    return err;\n}\n#endif\n#ifndef T2\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test2();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 1);\n    }\n#endif\n",
                        "tags": [
                            "async",
                            "runtime",
                            "construct-independent"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "3": {
                        "content": "#ifndef T3\n//T3:async,runtime,construct-independent,V:2.5-2.7\nint test3(){\n    int err = 0;\n    real_t **a = (real_t **)malloc(10 * sizeof(real_t *));\n    real_t **b = (real_t **)malloc(10 * sizeof(real_t *));\n    real_t **c = (real_t **)malloc(10 * sizeof(real_t *));\n    real_t **d = (real_t **)malloc(10 * sizeof(real_t *));\n    real_t **e = (real_t **)malloc(10 * sizeof(real_t *));\n\n    for (int x = 0; x < 10; ++x){\n        a[x] = (real_t *)malloc(n * sizeof(real_t));\n        b[x] = (real_t *)malloc(n * sizeof(real_t));\n        c[x] = (real_t *)malloc(n * sizeof(real_t));\n        d[x] = (real_t *)malloc(n * sizeof(real_t));\n        e[x] = (real_t *)malloc(n * sizeof(real_t));\n        for (int y = 0; y < n; ++y){\n            a[x][y] = rand() / (real_t)(RAND_MAX / 10);\n            b[x][y] = rand() / (real_t)(RAND_MAX / 10);\n            c[x][y] = 0;\n            d[x][y] = rand() / (real_t)(RAND_MAX / 10);\n            e[x][y] = 0;\n        }\n    }\n\n    #pragma acc data copyin(a[0:10][0:n], b[0:10][0:n], d[0:10][0:n]) copyout(c[0:10][0:n], e[0:10][0:n])\n    {\n        for (int x = 0; x < 10; ++x){\n            acc_set_default_async(x);\n            #pragma acc parallel present(a[0:10][0:n], b[0:10][0:n], c[0:10][0:n]) async\n            {\n                #pragma acc loop\n                for (int y = 0; y < n; ++y){\n                    c[x][y] = a[x][y] + b[x][y];\n                }\n            }\n            #pragma acc parallel present(c[0:10][0:n], d[0:10][0:n], e[0:10][0:n]) async\n            {\n                #pragma acc loop\n                for (int y = 0; y < n; ++y){\n                    e[x][y] = c[x][y] + d[x][y];\n                }\n            }\n        }\n        while (!acc_async_test_all());\n    }\n\n    int count = 0;\n    int total = 0;\n    for (int x = 0; x < 10; ++x) {\n        for (int y = 0; y < n; ++y) {\n            if (fabs(e[x][y]) < PRECISION) {\n                count += 1;\n            }\n            total += 1;\n        }\n    }\n    printf(\"%d out of %d\\n\", count, total);\n\n    for (int x = 0; x < 10; ++x){\n        for (int y = 0; y < n; ++y){\n            if (fabs(e[x][y] - (a[x][y] + b[x][y] + d[x][y])) > PRECISION){\n                err += 1;\n            }\n        }\n    }\n    \n    for (int x = 0; x < 10; ++x){\n        free(a[x]);\n        free(b[x]);\n        free(c[x]);\n        free(d[x]);\n        free(e[x]);\n    }\n    free(a);\n    free(b);\n    free(c);\n    free(d);\n    free(e);\n    \n    return err;\n}\n#endif\n#ifndef T3\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test3();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 2);\n    }\n#endif\n",
                        "tags": [
                            "async",
                            "runtime",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "acc_copyin.F90": {
                "num tests": 7,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:runtime,data,executable-data,construct-independent,V:2.0-2.7\n      LOGICAL FUNCTION test1()\n        USE OPENACC\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT):: a, b, c !Data\n        INTEGER :: errors = 0\n\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n        CALL RANDOM_NUMBER(a)\n        CALL RANDOM_NUMBER(b)\n        c = 0\n\n        CALL acc_copyin(a(1:LOOPCOUNT))\n        CALL acc_copyin(b(1:LOOPCOUNT))\n\n        !$acc data copy(c(1:LOOPCOUNT))\n          !$acc parallel present(a(1:LOOPCOUNT), b(1:LOOPCOUNT))\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              c(x) = a(x) + b(x)\n            END DO\n          !$acc end parallel\n        !$acc end data\n\n        !$acc exit data copyout(a(1:LOOPCOUNT), b(1:LOOPCOUNT))\n\n        DO x = 1, LOOPCOUNT\n          IF (abs(c(x) - (a(x) + b(x))) .gt. PRECISION) THEN\n            errors = errors + 1\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END FUNCTION\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "runtime",
                            "data",
                            "executable-data",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "2": {
                        "content": "#ifndef T2\n!T2:runtime,data,executable-data,construct-independent,V:2.0-2.7\n      LOGICAL FUNCTION test2()\n        USE OPENACC\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT):: a, b, c !Data\n        INTEGER :: errors = 0\n\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n        CALL RANDOM_NUMBER(a)\n        CALL RANDOM_NUMBER(b)\n        c = 1\n\n        CALL acc_copyin(a(1:LOOPCOUNT))\n        CALL acc_copyin(b(1:LOOPCOUNT))\n\n        !$acc data copyout(c(1:LOOPCOUNT))\n          !$acc parallel present(a(1:LOOPCOUNT), b(1:LOOPCOUNT))\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              c(x) = a(x) + b(x)\n            END DO\n          !$acc end parallel\n        !$acc end data\n\n        CALL acc_copyout(a(1:LOOPCOUNT))\n        CALL acc_copyout(b(1:LOOPCOUNT))\n\n        DO x = 1, LOOPCOUNT\n          IF (abs(c(x) - (a(x) + b(x))) .gt. PRECISION) THEN\n            errors = errors + 1\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test2 = .FALSE.\n        ELSE\n          test2 = .TRUE.\n        END IF\n      END FUNCTION\n#endif\n#ifndef T2\n        LOGICAL :: test2\n#endif\n#ifndef T2\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test2()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 1\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "runtime",
                            "data",
                            "executable-data",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "3": {
                        "content": "#ifndef T3\n!T3:runtime,data,executable-data,devonly,construct-independent,V:2.5-2.7\n      LOGICAL FUNCTION test3()\n        USE OPENACC\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT):: a, b, c, a_copy, b_copy !Data\n        INTEGER :: errors = 0\n        LOGICAL,DIMENSION(1):: devtest\n\n        devtest(1) = .TRUE.\n        !$acc enter data copyin(devtest(1:1))\n        !$acc parallel present(devtest(1:1))\n          devtest(1) = .FALSE.\n        !$acc end parallel\n\n        IF (devtest(1) .eqv. .TRUE.) THEN\n          SEEDDIM(1) = 1\n#         ifdef SEED\n          SEEDDIM(1) = SEED\n#         endif\n          CALL RANDOM_SEED(PUT=SEEDDIM)\n          CALL RANDOM_NUMBER(a)\n          a_copy(:) = a(:)\n          CALL RANDOM_NUMBER(b)\n          b_copy(:) = b(:)\n          c = 0\n\n          CALL acc_copyin(a(1:LOOPCOUNT))\n          CALL acc_copyin(b(1:LOOPCOUNT))\n\n          a = 0\n          b = 0\n\n          !$acc data copyin(a(1:LOOPCOUNT), b(1:LOOPCOUNT)) copyout(c(1:LOOPCOUNT))\n            !$acc parallel\n              !$acc loop\n              DO x = 1, LOOPCOUNT\n                c(x) = a(x) + b(x)\n              END DO\n            !$acc end parallel\n          !$acc end data\n\n          !$acc exit data copyout(a(1:LOOPCOUNT), b(1:LOOPCOUNT))\n\n          DO x = 1, LOOPCOUNT\n            IF (abs(a(x) - a_copy(x)) .gt. PRECISION) THEN\n              errors = errors + 1\n            END IF\n            IF (abs(b(x) - b_copy(x)) .gt. PRECISION) THEN\n              errors = errors + 1\n            END IF\n            IF (abs(c(x) - (a(x) + b(x))) .gt. PRECISION) THEN\n              errors = errors + 1\n            END IF\n          END DO\n        END IF\n\n        IF (errors .eq. 0) THEN\n          test3 = .FALSE.\n        ELSE\n          test3 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T3\n        LOGICAL :: test3\n#endif\n#ifndef T3\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test3()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 2\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "runtime",
                            "data",
                            "executable-data",
                            "devonly",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "4": {
                        "content": "#ifndef T4\n!T4:runtime,executable-data,construct-independent,compatibility-features,V:2.0-2.7\n      LOGICAL FUNCTION test4()\n        USE OPENACC\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT):: a, b, c !Data\n        INTEGER :: errors = 0\n\n        !Initialization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n        CALL RANDOM_NUMBER(a)\n        CALL RANDOM_NUMBER(b)\n        c = 0\n\n        CALL acc_pcopyin(a(1:LOOPCOUNT))\n        CALL acc_pcopyin(b(1:LOOPCOUNT))\n\n        !$acc data copyout(c(1:LOOPCOUNT))\n          !$acc parallel present(a(1:LOOPCOUNT), b(1:LOOPCOUNT))\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              c(x) = a(x) + b(x)\n            END DO\n          !$acc end parallel\n        !$acc end data\n\n        !$acc exit data delete(a(1:LOOPCOUNT), b(1:LOOPCOUNT))\n\n        DO x = 1, LOOPCOUNT\n          IF (abs(c(x) - (a(x) + b(x))) .gt. PRECISION) THEN\n            errors = errors + 1\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test4 = .FALSE.\n        ELSE\n          test4 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T4\n        LOGICAL :: test4\n#endif\n#ifndef T4\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test4()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 3\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "runtime",
                            "executable-data",
                            "construct-independent",
                            "compatibility-features"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "5": {
                        "content": "#ifndef T5\n!T5:runtime,executable-data,construct-independent,compatibility-features,V:2.0-2.7\n      LOGICAL FUNCTION test5()\n        USE OPENACC\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT):: a, b, c !Data\n        INTEGER :: errors = 0\n\n        !Initialization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n        CALL RANDOM_NUMBER(a)\n        CALL RANDOM_NUMBER(b)\n        c = 0\n        \n        CALL acc_present_or_copyin(a(1:LOOPCOUNT))\n        CALL acc_present_or_copyin(b(1:LOOPCOUNT))\n\n        !$acc data copyout(c(1:LOOPCOUNT))\n          !$acc parallel present(a(1:LOOPCOUNT), b(1:LOOPCOUNT))\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              c(x) = a(x) + b(x)\n            END DO\n          !$acc end parallel\n        !$acc end data\n\n        !$acc exit data delete(a(1:LOOPCOUNT), b(1:LOOPCOUNT))\n\n        DO x = 1, LOOPCOUNT\n          IF (abs(c(x) - (a(x) + b(x))) .gt. PRECISION) THEN\n            errors = errors + 1\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test5 = .FALSE.\n        ELSE\n          test5 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T5\n        LOGICAL :: test5\n#endif\n#ifndef T5\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test5()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 4\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "runtime",
                            "executable-data",
                            "construct-independent",
                            "compatibility-features"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "6": {
                        "content": "#ifndef T6\n!T6:runtime,data,executable-data,construct-independent,reference-counting,V:2.5-2.7\n      LOGICAL FUNCTION test6()\n        USE OPENACC\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT):: a, b, c !Data\n        INTEGER :: errors = 0\n\n        !Initialization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n        CALL RANDOM_NUMBER(a)\n        CALL RANDOM_NUMBER(b)\n        c = 0\n\n        CALL acc_copyin(a(1:LOOPCOUNT))\n        CALL acc_copyin(a(1:LOOPCOUNT))\n        CALL acc_copyin(b(1:LOOPCOUNT))\n        CALL acc_copyin(b(1:LOOPCOUNT))\n\n        !$acc data copyout(c(1:LOOPCOUNT))\n          !$acc parallel present(a(1:LOOPCOUNT), b(1:LOOPCOUNT))\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              c(x) = a(x) + b(x)\n            END DO\n          !$acc end parallel\n        !$acc end data\n\n        !$acc exit data delete(a(1:LOOPCOUNT), b(1:LOOPCOUNT))\n        !$acc exit data delete(a(1:LOOPCOUNT), b(1:LOOPCOUNT))\n\n        DO x = 1, LOOPCOUNT\n          IF (abs(c(x) - (a(x) + b(x))) .gt. PRECISION) THEN\n            errors = errors + 1\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test6 = .FALSE.\n        ELSE\n          test6 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T6\n        LOGICAL :: test6\n#endif\n#ifndef T6\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test6()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 5\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "runtime",
                            "data",
                            "executable-data",
                            "construct-independent",
                            "reference-counting"
                        ],
                        "versions": [
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "7": {
                        "content": "#ifndef T7\n!T7:runtime,data,executable-data,construct-independent,reference-counting,devonly,V:2.5-2.7\n      LOGICAL FUNCTION test7()\n        USE OPENACC\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT):: a, b, c, a_copy, b_copy !Data\n        INTEGER :: errors = 0\n        LOGICAL,DIMENSION(1):: devtest\n\n        devtest(1) = .TRUE.\n        !$acc enter data copyin(devtest(1:1))\n        !$acc parallel present(devtest(1:1))\n          devtest(1) = .FALSE.\n        !$acc end parallel\n\n        IF (devtest(1) .eqv. .TRUE.) THEN\n          !Initialization\n          SEEDDIM(1) = 1\n#         ifdef SEED\n          SEEDDIM(1) = SEED\n#         endif\n          CALL RANDOM_SEED(PUT=SEEDDIM)\n          CALL RANDOM_NUMBER(a)\n          CALL RANDOM_NUMBER(b)\n          c = 0\n          a_copy = a\n          b_copy = b\n\n          CALL acc_copyin(a(1:LOOPCOUNT))\n          CALL acc_copyin(b(1:LOOPCOUNT))\n\n          a = 0\n          b = 0\n\n          CALL acc_copyin(a(1:LOOPCOUNT))\n          CALL acc_copyin(b(1:LOOPCOUNT))\n\n          !$acc data copyout(c(1:LOOPCOUNT))\n            !$acc parallel present(a(1:LOOPCOUNT), b(1:LOOPCOUNT))\n              !$acc loop\n              DO x = 1, LOOPCOUNT\n                c(x) = a(x) + b(x)\n              END DO\n            !$acc end parallel\n          !$acc end data\n\n          !$acc exit data delete(a(1:LOOPCOUNT), b(1:LOOPCOUNT))\n          !$acc exit data delete(a(1:LOOPCOUNT), b(1:LOOPCOUNT))\n\n          DO x = 1, LOOPCOUNT\n            IF (abs(c(x) - (a_copy(x) + b_copy(x))) .gt. PRECISION) THEN\n              errors = errors + 1\n            END IF\n          END DO\n        END IF\n\n        IF (errors .eq. 0) THEN\n          test7 = .FALSE.\n        ELSE\n          test7 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T7\n        LOGICAL :: test7\n#endif\n#ifndef T7\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test7()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 6\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "runtime",
                            "data",
                            "executable-data",
                            "construct-independent",
                            "reference-counting",
                            "devonly"
                        ],
                        "versions": [
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "acc_copyin.c": {
                "num tests": 7,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:runtime,data,executable-data,construct-independent,V:2.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n    real_t * c = (real_t *)malloc(n * sizeof(real_t));\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n        c[x] = 0.0;\n    }\n\n    acc_copyin(a, n * sizeof(real_t));\n    acc_copyin(b, n * sizeof(real_t));\n\n    #pragma acc data copy(c[0:n])\n    {\n        #pragma acc parallel present(a[0:n], b[0:n])\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                c[x] = a[x] + b[x];\n            }\n        }\n    }\n\n    acc_copyout(a, n * sizeof(real_t));\n    acc_copyout(b, n * sizeof(real_t));\n\n    for (int x = 0; x < n; ++x){\n        if (fabs(c[x] - (a[x] + b[x])) > PRECISION){\n            err += 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "runtime",
                            "data",
                            "executable-data",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "2": {
                        "content": "#ifndef T2\n//T2:runtime,data,executable-data,construct-independent,V:2.0-2.7\nint test2(){\n    int err = 0;\n    srand(time(NULL));\n    real_t * a = (real_t *)malloc(n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n    real_t * c = (real_t *)malloc(n * sizeof(real_t));\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n        c[x] = 0.0;\n    }\n\n    acc_copyin(a, n * sizeof(real_t));\n    acc_copyin(b, n * sizeof(real_t));\n\n    #pragma acc data copy(c[0:n])\n    {\n        #pragma acc parallel present(a[0:n], b[0:n])\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                c[x] = a[x] + b[x];\n            }\n        }\n    }\n\n    #pragma acc exit data copyout(a[0:n], b[0:n])\n\n    for (int x = 0; x < n; ++x){\n        if (fabs(c[x] - (a[x] + b[x])) > PRECISION){\n            err += 1;\n        }\n    }\n    return err;\n}\n#endif\n#ifndef T2\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test2();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 1);\n    }\n#endif\n",
                        "tags": [
                            "runtime",
                            "data",
                            "executable-data",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "3": {
                        "content": "#ifndef T3\n//T3:runtime,data,executable-data,devonly,construct-independent,reference-counting,V:2.5-2.7\nint test3(){\n    int err = 0;\n    srand(time(NULL));\n    real_t * a = (real_t *)malloc(n * sizeof(real_t));\n    real_t * a_copy = (real_t *)malloc(n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n    real_t * b_copy = (real_t *)malloc(n * sizeof(real_t));\n    real_t * c = (real_t *)malloc(n * sizeof(real_t));\n    int * dev_test = (int *)malloc(n * sizeof(int));\n\n    dev_test[0] = 1;\n    #pragma acc enter data copyin(dev_test[0:1])\n    #pragma acc parallel present(dev_test[0:1])\n    {\n        dev_test[0] = 0;\n    }\n\n    if (dev_test[0] == 1){\n        for (int x = 0; x < n; ++x){\n            a[x] = rand() / (real_t)(RAND_MAX / 10);\n            a_copy[x] = a[x];\n            b[x] = rand() / (real_t)(RAND_MAX / 10);\n            b_copy[x] = b[x];\n            c[x] = 0.0;\n        }\n\n        acc_copyin(a, n * sizeof(real_t));\n        acc_copyin(b, n * sizeof(real_t));\n\n        for (int x = 0; x < n; ++x){\n            a[x] = 0;\n            b[x] = 0;\n        }\n\n        #pragma acc data copyin(a[0:n], b[0:n]) copyout(c[0:n])\n        {\n            #pragma acc parallel\n            {\n                #pragma acc loop\n                for (int x = 0; x < n; ++x){\n                    c[x] = a[x] + b[x];\n                }\n            }\n        }\n\n        acc_copyout(a, n * sizeof(real_t));\n        acc_copyout(b, n * sizeof(real_t));\n\n        for (int x = 0; x < n; ++x){\n            if (fabs(a[x] - a_copy[x]) > PRECISION){\n                err += 1;\n            }\n            if (fabs(b[x] - b_copy[x]) > PRECISION){\n                err += 1;\n            }\n            if (fabs(c[x] - (a[x] + b[x])) > PRECISION){\n                err += 1;\n            }\n        }\n    }\n    return err;\n}\n#endif\n#ifndef T3\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test3();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 2);\n    }\n#endif\n",
                        "tags": [
                            "runtime",
                            "data",
                            "executable-data",
                            "devonly",
                            "construct-independent",
                            "reference-counting"
                        ],
                        "versions": [
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "4": {
                        "content": "#ifndef T4\n//T4:runtime,data,executable-data,construct-independent,compatibility-features,V:2.0-2.7\nint test4(){\n    int err = 0;\n    srand(time(NULL));\n    real_t * a = (real_t *)malloc(n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n    real_t * c = (real_t *)malloc(n * sizeof(real_t));\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n        c[x] = 0.0;\n    }\n\n    acc_pcopyin(a, n * sizeof(real_t));\n    acc_pcopyin(b, n * sizeof(real_t));\n\n    #pragma acc data copy(c[0:n])\n    {\n        #pragma acc parallel present(a[0:n], b[0:n])\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                c[x] = a[x] + b[x];\n            }\n        }\n    }\n\n    #pragma acc exit data delete(a[0:n], b[0:n])\n\n    for (int x = 0; x < n; ++x){\n        if (fabs(c[x] - (a[x] + b[x])) > PRECISION){\n            err += 1;\n        }\n    }\n    return err;\n}\n#endif\n#ifndef T4\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test4();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 3);\n    }\n#endif\n",
                        "tags": [
                            "runtime",
                            "data",
                            "executable-data",
                            "construct-independent",
                            "compatibility-features"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "5": {
                        "content": "#ifndef T5\n//T5:runtime,data,executable-data,construct-independent,compatibility-features,V:2.0-2.7\nint test5(){\n    int err = 0;\n    srand(time(NULL));\n    real_t * a = (real_t *)malloc(n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n    real_t * c = (real_t *)malloc(n * sizeof(real_t));\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n        c[x] = 0;\n    }\n\n    acc_present_or_copyin(a, n * sizeof(real_t));\n    acc_present_or_copyin(b, n * sizeof(real_t));\n\n    #pragma acc data copyout(c[0:n]) present(a[0:n], b[0:n])\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                c[x] = a[x] + b[x];\n            }\n        }\n    }\n\n    #pragma acc exit data delete(a[0:n], b[0:n])\n\n    for (int x = 0; x < n; ++x){\n        if (fabs(c[x] - (a[x] + b[x])) > PRECISION){\n            err += 1;\n        }\n    }\n    return err;\n}\n#endif\n#ifndef T5\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test5();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 4);\n    }\n#endif\n",
                        "tags": [
                            "runtime",
                            "data",
                            "executable-data",
                            "construct-independent",
                            "compatibility-features"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "6": {
                        "content": "#ifndef T6\n//T6:runtime,data,executable-data,construct-independent,reference-counting,V:2.5-2.7\nint test6() {\n    int err = 0;\n    srand(time(NULL));\n    real_t *a = (real_t *)malloc(n * sizeof(real_t));\n    real_t *b = (real_t *)malloc(n * sizeof(real_t));\n    real_t *c = (real_t *)malloc(n * sizeof(real_t));\n\n    for (int x = 0; x < n; ++x) {\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n        c[x] = 0;\n    }\n\n    acc_copyin(a, n * sizeof(real_t));\n    acc_copyin(a, n * sizeof(real_t));\n    acc_copyin(b, n * sizeof(real_t));\n    acc_copyin(b, n * sizeof(real_t));\n\n    #pragma acc data copyout(c[0:n])\n    {\n        #pragma acc parallel present(a[0:n], b[0:n])\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x) {\n                c[x] = a[x] + b[x];\n            }\n        }\n    }\n\n    #pragma acc exit data delete(a[0:n], b[0:n])\n    #pragma acc exit data delete(a[0:n], b[0:n])\n\n    for (int x = 0; x < n; ++x) {\n        if (fabs(c[x] - (a[x] + b[x])) > PRECISION) {\n            err += 1;\n        }\n    }\n    return err;\n}\n#endif\n#ifndef T6\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x) {\n        failed = failed + test6();\n    }\n    if (failed != 0) {\n        failcode = failcode + (1 << 5);\n    }\n#endif\n",
                        "tags": [
                            "runtime",
                            "data",
                            "executable-data",
                            "construct-independent",
                            "reference-counting"
                        ],
                        "versions": [
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "7": {
                        "content": "#ifndef T7\n//T7:runtime,data,executable-data,construct-independent,reference-counting,devonly,V:2.5-2.7\nint test7() {\n    int err = 0;\n    srand(time(NULL));\n    real_t *a = (real_t *)malloc(n * sizeof(real_t));\n    real_t *b = (real_t *)malloc(n * sizeof(real_t));\n    real_t *a_copy = (real_t *)malloc(n * sizeof(real_t));\n    real_t *b_copy = (real_t *)malloc(n * sizeof(real_t));\n    real_t *c = (real_t *)malloc(n * sizeof(real_t));\n    int * dev_test = (int *)malloc(n * sizeof(int));\n\n    dev_test[0] = 1;\n    #pragma acc enter data copyin(dev_test[0:1])\n    #pragma acc parallel present(dev_test[0:1])\n    {\n        dev_test[0] = 0;\n    }\n\n    if (dev_test[0] == 1){\n        for (int x = 0; x < n; ++x){\n            a[x] = rand() / (real_t)(RAND_MAX / 10);\n            b[x] = rand() / (real_t)(RAND_MAX / 10);\n            a_copy[x] = a[x];\n            b_copy[x] = b[x];\n            c[x] = 0;\n        }\n        \n        acc_copyin(a, n * sizeof(real_t));\n        acc_copyin(b, n * sizeof(real_t));\n\n        for (int x = 0; x < n; ++x){\n            a[x] = 0;\n            b[x] = 0;\n        }\n\n        acc_copyin(a, n * sizeof(real_t));\n        acc_copyin(b, n * sizeof(real_t));\n\n        #pragma acc data copyout(c[0:n])\n        {\n            #pragma acc parallel present(a[0:n], b[0:n])\n            {\n                #pragma acc loop\n                for (int x = 0; x < n; ++x){\n                    c[x] = a[x] + b[x];\n                }\n            }\n        }\n\n        #pragma acc exit data delete(a[0:n], b[0:n])\n        #pragma acc exit data delete(a[0:n], b[0:n])\n\n        for (int x = 0; x < n; ++x){\n            if (fabs(c[x] - (a_copy[x] + b_copy[x])) > PRECISION){\n                err += 1;\n            }\n        }\n    }\n    return err;\n}\n#endif\n#ifndef T7\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x) {\n        failed = failed + test7();\n    }\n    if (failed != 0) {\n        failcode = failcode + (1 << 6);\n    }\n#endif\n",
                        "tags": [
                            "runtime",
                            "data",
                            "executable-data",
                            "construct-independent",
                            "reference-counting",
                            "devonly"
                        ],
                        "versions": [
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "acc_copyin_async.F90": {
                "num tests": 5,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:runtime,data,executable-data,async,construct-independent,V:2.5-2.7\n      LOGICAL FUNCTION test1()\n        USE OPENACC\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT):: a, b, c, a_host, b_host !Data\n        REAL(8) :: RAND\n        INTEGER :: errors = 0\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n        CALL RANDOM_NUMBER(a)\n        CALL RANDOM_NUMBER(b)\n        c = 0\n        a_host = a\n        b_host = b\n\n        CALL acc_copyin_async(a(1:LOOPCOUNT), 1)\n        CALL acc_copyin_async(b(1:LOOPCOUNT), 2)\n\n        !$acc data copyout(c(1:LOOPCOUNT))\n          !$acc parallel async(1) present(a(1:LOOPCOUNT))\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              a(x) = a(x) * a(x)\n            END DO\n          !$acc end parallel\n          !$acc parallel async(2) present(b(1:LOOPCOUNT))\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              b(x) = b(x) * b(x)\n            END DO\n          !$acc end parallel\n          !$acc parallel async(2) wait(1) present(a(1:LOOPCOUNT), b(1:LOOPCOUNT))\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              c(x) = a(x) + b(x)\n            END DO\n          !$acc end parallel\n        !$acc end data\n        DO x = 1, LOOPCOUNT\n          IF (abs(c(x) - (a_host(x)*a_host(x) + b_host(x)*b_host(x))) .gt. PRECISION) THEN\n            errors = errors + 1\n          END IF\n        END DO\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n      LOGICAL :: test1\n#endif\n#ifndef T1\n      DO testrun = 1, NUM_TEST_CALLS\n        failed = failed .or. test1()\n      END DO\n      IF (failed) THEN\n        failcode = failcode + 2 ** 0\n        failed = .FALSE.\n      END IF\n#endif\n",
                        "tags": [
                            "runtime",
                            "data",
                            "executable-data",
                            "async",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "2": {
                        "content": "#ifndef T2\n!T2:runtime,data,executable-data,async,construct-independent,V:2.5-2.7\n      LOGICAL FUNCTION test2()\n        USE OPENACC\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT):: a, b, c, a_host, b_host !Data\n        REAL(8) :: RAND\n        INTEGER :: errors = 0\n\n        !Initialization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n        CALL RANDOM_NUMBER(a)\n        CALL RANDOM_NUMBER(b)\n        c = 0\n\n        CALL acc_copyin_async(a(1:LOOPCOUNT), 1)\n        CALL acc_copyin_async(b(1:LOOPCOUNT), 2)\n\n        !$acc data copyout(c(1:LOOPCOUNT))\n          DO WHILE (acc_async_test_all() .eqv. .FALSE.)\n            CONTINUE\n          END DO\n          !$acc parallel present(a(1:LOOPCOUNT), b(1:LOOPCOUNT))\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              c(x) = a(x) + b(x)\n            END DO\n          !$acc end parallel\n        !$acc end data\n\n        !$acc exit data delete(a(1:LOOPCOUNT), b(1:LOOPCOUNT))\n\n        DO x = 1, LOOPCOUNT\n          IF (abs(c(x) - (a(x) + b(x))) .gt. PRECISION) THEN\n            errors = errors + 1\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test2 = .FALSE.\n        ELSE\n          test2 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T2\n      LOGICAL :: test2\n#endif\n#ifndef T2\n      DO testrun = 1, NUM_TEST_CALLS\n        failed = failed .or. test2()\n      END DO\n      IF (failed) THEN\n        failcode = failcode + 2 ** 1\n        failed = .FALSE.\n      END IF\n#endif\n",
                        "tags": [
                            "runtime",
                            "data",
                            "executable-data",
                            "async",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "3": {
                        "content": "#ifndef T3\n!T3:runtime,data,executable-data,async,construct-independent,V:2.5-2.7\n      LOGICAL FUNCTION test3()\n        USE OPENACC\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT):: a, b, c !Data\n        REAL(8) :: RAND\n        INTEGER :: errors = 0\n\n        !Initialization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n        CALL RANDOM_NUMBER(a)\n        CALL RANDOM_NUMBER(b)\n        c = 0\n\n        CALL acc_copyin_async(a(1:LOOPCOUNT), 1)\n        CALL acc_copyin_async(b(1:LOOPCOUNT), 2)\n\n        !$acc data copyout(c(1:LOOPCOUNT))\n          !$acc wait\n          !$acc parallel present(a(1:LOOPCOUNT), b(1:LOOPCOUNT))\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              c(x) = a(x) + b(x)\n            END DO\n          !$acc end parallel\n        !$acc end data\n\n        !$acc exit data delete(a(1:LOOPCOUNT), b(1:LOOPCOUNT))\n\n        DO x = 1, LOOPCOUNT\n          IF (abs(c(x) - (a(x) + b(x))) .gt. PRECISION) THEN\n            errors = errors + 1\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test3 = .FALSE.\n        ELSE\n          test3 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T3\n      LOGICAL :: test3\n#endif\n#ifndef T3\n      DO testrun = 1, NUM_TEST_CALLS\n        failed = failed .or. test3()\n      END DO\n      IF (failed) THEN\n        failcode = failcode + 2 ** 2\n        failed = .FALSE.\n      END IF\n#endif\n",
                        "tags": [
                            "runtime",
                            "data",
                            "executable-data",
                            "async",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "4": {
                        "content": "#ifndef T4\n!T4:runtime,data,executable-data,async,construct-independent,reference-counting,V:2.5-2.7\n      LOGICAL FUNCTION test4()\n        USE OPENACC\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT):: a, b, c, d, e !Data\n        REAL(8) :: RAND\n        INTEGER :: errors = 0\n\n        !Initialization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n        CALL RANDOM_NUMBER(a)\n        CALL RANDOM_NUMBER(b)\n        c = 0\n        CALL RANDOM_NUMBER(d)\n        e = 0\n\n        !$acc enter data create(c(1:LOOPCOUNT))\n        !$acc data copyin(a(1:LOOPCOUNT), b(1:LOOPCOUNT), d(1:LOOPCOUNT)) copyout(e(1:LOOPCOUNT))\n          !$acc parallel present(c(1:LOOPCOUNT)) async(1)\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              c(x) = a(x) + b(x)\n            END DO\n          !$acc end parallel\n          CALL acc_copyin_async(c(1:LOOPCOUNT), 1)\n          !$acc exit data delete(c(1:LOOPCOUNT))\n          !$acc parallel present(c(1:LOOPCOUNT)) async(1)\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              e(x) = c(x) + d(x)\n            END DO\n          !$acc end parallel\n        !$acc end data\n        !$acc exit data copyout(c(1:LOOPCOUNT))\n\n        DO x = 1, LOOPCOUNT\n          IF (abs(c(x) - (a(x) + b(x))) .gt. PRECISION) THEN\n            errors = errors + 1\n          END IF\n          IF (abs(e(x) - (a(x) + b(x) + d(x))) .gt. PRECISION) THEN\n            errors = errors + 1\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test4 = .FALSE.\n        ELSE\n          test4 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T4\n      LOGICAL :: test4\n#endif\n#ifndef T4\n      DO testrun = 1, NUM_TEST_CALLS\n        failed = failed .or. test4()\n      END DO\n      IF (failed) THEN\n        failcode = failcode + 2 ** 3\n        failed = .FALSE.\n      END IF\n#endif\n",
                        "tags": [
                            "runtime",
                            "data",
                            "executable-data",
                            "async",
                            "construct-independent",
                            "reference-counting"
                        ],
                        "versions": [
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "5": {
                        "content": "#ifndef T5\n!T5:runtime,data,executable-data,async,construct-independent,reference-counting,V:2.5-2.7\n      LOGICAL FUNCTION test5()\n        USE OPENACC\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT):: a, b, c, a_copy, b_copy !Data\n        REAL(8) :: RAND\n        INTEGER :: errors = 0\n\n        !Initialization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n        CALL RANDOM_NUMBER(a)\n        a_copy = a\n        CALL RANDOM_NUMBER(b)\n        b_copy = b\n        c = 0\n\n        CALL acc_copyin_async(a(1:LOOPCOUNT), 1)\n        CALL acc_copyin_async(b(1:LOOPCOUNT), 2)\n\n        a = 0\n        b = 0\n\n        !$acc data copyin(a(1:LOOPCOUNT), b(1:LOOPCOUNT)) copyout(c(1:LOOPCOUNT))\n          !$acc wait\n          !$acc parallel\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              c(x) = a(x) + b(x)\n            END DO\n          !$acc end parallel\n        !$acc end data\n\n        !$acc exit data delete(a(1:LOOPCOUNT), b(1:LOOPCOUNT))\n\n        DO x = 1, LOOPCOUNT\n          IF (abs(c(x) - (a_copy(x) + b_copy(x))) .gt. PRECISION) THEN\n            errors = errors + 1\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test5 = .FALSE.\n        ELSE\n          test5 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T5\n      LOGICAL :: test5\n#endif\n#ifndef T5\n      DO testrun = 1, NUM_TEST_CALLS\n        failed = failed .or. test5()\n      END DO\n      IF (failed) THEN\n        failcode = failcode + 2 ** 4\n        failed = .FALSE.\n      END IF\n#endif\n",
                        "tags": [
                            "runtime",
                            "data",
                            "executable-data",
                            "async",
                            "construct-independent",
                            "reference-counting"
                        ],
                        "versions": [
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "acc_copyin_async.c": {
                "num tests": 5,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:async,data,executable-data,runtime,construct-independent,V:2.5-2.7\nint test1(){\n    int err = 0;\n    real_t *a = (real_t *)malloc(n * sizeof(real_t));\n    real_t *b = (real_t *)malloc(n * sizeof(real_t));\n    real_t *c = (real_t *)malloc(n * sizeof(real_t));\n    real_t *a_host = (real_t *)malloc(n * sizeof(real_t));\n    real_t *b_host = (real_t *)malloc(n * sizeof(real_t));\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n        c[x] = 0;\n        a_host[x] = a[x];\n        b_host[x] = b[x];\n    }\n\n    acc_copyin_async(a, n * sizeof(real_t), 1);\n    acc_copyin_async(b, n * sizeof(real_t), 2);\n    #pragma acc data copyout(c[0:n]) present(a[0:n], b[0:n])\n    {\n        #pragma acc parallel async(1)\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                a[x] = a[x] * a[x];\n            }\n        }\n        #pragma acc parallel async(2)\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                b[x] = b[x] * b[x];\n            }\n        }\n        #pragma acc parallel async(2) wait(1)\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                c[x] = a[x] + b[x];\n            }\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        if (fabs(c[x] - (a_host[x] * a_host[x] + b_host[x] * b_host[x])) > PRECISION * 4){\n            err += 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "async",
                            "data",
                            "executable-data",
                            "runtime",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "2": {
                        "content": "#ifndef T2\n//T2:runtime,data,executable-data,async,construct-independent,V:2.5-2.7\nint test2(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n    real_t * c = (real_t *)malloc(n * sizeof(real_t));\n    real_t * a_copy = (real_t *)malloc(n * sizeof(real_t));\n    real_t * b_copy = (real_t *)malloc(n * sizeof(real_t));\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n        c[x] = 1;\n    }\n\n    acc_copyin_async(a, n*sizeof(real_t), 1);\n    acc_copyin_async(b, n*sizeof(real_t), 2);\n\n    #pragma acc data copyout(c[0:n])\n    {\n        while (!acc_async_test_all());\n        #pragma acc parallel present(a[0:n], b[0:n])\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x) {\n                c[x] = a[x] + b[x];\n            }\n        }\n    }\n\n    #pragma acc exit data delete(a[0:n], b[0:n])\n\n    for (int x = 0; x < n; ++x) {\n        if (fabs(c[x] - (a[x] + b[x])) > PRECISION) {\n            err += 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T2\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test2();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 1);\n    }\n#endif\n",
                        "tags": [
                            "runtime",
                            "data",
                            "executable-data",
                            "async",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "3": {
                        "content": "#ifndef T3\n//T3:runtime,data,executable-data,async,construct-independent,V:2.5-2.7\nint test3(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n    real_t * c = (real_t *)malloc(n * sizeof(real_t));\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n        c[x] = 0;\n    }\n\n    acc_copyin_async(a, n * sizeof(real_t), 1);\n    acc_copyin_async(b, n * sizeof(real_t), 2);\n\n    #pragma acc data copyout(c[0:n])\n    {\n        #pragma acc wait\n        #pragma acc parallel present(a[0:n], b[0:n])\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x) {\n                c[x] = a[x] + b[x];\n            }\n        }\n    }\n\n    #pragma acc exit data delete(a[0:n], b[0:n])\n\n    for (int x = 0; x < n; ++x) {\n        if (fabs(c[x] - (a[x] + b[x])) > PRECISION) {\n            err = err + 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T3\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test3();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 2);\n    }\n#endif\n",
                        "tags": [
                            "runtime",
                            "data",
                            "executable-data",
                            "async",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "4": {
                        "content": "#ifndef T4\n//T4:runtime,data,executable-data,async,construct-independent,reference-counting,V:2.5-2.7\nint test4(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n    real_t * c = (real_t *)malloc(n * sizeof(real_t));\n    real_t * d = (real_t *)malloc(n * sizeof(real_t));\n    real_t * e = (real_t *)malloc(n * sizeof(real_t));\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n        c[x] = 0;\n        d[x] = rand() / (real_t)(RAND_MAX / 10);\n        e[x] = 0;\n    }\n\n    #pragma acc enter data create(c[0:n])\n    #pragma acc data copyin(a[0:n], b[0:n], d[0:n]) copyout(e[0:n])\n    {\n        #pragma acc parallel present(c[0:n]) async(1)\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x) {\n                c[x] = a[x] + b[x];\n            }\n        }\n        acc_copyin_async(c, n * sizeof(real_t), 1);\n        #pragma acc exit data delete(c[0:n]) async(1)\n        #pragma acc parallel present(c[0:n]) async(1)\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x) {\n                e[x] = c[x] + d[x];\n            }\n        }\n    }\n    #pragma acc wait\n    #pragma acc exit data copyout(c[0:n])\n\n    for (int x = 0; x < n; ++x) {\n        if (fabs(c[x] - (a[x] + b[x])) > PRECISION) {\n            err += 1;\n        }\n        if (fabs(e[x] - (a[x] + b[x] + d[x])) > PRECISION) {\n            err += 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T4\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test4();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 3);\n    }\n#endif\n",
                        "tags": [
                            "runtime",
                            "data",
                            "executable-data",
                            "async",
                            "construct-independent",
                            "reference-counting"
                        ],
                        "versions": [
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "5": {
                        "content": "#ifndef T5\n//T5:runtime,data,executable-data,async,construct-independent,reference-counting,V:2.5-2.7\nint test5(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n    real_t * c = (real_t *)malloc(n * sizeof(real_t));\n    real_t * a_copy = (real_t *)malloc(n * sizeof(real_t));\n    real_t * b_copy = (real_t *)malloc(n * sizeof(real_t));\n    int * devtest = (int *)malloc(sizeof(int));\n\n    devtest[0] = 0;\n    #pragma acc enter data copyin(devtest[0:1])\n    #pragma acc parallel present(devtest[0:1])\n    {\n        devtest[0] = 1;\n    }\n\n    if (devtest[0] == 0){\n        for (int x = 0; x < n; ++x){\n            a[x] = rand() / (real_t)(RAND_MAX / 10);\n            b[x] = rand() / (real_t)(RAND_MAX / 10);\n            c[x] = 0;\n            a_copy[x] = a[x];\n            b_copy[x] = b[x];\n        }\n\n        acc_copyin_async(a, n * sizeof(real_t), 1);\n        acc_copyin_async(b, n * sizeof(real_t), 2);\n\n        for (int x = 0; x < n; ++x) {\n            a[x] = 0;\n            b[x] = 0;\n        }\n\n        #pragma acc data copyin(a[0:n], b[0:n]) copyout(c[0:n])\n        {\n            #pragma acc wait\n            #pragma acc parallel\n            {\n                #pragma acc loop\n                for (int x = 0; x < n; ++x) {\n                    c[x] = a[x] + b[x];\n                }\n            }\n        }\n\n        #pragma acc exit data delete(a[0:n], b[0:n])\n\n        for (int x = 0; x < n; ++x) {\n            if (fabs(c[x] - (a_copy[x] + b_copy[x])) > PRECISION) {\n                err += 1;\n            }\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T5\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test5();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 4);\n    }\n#endif\n",
                        "tags": [
                            "runtime",
                            "data",
                            "executable-data",
                            "async",
                            "construct-independent",
                            "reference-counting"
                        ],
                        "versions": [
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "acc_copyin_async_with_len.F90": {
                "num tests": 5,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:runtime,data,executable-data,async,construct-independent,V:2.5-2.7\n      LOGICAL FUNCTION test1()\n        USE OPENACC\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT):: a, b, c, a_host, b_host !Data\n        INTEGER :: errors\n        errors = 0\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n        CALL RANDOM_NUMBER(a)\n        CALL RANDOM_NUMBER(b)\n        c = 0\n        a_host = a\n        b_host = b\n\n        CALL acc_copyin_async(a(1), LOOPCOUNT*8, 1)\n        CALL acc_copyin_async(b(1), LOOPCOUNT*8, 2)\n\n        !$acc data copyout(c(1:LOOPCOUNT)) present(a(1:LOOPCOUNT), b(1:LOOPCOUNT))\n          !$acc parallel async(1)\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              a(x) = a(x) * a(x)\n            END DO\n          !$acc end parallel\n          !$acc parallel async(2)\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              b(x) = b(x) * b(x)\n            END DO\n          !$acc end parallel\n          !$acc parallel wait(1, 2)\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              c(x) = a(x) + b(x)\n            END DO\n          !$acc end parallel\n        !$acc end data\n\n        DO x = 1, LOOPCOUNT\n          IF (abs(c(x) - (a_host(x)*a_host(x) + b_host(x)*b_host(x))) .gt. 4*PRECISION) THEN\n            errors = errors + 1\n          END IF\n        END DO\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "runtime",
                            "data",
                            "executable-data",
                            "async",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "2": {
                        "content": "#ifndef T2\n!T2:runtime,data,executable-data,async,construct-independent,V:2.5-2.7\n      LOGICAL FUNCTION test2()\n        USE OPENACC\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT):: a, b, c !Data\n        INTEGER :: errors\n        errors = 0\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n        CALL RANDOM_NUMBER(a)\n        CALL RANDOM_NUMBER(b)\n        c = 0\n\n        CALL acc_copyin_async(a(1), LOOPCOUNT*8, 1)\n        CALL acc_copyin_async(b(1), LOOPCOUNT*8, 2)\n\n        !$acc data copyout(c(1:LOOPCOUNT))\n          DO WHILE (acc_async_test_all() .eqv. .FALSE.)\n            CONTINUE\n          END DO\n          !$acc parallel present(a(1:LOOPCOUNT), b(1:LOOPCOUNT))\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              c(x) = a(x) + b(x)\n            END DO\n          !$acc end parallel\n        !$acc end data\n\n        !$acc exit data delete(a(1:LOOPCOUNT), b(1:LOOPCOUNT))\n\n        DO x = 1, LOOPCOUNT\n          IF (abs(c(x) - (a(x) + b(x))) .gt. PRECISION) THEN\n            errors = errors + 1\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test2 = .FALSE.\n        ELSE\n          test2 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T2\n        LOGICAL :: test2\n#endif\n#ifndef T2\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test2()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 1\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "runtime",
                            "data",
                            "executable-data",
                            "async",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "3": {
                        "content": "#ifndef T3\n!T3:runtime,data,executable-data,async,construct-independent,V:2.5-2.7\n      LOGICAL FUNCTION test3()\n        USE OPENACC\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT):: a, b, c !Data\n        INTEGER :: errors\n        errors = 0\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n        CALL RANDOM_NUMBER(a)\n        CALL RANDOM_NUMBER(b)\n        c = 0\n\n        CALL acc_copyin_async(a(1), LOOPCOUNT*8, 1)\n        CALL acc_copyin_async(b(1), LOOPCOUNT*8, 2)\n\n        !$acc data copyout(c(1:LOOPCOUNT))\n          !$acc wait\n          !$acc parallel present(a(1:LOOPCOUNT), b(1:LOOPCOUNT))\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              c(x) = a(x) + b(x)\n            END DO\n          !$acc end parallel\n        !$acc end data\n\n        !$acc exit data delete(a(1:LOOPCOUNT), b(1:LOOPCOUNT))\n\n        DO x = 1, LOOPCOUNT\n          IF (abs(c(x) - (a(x) + b(x))) .gt. PRECISION) THEn\n            errors = errors + 1\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test3 = .FALSE.\n        ELSE\n          test3 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T3\n        LOGICAL :: test3\n#endif\n#ifndef T3\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test3()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 2\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "runtime",
                            "data",
                            "executable-data",
                            "async",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "4": {
                        "content": "#ifndef T4\n!T4:runtime,data,executable-data,async,construct-independent,reference-counting,V:2.5-2.7\n      LOGICAL FUNCTION test4()\n        USE OPENACC\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT):: a, b, c, d, e !Data\n        REAL(8) :: RAND\n        INTEGER :: errors = 0\n\n        !Initialization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n        CALL RANDOM_NUMBER(a)\n        CALL RANDOM_NUMBER(b)\n        c = 0\n        CALL RANDOM_NUMBER(d)\n        e = 0\n\n        !$acc enter data create(c(1:LOOPCOUNT))\n        !$acc data copyin(a(1:LOOPCOUNT), b(1:LOOPCOUNT), d(1:LOOPCOUNT)) copyout(e(1:LOOPCOUNT))\n          !$acc parallel present(c(1:LOOPCOUNT)) async(1)\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              c(x) = a(x) + b(x)\n            END DO\n          !$acc end parallel\n          CALL acc_copyin_async(c(1), LOOPCOUNT*8, 1)\n          !$acc exit data delete(c(1:LOOPCOUNT))\n          !$acc parallel present(c(1:LOOPCOUNT)) async(1)\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              e(x) = c(x) + d(x)\n            END DO\n          !$acc end parallel\n        !$acc end data\n        !$acc exit data copyout(c(1:LOOPCOUNT))\n\n        DO x = 1, LOOPCOUNT\n          IF (abs(c(x) - (a(x) + b(x))) .gt. PRECISION) THEN\n            errors = errors + 1\n          END IF\n          IF (abs(e(x) - (a(x) + b(x) + d(x))) .gt. PRECISION) THEN\n            errors = errors + 1\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test4 = .FALSE.\n        ELSE\n          test4 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T4\n        LOGICAL :: test4\n#endif\n#ifndef T4\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test4()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 3\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "runtime",
                            "data",
                            "executable-data",
                            "async",
                            "construct-independent",
                            "reference-counting"
                        ],
                        "versions": [
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "5": {
                        "content": "#ifndef T5\n!T5:runtime,data,executable-data,async,construct-independent,reference-counting,V:2.5-2.7\n      LOGICAL FUNCTION test5()\n        USE OPENACC\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT):: a, b, c !Data\n        REAL(8) :: RAND\n        INTEGER :: errors = 0\n\n        !Initialization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n        CALL RANDOM_NUMBER(a)\n        CALL RANDOM_NUMBER(b)\n        c = 0\n\n        CALL acc_copyin_async(a(1), LOOPCOUNT*8, 1)\n        CALL acc_copyin_async(b(1), LOOPCOUNT*8, 2)\n\n        !$acc data create(a(1:LOOPCOUNT), b(1:LOOPCOUNT)) copyout(c(1:LOOPCOUNT))\n          !$acc wait\n          !$acc parallel\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              c(x) = a(x) + b(x)\n            END DO\n          !$acc end parallel\n        !$acc end data\n\n        !$acc exit data delete(a(1:LOOPCOUNT), b(1:LOOPCOUNT))\n\n        DO x = 1, LOOPCOUNT\n          IF (abs(c(x) - (a(x) + b(x))) .gt. PRECISION) THEN\n            errors = errors + 1\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test5 = .FALSE.\n        ELSE\n          test5 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T5\n        LOGICAL :: test5\n#endif\n#ifndef T5\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test5()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 4\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "runtime",
                            "data",
                            "executable-data",
                            "async",
                            "construct-independent",
                            "reference-counting"
                        ],
                        "versions": [
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "acc_copyin_with_len.F90": {
                "num tests": 7,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:runtime,data,executable-data,construct-independent,V:2.0-2.7\n      LOGICAL FUNCTION test1()\n        USE OPENACC\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT):: a, b, c !Data\n        REAL(8) :: RAND\n        INTEGER :: errors = 0\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n        CALL RANDOM_NUMBER(a)\n        CALL RANDOM_NUMBER(b)\n        c = 0\n        CALL acc_copyin(a(1), LOOPCOUNT*8)\n        CALL acc_copyin(b(1), LOOPCOUNT*8)\n        !$acc data copy(c(1:LOOPCOUNT))\n          !$acc parallel present(a(1:LOOPCOUNT), b(1:LOOPCOUNT))\n            !$acc Loop\n            DO x = 1, LOOPCOUNT\n              c(x) = a(x) + b(x)\n            END DO\n          !$acc end parallel\n        !$acc end data\n\n        CALL acc_copyout(a(1:LOOPCOUNT))\n        CALL acc_copyout(b(1:LOOPCOUNT))\n\n        DO x = 1, LOOPCOUNT\n          IF (abs(c(x) - (a(x) + b(x))) .gt. PRECISION) THEN\n            errors = errors + 1\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END FUNCTION\n#endif\n#ifndef T1\n      LOGICAL :: test1\n#endif\n#ifndef T1\n      DO testrun = 1, NUM_TEST_CALLS\n        failed = failed .or. test1()\n      END DO\n      IF (failed) THEN\n        failcode = failcode + 2 ** 0\n        failed = .FALSE.\n      END IF\n#endif\n",
                        "tags": [
                            "runtime",
                            "data",
                            "executable-data",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "2": {
                        "content": "#ifndef T2\n!T2:runtime,data,executable-data,construct-independent,V:2.0-2.7\n      LOGICAL FUNCTION test2()\n        USE OPENACC\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT):: a, b, c !Data\n        REAL(8) :: RAND\n        INTEGER :: errors = 0\n\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n        CALL RANDOM_NUMBER(a)\n        CALL RANDOM_NUMBER(b)\n        c = 0\n\n        CALL acc_copyin(a(1), LOOPCOUNT*8)\n        CALL acc_copyin(b(1), LOOPCOUNT*8)\n        !$acc data copy(c(1:LOOPCOUNT))\n          !$acc parallel present(a(1:LOOPCOUNT), b(1:LOOPCOUNT))\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              c(x) = a(x) + b(x)\n            END DO\n          !$acc end parallel\n        !$acc end data\n\n        !$acc exit data copyout(a(1:LOOPCOUNT), b(1:LOOPCOUNT))\n\n        DO x = 1, LOOPCOUNT\n          IF (abs(c(x) - (a(x) + b(x))) .gt. PRECISION) THEN\n            errors = errors + 1\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test2 = .FALSE.\n        ELSE\n          test2 = .TRUE.\n        END IF\n      END FUNCTION\n#endif\n#ifndef T2\n      LOGICAL :: test2\n#endif\n#ifndef T2\n      DO testrun = 1, NUM_TEST_CALLS\n        failed = failed .or. test2()\n      END DO\n      IF (failed) THEN\n        failcode = failcode + 2 ** 1\n        failed = .FALSE.\n      END IF\n#endif\n",
                        "tags": [
                            "runtime",
                            "data",
                            "executable-data",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "3": {
                        "content": "#ifndef T3\n!T3:runtime,data,executable-data,devonly,construct-independent,V:2.5-2.7\n      LOGICAL FUNCTION test3()\n        USE OPENACC\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT):: a, b, c, a_copy, b_copy !Data\n        REAL(8) :: RAND\n        INTEGER :: errors = 0\n        INTEGER,DIMENSION(1) :: devtest\n\n        devtest(1) = 1\n        !$acc enter data copyin(devtest(1:1))\n        !$acc parallel present(devtest(1:1))\n          devtest(1) = 0\n        !$acc end parallel\n\n        IF (devtest(1) .eq. 1) THEN\n          SEEDDIM(1) = 1\n#         ifdef SEED\n          SEEDDIM(1) = SEED\n#         endif\n          CALL RANDOM_SEED(PUT=SEEDDIM)\n          CALL RANDOM_NUMBER(a)\n          CALL RANDOM_NUMBER(b)\n          a_copy = a\n          b_copy = b\n          c = 0\n\n          CALL acc_copyin(a(1), LOOPCOUNT*8)\n          CALL acc_copyin(b(1), LOOPCOUNT*8)\n\n          a = 0\n          b = 0\n\n          !$acc data copyin(a(1:LOOPCOUNT), b(1:LOOPCOUNT)) copy(c(1:LOOPCOUNT))\n            !$acc parallel\n              !$acc loop\n              DO x = 1, LOOPCOUNT\n                c(x) = a(x) + b(x)\n              END DO\n            !$acc end parallel\n          !$acc end data\n\n          CALL acc_copyout(a(1:LOOPCOUNT))\n          CALL acc_copyout(b(1:LOOPCOUNT))\n\n          DO x = 1, LOOPCOUNT\n            IF (abs(a(x) - a_copy(x)) .gt. PRECISION) THEN\n              errors = errors + 1\n            END IF\n            IF (abs(b(x) - b_copy(x)) .gt. PRECISION) THEN\n              errors = errors + 1\n            END IF\n            IF (abs(c(x) - (a(x) + b(x))) .gt. PRECISION) THEN\n              errors = errors + 1\n            END IF\n          END DO\n        END IF\n\n        IF (errors .eq. 0) THEN\n          test3 = .FALSE.\n        ELSE\n          test3 = .TRUE.\n        END IF\n      END FUNCTION\n#endif\n#ifndef T3\n      LOGICAL :: test3\n#endif\n#ifndef T3\n      DO testrun = 1, NUM_TEST_CALLS\n        failed = failed .or. test3()\n      END DO\n      IF (failed) THEN\n        failcode = failcode + 2 ** 2\n        failed = .FALSE.\n      END IF\n#endif\n",
                        "tags": [
                            "runtime",
                            "data",
                            "executable-data",
                            "devonly",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "4": {
                        "content": "#ifndef T4\n!T4:runtime,compatibility-features,construct-independent,V:2.0-2.7\n      LOGICAL FUNCTION test4()\n        USE OPENACC\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT):: a, b, c !Data\n        REAL(8) :: RAND\n        INTEGER :: errors = 0\n\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n        CALL RANDOM_NUMBER(a)\n        CALL RANDOM_NUMBER(b)\n        c = 0\n\n        CALL acc_pcopyin(a(1), LOOPCOUNT*8)\n        CALL acc_pcopyin(b(1), LOOPCOUNT*8)\n\n        !$acc data copyout(c(1:LOOPCOUNT)) present(a(1:LOOPCOUNT), b(1:LOOPCOUNT))\n          !$acc parallel\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              c(x) = a(x) + b(x)\n            END DO\n          !$acc end parallel\n        !$acc end data\n\n        !$acc exit data delete(a(1:LOOPCOUNT), b(1:LOOPCOUNT))\n\n        DO x = 1, LOOPCOUNT\n          IF (abs(c(x) - (a(x) + b(x))) .gt. PRECISION) THEN\n            errors = errors + 1\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test4 = .FALSE.\n        ELSE\n          test4 = .TRUE.\n        END IF\n      END FUNCTION\n#endif\n#ifndef T4\n      LOGICAL :: test4\n#endif\n#ifndef T4\n      DO testrun = 1, NUM_TEST_CALLS\n        failed = failed .or. test4()\n      END DO\n      IF (failed) THEN\n        failcode = failcode + 2 ** 3\n        failed = .FALSE.\n      END IF\n#endif\n",
                        "tags": [
                            "runtime",
                            "compatibility-features",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "5": {
                        "content": "#ifndef T5\n!T5:runtime,compatibility-features,construct-independent,V:2.0-2.7\n      LOGICAL FUNCTION test5()\n        USE OPENACC\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT):: a, b, c !Data\n        REAL(8) :: RAND\n        INTEGER :: errors = 0\n\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n        CALL RANDOM_NUMBER(a)\n        CALL RANDOM_NUMBER(b)\n        c = 0\n\n        CALL acc_present_or_copyin(a(1), LOOPCOUNT*8)\n        CALL acc_present_or_copyin(b(1), LOOPCOUNT*8)\n\n        !$acc data copyout(c(1:LOOPCOUNT)) present(a(1:LOOPCOUNT), b(1:LOOPCOUNT))\n          !$acc parallel\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              c(x) = a(x) + b(x)\n            END DO\n          !$acc end parallel\n        !$acc end data\n\n        !$acc exit data delete(a(1:LOOPCOUNT), b(1:LOOPCOUNT))\n\n        DO x = 1, LOOPCOUNT\n          IF (abs(c(x) - (a(x) + b(x))) .gt. PRECISION) THEN\n            errors = errors + 1\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test5 = .FALSE.\n        ELSE\n          test5 = .TRUE.\n        END IF\n      END FUNCTION\n#endif\n#ifndef T5\n      LOGICAL :: test5\n#endif\n#ifndef T5\n      DO testrun = 1, NUM_TEST_CALLS\n        failed = failed .or. test5()\n      END DO\n      IF (failed) THEN\n        failcode = failcode + 2 ** 4\n        failed = .FALSE.\n      END IF\n#endif\n",
                        "tags": [
                            "runtime",
                            "compatibility-features",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "6": {
                        "content": "#ifndef T6\n!T6:runtime,data,executable-data,construct-independent,reference-counting,V:2.5-2.7\n      LOGICAL FUNCTION test6()\n        USE OPENACC\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT):: a, b, c !Data\n        REAL(8) :: RAND\n        INTEGER :: errors = 0\n\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n        CALL RANDOM_NUMBER(a)\n        CALL RANDOM_NUMBER(b)\n        c = 0\n\n        CALL acc_copyin(a(1), LOOPCOUNT*8)\n        CALL acc_copyin(a(1), LOOPCOUNT*8)\n        CALL acc_copyin(b(1), LOOPCOUNT*8)\n        CALL acc_copyin(b(1), LOOPCOUNT*8)\n\n        !$acc data copyout(c(1:LOOPCOUNT))\n          !$acc parallel present(a(1:LOOPCOUNT), b(1:LOOPCOUNT))\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              c(x) = a(x) + b(x)\n            END DO\n          !$acc end parallel\n        !$acc end data\n\n        !$acc exit data delete(a(1:LOOPCOUNT), b(1:LOOPCOUNT))\n        !$acc exit data delete(a(1:LOOPCOUNT), b(1:LOOPCOUNT))\n\n        DO x = 1, LOOPCOUNT\n          IF (abs(c(x) + (a(x) + b(x))) .gt. PRECISION) THEN\n            errors = errors + 1\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test6 = .FALSE.\n        ELSE\n          test6 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T6\n      LOGICAL :: test6\n#endif\n#ifndef T6\n      DO testrun = 1, NUM_TEST_CALLS\n        failed = failed .or. test6()\n      END DO\n      IF (failed) THEN\n        failcode = failcode + 2 ** 5\n        failed = .FALSE.\n      END IF\n#endif\n",
                        "tags": [
                            "runtime",
                            "data",
                            "executable-data",
                            "construct-independent",
                            "reference-counting"
                        ],
                        "versions": [
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "7": {
                        "content": "#ifndef T7\n!T7:runtime,data,executable-data,construct-independent,reference-counting,devonly,V:2.5-2.7\n      LOGICAL FUNCTION test7()\n        USE OPENACC\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT):: a, b, c, a_copy, b_copy !Data\n        REAL(8) :: RAND\n        INTEGER :: errors = 0\n        LOGICAL,DIMENSION(1):: devtest\n\n        devtest(1) = .TRUE.\n        !$acc enter data copyin(devtest(1:1))\n        !$acc parallel present(devtest(1:1))\n          devtest(1) = .FALSE.\n        !$acc end parallel\n\n        IF (devtest(1) .eqv. .TRUE.) THEN\n          SEEDDIM(1) = 1\n#         ifdef SEED\n          SEEDDIM(1) = SEED\n#         endif\n          CALL RANDOM_SEED(PUT=SEEDDIM)\n          CALL RANDOM_NUMBER(a)\n          CALL RANDOM_NUMBER(b)\n          c = 0\n          a_copy = a\n          b_copy = b\n\n          CALL acc_copyin(a(1), LOOPCOUNT*8)\n          CALL acc_copyin(b(1), LOOPCOUNT*8)\n\n          a = 0\n          b = 0\n\n          CALL acc_copyin(a(1), LOOPCOUNT*8)\n          CALL acc_copyin(b(1), LOOPCOUNT*8)\n\n          !$acc data copyout(c(1:LOOPCOUNT))\n            !$acc parallel present(a(1:LOOPCOUNT), b(1:LOOPCOUNT))\n              !$acc loop\n              DO x = 1, LOOPCOUNT\n                c(x) = a(x) + b(x)\n              END DO\n            !$acc end parallel\n          !$acc end data\n\n          !$acc exit data delete(a(1:LOOPCOUNT), b(1:LOOPCOUNT))\n          !$acc exit data delete(a(1:LOOPCOUNT), b(1:LOOPCOUNT))\n\n          DO x = 1, LOOPCOUNT\n            IF (abs(c(x) - (a(x) + b(x))) .gt. PRECISION) THEN\n              errors = errors + 1\n            END IF\n          END DO\n        END IF\n        IF (errors .eq. 0) THEN\n          test7 = .FALSE.\n        ELSE\n          test7 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T7\n      LOGICAL :: test7\n#endif\n#ifndef T7\n      DO testrun = 1, NUM_TEST_CALLS\n        failed = failed .or. test7()\n      END DO\n      IF (failed) THEN\n        failcode = failcode + 2 ** 6\n        failed = .FALSE.\n      END IF\n#endif\n",
                        "tags": [
                            "runtime",
                            "data",
                            "executable-data",
                            "construct-independent",
                            "reference-counting",
                            "devonly"
                        ],
                        "versions": [
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "acc_copyout.F90": {
                "num tests": 5,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:runtime,data,executable-data,construct-independent,V:2.0-2.7\n      LOGICAL FUNCTION test1()\n        USE OPENACC\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT):: a, b, c !Data\n        INTEGER :: errors = 0\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n        CALL RANDOM_NUMBER(a)\n        CALL RANDOM_NUMBER(b)\n        c = 0\n\n        CALL acc_create(c(1:LOOPCOUNT))\n\n        !$acc data copyin(a(1:LOOPCOUNT), b(1:LOOPCOUNT)) present(c(1:LOOPCOUNT))\n          !$acc parallel\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              c(x) = a(x) + b(x)\n            END DO\n          !$acc end parallel\n        !$acc end data\n\n        CALL acc_copyout(c(1:LOOPCOUNT))\n\n        DO x = 1, LOOPCOUNT\n          IF (abs(c(x) - (a(x) + b(x))) .gt. PRECISION) THEN\n            errors = errors + 1\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END FUNCTION\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "runtime",
                            "data",
                            "executable-data",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "2": {
                        "content": "#ifndef T2\n!T2:runtime,data,executable-data,construct-independent,V:2.0-2.7\n      LOGICAL FUNCTION test2()\n        USE OPENACC\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x\n        REAL(8),DIMENSION(LOOPCOUNT):: a, b, c\n        INTEGER :: errors = 0\n\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n        CALL RANDOM_NUMBER(a)\n        CALL RANDOM_NUMBER(b)\n        c = 0\n\n        !$acc enter data create(c(1:LOOPCOUNT))\n\n        !$acc data copyin(a(1:LOOPCOUNT), b(1:LOOPCOUNT)) present(c(1:LOOPCOUNT))\n          !$acc parallel\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              c(x) = a(x) + b(x)\n            END DO\n          !$acc end parallel\n        !$acc end data\n\n        CALL acc_copyout(c(1:LOOPCOUNT))\n\n        DO x = 1, LOOPCOUNT\n          IF (abs(c(x) - (a(x) + b(x))) .gt. PRECISION) THEN\n            errors = errors + 1\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test2 = .FALSE.\n        ELSE\n          test2 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T2\n        LOGICAL :: test2\n#endif\n#ifndef T2\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test2()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 1\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "runtime",
                            "data",
                            "executable-data",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "3": {
                        "content": "#ifndef T3\n!T3:runtime,data,executable-data,construct-independent,devonly,reference-counting,V:2.5-2.7\n      LOGICAL FUNCTION test3()\n        USE OPENACC\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x\n        REAL(8),DIMENSION(LOOPCOUNT):: a, b, c\n        INTEGER :: errors = 0\n        LOGICAL,DIMENSION(1):: devtest\n\n        devtest(1) = .TRUE.\n        !$acc enter data copyin(devtest(1:1))\n        !$acc parallel present(devtest(1:1))\n          devtest(1) = .FALSE.\n        !$acc end parallel\n\n        IF (devtest(1) .eqv. .TRUE.) THEN\n          SEEDDIM(1) = 1\n#         ifdef SEED\n          SEEDDIM(1) = SEED\n#         endif\n          CALL RANDOM_SEED(PUT=SEEDDIM)\n          CALL RANDOM_NUMBER(a)\n          CALL RANDOM_NUMBER(b)\n          c = 0\n\n          !$acc enter data copyin(c(1:LOOPCOUNT))\n          !$acc data copyin(a(1:LOOPCOUNT), b(1:LOOPCOUNT), c(1:LOOPCOUNT))\n            !$acc parallel\n              !$acc loop\n              DO x = 1, LOOPCOUNT\n                c(x) = a(x) + b(x)\n              END DO\n            !$acc end parallel\n            CALL acc_copyout(c(1:LOOPCOUNT))\n          !$acc end data\n\n          DO x = 1, LOOPCOUNT\n            IF (abs(c(x)) .gt. PRECISION) THEN\n              errors = errors + 1\n            END IF\n          END DO\n        END IF\n\n        IF (errors .eq. 0) THEN\n          test3 = .FALSE.\n        ELSE\n          test3 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T3\n        LOGICAL :: test3\n#endif\n#ifndef T3\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test3()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 2\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "runtime",
                            "data",
                            "executable-data",
                            "construct-independent",
                            "devonly",
                            "reference-counting"
                        ],
                        "versions": [
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "4": {
                        "content": "#ifndef T4\n!T4:runtime,data,executable-data,construct-independent,reference-counting,V:2.5-2.7\n      LOGICAL FUNCTION test4()\n        USE OPENACC\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x\n        REAL(8),DIMENSION(LOOPCOUNT):: a, b, c\n        INTEGER :: errors = 0\n\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n        CALL RANDOM_NUMBER(a)\n        CALL RANDOM_NUMBER(b)\n        c = 0\n\n        !$acc enter data create(c(1:LOOPCOUNT))\n        !$acc enter data create(c(1:LOOPCOUNT))\n        !$acc data copyin(a(1:LOOPCOUNT), b(1:LOOPCOUNT)) present(c(1:LOOPCOUNT))\n          !$acc parallel\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              c(x) = a(x) + b(x)\n            END DO\n          !$acc end parallel\n        !$acc end data\n        !$acc exit data delete(c(1:LOOPCOUNT))\n        CALL acc_copyout(c(1:LOOPCOUNT))\n\n        DO x = 1, LOOPCOUNT\n          IF (abs(c(x) - (a(x) + b(x))) .gt. PRECISION) THEN\n            errors = errors + 1\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test4 = .FALSE.\n        ELSE\n          test4 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T4\n        LOGICAL :: test4\n#endif\n#ifndef T4\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test4()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 3\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "runtime",
                            "data",
                            "executable-data",
                            "construct-independent",
                            "reference-counting"
                        ],
                        "versions": [
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "5": {
                        "content": "#ifndef T5\n!T5:runtime,data,executable-data,construct-independent,reference-counting,devonly,V:2.5-2.7\n      LOGICAL FUNCTION test5()\n        USE OPENACC\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x\n        REAL(8),DIMENSION(LOOPCOUNT):: a, b, c\n        INTEGER :: errors = 0\n        LOGICAL,DIMENSION(1):: devtest\n        devtest(1) = .TRUE.\n\n        !$acc enter data copyin(devtest(1:1))\n        !$acc parallel present(devtest(1:1))\n          devtest(1) = .FALSE.\n        !$acc end parallel\n\n        IF (devtest(1) .eqv. .TRUE.) THEN\n          SEEDDIM(1) = 1\n#         ifdef SEED\n          SEEDDIM(1) = SEED\n#         endif\n          CALL RANDOM_SEED(PUT=SEEDDIM)\n          CALL RANDOM_NUMBER(a)\n          CALL RANDOM_NUMBER(b)\n          c = 0\n\n          !$acc enter data create(c(1:LOOPCOUNT))\n          !$acc enter data create(c(1:LOOPCOUNT))\n          !$acc data copyin(a(1:LOOPCOUNT), b(1:LOOPCOUNT)) present(c(1:LOOPCOUNT))\n            !$acc parallel\n              !$acc loop\n              DO x = 1, LOOPCOUNT\n                c(x) = a(x) + b(x)\n              END DO\n            !$acc end parallel\n          !$acc end data\n          CALL acc_copyout(c(1:LOOPCOUNT))\n          !$acc exit data delete(c(1:LOOPCOUNT))\n\n          DO x = 1, LOOPCOUNT\n            IF (abs(c(x)) .gt. PRECISION) THEN\n              errors = errors + 1\n            END IF\n          END DO\n        END IF\n\n        IF (errors .eq. 0) THEN\n          test5 = .FALSE.\n        ELSE\n          test5 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T5\n        LOGICAL :: test5\n#endif\n#ifndef T5\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test5()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 4\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "runtime",
                            "data",
                            "executable-data",
                            "construct-independent",
                            "reference-counting",
                            "devonly"
                        ],
                        "versions": [
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "acc_copyout.c": {
                "num tests": 2,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:runtime,data,executable-data,construct-independent,V:2.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n    real_t * c = (real_t *)malloc(n * sizeof(real_t));\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n        c[x] = 0;\n    }\n\n    acc_create(c, n * sizeof(real_t));\n\n    #pragma acc data copyin(a[0:n], b[0:n]) present(c[0:n])\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                c[x] = a[x] + b[x];\n            }\n        }\n    }\n\n    acc_copyout(c, n * sizeof(real_t));\n\n    for (int x = 0; x < n; ++x){\n        if (fabs(c[x] - (a[x] + b[x])) > PRECISION){\n            err += 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "runtime",
                            "data",
                            "executable-data",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "2": {
                        "content": "#ifndef T2\n//T2:runtime,data,executable-data,construct-independent,V:2.0-2.7\nint test2(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n    real_t * c = (real_t *)malloc(n * sizeof(real_t));\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n        c[x] = 0;\n    }\n\n    #pragma acc enter data create(c[0:n])\n\n    #pragma acc data copyin(a[0:n], b[0:n]) present(c[0:n])\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                c[x] = a[x] + b[x];\n            }\n        }\n    }\n\n    acc_copyout(c, n * sizeof(real_t));\n\n    for (int x = 0; x < n; ++x){\n        if (fabs(c[x] - (a[x] + b[x])) > PRECISION){\n            err += 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T2\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test2();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 1);\n    }\n#endif\n",
                        "tags": [
                            "runtime",
                            "data",
                            "executable-data",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "acc_copyout_async.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:runtime,data,executable-data,async,construct-independent,V:2.5-2.7\n      LOGICAL FUNCTION test1()\n        USE OPENACC\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.fh\"\n        INTEGER :: x !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT):: a, b, c, d, e, f !Data\n        REAL(8) :: RAND\n        INTEGER :: errors = 0\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n        CALL RANDOM_NUMBER(a)\n        CALL RANDOM_NUMBER(b)\n        c = 0\n        CALL RANDOM_NUMBER(d)\n        CALL RANDOM_NUMBER(e)\n        f = 0\n\n        !$acc enter data create(c(1:LOOPCOUNT), f(1:LOOPCOUNT))\n\n        !$acc data copyin(a(1:LOOPCOUNT), b(1:LOOPCOUNT), d(1:LOOPCOUNT), e(1:LOOPCOUNT)) present(c(1:LOOPCOUNT), f(1:LOOPCOUNT))\n          !$acc parallel async(1)\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              c(x) = a(x) + b(x)\n            END DO\n          !$acc end parallel\n          !$acc parallel async(2)\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              f(x) = d(x) + e(x)\n            END DO\n          !$acc end parallel\n          CALL acc_copyout_async(c(1:LOOPCOUNT), 1)\n          CALL acc_copyout_async(f(1:LOOPCOUNT), 2)\n        !$acc end data\n        !$acc wait\n        DO x = 1, LOOPCOUNT\n          IF (abs(c(x) - (a(x) + b(x))) .gt. PRECISION) THEN\n            errors = errors + 1\n          END IF\n          IF (abs(f(x) - (d(x) + e(x))) .gt. PRECISION) THEN\n            errors = errors + 1\n          END IF\n        END DO\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n      LOGICAL :: test1\n#endif\n#ifndef T1\n      DO testrun = 1, NUM_TEST_CALLS\n        failed = failed .or. test1()\n      END DO\n      IF (failed) THEN\n        failcode = failcode + 2 ** 0\n        failed = .FALSE.\n      END IF\n#endif\n",
                        "tags": [
                            "runtime",
                            "data",
                            "executable-data",
                            "async",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "acc_copyout_async.c": {
                "num tests": 4,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:runtime,data,executable-data,async,construct-independent,V:2.5-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t *a = (real_t *)malloc(n * sizeof(real_t));\n    real_t *b = (real_t *)malloc(n * sizeof(real_t));\n    real_t *c = (real_t *)malloc(n * sizeof(real_t));\n    real_t *d = (real_t *)malloc(n * sizeof(real_t));\n    real_t *e = (real_t *)malloc(n * sizeof(real_t));\n    real_t *f = (real_t *)malloc(n * sizeof(real_t));\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n        c[x] = 0;\n        d[x] = rand() / (real_t)(RAND_MAX / 10);\n        e[x] = rand() / (real_t)(RAND_MAX / 10);\n        f[x] = 0;\n    }\n\n    #pragma acc enter data create(c[0:n], f[0:n])\n\n    #pragma acc data copyin(a[0:n], b[0:n], d[0:n], e[0:n])\n    {\n        #pragma acc parallel async(1) present(c[0:n])\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                c[x] = a[x] + b[x];\n            }\n        }\n        #pragma acc parallel async(2) present(f[0:n])\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                f[x] = d[x] + e[x];\n            }\n        }\n        acc_copyout_async(c, n * sizeof(real_t), 1);\n        acc_copyout_async(f, n * sizeof(real_t), 2);\n        #pragma acc wait\n    }\n\n    for (int x = 0; x < n; ++x){\n        if (fabs(c[x] - (a[x] + b[x])) > PRECISION){\n            err += 1;\n        }\n        if (fabs(f[x] - (d[x] + e[x])) > PRECISION){\n            err += 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "runtime",
                            "data",
                            "executable-data",
                            "async",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "2": {
                        "content": "#ifndef T2\n//T2:runtime,async,data,executable-data,internal-control-values,construct-independent,V:2.5-2.7\nint test2(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n    real_t * c = (real_t *)malloc(n * sizeof(real_t));\n    int def_async_var = acc_get_default_async();\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n        c[x] = 0;\n    }\n\n    #pragma acc enter data create(c[0:n])\n\n    #pragma acc data copyin(a[0:n], b[0:n])\n    {\n        #pragma acc parallel present(c[0:n]) async\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x) {\n                c[x] = a[x] + b[x];\n            }\n        }\n        acc_copyout_async(c, n * sizeof(real_t), def_async_var);\n        #pragma acc wait\n    }\n\n    for (int x = 0; x < n; ++x) {\n        if (fabs(c[x] - (a[x] + b[x])) > PRECISION) {\n            err += 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T2\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test2();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 1);\n    }\n#endif\n",
                        "tags": [
                            "runtime",
                            "async",
                            "data",
                            "executable-data",
                            "internal-control-values",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "3": {
                        "content": "#ifndef T3\n//T3:runtime,async,data,executable-data,internal-control-values,construct-independent,V:2.5-2.7\nint test3(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n    real_t * c = (real_t *)malloc(n * sizeof(real_t));\n    int def_async_var = acc_get_default_async();\n\n    acc_set_default_async(def_async_var + 1);\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n        c[x] = 0;\n    }\n    \n    #pragma acc enter data create(c[0:n])\n    #pragma acc data copyin(a[0:n], b[0:n])\n    {\n        #pragma acc parallel present(c[0:n]) async\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x) {\n                c[x] = a[x] + b[x];\n            }\n        }\n        acc_copyout_async(c, n * sizeof(real_t), def_async_var + 1);\n        #pragma acc wait\n    }\n\n    for (int x = 0; x < n; ++x) {\n        if (fabs(c[x] - (a[x] + b[x])) > PRECISION) {\n            err += 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T3\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test3();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 2);\n    }\n#endif\n",
                        "tags": [
                            "runtime",
                            "async",
                            "data",
                            "executable-data",
                            "internal-control-values",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "4": {
                        "content": "#ifndef T4\n//T4:runtime,async,data,executable-data,construct-independent,V:2.5-2.7\nint test4(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n    real_t * c = (real_t *)malloc(n * sizeof(real_t));\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n        c[x] = 0;\n    }\n\n    #pragma acc enter data create(c[0:n])\n    #pragma acc data copyin(a[0:n], b[0:n])\n    {\n        #pragma acc parallel present(c[0:n]) async(1)\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x) {\n                c[x] = a[x] + b[x];\n            }\n        }\n        #pragma acc enter data copyin(c[0:n])\n        acc_copyout_async(c, n * sizeof(real_t), 1);\n        #pragma acc parallel present(c[0:n]) async(1)\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x) {\n                c[x] += a[x] + b[x];\n            }\n        }\n        acc_copyout_async(c, n * sizeof(real_t), 1);\n    }\n    \n    for (int x = 0; x < n; ++x) {\n        if (fabs(c[x] - (2 * (a[x] + b[x]))) > PRECISION) {\n            err += 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T4\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test4();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 3);\n    }\n#endif\n",
                        "tags": [
                            "runtime",
                            "async",
                            "data",
                            "executable-data",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "acc_copyout_async_with_len.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:runtime,data,executable-data,async,construct-independent,V:2.5-2.7\n      LOGICAL FUNCTION test1()\n        USE OPENACC\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.fh\"\n        INTEGER :: x !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT):: a, b, c, d, e, f !Data\n        REAL(8) :: RAND\n        INTEGER :: errors = 0\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n        CALL RANDOM_NUMBER(a)\n        CALL RANDOM_NUMBER(b)\n        c = 0\n        CALL RANDOM_NUMBER(d)\n        CALL RANDOM_NUMBER(e)\n        f = 0\n\n        !$acc enter data create(c(1:LOOPCOUNT), f(1:LOOPCOUNT))\n\n        !$acc data copyin(a(1:LOOPCOUNT), b(1:LOOPCOUNT), d(1:LOOPCOUNT), e(1:LOOPCOUNT)) present(c(1:LOOPCOUNT), f(1:LOOPCOUNT))\n          !$acc parallel async(1)\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              c(x) = a(x) + b(x)\n            END DO\n          !$acc end parallel\n          !$acc parallel async(2)\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              f(x) = d(x) + e(x)\n            END DO\n          !$acc end parallel\n          CALL acc_copyout_async(c(1), LOOPCOUNT*8, 1)\n          CALL acc_copyout_async(f(1), LOOPCOUNT*8, 2)\n        !$acc end data\n\n        DO x = 1, LOOPCOUNT\n          IF (abs(c(x) - (a(x) + b(x))) .gt. PRECISION) THEN\n            errors = errors + 1\n          END IF\n          IF (abs(f(x) - (d(x) + e(x))) .gt. PRECISION) THEN\n            errors = errors + 1\n          END IF\n        END DO\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "runtime",
                            "data",
                            "executable-data",
                            "async",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "acc_copyout_finalize.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:runtime,data,executable-data,construct-independent,V:2.5-2.7\n      LOGICAL FUNCTION test1()\n        USE OPENACC\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.fh\"\n        INTEGER :: x !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT):: a, b, c !Data\n        INTEGER :: errors = 0\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n        CALL RANDOM_NUMBER(a)\n        CALL RANDOM_NUMBER(b)\n        c = 0\n\n        !$acc enter data create(c(1:LOOPCOUNT))\n        !$acc enter data create(c(1:LOOPCOUNT))\n\n        !$acc data copyin(a(1:LOOPCOUNT), b(1:LOOPCOUNT)) present(c(1:LOOPCOUNT))\n          !$acc parallel\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              c(x) = a(x) + b(x)\n            END DO\n          !$acc end parallel\n        !$acc end data\n\n        CALL acc_copyout_finalize(c(1:LOOPCOUNT))\n\n        DO x = 1, LOOPCOUNT\n          IF (abs(c(x) - (a(x) + b(x))) .gt. PRECISION) THEN\n            errors = errors + 1\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "runtime",
                            "data",
                            "executable-data",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "acc_copyout_finalize.c": {
                "num tests": 3,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:runtime,data,executable-data,construct-independent,reference-counting,V:2.5-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t *a = (real_t *)malloc(n * sizeof(real_t));\n    real_t *b = (real_t *)malloc(n * sizeof(real_t));\n    real_t *c = (real_t *)malloc(n * sizeof(real_t));\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n        c[x] = 0;\n    }\n\n    #pragma acc enter data create(c[0:n])\n    #pragma acc enter data create(c[0:n])\n\n    #pragma acc data copyin(a[0:n], b[0:n]) present(c[0:n])\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                c[x] = a[x] + b[x];\n            }\n        }\n    }\n    acc_copyout_finalize(c, n * sizeof(real_t));\n\n    for (int x = 0; x < n; ++x){\n        if (fabs(c[x] - (a[x] + b[x])) > PRECISION){\n            err += 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "runtime",
                            "data",
                            "executable-data",
                            "construct-independent",
                            "reference-counting"
                        ],
                        "versions": [
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "2": {
                        "content": "#ifndef T2\n//T2:runtime,data,executable-data,construct-independent,reference-counting,V:2.5-2.7\nint test2(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n    real_t * c = (real_t *)malloc(n * sizeof(real_t));\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n        c[x] = 0;\n    }\n\n    #pragma acc enter data copyin(c[0:n])\n    #pragma acc data copyin(a[0:n], b[0:n])\n    {\n        #pragma acc parallel present(a[0:n], b[0:n])\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x) {\n                c[x] = a[x] + b[x];\n            }\n        }\n    }\n    acc_copyout_finalize(c, n * sizeof(real_t));\n\n    for (int x = 0; x < n; ++x) {\n        if (fabs(c[x] - (a[x] + b[x])) > PRECISION) {\n            err += 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T2\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test2();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 1);\n    }\n#endif\n",
                        "tags": [
                            "runtime",
                            "data",
                            "executable-data",
                            "construct-independent",
                            "reference-counting"
                        ],
                        "versions": [
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "3": {
                        "content": "#ifndef T3\n//T3:runtime,data,executable-data,construct-independent,reference-counting,V:2.5-2.7\nint test3(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n    real_t * c = (real_t *)malloc(n * sizeof(real_t));\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n        c[x] = 0;\n    }\n\n    #pragma acc enter data copyin(c[0:n])\n    #pragma acc enter data copyin(c[0:n])\n    #pragma acc data copyin(a[0:n], b[0:n])\n    {\n        #pragma acc parallel present(c[0:n])\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x) {\n                c[x] = a[x] + b[x];\n            }\n        }\n        acc_copyout_finalize(c, n * sizeof(real_t));\n        #pragma acc enter data copyin(c[0:n])\n        #pragma acc parallel present(c[0:n])\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x) {\n                c[x] += a[x] + b[x];\n            }\n        }\n    }\n    #pragma acc exit data copyout(c[0:n])\n\n    for (int x = 0; x < n; ++x) {\n        if (fabs(c[x] - (2 * (a[x] + b[x]))) > PRECISION) {\n            err += 1;\n        }\n    }\n    \n\n    return err;\n}\n#endif\n#ifndef T3\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test3();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 2);\n    }\n#endif\n",
                        "tags": [
                            "runtime",
                            "data",
                            "executable-data",
                            "construct-independent",
                            "reference-counting"
                        ],
                        "versions": [
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "acc_copyout_finalize_async.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:runtime,data,executable-data,async,construct-independent,V:2.5-2.7\n      LOGICAL FUNCTION test1()\n        USE OPENACC\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.fh\"\n        INTEGER :: x !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT):: a, b, c, d, e, f !Data\n        REAL(8) :: RAND\n        INTEGER :: errors = 0\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n        CALL RANDOM_NUMBER(a)\n        CALL RANDOM_NUMBER(b)\n        c = 0\n        CALL RANDOM_NUMBER(d)\n        CALL RANDOM_NUMBER(e)\n        f = 0\n\n        !$acc enter data create(c(1:LOOPCOUNT), f(1:LOOPCOUNT))\n        !$acc enter data create(c(1:LOOPCOUNT), f(1:LOOPCOUNT))\n\n        !$acc data copyin(a(1:LOOPCOUNT), b(1:LOOPCOUNT), d(1:LOOPCOUNT), e(1:LOOPCOUNT)) present(c(1:LOOPCOUNT), f(1:LOOPCOUNT))\n          !$acc parallel async(1)\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              c(x) = a(x) + b(x)\n            END DO\n          !$acc end parallel\n          !$acc parallel async(2)\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              f(x) = d(x) + e(x)\n            END DO\n          !$acc end parallel\n          CALL acc_copyout_finalize_async(c(1:LOOPCOUNT), 1)\n          CALL acc_copyout_finalize_async(f(1:LOOPCOUNT), 2)\n          !$acc wait\n        !$acc end data\n\n        DO x = 1, LOOPCOUNT\n          IF (abs(c(x) - (a(x) + b(x))) .gt. PRECISION) THEN\n            errors = errors + 1\n          END IF\n          IF (abs(f(x) - (d(x) + e(x))) .gt. PRECISION) THEN\n            errors = errors + 1\n          END IF\n        END DO\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n      LOGICAL :: test1\n#endif\n#ifndef T1\n      DO testrun = 1, NUM_TEST_CALLS\n        failed = failed .or. test1()\n      END DO\n      IF (failed) THEN\n        failcode = failcode + 2 ** 0\n        failed = .FALSE.\n      END IF\n#endif\n",
                        "tags": [
                            "runtime",
                            "data",
                            "executable-data",
                            "async",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "acc_copyout_finalize_async.c": {
                "num tests": 4,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:runtime,data,executable-data,async,construct-independent,reference-counting,V:2.5-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t *a = (real_t *)malloc(n * sizeof(real_t));\n    real_t *b = (real_t *)malloc(n * sizeof(real_t));\n    real_t *c = (real_t *)malloc(n * sizeof(real_t));\n    real_t *d = (real_t *)malloc(n * sizeof(real_t));\n    real_t *e = (real_t *)malloc(n * sizeof(real_t));\n    real_t *f = (real_t *)malloc(n * sizeof(real_t));\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n        c[x] = 0;\n        d[x] = rand() / (real_t)(RAND_MAX / 10);\n        e[x] = rand() / (real_t)(RAND_MAX / 10);\n        f[x] = 0;\n    }\n\n    #pragma acc enter data create(c[0:n], f[0:n])\n    #pragma acc enter data create(c[0:n], f[0:n])\n\n    #pragma acc data copyin(a[0:n], b[0:n], d[0:n], e[0:n]) present(c[0:n], f[0:n])\n    {\n        #pragma acc parallel async(1)\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                c[x] = a[x] + b[x];\n            }\n        }\n        #pragma acc parallel async(2)\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                f[x] = d[x] + e[x];\n            }\n        }\n        acc_copyout_finalize_async(c, n * sizeof(real_t), 1);\n        acc_copyout_finalize_async(f, n * sizeof(real_t), 2);\n        #pragma acc wait\n    }\n\n    for (int x = 0; x < n; ++x){\n        if (fabs(c[x] - (a[x] + b[x])) > PRECISION){\n            err += 1;\n        }\n        if (fabs(f[x] - (d[x] + e[x])) > PRECISION){\n            err += 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "runtime",
                            "data",
                            "executable-data",
                            "async",
                            "construct-independent",
                            "reference-counting"
                        ],
                        "versions": [
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "2": {
                        "content": "#ifndef T2\n//T2:runtime,data,executable-data,async,construct-independent,internal-control-values,V:2.5-2.7\nint test2(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n    real_t * c = (real_t *)malloc(n * sizeof(real_t));\n    int def_async_var = acc_get_default_async();\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n        c[x] = 0;\n    }\n\n    #pragma acc enter data create(c[0:n])\n    #pragma acc enter data create(c[0:n])\n    \n    #pragma acc data copyin(a[0:n], b[0:n])\n    {\n        #pragma acc parallel present(c[0:n])\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x) {\n                c[x] = a[x] + b[x];\n            }\n        }\n        acc_copyout_finalize_async(c, n * sizeof(real_t), def_async_var);\n        #pragma acc wait\n    }\n\n    for (int x = 0; x < n; ++x) {\n        if (fabs(c[x] - (a[x] + b[x])) > PRECISION) {\n            err += 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T2\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test2();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 1);\n    }\n#endif\n",
                        "tags": [
                            "runtime",
                            "data",
                            "executable-data",
                            "async",
                            "construct-independent",
                            "internal-control-values"
                        ],
                        "versions": [
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "3": {
                        "content": "#ifndef T3\n//T3:runtime,data,executable-data,async,construct-independent,internal-control-values,set,V:2.5-2.7\nint test3(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n    real_t * c = (real_t *)malloc(n * sizeof(real_t));\n    int def_async_var = acc_get_default_async();\n\n    acc_set_default_async(def_async_var + 1);\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n        c[x] = 0;\n    }\n\n    #pragma acc enter data create(c[0:n])\n    #pragma acc enter data create(c[0:n])\n    #pragma acc data copyin(a[0:n], b[0:n])\n    {\n        #pragma acc parallel present(c[0:n]) async\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x) {\n                c[x] = a[x] + b[x];\n            }\n        }\n        acc_copyout_async(c, n * sizeof(real_t), def_async_var + 1);\n        #pragma acc wait\n    }\n\n    for (int x = 0; x < n; ++x) {\n        if (fabs(c[x] - (a[x] + b[x])) > PRECISION) {\n            err += 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T3\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test3();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 2);\n    }\n#endif\n",
                        "tags": [
                            "runtime",
                            "data",
                            "executable-data",
                            "async",
                            "construct-independent",
                            "internal-control-values",
                            "set"
                        ],
                        "versions": [
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "4": {
                        "content": "#ifndef T4\n//T4:runtime,data,executable-data,async,construct-independent,V:2.5-2.7\nint test4(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n    real_t * c = (real_t *)malloc(n * sizeof(real_t));\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n        c[x] = 0;\n    }\n\n    #pragma acc enter data create(c[0:n])\n    #pragma acc enter data create(c[0:n])\n    #pragma acc data copyin(a[0:n], b[0:n])\n    {\n        #pragma acc parallel present(c[0:n]) async(1)\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x) {\n                c[x] = a[x] + b[x];\n            }\n        }\n        acc_copyout_finalize_async(c, n * sizeof(real_t), 1);\n        #pragma acc enter data copyin(c[0:n]) async(1)\n        #pragma acc parallel present(c[0:n]) async(1)\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x) {\n                c[x] += a[x] + b[x];\n            }\n        }\n    }\n\n    for (int x = 0; x < n; ++x) {\n        if (fabs(c[x] - (2 * (a[x] + b[x]))) > PRECISION) {\n            err += 1;\n        }\n    }\n    \n\n    return err;\n}\n#endif\n#ifndef T4\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test4();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 3);\n    }\n#endif\n",
                        "tags": [
                            "runtime",
                            "data",
                            "executable-data",
                            "async",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "acc_copyout_finalize_async_with_len.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:runtime,data,executable-data,async,construct-independent,V:2.5-2.7\n      LOGICAL FUNCTION test1()\n        USE OPENACC\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.fh\"\n        INTEGER :: x !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT):: a, b, c, d, e, f !Data\n        REAL(8) :: RAND\n        INTEGER :: errors = 0\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n        CALL RANDOM_NUMBER(a)\n        CALL RANDOM_NUMBER(b)\n        c = 0\n        CALL RANDOM_NUMBER(d)\n        CALL RANDOM_NUMBER(e)\n        f = 0\n\n        !$acc enter data create(c(1:LOOPCOUNT), f(1:LOOPCOUNT))\n        !$acc enter data create(c(1:LOOPCOUNT), f(1:LOOPCOUNT))\n\n        !$acc data copyin(a(1:LOOPCOUNT), b(1:LOOPCOUNT), d(1:LOOPCOUNT), e(1:LOOPCOUNT)) present(c(1:LOOPCOUNT), f(1:LOOPCOUNT))\n          !$acc parallel async(1)\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              c(x) = a(x) + b(x)\n            END DO\n          !$acc end parallel\n          !$acc parallel async(2)\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              f(x) = d(x) + e(x)\n            END DO\n          !$acc end parallel\n          CALL acc_copyout_finalize_async(c(1), LOOPCOUNT*8, 1)\n          CALL acc_copyout_finalize_async(f(1), LOOPCOUNT*8, 2)\n          !$acc wait\n        !$acc end data\n\n        DO x = 1, LOOPCOUNT\n          IF (abs(c(x) - (a(x) + b(x))) .gt. PRECISION) THEN\n            errors = errors + 1\n          END IF\n          IF (abs(f(x) - (d(x) + e(x))) .gt. PRECISION) THEN\n            errors = errors + 1\n          END IF\n        END DO\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n      LOGICAL :: test1\n#endif\n#ifndef T1\n      DO testrun = 1, NUM_TEST_CALLS\n        failed = failed .or. test1()\n      END DO\n      IF (failed) THEN\n        failcode = failcode + 2 ** 0\n        failed = .FALSE.\n      END IF\n#endif\n",
                        "tags": [
                            "runtime",
                            "data",
                            "executable-data",
                            "async",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "acc_copyout_finalize_with_len.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:runtime,data,executable-data,construct-independent,V:2.5-2.7\n      LOGICAL FUNCTION test1()\n        USE OPENACC\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.fh\"\n        INTEGER :: x !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT):: a, b, c !Data\n        REAL(8) :: RAND\n        INTEGER :: errors = 0\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n        CALL RANDOM_NUMBER(a)\n        CALL RANDOM_NUMBER(b)\n        c = 0\n\n        !$acc enter data create(c(1:LOOPCOUNT))\n        !$acc enter data create(c(1:LOOPCOUNT))\n\n        !$acc data copyin(a(1:LOOPCOUNT), b(1:LOOPCOUNT)) present(c(1:LOOPCOUNT))\n          !$acc parallel\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              c(x) = a(x) + b(x)\n            END DO\n          !$acc end parallel\n        !$acc end data\n\n        CALL acc_copyout_finalize(c(1), LOOPCOUNT*8)\n\n        DO x = 1, LOOPCOUNT\n          IF (abs(c(x) - (a(x) + b(x))) .gt. PRECISION) THEN\n            errors = errors + 1\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "runtime",
                            "data",
                            "executable-data",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "acc_copyout_with_len.F90": {
                "num tests": 2,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:runtime,data,executable-data,construct-independent,V:2.0-2.7\n      LOGICAL FUNCTION test1()\n        USE OPENACC\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT):: a, b, c !Data\n        INTEGER :: errors = 0\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n        CALL RANDOM_NUMBER(a)\n        CALL RANDOM_NUMBER(b)\n        c = 0\n\n        CALL acc_create(c(1:LOOPCOUNT))\n\n        !$acc data copyin(a(1:LOOPCOUNT), b(1:LOOPCOUNT)) present(c(1:LOOPCOUNT))\n          !$acc parallel\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              c(x) = a(x) + b(x)\n            END DO\n          !$acc end parallel\n        !$acc end data\n\n        CALL acc_copyout(c(1), LOOPCOUNT*8)\n\n        DO x = 1, LOOPCOUNT\n          IF (abs(c(x) - (a(x) + b(x))) .gt. PRECISION) THEN\n            errors = errors + 1\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "runtime",
                            "data",
                            "executable-data",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "2": {
                        "content": "#ifndef T2\n!T2:runtime,data,executable-data,construct-independent,V:2.0-2.7\n      LOGICAL FUNCTION test2()\n        USE OPENACC\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x\n        REAL(8),DIMENSION(LOOPCOUNT):: a, b, c\n        INTEGER :: errors = 0\n\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n        CALL RANDOM_NUMBER(a)\n        CALL RANDOM_NUMBER(b)\n        c = 0\n\n        !$acc enter data create(c(1:LOOPCOUNT))\n\n        !$acc data copyin(a(1:LOOPCOUNT), b(1:LOOPCOUNT)) present(c(1:LOOPCOUNT))\n          !$acc parallel\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              c(x) = a(x) + b(x)\n            END DO\n          !$acc end parallel\n        !$acc end data\n\n        CALL acc_copyout(c(1), LOOPCOUNT*8)\n\n        DO x = 1, LOOPCOUNT\n          IF (abs(c(x) - (a(x) + b(x))) .gt. PRECISION) THEN\n            errors = errors + 1\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test2 = .FALSE.\n        ELSE\n          test2 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T2\n        LOGICAL :: test2\n#endif\n#ifndef T2\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test2()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2**1\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "runtime",
                            "data",
                            "executable-data",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "acc_create.F90": {
                "num tests": 4,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:runtime,data,executable-data,construct-independent,V:2.0-2.7\n      LOGICAL FUNCTION test1()\n        USE OPENACC\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT):: a, b, c !Data\n        INTEGER :: errors\n        errors = 0\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n        CALL RANDOM_NUMBER(a)\n        CALL RANDOM_NUMBER(b)\n        c = 0\n\n        CALL acc_create(c(1:LOOPCOUNT))\n\n        !$acc data copyin(a(1:LOOPCOUNT), b(1:LOOPCOUNT))\n          !$acc parallel present(c(1:LOOPCOUNT))\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              c(x) = a(x) + b(x)\n            END DO\n          !$acc end parallel\n        !$acc end data\n\n        CALL acc_copyout(c(1:LOOPCOUNT))\n\n        DO x = 1, LOOPCOUNT\n          IF (abs(c(x) - (a(x) + b(x))) .gt. PRECISION) THEN\n            errors = errors + 1\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "runtime",
                            "data",
                            "executable-data",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "2": {
                        "content": "#ifndef T2\n!T2:runtime,data,executable-data,construct-independent,V:2.0-2.7\n      LOGICAL FUNCTION test2()\n        USE OPENACC\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x\n        REAL(8),DIMENSION(LOOPCOUNT):: a, b, c\n        INTEGER:: errors\n        errors = 0\n\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n        CALL RANDOM_NUMBER(a)\n        CALL RANDOM_NUMBER(b)\n        c= 0\n\n        CALL acc_create(c(1:LOOPCOUNT))\n\n        !$acc data copyin(a(1:LOOPCOUNT), b(1:LOOPCOUNT))\n          !$acc parallel present(c(1:LOOPCOUNT))\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              c(x) = a(x) + b(x)\n            END DO\n          !$acc end parallel\n        !$acc end data\n\n        !$acc exit data copyout(c(1:LOOPCOUNT))\n\n        DO x = 1, LOOPCOUNT\n          IF (abs(c(x) - (a(x) + b(x))) .gt. PRECISION) THEN\n            errors = errors + 1\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test2 = .FALSE.\n        ELSE\n          test2 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T2\n        LOGICAL :: test2\n#endif\n#ifndef T2\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test2()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 1\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "runtime",
                            "data",
                            "executable-data",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "3": {
                        "content": "#ifndef T3\n!T3:runtime,compatibility-features,construct-independent,V:2.0-2.7\n      LOGICAL FUNCTION test3()\n        USE OPENACC\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER:: x\n        REAL(8),DIMENSION(LOOPCOUNT):: a, b, c\n        INTEGER:: errors\n        errors = 0\n\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n        CALL RANDOM_NUMBER(a)\n        CALL RANDOM_NUMBER(b)\n        c = 0\n\n        CALL acc_pcreate(c(1:LOOPCOUNT))\n\n        !$acc data copyin(a(1:LOOPCOUNT), b(1:LOOPCOUNT)) present(c(1:LOOPCOUNT))\n          !$acc parallel\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              c(x) = a(x) + b(x)\n            END DO\n          !$acc end parallel\n        !$acc end data\n\n        !$acc exit data copyout(c(1:LOOPCOUNT))\n\n        DO x = 1, LOOPCOUNT\n          IF (abs(c(x) - (a(x) + b(x))) .gt. PRECISION) THEN\n            errors = errors + 1\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test3 = .FALSE.\n        ELSE\n          test3 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T3\n        LOGICAL :: test3\n#endif\n#ifndef T3\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test3()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 2\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "runtime",
                            "compatibility-features",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "4": {
                        "content": "#ifndef T4\n!T4:runtime,compatibility-features,construct-independent,V:2.0-2.7\n      LOGICAL FUNCTION test4()\n        USE OPENACC\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER:: x\n        REAL(8),DIMENSION(LOOPCOUNT):: a, b, c\n        INTEGER:: errors\n        errors = 0\n\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n        CALL RANDOM_NUMBER(a)\n        CALL RANDOM_NUMBER(b)\n        c = 0\n\n        CALL acc_present_or_create(c(1:LOOPCOUNT))\n\n        !$acc data copyin(a(1:LOOPCOUNT), b(1:LOOPCOUNT)) present(c(1:LOOPCOUNT))\n          !$acc parallel\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              c(x) = a(x) + b(x)\n            END DO\n          !$acc end parallel\n        !$acc end data\n\n        !$acc exit data copyout(c(1:LOOPCOUNT))\n\n        DO x = 1, LOOPCOUNT\n          IF (abs(c(x) - (a(x) + b(x))) .gt. PRECISION) THEN\n            errors = errors + 1\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test4 = .FALSE.\n        ELSE\n          test4 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T4\n        LOGICAL :: test4\n#endif\n#ifndef T4\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test4()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 3\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "runtime",
                            "compatibility-features",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "acc_create.c": {
                "num tests": 5,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:runtime,data,executable-data,construct-independent,V:2.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n    real_t * c = (real_t *)malloc(n * sizeof(real_t));\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n        c[x] = 0.0;\n    }\n\n    acc_create(c, n * sizeof(real_t));\n\n    #pragma acc data copyin(a[0:n], b[0:n])\n    {\n        #pragma acc parallel present(c[0:n])\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                c[x] = a[x] + b[x];\n            }\n        }\n    }\n\n    acc_copyout(c, n * sizeof(real_t));\n\n    for (int x = 0; x < n; ++x){\n        if (fabs(c[x] - (a[x] + b[x])) > PRECISION){\n            err += 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "runtime",
                            "data",
                            "executable-data",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "2": {
                        "content": "#ifndef T2\n//T2:runtime,data,executable-data,construct-independent,V:2.0-2.7\nint test2(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n    real_t * c = (real_t *)malloc(n * sizeof(real_t));\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n        c[x] = 0.0;\n    }\n\n    acc_create(c, n * sizeof(real_t));\n\n    #pragma acc data copyin(a[0:n], b[0:n])\n    {\n        #pragma acc parallel present(c[0:n])\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                c[x] = a[x] + b[x];\n            }\n        }\n    }\n\n    #pragma acc exit data copyout(c[0:n])\n\n    for (int x = 0; x < n; ++x){\n        if (fabs(c[x] - (a[x] + b[x])) > PRECISION){\n            err += 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T2\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test2();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 1);\n    }\n#endif\n",
                        "tags": [
                            "runtime",
                            "data",
                            "executable-data",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "3": {
                        "content": "#ifndef T3\n//T3:runtime,data,executable-data,compatibility-features,construct-independent,V:2.0-2.7\nint test3(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n    real_t * c = (real_t *)malloc(n * sizeof(real_t));\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n        c[x] = 0;\n    }\n\n    acc_pcreate(c, n * sizeof(real_t));\n\n    #pragma acc data copyin(a[0:n], b[0:n]) present(c[0:n])\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                c[x] = a[x] + b[x];\n            }\n        }\n    }\n\n    #pragma acc exit data copyout(c[0:n])\n\n    for (int x = 0; x < n; ++x){\n        if (fabs(c[x] - (a[x] + b[x])) > PRECISION){\n            err += 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T3\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test3();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 2);\n    }\n#endif\n",
                        "tags": [
                            "runtime",
                            "data",
                            "executable-data",
                            "compatibility-features",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "4": {
                        "content": "#ifndef T4\n//T4:runtime,data,executable-data,compatibility-features,construct-independent,V:2.0-2.7\nint test4(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n    real_t * c = (real_t *)malloc(n * sizeof(real_t));\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n        c[x] = 0;\n    }\n\n    acc_present_or_create(c, n * sizeof(real_t));\n\n    #pragma acc data copyin(a[0:n], b[0:n]) present(c[0:n])\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                c[x] = a[x] + b[x];\n            }\n        }\n    }\n\n    #pragma acc exit data copyout(c[0:n])\n\n    for (int x = 0; x < n; ++x){\n        if (fabs(c[x] - (a[x] + b[x])) > PRECISION){\n            err += 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T4\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test4();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 3);\n    }\n#endif\n",
                        "tags": [
                            "runtime",
                            "data",
                            "executable-data",
                            "compatibility-features",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "5": {
                        "content": "#ifndef T5\n//T5:runtime,data,executable-data,devonly,construct-independent,reference-counting,V:2.5-2.7\nint test5(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n    real_t * c = (real_t *)malloc(n * sizeof(real_t));\n    int * dev_test = (int *)malloc(sizeof(int));\n\n    dev_test[0] = 1;\n    #pragma acc enter data copyin(dev_test[0:1])\n    #pragma acc parallel present(dev_test[0:1])\n    {\n        dev_test[0] = 0;\n    }\n    if (dev_test[0] == 1){\n        for (int x = 0; x < n; ++x){\n            a[x] = rand() / (real_t)(RAND_MAX / 10);\n            b[x] = rand() / (real_t)(RAND_MAX / 10);\n            c[x] = 1;\n        }\n\n        #pragma acc enter data copyin(c[0:n])\n        for (int x = 0; x < n; ++x){\n            c[x] = 0;\n        }\n        acc_create(c, n * sizeof(real_t));\n        #pragma acc data copyin(a[0:n], b[0:n])\n        {\n            #pragma acc parallel present(c[0:n])\n            {\n                #pragma acc loop\n                for (int x = 0; x < n; ++x) {\n                    c[x] += a[x] + b[x];\n                }\n            }\n        }\n\n        #pragma acc exit data delete(c[0:n])\n        #pragma acc exit data copyout(c[0:n])\n    \n        for (int x = 0; x < n; ++x) {\n            if (fabs(c[x] - (1 + a[x] + b[x])) > PRECISION) {\n                err += 1;\n            }\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T5\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test5();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 4);\n    }\n#endif\n",
                        "tags": [
                            "runtime",
                            "data",
                            "executable-data",
                            "devonly",
                            "construct-independent",
                            "reference-counting"
                        ],
                        "versions": [
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "acc_create_async.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:runtime,data,executable-data,async,construct-independent,V:2.5-2.7\n      LOGICAL FUNCTION test1()\n        USE OPENACC\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT):: a, b, c, d, e, f !Data\n        REAL(8) :: RAND\n        INTEGER :: errors = 0\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n        CALL RANDOM_NUMBER(a)\n        CALL RANDOM_NUMBER(b)\n        c = 0\n        CALL RANDOM_NUMBER(d)\n        CALL RANDOM_NUMBER(e)\n        f = 0\n\n        !$acc data copyin(a(1:LOOPCOUNT), b(1:LOOPCOUNT), d(1:LOOPCOUNT), e(1:LOOPCOUNT))\n          CALL acc_create_async(c(1:LOOPCOUNT), 1)\n          CALL acc_create_async(f(1:LOOPCOUNT), 2)\n          !$acc data present(c(1:LOOPCOUNT), f(1:LOOPCOUNT))\n            !$acc parallel async(1)\n              !$acc loop\n              DO x = 1, LOOPCOUNT\n                c(x) = a(x) + b(x)\n              END DO\n            !$acc end parallel\n            !$acc parallel async(2)\n              !$acc loop\n              DO x = 1, LOOPCOUNT\n                f(x) = d(x) + e(x)\n              END DO\n            !$acc end parallel\n            !$acc wait\n          !$acc end data\n        !$acc end data\n\n        !$acc exit data copyout(c(1:LOOPCOUNT), f(1:LOOPCOUNT))\n\n        DO x = 1, LOOPCOUNT\n          IF (abs(c(x) - (a(x) + b(x))) .gt. PRECISION) THEN\n            errors = errors + 1\n          END IF\n          IF (abs(f(x) - (d(x) + e(x))) .gt. PRECISION) THEN\n            errors = errors + 1\n          END IF\n        END DO\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "runtime",
                            "data",
                            "executable-data",
                            "async",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "acc_create_async.c": {
                "num tests": 5,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:runtime,async,data,executable-data,construct-independent,V:2.5-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t *a = (real_t *)malloc(n * sizeof(real_t));\n    real_t *b = (real_t *)malloc(n * sizeof(real_t));\n    real_t *c = (real_t *)malloc(n * sizeof(real_t));\n    real_t *d = (real_t *)malloc(n * sizeof(real_t));\n    real_t *e = (real_t *)malloc(n * sizeof(real_t));\n    real_t *f = (real_t *)malloc(n * sizeof(real_t));\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n        c[x] = 0;\n        d[x] = rand() / (real_t)(RAND_MAX / 10);\n        e[x] = rand() / (real_t)(RAND_MAX / 10);\n        f[x] = 0;\n    }\n\n    #pragma acc data copyin(a[0:n], b[0:n], d[0:n], e[0:n])\n    {\n        acc_create_async(c, n * sizeof(real_t), 1);\n        acc_create_async(f, n * sizeof(real_t), 2);\n        #pragma acc data present(c[0:n], f[0:n])\n        {\n            #pragma acc parallel async(1)\n            {\n                #pragma acc loop\n                for (int x = 0; x < n; ++x){\n                    c[x] = a[x] + b[x];\n                }\n            }\n            #pragma acc parallel async(2)\n            {\n                #pragma acc loop\n                for (int x = 0; x < n; ++x){\n                    f[x] = d[x] + e[x];\n                }\n            }\n            #pragma acc wait\n        }\n    }\n\n    #pragma acc exit data copyout(c[0:n], f[0:n])\n\n    for (int x = 0; x < n; ++x){\n        if (fabs(c[x] - (a[x] + b[x])) > PRECISION){\n            err += 1;\n        }\n        if (fabs(f[x] - (d[x] + e[x])) > PRECISION){\n            err += 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "runtime",
                            "async",
                            "data",
                            "executable-data",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "2": {
                        "content": "#ifndef T2\n//T2:runtime,data,executable-data,async,construct-independent,V:2.5-2.7\nint test2(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n    real_t * c = (real_t *)malloc(n * sizeof(real_t));\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n        c[x] = 0;\n    }\n\n    acc_create_async(c, n * sizeof(real_t), 1);\n\n    #pragma acc data copyin(a[0:n], b[0:n])\n    {\n        while (!acc_async_test_all());\n        #pragma acc parallel present(c[0:n])\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x) {\n                c[x] = a[x] + b[x];\n            }\n        }\n    }\n\n    #pragma acc exit data copyout(c[0:n])\n\n    for (int x = 0; x < n; ++x) {\n        if (fabs(c[x] - (a[x] + b[x])) > PRECISION){\n            err += 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T2\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test2();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 1);\n    }\n#endif\n",
                        "tags": [
                            "runtime",
                            "data",
                            "executable-data",
                            "async",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "3": {
                        "content": "#ifndef T3\n//T3:runtime,data,executable-data,async,construct-independent,V:2.5-2.7\nint test3(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n    real_t * c = (real_t *)malloc(n * sizeof(real_t));\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n        c[x] = 0;\n    }\n\n    acc_create_async(c, n * sizeof(real_t), 1);\n\n    #pragma acc data copyin(a[0:n], b[0:n])\n    {\n        #pragma acc wait\n        #pragma acc parallel present(c[0:n])\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x) {\n                c[x] = a[x] + b[x];\n            }\n        }\n    }\n\n    #pragma acc exit data copyout(c[0:n])\n\n    for (int x = 0; x < n; ++x) {\n        if (fabs(c[x] - (a[x] + b[x])) > PRECISION) {\n            err += 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T3\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test3();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 2);\n    }\n#endif\n",
                        "tags": [
                            "runtime",
                            "data",
                            "executable-data",
                            "async",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "4": {
                        "content": "#ifndef T4\n//T4:runtime,data,executable-data,async,construct-independent,reference-counting,V:2.5-2.7\nint test4(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n    real_t * c = (real_t *)malloc(n * sizeof(real_t));\n    real_t * d = (real_t *)malloc(n * sizeof(real_t));\n    real_t * e = (real_t *)malloc(n * sizeof(real_t));\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n        c[x] = 0;\n        d[x] = rand() / (real_t)(RAND_MAX / 10);\n        e[x] = 0;\n    }\n\n    #pragma acc enter data create(c[0:n])\n    #pragma acc data copyin(a[0:n], b[0:n], d[0:n]) copyout(e[0:n])\n    {\n        #pragma acc parallel present(c[0:n]) async(1)\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x) {\n                c[x] = a[x] + b[x];\n            }\n        }\n        acc_create_async(c, n * sizeof(real_t), 1);\n        #pragma acc exit data delete(c[0:n]) async(1)\n        #pragma acc parallel present(c[0:n]) async(1)\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x) {\n                e[x] = c[x] + d[x];\n            }\n        }\n    }\n    #pragma acc wait\n    #pragma acc exit data copyout(c[0:n])\n\n    for (int x = 0; x < n; ++x) {\n        if (fabs(e[x] - (a[x] + b[x] + d[x])) > PRECISION) {\n            err += 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T4\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test4();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 3);\n    }\n#endif\n",
                        "tags": [
                            "runtime",
                            "data",
                            "executable-data",
                            "async",
                            "construct-independent",
                            "reference-counting"
                        ],
                        "versions": [
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "5": {
                        "content": "#ifndef T5\n//T5:runtime,data,executable-data,devonly,async,construct-independent,reference-counting,V:2.5-2.7\nint test5(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n    real_t * c = (real_t *)malloc(n * sizeof(real_t));\n    int * devtest = (int *)malloc(sizeof(int));\n    \n    devtest[0] = 0;\n    #pragma acc enter data copyin(devtest[0:1])\n    #pragma acc parallel present(devtest[0:1])\n    {\n        devtest[0] = 1;\n    }\n\n    if (devtest[0] == 0){\n        for (int x = 0; x < n; ++x){\n            a[x] = rand() / (real_t)(RAND_MAX / 10);\n            b[x] = rand() / (real_t)(RAND_MAX / 10);\n            c[x] = 0;\n        }\n\n        #pragma acc enter data create(c[0:n])\n        #pragma acc data copyin(a[0:n], b[0:n])\n        {\n            #pragma acc parallel present(c[0:n]) async(1)\n            {\n                #pragma acc loop\n                for (int x = 0; x < n; ++x) {\n                    c[x] = a[x] + b[x];\n                }\n            }\n            acc_create_async(c, n * sizeof(real_t), 1);\n            #pragma acc parallel present(c[0:n]) async(1)\n            {\n                #pragma acc loop\n                for (int x = 0; x < n; ++x) {\n                    c[x] += a[x] + b[x];\n                }\n            }\n            #pragma acc exit data copyout(c[0:n]) async(1)\n            #pragma acc wait\n        }\n\n        for (int x = 0; x < n; ++x) {\n            if (fabs(c[x] - (2 * (a[x] + b[x]))) > PRECISION) {\n                err += 1;\n            }\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T5\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test5();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 4);\n    }\n#endif\n",
                        "tags": [
                            "runtime",
                            "data",
                            "executable-data",
                            "devonly",
                            "async",
                            "construct-independent",
                            "reference-counting"
                        ],
                        "versions": [
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "acc_create_async_with_len.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:runtime,data,executable-data,async,construct-independent,V:2.5-2.7\n      LOGICAL FUNCTION test1()\n        USE OPENACC\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.fh\"\n        INTEGER :: x !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT):: a, b, c, d, e, f !Data\n        REAL(8) :: RAND\n        INTEGER :: errors = 0\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n        CALL RANDOM_NUMBER(a)\n        CALL RANDOM_NUMBER(b)\n        c = 0\n        CALL RANDOM_NUMBER(d)\n        CALL RANDOM_NUMBER(e)\n        f = 0\n\n        !$acc data copyin(a(1:LOOPCOUNT), b(1:LOOPCOUNT), d(1:LOOPCOUNT), e(1:LOOPCOUNT))\n          CALL acc_create_async(c(1), LOOPCOUNT*8, 1)\n          CALL acc_create_async(f(1), LOOPCOUNT*8, 2)\n          !$acc data present(c(1:LOOPCOUNT), f(1:LOOPCOUNT))\n            !$acc parallel async(1)\n              !$acc loop\n              DO x = 1, LOOPCOUNT\n                c(x) = a(x) + b(x)\n              END DO\n            !$acc end parallel\n            !$acc parallel async(2)\n              !$acc loop\n              DO x = 1, LOOPCOUNT\n                f(x) = d(x) + e(x)\n              END DO\n            !$acc end parallel\n            !$acc wait\n          !$acc end data\n        !$acc end data\n\n        !$acc exit data copyout(c(1:LOOPCOUNT), f(1:LOOPCOUNT))\n\n        DO x = 1, LOOPCOUNT\n          IF (abs(c(x) - (a(x) + b(x))) .gt. PRECISION) THEN\n            errors = errors + 1\n          END IF\n          IF (abs(f(x) - (d(x) + e(x))) .gt. PRECISION) THEN\n            errors = errors + 1\n          END IF\n        END DO\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "runtime",
                            "data",
                            "executable-data",
                            "async",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "acc_create_with_len.F90": {
                "num tests": 4,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:runtime,data,executable-data,construct-independent,V:2.0-2.7\n      LOGICAL FUNCTION test1()\n        USE OPENACC\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT):: a, b, c !Data\n        INTEGER :: errors\n        errors = 0\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n        CALL RANDOM_NUMBER(a)\n        CALL RANDOM_NUMBER(b)\n        c = 0\n\n        CALL acc_create(c(1), LOOPCOUNT*8)\n\n        !$acc data copyin(a(1:LOOPCOUNT), b(1:LOOPCOUNT))\n          !$acc parallel present(c(1:LOOPCOUNT))\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              c(x) = a(x) + b(x)\n            END DO\n          !$acc end parallel\n        !$acc end data\n\n        CALL acc_copyout(c(1:LOOPCOUNT))\n\n        DO x = 1, LOOPCOUNT\n          IF (abs(c(x) - (a(x) + b(x))) .gt. PRECISION) THEN\n            errors = errors + 1\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "runtime",
                            "data",
                            "executable-data",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "2": {
                        "content": "#ifndef T2\n!T2:runtime,data,executable-data,construct-independent,V:2.0-2.7\n      LOGICAL FUNCTION test2()\n        USE OPENACC\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER:: x\n        REAL(8),DIMENSION(LOOPCOUNT):: a, b, c\n        INTEGER :: errors\n        errors = 0\n\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n        CALL RANDOM_NUMBER(a)\n        CALL RANDOM_NUMBER(b)\n        c= 0\n\n        CALL acc_create(c(1), LOOPCOUNT*8)\n\n        !$acc data copyin(a(1:LOOPCOUNT), b(1:LOOPCOUNT))\n          !$acc parallel present(c(1:LOOPCOUNT))\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              c(x) = a(x) + b(x)\n            END DO\n          !$acc end parallel\n        !$acc end data\n\n        !$acc exit data copyout(c(1:LOOPCOUNT))\n\n        DO x = 1, LOOPCOUNT\n          IF (abs(c(x) - (a(x) + b(x))) .gt. PRECISION) THEN\n            errors = errors + 1\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test2 = .FALSE.\n        ELSE\n          test2 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T2\n        LOGICAL :: test2\n#endif\n#ifndef T2\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test2()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 1\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "runtime",
                            "data",
                            "executable-data",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "3": {
                        "content": "#ifndef T3\n!T3:runtime,compatibility-features,construct-independent,V:2.0-2.7\n      LOGICAL FUNCTION test3()\n        USE OPENACC\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER:: x\n        REAL(8),DIMENSION(LOOPCOUNT):: a, b, c\n        INTEGER:: errors\n        errors = 0\n\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n        CALL RANDOM_NUMBER(a)\n        CALL RANDOM_NUMBER(b)\n        c = 0\n\n        CALL acc_pcreate(c(1), LOOPCOUNT*8)\n\n        !$acc data copyin(a(1:LOOPCOUNT), b(1:LOOPCOUNT)) present(c(1:LOOPCOUNT))\n          !$acc parallel\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              c(x) = a(x) + b(x)\n            END DO\n          !$acc end parallel\n        !$acc end data\n\n        !$acc exit data copyout(c(1:LOOPCOUNT))\n\n        DO x = 1, LOOPCOUNT\n          IF (abs(c(x) - (a(x) + b(x))) .gt. PRECISION) THEN\n            errors = errors + 1\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test3 = .FALSE.\n        ELSE\n          test4 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T3\n        LOGICAL :: test3\n#endif\n#ifndef T3\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test3()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 2\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "runtime",
                            "compatibility-features",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "4": {
                        "content": "#ifndef T4\n!T4:runtime,compatibility-features,construct-independent,V:2.0-2.7\n      LOGICAL FUNCTION test4()\n        USE OPENACC\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER:: x\n        REAL(8),DIMENSION(LOOPCOUNT):: a, b, c\n        INTEGER:: errors\n        errors = 0\n\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n        CALL RANDOM_NUMBER(a)\n        CALL RANDOM_NUMBER(b)\n        c = 0\n\n        CALL acc_present_or_create(c(1), LOOPCOUNT*8)\n\n        !$acc data copyin(a(1:LOOPCOUNT), b(1:LOOPCOUNT)) present(c(1:LOOPCOUNT))\n          !$acc parallel\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              c(x) = a(x) + b(x)\n            END DO\n          !$acc end parallel\n        !$acc end data\n\n        DO x = 1, LOOPCOUNT\n          IF (abs(c(x) - (a(x) + b(x))) .gt. PRECISION) THEN\n            errors = errors + 1\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test4 = .FALSE.\n        ELSE\n          test4 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T4\n        LOGICAL :: test4\n#endif\n#ifndef T4\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test4()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 3\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "runtime",
                            "compatibility-features",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "acc_delete.F90": {
                "num tests": 2,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:runtime,data,executable-data,construct-independent,V:2.0-2.7\n      LOGICAL FUNCTION test1()\n        USE OPENACC\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT):: a, b, c !Data\n        INTEGER :: errors\n        errors = 0\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n        CALL RANDOM_NUMBER(a)\n        CALL RANDOM_NUMBER(b)\n        c = 0\n\n        !$acc enter data copyin(a(1:LOOPCOUNT), b(1:LOOPCOUNT))\n\n        !$acc data copyout(c(1:LOOPCOUNT))\n          !$acc parallel present(a(1:LOOPCOUNT), b(1:LOOPCOUNT))\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              c(x) = a(x) + b(x)\n            END DO\n          !$acc end parallel\n        !$acc end data\n\n        CALL acc_delete(a(1:LOOPCOUNT))\n        CALL acc_delete(b(1:LOOPCOUNT))\n\n        DO x = 1, LOOPCOUNT\n          IF (abs(c(x) - (a(x) + b(x))) .gt. PRECISION) THEN\n            errors = errors + 1\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "runtime",
                            "data",
                            "executable-data",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "2": {
                        "content": "#ifndef T2\n!T2:runtime,data,executable-data,construct-independent,V:2.0-2.7\n      LOGICAL FUNCTION test2()\n        USE OPENACC\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER:: x\n        REAL(8),DIMENSION(LOOPCOUNT):: a, b, c\n        INTEGER:: errors\n        errors = 0\n\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n        CALL RANDOM_NUMBER(a)\n        CALL RANDOM_NUMBER(b)\n        c = 0\n\n        CALL acc_copyin(a(1:LOOPCOUNT))\n        CALL acc_copyin(b(1:LOOPCOUNT))\n\n        !$acc data copyout(c(1:LOOPCOUNT))\n          !$acc parallel present(a(1:LOOPCOUNT), b(1:LOOPCOUNT))\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              c(x) = a(x) + b(x)\n            END DO\n          !$acc end parallel\n        !$acc end data\n\n        CALL acc_delete(a(1:LOOPCOUNT))\n        CALL acc_delete(b(1:LOOPCOUNT))\n\n        DO x = 1, LOOPCOUNT\n          IF (abs(c(x) - (a(x) + b(x))) .gt. PRECISION) THEN\n            errors = errors + 1\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test2 = .FALSE.\n        ELSE\n          test2 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T2\n        LOGICAL :: test2\n#endif\n#ifndef T2\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test2()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2**1\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "runtime",
                            "data",
                            "executable-data",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "acc_delete.c": {
                "num tests": 2,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:runtime,data,executable-data,construct-independent,V:2.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n    real_t * c = (real_t *)malloc(n * sizeof(real_t));\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n        c[x] = 0.0;\n    }\n\n    #pragma acc enter data copyin(a[0:n], b[0:n])\n\n    #pragma acc data copyout(c[0:n])\n    {\n        #pragma acc parallel present(a[0:n], b[0:n])\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                c[x] = a[x] + b[x];\n            }\n        }\n    }\n\n    acc_delete(a, n * sizeof(real_t));\n    acc_delete(b, n * sizeof(real_t));\n\n    for (int x = 0; x < n; ++x){\n        if (fabs(c[x] - (a[x] + b[x])) > PRECISION){\n            err += 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "runtime",
                            "data",
                            "executable-data",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "2": {
                        "content": "#ifndef T2\n//T2:runtime,data,executable-data,construct-independent,V:2.0-2.7\nint test2(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n    real_t * c = (real_t *)malloc(n * sizeof(real_t));\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n        c[x] = 0.0;\n    }\n\n    acc_copyin(a, n * sizeof(real_t));\n    acc_copyin(b, n * sizeof(real_t));\n\n    #pragma acc data copyout(c[0:n])\n    {\n        #pragma acc parallel present(a[0:n], b[0:n])\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                c[x] = a[x] + b[x];\n            }\n        }\n    }\n\n    acc_delete(a, n * sizeof(real_t));\n    acc_delete(b, n * sizeof(real_t));\n\n    for (int x = 0; x < n; ++x){\n        if (fabs(c[x] - (a[x] + b[x])) > PRECISION){\n            err += 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T2\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test2();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 1);\n    }\n#endif\n",
                        "tags": [
                            "runtime",
                            "data",
                            "executable-data",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "acc_delete_async.F90": {
                "num tests": 2,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:runtime,data,executable-data,async,construct-independent,V:2.5-2.7\n      LOGICAL FUNCTION test1()\n        USE OPENACC\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT):: a, b, c, d, e, f !Data\n        INTEGER :: errors = 0\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n        CALL RANDOM_NUMBER(a)\n        CALL RANDOM_NUMBER(b)\n        c = 0\n        CALL RANDOM_NUMBER(d)\n        CALL RANDOM_NUMBER(e)\n        f = 0\n\n        !$acc enter data copyin(a(1:LOOPCOUNT), b(1:LOOPCOUNT), d(1:LOOPCOUNT), e(1:LOOPCOUNT))\n\n        !$acc data present(a(1:LOOPCOUNT), b(1:LOOPCOUNT), d(1:LOOPCOUNT), e(1:LOOPCOUNT)) copyout(c(1:LOOPCOUNT), f(1:LOOPCOUNT))\n          !$acc parallel async(1)\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              c(x) = a(x) + b(x)\n            END DO\n          !$acc end parallel\n          !$acc parallel async(2)\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              f(x) = d(x) + e(x)\n            END DO\n          !$acc end parallel\n          CALL acc_delete_async(a(1:LOOPCOUNT), 1)\n          CALL acc_delete_async(b(1:LOOPCOUNT), 1)\n          CALL acc_delete_async(d(1:LOOPCOUNT), 2)\n          CALL acc_delete_async(e(1:LOOPCOUNT), 2)\n          !$acc wait\n        !$acc end data\n\n        DO x = 1, LOOPCOUNT\n          IF (abs(c(x) - (a(x) + b(x))) .gt. PRECISION) THEN\n            errors = errors + 1\n          END IF\n          IF (abs(f(x) - (d(x) + e(x))) .gt. PRECISION) THEN\n            errors = errors + 1\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "runtime",
                            "data",
                            "executable-data",
                            "async",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "2": {
                        "content": "#ifndef T2\n!T2:runtime,data,executable-data,devonly,async,construct-independent,V:2.5-2.7\n      LOGICAL FUNCTION test2()\n        USE OPENACC\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT):: a, b, c!Data\n        INTEGER,DIMENSION(1) :: devtest\n        INTEGER :: errors = 0\n\n        devtest(1) = 1\n        !$acc enter data copyin(devtest(1:1))\n        !$acc parallel present(devtest(1:1))\n          devtest(1) = 0\n        !$acc end parallel\n\n        IF (devtest(1) == 1) THEN\n          CALL RANDOM_NUMBER(a)\n          CALL RANDOM_NUMBER(b)\n          c = 0\n\n          !$acc enter data copyin(a(1:LOOPCOUNT), b(1:LOOPCOUNT), c(1:LOOPCOUNT))\n          !$acc data present(a(1:LOOPCOUNT), b(1:LOOPCOUNT), c(1:LOOPCOUNT))\n            !$acc parallel async(1)\n              !$acc loop\n              DO x = 1, LOOPCOUNT\n                c(x) = a(x) + b(x)\n              END DO\n            !$acc end parallel\n          !$acc end data\n          CALL acc_delete_async(c(1:LOOPCOUNT), 1)\n          !$acc enter data copyin(c(1:LOOPCOUNT)) async(1)\n          !$acc data present(a(1:LOOPCOUNT), b(1:LOOPCOUNT), c(1:LOOPCOUNT))\n            !$acc parallel async(1)\n              !$acc loop\n              DO x = 1, LOOPCOUNT\n                c(x) = c(x) + a(x) + b(x)\n              END DO\n            !$acc end parallel\n          !$acc end data\n          !$acc exit data delete(a(1:LOOPCOUNT), b(1:LOOPCOUNT)) copyout(c(1:LOOPCOUNT))\n\n          DO x = 1, LOOPCOUNT\n            IF (abs(c(x) - (a(x) + b(x))) .gt. PRECISION) THEN\n              errors = errors + 1\n            END IF\n          END DO\n        END IF\n\n        IF (errors .eq. 0) THEN\n          test2 = .FALSE.\n        ELSE\n          test2 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T2\n        LOGICAL :: test2\n#endif\n#ifndef T2\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test2()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2**1\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "runtime",
                            "data",
                            "executable-data",
                            "devonly",
                            "async",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "acc_delete_async.c": {
                "num tests": 2,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:runtime,data,executable-data,construct-independent,async,V:2.5-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t *a = (real_t *)malloc(n * sizeof(real_t));\n    real_t *b = (real_t *)malloc(n * sizeof(real_t));\n    real_t *c = (real_t *)malloc(n * sizeof(real_t));\n    real_t *d = (real_t *)malloc(n * sizeof(real_t));\n    real_t *e = (real_t *)malloc(n * sizeof(real_t));\n    real_t *f = (real_t *)malloc(n * sizeof(real_t));\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n        c[x] = 0;\n        d[x] = rand() / (real_t)(RAND_MAX / 10);\n        e[x] = rand() / (real_t)(RAND_MAX / 10);\n        f[x] = 0;\n    }\n\n    #pragma acc enter data copyin(a[0:n], b[0:n], d[0:n], e[0:n])\n\n    #pragma acc data present(a[0:n], b[0:n], d[0:n], e[0:n]) copyout(c[0:n], f[0:n])\n    {\n        #pragma acc parallel async(1)\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                c[x] = a[x] + b[x];\n            }\n        }\n        #pragma acc parallel async(2)\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                f[x] = d[x] + e[x];\n            }\n        }\n        acc_delete_async(a, n * sizeof(real_t), 1);\n        acc_delete_async(b, n * sizeof(real_t), 1);\n        acc_delete_async(d, n * sizeof(real_t), 2);\n        acc_delete_async(e, n * sizeof(real_t), 2);\n        #pragma acc wait\n    }\n\n    for (int x = 0; x < n; ++x){\n        if (fabs(c[x] - (a[x] + b[x])) > PRECISION){\n            err += 1;\n        }\n        if (fabs(f[x] - (d[x] + e[x])) > PRECISION){\n            err += 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "runtime",
                            "data",
                            "executable-data",
                            "construct-independent",
                            "async"
                        ],
                        "versions": [
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "2": {
                        "content": "#ifndef T2\n//T2:runtime,data,executable-data,devonly,async,construct-independent,V:2.5-2.7\nint test2(){\n    int err = 0;\n    srand(SEED);\n    real_t *a = (real_t *)malloc(n * sizeof(real_t));\n    real_t *b = (real_t *)malloc(n * sizeof(real_t));\n    real_t *c = (real_t *)malloc(n * sizeof(real_t));\n    real_t *d = (real_t *)malloc(n * sizeof(real_t));\n    real_t *e = (real_t *)malloc(n * sizeof(real_t));\n    real_t *f = (real_t *)malloc(n * sizeof(real_t));\n    int* devtest = (int *)malloc(sizeof(int));\n\n    devtest[0] = 1;\n    #pragma acc enter data copyin(devtest[0:1])\n    #pragma acc parallel present(devtest[0:1])\n    {\n        devtest[0] = 0;\n    }\n\n    if (devtest[0] == 1){\n        for (int x = 0; x < n; ++x){\n            a[x] = rand() / (real_t)(RAND_MAX / 10);\n            b[x] = rand() / (real_t)(RAND_MAX / 10);\n            c[x] = 0;\n        }\n\n        #pragma acc enter data copyin(a[0:n], b[0:n], c[0:n])\n        #pragma acc data present(a[0:n], b[0:n], c[0:n])\n        {\n            #pragma acc parallel async(1)\n            {\n                #pragma acc loop\n                for (int x = 0; x < n; ++x){\n                    c[x] = a[x] * b[x];\n                }\n            }\n        }\n        acc_delete_async(c, n * sizeof(real_t), 1);\n        #pragma acc enter data copyin(c[0:n]) async(1)\n        #pragma acc data present(a[0:n], b[0:n], c[0:n])\n        {\n            #pragma acc parallel async(1)\n            {\n                #pragma acc loop\n                for (int x = 0; x < n; ++x){\n                    c[x] += a[x] + b[x];\n                }\n            }\n        }\n        #pragma acc exit data delete(a[0:n], b[0:n]) copyout(c[0:n])\n\n        for (int x = 0; x < n; ++x){\n            if (fabs(c[x] - (a[x] + b[x])) > PRECISION){\n                err += 1;\n            }\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T2\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test2();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 1);\n    }\n#endif\n",
                        "tags": [
                            "runtime",
                            "data",
                            "executable-data",
                            "devonly",
                            "async",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "acc_delete_async_with_len.F90": {
                "num tests": 2,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:runtime,data,executable-data,async,construct-independent,V:2.5-2.7\n      LOGICAL FUNCTION test1()\n        USE OPENACC\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT):: a, b, c, d, e, f !Data\n        INTEGER :: errors = 0\n\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n        CALL RANDOM_NUMBER(a)\n        CALL RANDOM_NUMBER(b)\n        c = 0\n        CALL RANDOM_NUMBER(d)\n        CALL RANDOM_NUMBER(e)\n        f = 0\n\n        !$acc enter data copyin(a(1:LOOPCOUNT), b(1:LOOPCOUNT), d(1:LOOPCOUNT), e(1:LOOPCOUNT))\n\n        !$acc data present(a(1:LOOPCOUNT), b(1:LOOPCOUNT), d(1:LOOPCOUNT), e(1:LOOPCOUNT)) copyout(c(1:LOOPCOUNT), f(1:LOOPCOUNT))\n          !$acc parallel async(1)\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              c(x) = a(x) + b(x)\n            END DO\n          !$acc end parallel\n          !$acc parallel async(2)\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              f(x) = d(x) + e(x)\n            END DO\n          !$acc end parallel\n          CALL acc_delete_async(a(1), LOOPCOUNT*8, 1)\n          CALL acc_delete_async(b(1), LOOPCOUNT*8, 1)\n          CALL acc_delete_async(d(1), LOOPCOUNT*8, 2)\n          CALL acc_delete_async(e(1), LOOPCOUNT*8, 2)\n          !$acc wait\n        !$acc end data\n\n        DO x = 1, LOOPCOUNT\n          IF (abs(c(x) - (a(x) + b(x))) .gt. PRECISION) THEN\n            errors = errors + 1\n          END IF\n          IF (abs(f(x) - (d(x) + e(x))) .gt. PRECISION) THEN\n            errors = errors + 1\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "runtime",
                            "data",
                            "executable-data",
                            "async",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "2": {
                        "content": "#ifndef T2\n!T2:runtime,data,executable-data,devonly,async,construct-independent,V:2.5-2.7\n      LOGICAL FUNCTION test2()\n        USE OPENACC\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT):: a, b, c !Data\n        INTEGER,DIMENSION(1):: devtest\n        INTEGER :: errors = 0\n\n        devtest(1) = 1\n        !$acc enter data copyin(devtest(1:1))\n        !$acc parallel present(devtest(1:1))\n          devtest(1) = 0\n        !$acc end parallel\n        IF (devtest(1) == 1) THEN\n          CALL RANDOM_NUMBER(a)\n          CALL RANDOM_NUMBER(b)\n          c = 0\n\n          !$acc enter data copyin(a(1:LOOPCOUNT), b(1:LOOPCOUNT), c(1:LOOPCOUNT))\n          !$acc data present(a(1:LOOPCOUNT), b(1:LOOPCOUNT), c(1:LOOPCOUNT))\n            !$acc parallel async(1)\n              !$acc loop\n              DO x = 1, LOOPCOUNT\n                c(x) = a(x) + b(x)\n              END DO\n            !$acc end parallel\n          !$acc end data\n          CALL acc_delete_async(c(1), LOOPCOUNT*8, 1)\n          !$acc enter data copyin(c(1:LOOPCOUNT)) async(1)\n          !$acc data present(a(1:LOOPCOUNT), b(1:LOOPCOUNT), c(1:LOOPCOUNT))\n            !$acc parallel async(1)\n              !$acc loop\n              DO x = 1, LOOPCOUNT\n                c(x) = c(x) + a(x) + b(x)\n              END DO\n            !$acc end parallel\n          !$acc end data\n          !$acc exit data delete(a(1:LOOPCOUNT), b(1:LOOPCOUNT)) copyout(c(1:LOOPCOUNT))\n\n          DO x = 1, LOOPCOUNT\n            IF (abs(c(x) - (a(x) + b(x))) .gt. PRECISION) THEN\n              errors = errors + 1\n            END IF\n          END DO\n        END IF\n\n        IF (errors .eq. 0) THEN\n          test2 = .FALSE.\n        ELSE\n          test2 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T2\n        LOGICAL :: test2\n#endif\n#ifndef T2\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test2()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2**1\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "runtime",
                            "data",
                            "executable-data",
                            "devonly",
                            "async",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "acc_delete_finalize.F90": {
                "num tests": 2,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:runtime,data,executable-data,construct-independent,V:2.5-2.7\n      LOGICAL FUNCTION test1()\n        USE OPENACC\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT):: a, b, c !Data\n        INTEGER :: errors = 0\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n        CALL RANDOM_NUMBER(a)\n        CALL RANDOM_NUMBER(b)\n        c = 0\n\n        !$acc enter data copyin(a(1:LOOPCOUNT), b(1:LOOPCOUNT))\n        !$acc enter data copyin(a(1:LOOPCOUNT), b(1:LOOPCOUNT))\n\n        !$acc data copyout(c(1:LOOPCOUNT))\n          !$acc parallel present(a(1:LOOPCOUNT), b(1:LOOPCOUNT))\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              c(x) = a(x) + b(x)\n            END DO\n          !$acc end parallel\n        !$acc end data\n\n        CALL acc_delete_finalize(a(1:LOOPCOUNT))\n        CALL acc_delete_finalize(b(1:LOOPCOUNT))\n\n        DO x = 1, LOOPCOUNT\n          IF (abs(c(x) - (a(x) + b(x))) .gt. PRECISION) THEN\n            errors = errors + 1\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "runtime",
                            "data",
                            "executable-data",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "2": {
                        "content": "#ifndef T2\n!T2:runtime,data,executable-data,construct-independent,V:2.5-2.7\n      LOGICAL FUNCTION test2()\n        USE OPENACC\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT):: a, b, c !Data\n        INTEGER :: errors = 0\n\n        CALL RANDOM_NUMBER(a)\n        CALL RANDOM_NUMBER(b)\n        c = 0\n\n        CALL acc_copyin(a(1:LOOPCOUNT))\n        CALL acc_copyin(a(1:LOOPCOUNT))\n        CALL acc_copyin(b(1:LOOPCOUNT))\n        CALL acc_copyin(b(1:LOOPCOUNT))\n\n        !$acc data copyout(c(1:LOOPCOUNT))\n          !$acc parallel present(a(1:LOOPCOUNT), b(1:LOOPCOUNT))\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              c(x) = a(x) + b(x)\n            END DO\n          !$acc end parallel\n        !$acc end data\n\n        CALL acc_delete_finalize(a(1:LOOPCOUNT))\n        CALL acc_delete_finalize(b(1:LOOPCOUNT))\n\n        DO x = 1, LOOPCOUNT\n          IF (abs(c(x) - (a(x) + b(x))) .gt. PRECISION) THEN\n            errors = errors + 1\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test2 = .FALSE.\n        ELSE\n          test2 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T2\n        LOGICAL :: test2\n#endif\n#ifndef T2\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test2()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2**1\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "runtime",
                            "data",
                            "executable-data",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "acc_delete_finalize.c": {
                "num tests": 2,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:runtime,data,executable-data,reference-counting,construct-independent,syntactic,V:2.5-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n    real_t * c = (real_t *)malloc(n * sizeof(real_t));\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n        c[x] = 0.0;\n    }\n\n    #pragma acc enter data copyin(a[0:n], b[0:n])\n    #pragma acc enter data copyin(a[0:n], b[0:n])\n\n    #pragma acc data copyout(c[0:n])\n    {\n        #pragma acc parallel present(a[0:n], b[0:n])\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                c[x] = a[x] + b[x];\n            }\n        }\n    }\n\n    acc_delete_finalize(a, n * sizeof(real_t));\n    acc_delete_finalize(b, n * sizeof(real_t));\n\n    for (int x = 0; x < n; ++x){\n        if (fabs(c[x] - (a[x] + b[x])) > PRECISION){\n            err += 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "runtime",
                            "data",
                            "executable-data",
                            "reference-counting",
                            "construct-independent",
                            "syntactic"
                        ],
                        "versions": [
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "2": {
                        "content": "#ifndef T2\n//T2:runtime,data,executable-data,reference-counting,syntactic,construct-independent,V:2.5-2.7\nint test2(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n    real_t * c = (real_t *)malloc(n * sizeof(real_t));\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n        c[x] = 0.0;\n    }\n\n    acc_copyin(a, n * sizeof(real_t));\n    acc_copyin(a, n * sizeof(real_t));\n    acc_copyin(b, n * sizeof(real_t));\n    acc_copyin(b, n * sizeof(real_t));\n\n    #pragma acc data copyout(c[0:n])\n    {\n        #pragma acc parallel present(a[0:n], b[0:n])\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                c[x] = a[x] + b[x];\n            }\n        }\n    }\n\n    acc_delete_finalize(a, n * sizeof(real_t));\n    acc_delete_finalize(b, n * sizeof(real_t));\n\n    for (int x = 0; x < n; ++x){\n        if (fabs(c[x] - (a[x] + b[x])) > PRECISION){\n            err += 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T2\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test2();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 1);\n    }\n#endif\n",
                        "tags": [
                            "runtime",
                            "data",
                            "executable-data",
                            "reference-counting",
                            "syntactic",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "acc_delete_finalize_async.F90": {
                "num tests": 2,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:runtime,data,executable-data,async,construct-independent,V:2.5-2.7\n      LOGICAL FUNCTION test1()\n        USE OPENACC\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT):: a, b, c, d, e, f !Data\n        INTEGER :: errors\n        errors = 0\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n        CALL RANDOM_NUMBER(a)\n        CALL RANDOM_NUMBER(b)\n        c = 0\n        CALL RANDOM_NUMBER(d)\n        CALL RANDOM_NUMBER(e)\n        f = 0\n\n        !$acc enter data copyin(a(1:LOOPCOUNT), b(1:LOOPCOUNT), d(1:LOOPCOUNT), e(1:LOOPCOUNT))\n        !$acc enter data copyin(a(1:LOOPCOUNT), b(1:LOOPCOUNT), d(1:LOOPCOUNT), e(1:LOOPCOUNT))\n\n        !$acc data present(a(1:LOOPCOUNT), b(1:LOOPCOUNT), d(1:LOOPCOUNT), e(1:LOOPCOUNT)) copyout(c(1:LOOPCOUNT), f(1:LOOPCOUNT))\n          !$acc parallel async(1)\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              c(x) = a(x) + b(x)\n            END DO\n          !$acc end parallel\n          !$acc parallel async(2)\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              f(x) = d(x) + e(x)\n            END DO\n          !$acc end parallel\n          CALL acc_delete_finalize_async(a(1:LOOPCOUNT), 1)\n          CALL acc_delete_finalize_async(b(1:LOOPCOUNT), 1)\n          CALL acc_delete_finalize_async(d(1:LOOPCOUNT), 2)\n          CALL acc_delete_finalize_async(e(1:LOOPCOUNT), 2)\n          !$acc wait\n        !$acc end data\n\n        DO x = 1, LOOPCOUNT\n          IF (abs(c(x) - (a(x) + b(x))) .gt. PRECISION) THEN\n            errors = errors + 1\n          END IF\n          IF (abs(f(x) - (d(x) + e(x))) .gt. PRECISION) THEN\n            errors = errors + 1\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "runtime",
                            "data",
                            "executable-data",
                            "async",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "2": {
                        "content": "#ifndef T2\n!T2:runtime,data,executable-data,async,construct-independent,V:2.5-2.7\n      LOGICAL FUNCTION test2()\n        USE OPENACC\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT):: a, b, c !Data\n        INTEGER :: errors\n        errors = 0\n\n        CALL RANDOM_NUMBER(a)\n        CALL RANDOM_NUMBER(b)\n        c = 0\n\n        !$acc enter data copyin(a(1:LOOPCOUNT), b(1:LOOPCOUNT), c(1:LOOPCOUNT))\n        !$acc enter data copyin(c(1:LOOPCOUNT))\n        !$acc data present(a(1:LOOPCOUNT), b(1:LOOPCOUNT), c(1:LOOPCOUNT))\n          !$acc parallel async(1)\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              c(x) = a(x) + b(x)\n            END DO\n          !$acc end parallel\n        !$acc end data\n\n        CALL acc_delete_finalize_async(c(1:LOOPCOUNT), 1)\n\n        !$acc enter data copyin(c(1:LOOPCOUNT)) async(1)\n        !$acc data present(a(1:LOOPCOUNT), b(1:LOOPCOUNT), c(1:LOOPCOUNT))\n          !$acc parallel async(1)\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              c(x) = c(x) + a(x) + b(x)\n            END DO\n          !$acc end parallel\n        !$acc end data\n\n        !$acc exit data delete(a(1:LOOPCOUNT), b(1:LOOPCOUNT)) copyout(c(1:LOOPCOUNT))\n\n        DO x = 1, LOOPCOUNT\n          IF (abs(c(x) - (a(x) + b(x))) .gt. PRECISION) THEN\n            errors = errors + 1\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test2 = .FALSE.\n        ELSE\n          test2 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T2\n        LOGICAL :: test2\n#endif\n#ifndef T2\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test2()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2**1\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "runtime",
                            "data",
                            "executable-data",
                            "async",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "acc_delete_finalize_async.c": {
                "num tests": 2,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:runtime,data,executable-data,reference-counting,syntactic,construct-independent,async,V:2.5-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t *a = (real_t *)malloc(n * sizeof(real_t));\n    real_t *b = (real_t *)malloc(n * sizeof(real_t));\n    real_t *c = (real_t *)malloc(n * sizeof(real_t));\n    real_t *d = (real_t *)malloc(n * sizeof(real_t));\n    real_t *e = (real_t *)malloc(n * sizeof(real_t));\n    real_t *f = (real_t *)malloc(n * sizeof(real_t));\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n        c[x] = 0;\n        d[x] = rand() / (real_t)(RAND_MAX / 10);\n        e[x] = rand() / (real_t)(RAND_MAX / 10);\n        f[x] = 0;\n    }\n\n    #pragma acc enter data copyin(a[0:n], b[0:n], d[0:n], e[0:n])\n    #pragma acc enter data copyin(a[0:n], b[0:n], d[0:n], e[0:n])\n\n    #pragma acc data present(a[0:n], b[0:n], d[0:n], e[0:n]) copyout(c[0:n], f[0:n])\n    {\n        #pragma acc parallel async(1)\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                c[x] = a[x] + b[x];\n            }\n        }\n        #pragma acc parallel async(2)\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                f[x] = d[x] + e[x];\n            }\n        }\n        acc_delete_finalize_async(a, n * sizeof(real_t), 1);\n        acc_delete_finalize_async(b, n * sizeof(real_t), 1);\n        acc_delete_finalize_async(d, n * sizeof(real_t), 2);\n        acc_delete_finalize_async(e, n * sizeof(real_t), 2);\n        #pragma acc wait\n    }\n\n    for (int x = 0; x < n; ++x){\n        if (fabs(c[x] - (a[x] + b[x])) > PRECISION){\n            err += 1;\n        }\n        if (fabs(f[x] - (d[x] + e[x])) > PRECISION){\n            err += 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "runtime",
                            "data",
                            "executable-data",
                            "reference-counting",
                            "syntactic",
                            "construct-independent",
                            "async"
                        ],
                        "versions": [
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "2": {
                        "content": "#ifndef T2\n//T2:runtime,data,executable-data,reference-counting,devonly,async,construct-independent,V:2.5-2.7\nint test2(){\n    int err = 0;\n    srand(SEED);\n    real_t *a = (real_t *)malloc(n * sizeof(real_t));\n    real_t *b = (real_t *)malloc(n * sizeof(real_t));\n    real_t *c = (real_t *)malloc(n * sizeof(real_t));\n    real_t *d = (real_t *)malloc(n * sizeof(real_t));\n    real_t *e = (real_t *)malloc(n * sizeof(real_t));\n    real_t *f = (real_t *)malloc(n * sizeof(real_t));\n    int* devtest = (int *)malloc(sizeof(int));\n\n    devtest[0] = 1;\n    #pragma acc enter data copyin(devtest[0:1])\n    #pragma acc parallel present(devtest[0:1])\n    {\n        devtest[0] = 0;\n    }\n\n    if (devtest[0] == 1){\n        for (int x = 0; x < n; ++x){\n            a[x] = rand() / (real_t)(RAND_MAX / 10);\n            b[x] = rand() / (real_t)(RAND_MAX / 10);\n            c[x] = 0;\n        }\n\n        #pragma acc enter data copyin(a[0:n], b[0:n], c[0:n])\n        #pragma acc enter data copyin(c[0:n])\n        #pragma acc data present(a[0:n], b[0:n], c[0:n])\n        {\n            #pragma acc parallel async(1)\n            {\n                #pragma acc loop\n                for (int x = 0; x < n; ++x){\n                    c[x] = a[x] * b[x];\n                }\n            }\n        }\n        acc_delete_finalize_async(c, n * sizeof(real_t), 1);\n        #pragma acc enter data copyin(c[0:n]) async(1)\n        #pragma acc data present(a[0:n], b[0:n], c[0:n])\n        {\n            #pragma acc parallel async(1)\n            {\n                #pragma acc loop\n                for (int x = 0; x < n; ++x){\n                    c[x] += a[x] + b[x];\n                }\n            }\n        }\n        #pragma acc exit data delete(a[0:n], b[0:n]) copyout(c[0:n])\n\n        for (int x = 0; x < n; ++x){\n            if (fabs(c[x] - (a[x] + b[x])) > PRECISION){\n                err += 1;\n            }\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T2\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test2();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 1);\n    }\n#endif\n",
                        "tags": [
                            "runtime",
                            "data",
                            "executable-data",
                            "reference-counting",
                            "devonly",
                            "async",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "acc_delete_finalize_async_with_len.F90": {
                "num tests": 2,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:runtime,data,executable-data,async,construct-independent,V:2.5-2.7\n      LOGICAL FUNCTION test1()\n        USE OPENACC\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT):: a, b, c, d, e, f !Data\n        INTEGER :: errors = 0\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n        CALL RANDOM_NUMBER(a)\n        CALL RANDOM_NUMBER(b)\n        c = 0\n        CALL RANDOM_NUMBER(d)\n        CALL RANDOM_NUMBER(e)\n        f = 0\n\n        !$acc enter data copyin(a(1:LOOPCOUNT), b(1:LOOPCOUNT), d(1:LOOPCOUNT), e(1:LOOPCOUNT))\n        !$acc enter data copyin(a(1:LOOPCOUNT), b(1:LOOPCOUNT), d(1:LOOPCOUNT), e(1:LOOPCOUNT))\n\n        !$acc data present(a(1:LOOPCOUNT), b(1:LOOPCOUNT), d(1:LOOPCOUNT), e(1:LOOPCOUNT)) copyout(c(1:LOOPCOUNT), f(1:LOOPCOUNT))\n          !$acc parallel async(1)\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              c(x) = a(x) + b(x)\n            END DO\n          !$acc end parallel\n          !$acc parallel async(2)\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              f(x) = d(x) + e(x)\n            END DO\n          !$acc end parallel\n          CALL acc_delete_finalize_async(a(1), LOOPCOUNT*8, 1)\n          CALL acc_delete_finalize_async(b(1), LOOPCOUNT*8, 1)\n          CALL acc_delete_finalize_async(d(1), LOOPCOUNT*8, 2)\n          CALL acc_delete_finalize_async(e(1), LOOPCOUNT*8, 2)\n          !$acc wait\n        !$acc end data\n\n        DO x = 1, LOOPCOUNT\n          IF (abs(c(x) - (a(x) + b(x))) .gt. PRECISION) THEN\n            errors = errors + 1\n          END IF\n          IF (abs(f(x) - (d(x) + e(x))) .gt. PRECISION) THEN\n            errors = errors + 1\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "runtime",
                            "data",
                            "executable-data",
                            "async",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "2": {
                        "content": "#ifndef T2\n!T2:runtime,data,executable-data,async,construct-independent,V:2.5-2.7\n      LOGICAL FUNCTION test2()\n        USE OPENACC\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT):: a, b, c !Data\n        INTEGER :: errors = 0\n\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n        CALL RANDOM_NUMBER(a)\n        CALL RANDOM_NUMBER(b)\n        c = 0\n\n        !$acc enter data copyin(a(1:LOOPCOUNT), b(1:LOOPCOUNT), c(1:LOOPCOUNT))\n        !$acc enter data copyin(c(1:LOOPCOUNT))\n        !$acc data present(a(1:LOOPCOUNT), b(1:LOOPCOUNT), c(1:LOOPCOUNT))\n          !$acc parallel async(1)\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              c(x) = a(x) + b(x)\n            END DO\n          !$acc end parallel\n        !$acc end data\n\n        CALL acc_delete_finalize_async(c(1), LOOPCOUNT*8, 1)\n\n        !$acc enter data copyin(c(1:LOOPCOUNT)) async(1)\n        !$acc data present(a(1:LOOPCOUNT), b(1:LOOPCOUNT), c(1:LOOPCOUNT))\n          !$acc parallel async(1)\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              c(x) = c(x) + a(x) + b(x)\n            END DO\n          !$acc end parallel\n        !$acc end data\n\n        !$acc exit data delete(a(1:LOOPCOUNT), b(1:LOOPCOUNT)) copyout(c(1:LOOPCOUNT))\n\n        DO x = 1, LOOPCOUNT\n          IF (abs(c(x) - (a(x) + b(x))) .gt. PRECISION) THEN\n            errors = errors + 1\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test2 = .FALSE.\n        ELSE\n          test2 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T2\n        LOGICAL :: test2\n#endif\n#ifndef T2\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test2()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2**1\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "runtime",
                            "data",
                            "executable-data",
                            "async",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "acc_delete_finalize_with_len.F90": {
                "num tests": 2,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:runtime,data,executable-data,construct-independent,V:2.5-2.7\n      LOGICAL FUNCTION test1()\n        USE OPENACC\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT):: a, b, c !Data\n        INTEGER :: errors\n        errors = 0\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n        CALL RANDOM_NUMBER(a)\n        CALL RANDOM_NUMBER(b)\n        c = 0\n\n        !$acc enter data copyin(a(1:LOOPCOUNT), b(1:LOOPCOUNT))\n        !$acc enter data copyin(a(1:LOOPCOUNT), b(1:LOOPCOUNT))\n\n        !$acc data copyout(c(1:LOOPCOUNT))\n          !$acc parallel present(a(1:LOOPCOUNT), b(1:LOOPCOUNT))\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              c(x) = a(x) + b(x)\n            END DO\n          !$acc end parallel\n        !$acc end data\n\n        CALL acc_delete_finalize(a(1), LOOPCOUNT*8)\n        CALL acc_delete_finalize(b(1), LOOPCOUNT*8)\n\n        DO x = 1, LOOPCOUNT\n          IF (abs(c(x) - (a(x) + b(x))) .gt. PRECISION) THEN\n            errors = errors + 1\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "runtime",
                            "data",
                            "executable-data",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "2": {
                        "content": "#ifndef T2\n!T2:runtime,data,executable-data,construct-independent,V:2.5-2.7\n      LOGICAL FUNCTION test2()\n        USE OPENACC\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT):: a, b, c !Data\n        INTEGER :: errors\n        errors = 0\n\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n        CALL RANDOM_NUMBER(a)\n        CALL RANDOM_NUMBER(b)\n        c = 0\n\n        CALL acc_copyin(a(1:LOOPCOUNT))\n        CALL acc_copyin(a(1:LOOPCOUNT))\n        CALL acc_copyin(b(1:LOOPCOUNT))\n        CALL acc_copyin(b(1:LOOPCOUNT))\n\n        !$acc data copyout(c(1:LOOPCOUNT))\n          !$acc parallel present(a(1:LOOPCOUNT), b(1:LOOPCOUNT))\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              c(x) = a(x) + b(x)\n            END DO\n          !$acc end parallel\n        !$acc end data\n\n        CALL acc_delete_finalize(a(1), LOOPCOUNT*8)\n        CALL acc_delete_finalize(b(1), LOOPCOUNT*8)\n\n        DO x = 1, LOOPCOUNT\n          IF (abs(c(x) - (a(x) + b(x))) .gt. PRECISION) THEN\n            errors = errors + 1\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test2 = .FALSE.\n        ELSE\n          test2 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T2\n        LOGICAL :: test2\n#endif\n#ifndef T2\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test2()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2**1\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "runtime",
                            "data",
                            "executable-data",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "acc_delete_with_len.F90": {
                "num tests": 2,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:runtime,data,executable-data,construct-independent,V:2.0-2.7\n      LOGICAL FUNCTION test1()\n        USE OPENACC\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT):: a, b, c !Data\n        INTEGER :: errors\n        errors = 0\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n        CALL RANDOM_NUMBER(a)\n        CALL RANDOM_NUMBER(b)\n        c = 0\n\n        !$acc enter data copyin(a(1:LOOPCOUNT), b(1:LOOPCOUNT))\n\n        !$acc data copyout(c(1:LOOPCOUNT))\n          !$acc parallel present(a(1:LOOPCOUNT), b(1:LOOPCOUNT))\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              c(x) = a(x) + b(x)\n            END DO\n          !$acc end parallel\n        !$acc end data\n\n        CALL acc_delete(a(1), LOOPCOUNT*8)\n        CALL acc_delete(b(1), LOOPCOUNT*8)\n\n        DO x = 1, LOOPCOUNT\n          IF (abs(c(x) - (a(x) + b(x))) .gt. PRECISION) THEN\n            errors = errors + 1\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "runtime",
                            "data",
                            "executable-data",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "2": {
                        "content": "#ifndef T2\n!T2:runtime,data,executable-data,construct-independent,V:2.0-2.7\n      LOGICAL FUNCTION test2()\n        USE OPENACC\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT):: a, b, c !Data\n        INTEGER :: errors\n        errors = 0\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n        CALL RANDOM_NUMBER(a)\n        CALL RANDOM_NUMBER(b)\n        c = 0\n\n        CALL acc_copyin(a(1:LOOPCOUNT))\n        CALL acc_copyin(b(1:LOOPCOUNT))\n\n        !$acc data copyout(c(1:LOOPCOUNT))\n          !$acc parallel present(a(1:LOOPCOUNT), b(1:LOOPCOUNT))\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              c(x) = a(x) + b(x)\n            END DO\n          !$acc end parallel\n        !$acc end data\n\n        CALL acc_delete(a(1), LOOPCOUNT*8)\n        CALL acc_delete(b(1), LOOPCOUNT*8)\n\n        DO x = 1, LOOPCOUNT\n          IF (abs(c(x) - (a(x) + b(x))) .gt. PRECISION) THEN\n            errors = errors + 1\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test2 = .FALSE.\n        ELSE\n          test2 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T2\n        LOGICAL :: test2\n#endif\n#ifndef T2\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test2()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2**1\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "runtime",
                            "data",
                            "executable-data",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "acc_deviceptr.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:runtime,data,executable-data,construct-independent,V:2.0-2.7\nint test1(){\n    int err = 0;\n    real_t *a = (real_t *)malloc(n * sizeof(real_t));\n    real_t *b = (real_t *)malloc(n * sizeof(real_t));\n    real_t *c = (real_t *)malloc(n * sizeof(real_t));\n    real_t *a_ptr;\n    real_t *b_ptr;\n    real_t *c_ptr;\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n        c[x] = 0;\n    }\n\n    #pragma acc enter data copyin(a[0:n], b[0:n]) create(c[0:n])\n\n    a_ptr = acc_deviceptr(a);\n    b_ptr = acc_deviceptr(b);\n    c_ptr = acc_deviceptr(c);\n\n    #pragma acc data deviceptr(a_ptr, b_ptr, c_ptr)\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                c_ptr[x] = a_ptr[x] + b_ptr[x];\n            }\n        }\n    }\n\n    #pragma acc exit data copyout(c[0:n]) delete(a[0:n], b[0:n])\n\n    for (int x = 0; x < n; ++x){\n        if (fabs(c[x] - (a[x] + b[x])) > PRECISION){\n            err += 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "runtime",
                            "data",
                            "executable-data",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "acc_free.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:runtime,data,executable-data,V:2.6-2.7\nint test1(){\n    int err = 0;\n    int *a = (int *)acc_malloc(n * sizeof(int));\n    size_t initial_memory = acc_get_property(acc_get_device_num(acc_get_device_type()), acc_get_device_type(), acc_property_free_memory);\n\n    acc_free(a);\n    size_t final_memory = acc_get_property(acc_get_device_num(acc_get_device_type()), acc_get_device_type(), acc_property_free_memory);\n    if (final_memory < initial_memory + n * sizeof(int)){\n        err += 1;\n    }\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "runtime",
                            "data",
                            "executable-data"
                        ],
                        "versions": [
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "acc_get_default_async.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:runtime,async,construct-independent,internal-control-values,V:2.5-2.7\n      LOGICAL FUNCTION test1()\n        USE OPENACC\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x, holder !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT):: a, b, c !Data\n        INTEGER :: errors\n        INTEGER :: acc_get_default_async\n        errors = 0\n        holder = acc_get_default_async()\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n        CALL RANDOM_NUMBER(a)\n        CALL RANDOM_NUMBER(b)\n        c = 0\n\n        !$acc data copyin(a(1:LOOPCOUNT), b(1:LOOPCOUNT)) copyout(c(1:LOOPCOUNT))\n          !$acc parallel async\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              c(x) = a(x) + b(x)\n            END DO\n          !$acc end parallel\n          !$acc wait(holder)\n        !$acc end data\n\n        DO x = 1, LOOPCOUNT\n          IF (abs(c(x) - (a(x) + b(x))) .gt. PRECISION) THEN\n            errors = errors + 1\n          END IF\n        END DO\n\n        IF (acc_get_default_async() .lt. 0) THEN\n          errors = errors + 1\n        END IF\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "runtime",
                            "async",
                            "construct-independent",
                            "internal-control-values"
                        ],
                        "versions": [
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "acc_get_default_async.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:runtime,async,construct-independent,internal-control-values,V:2.5-2.7\nint test1(){\n    int err = 0;\n    real_t *a = (real_t *)malloc(n * sizeof(real_t));\n    real_t *b = (real_t *)malloc(n * sizeof(real_t));\n    real_t *c = (real_t *)malloc(n * sizeof(real_t));\n    int holder = acc_get_default_async();\n\n    for(int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n        c[x] = 0;\n    }\n\n    #pragma acc data copyin(a[0:n], b[0:n]) copyout(c[0:n])\n    {\n        #pragma acc parallel async\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                c[x] = a[x] + b[x];\n            }\n        }\n        #pragma acc wait(holder)\n    }\n\n    for (int x = 0; x < n; ++x){\n        if (fabs(c[x] - (a[x] + b[x])) > PRECISION){\n            err += 1;\n        }\n    }\n    if (acc_get_default_async() < 0){\n        err += 1;\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "runtime",
                            "async",
                            "construct-independent",
                            "internal-control-values"
                        ],
                        "versions": [
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "acc_get_device_num.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:runtime,construct-independent,internal-control-values,set,V:1.0-2.7\n      LOGICAL FUNCTION test1()\n        USE OPENACC\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x !Iterators\n        INTEGER :: errors\n        errors = 0\n\n        IF (acc_get_device_type() .ne. acc_device_none) THEN\n          DO x = 1, acc_get_num_devices(acc_get_device_type())\n            CALL acc_set_device_num(x, acc_get_device_type())\n            IF (acc_get_device_num(acc_get_device_type()) .ne. x) THEN\n              errors = errors + 1\n            END IF\n          END DO\n        END IF\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "runtime",
                            "construct-independent",
                            "internal-control-values",
                            "set"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "acc_get_device_num.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:runtime,devonly,internal-control-values,syntactic,V:1.0-2.7\nint test1(){\n    int err = 0;\n\n    if (acc_get_device_type() != acc_device_none){\n        for (int x = 0; x < acc_get_num_devices(acc_get_device_type()); ++x){\n            acc_set_device_num(x, acc_get_device_type());\n            if (acc_get_device_num(acc_get_device_type()) != x){\n                err += 1;\n            }\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "runtime",
                            "devonly",
                            "internal-control-values",
                            "syntactic"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "acc_get_num_devices.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:runtime,construct-independent,internal-control-values,V:1.0-2.7\n      LOGICAL FUNCTION test1()\n        USE OPENACC\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: errors\n        errors = 0\n\n        IF (acc_get_device_type() .ne. acc_device_none) THEN\n          IF (acc_get_num_devices(acc_get_device_type()) .eq. 0) THEN\n            errors = errors + 1\n          END IF\n        END IF\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "runtime",
                            "construct-independent",
                            "internal-control-values"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "acc_get_num_devices.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:runtime,devonly,internal-control-values,syntactic,V:1.0-2.7\nint test1(){\n    int err = 0;\n\n    if(acc_get_device_type() != acc_device_none && acc_get_num_devices(acc_get_device_type()) == 0){ //Can't have zero of current device type\n          err += 1;\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "runtime",
                            "devonly",
                            "internal-control-values",
                            "syntactic"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "acc_get_property.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:runtime,construct-independent,internal-control-values,nonvalidating,V:2.6-2.7\n      LOGICAL FUNCTION test1()\n        USE OPENACC\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: output\n        IF (acc_get_device_type() .ne. acc_device_none) THEN\n          output = acc_get_property(acc_get_device_num(acc_get_device_type()), acc_get_device_type(), acc_property_memory)\n          output = acc_get_property(acc_get_device_num(acc_get_device_type()), acc_get_device_type(), acc_property_free_memory)\n        END IF\n        test1 = .FALSE.\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "runtime",
                            "construct-independent",
                            "internal-control-values",
                            "nonvalidating"
                        ],
                        "versions": [
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "acc_get_property.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:runtime,devonly,syntactic,V:2.6-2.7\nint test1(){\n    int err = 0;\n\n    if (acc_get_device_type() != acc_device_none){\n        const char* returned_string1;\n        const char* returned_string2;\n        const char* returned_string3;\n        int returned_int;\n        returned_int = acc_get_property(acc_get_device_num(acc_get_device_type()), acc_get_device_type(), acc_property_memory);\n        returned_int = acc_get_property(acc_get_device_num(acc_get_device_type()), acc_get_device_type(), acc_property_free_memory);\n        returned_string1 = acc_get_property_string(acc_get_device_num(acc_get_device_type()), acc_get_device_type(), acc_property_name);\n        returned_string2 = acc_get_property_string(acc_get_device_num(acc_get_device_type()), acc_get_device_type(), acc_property_vendor);\n        returned_string3 = acc_get_property_string(acc_get_device_num(acc_get_device_type()), acc_get_device_type(), acc_property_driver);\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "runtime",
                            "devonly",
                            "syntactic"
                        ],
                        "versions": [
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "acc_get_property_string.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:runtime,construct-independent,internal-control-values,nonvalidating,V:2.6-2.7\n      LOGICAL FUNCTION test1()\n        USE OPENACC\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        CHARACTER(len=:),ALLOCATABLE :: output1\n        CHARACTER(len=:),ALLOCATABLE :: output2\n        CHARACTER(len=:),ALLOCATABLE :: output3\n        IF (acc_get_device_type() .ne. acc_device_none) THEN\n          CALL acc_get_property_string(acc_get_device_num(acc_get_device_type()), acc_get_device_type, acc_property_name, output1)\n          CALL acc_get_property_string(acc_get_device_num(acc_get_device_type()), acc_get_device_type, acc_property_vendor, output2)\n          CALL acc_get_property_string(acc_get_device_num(acc_get_device_type()), acc_get_device_type, acc_property_driver, output3)\n        END IF\n        test1 = .FALSE.\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "runtime",
                            "construct-independent",
                            "internal-control-values",
                            "nonvalidating"
                        ],
                        "versions": [
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "acc_hostptr.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:runtime,data,V:2.0-2.7\nint test1(){\n    int err = 0;\n    real_t *a = (real_t *)malloc(n * sizeof(real_t));\n    real_t *a_ptr;\n\n    a_ptr = acc_create(a, n * sizeof(real_t));\n\n    if (a != acc_hostptr(acc_deviceptr(a))){\n        err += 1;\n    }\n\n    acc_delete(a, n * sizeof(real_t));\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "runtime",
                            "data"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "acc_init.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:runtime,construct-independent,internal-control-values,init,nonvalidating,V:1.0-2.7\n      LOGICAL FUNCTION test1()\n        USE OPENACC\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        IF (acc_get_device_type() .ne. acc_device_none) THEN\n          CALL acc_init(acc_get_device_type())\n        END IF\n\n        test1 = .FALSE.\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "runtime",
                            "construct-independent",
                            "internal-control-values",
                            "init",
                            "nonvalidating"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "acc_init.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:runtime,init,syntactic,V:2.5-2.7\nint test1(){\n    int err = 0;\n\n    if (acc_get_device_type() != acc_device_none){\n        acc_init(acc_get_device_type());\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "runtime",
                            "init",
                            "syntactic"
                        ],
                        "versions": [
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "acc_is_present.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:runtime,devonly,construct-independent,present,V:2.0-2.7\n      LOGICAL FUNCTION test1()\n        USE OPENACC\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT):: a !Data\n        INTEGER,DIMENSION(1):: devtest\n        INTEGER :: errors\n        errors = 0\n\n        devtest(1) = 1\n        !$acc enter data copyin(devtest(1:1))\n        !$acc parallel present(devtest(1:1))\n          devtest(1) = 0\n        !$acc end parallel\n\n        !$acc enter data create(a(1:LOOPCOUNT))\n        IF (acc_is_present(a(1:LOOPCOUNT)) .eqv. .FALSE.) THEN\n          errors = errors + 1\n          PRINT*, 1\n        END IF\n        !$acc exit data delete(a(1:LOOPCOUNT))\n\n        IF (devtest(1) .eq. 1) THEN\n          IF (acc_is_present(a(1:LOOPCOUNT)) .eqv. .TRUE.) THEN\n            errors = errors + 1\n            PRINT*, 2\n          END IF\n        END IF\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "runtime",
                            "devonly",
                            "construct-independent",
                            "present"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "acc_is_present.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:runtime,data,executable-data,devonly,V:2.0-2.7\nint test1(){\n    int err = 0;\n    real_t *a = (real_t *)malloc(n * sizeof(real_t));\n    int *devtest = (int *)malloc(sizeof(int));\n\n    devtest[0] = 1;\n    #pragma acc enter data copyin(devtest[0:1])\n    #pragma acc parallel present(devtest[0:1])\n    {\n        devtest[0] = 0;\n    }\n\n    #pragma acc enter data create(a[0:n])\n    if (acc_is_present(a, n * sizeof(real_t)) == 0){\n        err += 1;\n    }\n    #pragma acc exit data delete(a[0:n])\n\n    if (devtest[0] == 1){\n        if (acc_is_present(a, n * sizeof(real_t)) != 0){\n            err += 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "runtime",
                            "data",
                            "executable-data",
                            "devonly"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "acc_is_present_with_len.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:runtime,devonly,construct-independent,present,V:2.0-2.7\n      LOGICAL FUNCTION test1()\n        USE OPENACC\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT):: a !Data\n        INTEGER,DIMENSION(1):: devtest\n        INTEGER :: errors = 0\n\n        devtest(1) = 1\n        !$acc enter data copyin(devtest(1:1))\n        !$acc parallel present(devtest(1:1))\n          devtest(1) = 0\n        !$acc end parallel\n\n        !$acc enter data create(a(1:LOOPCOUNT))\n        IF (acc_is_present(a(1), LOOPCOUNT*8) .eqv. .FALSE.) THEN\n          errors = errors + 1\n        END IF\n        !$acc exit data delete(a(1:LOOPCOUNT))\n\n        IF (devtest(1) .eq. 1) THEN\n          IF (acc_is_present(a(1), LOOPCOUNT*8) .eqv. .TRUE.) THEN\n            errors = errors + 1\n          END IF\n        END IF\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "runtime",
                            "devonly",
                            "construct-independent",
                            "present"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "acc_malloc.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:runtime,data,executable-data,V:1.0-2.7\nint test1(){\n    int err = 0;\n    size_t initial_memory = acc_get_property(acc_get_device_num(acc_get_device_type()), acc_get_device_type(), acc_property_free_memory);\n    int *a = (int *)acc_malloc(n * sizeof(int));\n\n    if (initial_memory == 0){\n        return err;\n    }\n    size_t final_memory = acc_get_property(acc_get_device_num(acc_get_device_type()), acc_get_device_type(), acc_property_free_memory);\n    if (final_memory + n * sizeof(int) > initial_memory){\n        err += 1;\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "runtime",
                            "data",
                            "executable-data"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "acc_map_data.c": {
                "num tests": 3,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:runtime,data,executable-data,construct-independent,V:2.0-2.7\nint test1(){\n    int err = 0;\n    real_t *a = (real_t *)malloc(n * sizeof(real_t));\n    real_t *b = (real_t *)malloc(n * sizeof(real_t));\n    real_t *c = (real_t *)malloc(n * sizeof(real_t));\n    real_t *d;\n    real_t *e = (real_t *)malloc(n * sizeof(real_t));\n\n    d = (real_t *)acc_malloc(n * sizeof(real_t));\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n    }\n\n    acc_map_data(c, d, n * sizeof(real_t));\n\n    #pragma acc data copyin(a[0:n], b[0:n]) present(c[0:n])\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                c[x] = a[x] + b[x];\n            }\n        }\n    }\n\n    #pragma acc update host(c[0:n])\n    for (int x = 0; x < n; ++x){\n        if (fabs(c[x] - (a[x] + b[x]))> PRECISION){\n            err += 1;\n        }\n    }\n\n    acc_unmap_data(c);\n    acc_free(d);\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "runtime",
                            "data",
                            "executable-data",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "2": {
                        "content": "#ifndef T2\n//T2:runtime,data,executable-data,construct-independent,V:2.0-2.7\nint test2(){\n    int err = 0;\n    real_t *a = (real_t *)malloc(n * sizeof(real_t));\n    real_t *b = (real_t *)malloc(n * sizeof(real_t));\n    real_t *c = (real_t *)malloc(n * sizeof(real_t));\n    real_t *d;\n    real_t *e = (real_t *)malloc(n * sizeof(real_t));\n\n    d = (real_t *)acc_malloc(2 * n * sizeof(real_t));\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n    }\n    acc_map_data(c, d, n * sizeof(real_t));\n    acc_map_data(e, &(d[n]), n * sizeof(real_t));\n\n    #pragma acc data copyin(a[0:n], b[0:n]) present(c[0:n], e[0:n])\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                c[x] = a[x] + b[x];\n            }\n        }\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                e[x] = a[x] * b[x];\n            }\n        }\n    }\n\n    #pragma acc update host(c[0:n])\n    #pragma acc update host(e[0:n])\n\n    for (int x = 0; x < n; ++x){\n        if (fabs(c[x] - (a[x] + b[x])) > PRECISION){\n            err += 1;\n        }\n        if (fabs(e[x] - (a[x] * b[x])) > PRECISION){\n            err += 1;\n        }\n    }\n    acc_unmap_data(c);\n    acc_unmap_data(e);\n    acc_free(d);\n\n    return err;\n}\n#endif\n#ifndef T2\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test2();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 1);\n    }\n#endif\n",
                        "tags": [
                            "runtime",
                            "data",
                            "executable-data",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "3": {
                        "content": "#ifndef T3\n//T3:runtime,data,executable-data,construct-independent,V:2.0-2.7\nint test3(){\n    int err = 0;\n    real_t *a = (real_t *)malloc(n * sizeof(real_t));\n    real_t *b = (real_t *)malloc(n * sizeof(real_t));\n    real_t *c = (real_t *)malloc(n * sizeof(real_t));\n    real_t *d;\n    real_t *e = (real_t *)malloc(n * sizeof(real_t));\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n    }\n    d = (real_t *)acc_malloc(n * sizeof(real_t));\n\n    #pragma acc data copyin(a[0:n], b[0:n]) deviceptr(d)\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                d[x] = a[x] + b[x];\n            }\n        }\n    }\n\n    acc_map_data(c, d, n * sizeof(real_t));\n    #pragma acc data copyin(a[0:n], b[0:n]) present(c[0:n])\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                c[x] += a[x] + b[x];\n            }\n        }\n    }\n\n    #pragma acc update host(c[0:n])\n\n    for (int x = 0; x < n; ++x){\n        if (fabs(c[x] - 2 * (a[x] + b[x])) > 2 * PRECISION){\n            err += 1;\n        }\n    }\n\n    acc_unmap_data(c);\n    acc_free(d);\n\n    return err;\n}\n#endif\n#ifndef T3\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test3();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 2);\n    }\n#endif\n",
                        "tags": [
                            "runtime",
                            "data",
                            "executable-data",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "acc_memcpy_device.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:runtime,data,executable-data,construct-independent,V:2.5-2.7\nint test1(){\n    int err = 0;\n    real_t *a = (real_t *)malloc(n * sizeof(real_t));\n    real_t *b = (real_t *)malloc(n * sizeof(real_t));\n    real_t *c = (real_t *)malloc(n * sizeof(real_t));\n    real_t *hostdata = (real_t *)malloc(3 * n * sizeof(real_t));\n    real_t *devdata;\n\n    for (int x = 0; x < n; ++x){\n        hostdata[x] = rand() / (real_t)(RAND_MAX / 10);\n        hostdata[n + x] = rand() / (real_t)(RAND_MAX / 10);\n        hostdata[2*n + x] = 1;\n    }\n\n    devdata = acc_copyin(hostdata, 3 * n * sizeof(real_t));\n    #pragma acc enter data create(a[0:n], b[0:n], c[0:n])\n    acc_memcpy_device(a, devdata, n * sizeof(real_t));\n    acc_memcpy_device(b, devdata+n, n * sizeof(real_t));\n    acc_memcpy_device(c, devdata+2*n, n * sizeof(real_t));\n\n    #pragma acc data present(a[0:n], b[0:n], c[0:n])\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                c[x] += a[x] + b[x];\n            }\n        }\n    }\n\n    #pragma acc exit data copyout(a[0:n], b[0:n], c[0:n])\n\n    for (int x = 0; x < n; ++x){\n        if (fabs(a[x] - hostdata[x]) > PRECISION){\n            err += 1;\n        }\n        if (fabs(b[x] - hostdata[n + x]) > PRECISION){\n            err += 1;\n        }\n        if (fabs(c[x] - (1 + a[x] + b[x])) > PRECISION){\n            err += 1;\n        }\n    }\n\n    #pragma acc exit data delete(hostdata[0:3*n])\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "runtime",
                            "data",
                            "executable-data",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "acc_memcpy_from_device.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:runtime,data,executable-data,construct-independent,V:2.0-2.7\nint test1(){\n    int err = 0;\n    real_t *a = (real_t *)malloc(n * sizeof(real_t));\n    real_t *b = (real_t *)malloc(n * sizeof(real_t));\n    real_t *c = (real_t *)malloc(n * sizeof(real_t));\n    real_t *hostdata = (real_t *)malloc(3 * n * sizeof(real_t));\n    real_t *devdata;\n\n    for (int x = 0; x < n; ++x){\n        hostdata[x] = rand() / (real_t)(RAND_MAX / 10);\n        hostdata[n + x] = rand() / (real_t)(RAND_MAX / 10);\n        hostdata[2*n + x] = 1;\n    }\n\n    devdata = acc_copyin(hostdata, 3 * n * sizeof(real_t));\n\n    #pragma acc data deviceptr(devdata)\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                devdata[2*n + x] += devdata[x] + devdata[n + x];\n            }\n        }\n    }\n\n    acc_memcpy_from_device(a, devdata, n * sizeof(real_t));\n    acc_memcpy_from_device(b, &(devdata[n]), n * sizeof(real_t));\n    acc_memcpy_from_device(c, &(devdata[2*n]), n * sizeof(real_t));\n\n\n    for (int x = 0; x < n; ++x){\n        if (fabs(a[x] - hostdata[x]) > PRECISION){\n            err += 1;\n        }\n        if (fabs(b[x] - hostdata[n + x]) > PRECISION){\n            err += 1;\n        }\n        if (fabs(c[x] - (1 + a[x] + b[x])) > PRECISION){\n            err += 1;\n        }\n    }\n\n    #pragma acc exit data delete(hostdata[0:3*n])\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "runtime",
                            "data",
                            "executable-data",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "acc_memcpy_from_device_async.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:runtime,data,executable-data,async,construct-independent,V:2.5-2.7\nint test1(){\n    int err = 0;\n    real_t *a = (real_t *)malloc(n * sizeof(real_t));\n    real_t *b = (real_t *)malloc(n * sizeof(real_t));\n    real_t *c = (real_t *)malloc(n * sizeof(real_t));\n    real_t *d = (real_t *)malloc(n * sizeof(real_t));\n    real_t *e = (real_t *)malloc(n * sizeof(real_t));\n    real_t *f = (real_t *)malloc(n * sizeof(real_t));\n    real_t *hostdata = (real_t *)malloc(6 * n * sizeof(real_t));\n    real_t *hostdata_copy = (real_t *)malloc(6 * n * sizeof(real_t));\n\n    real_t *devdata;\n\n    for (int x = 0; x < n; ++x){\n        hostdata[x] = rand() / (real_t)(RAND_MAX / 10);\n        hostdata[n + x] = rand() / (real_t)(RAND_MAX / 10);\n        hostdata[2*n + x] = 1;\n        hostdata[3*n + x] = rand() / (real_t)(RAND_MAX / 10);\n        hostdata[4*n + x] = rand() / (real_t)(RAND_MAX / 10);\n        hostdata[5*n + x] = 2;\n    }\n\n    for (int x = 0; x < 6*n; ++x){\n        hostdata_copy[x] = hostdata[x];\n    }\n\n    devdata = acc_copyin(hostdata, 6 * n * sizeof(real_t));\n\n    #pragma acc data deviceptr(devdata)\n    {\n        #pragma acc parallel async(1)\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                devdata[x] = devdata[x] * devdata[x];\n            }\n        }\n        acc_memcpy_from_device_async(a, devdata, n * sizeof(real_t), 1);\n        #pragma acc parallel async(2)\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                devdata[n + x] = devdata[n + x] * devdata[n + x];\n            }\n        }\n        acc_memcpy_from_device_async(b, &(devdata[n]), n * sizeof(real_t), 2);\n        #pragma acc parallel async(4)\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                devdata[3*n + x] = devdata[3*n + x] * devdata[3*n + x];\n            }\n        }\n        acc_memcpy_from_device_async(d, &(devdata[3*n]), n * sizeof(real_t), 4);\n        #pragma acc parallel async(5)\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                devdata[4*n + x] = devdata[4*n + x] * devdata[4*n + x];\n            }\n        }\n        acc_memcpy_from_device_async(e, &(devdata[4*n]), n * sizeof(real_t), 5);\n        #pragma acc parallel async(3) wait(1, 2)\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                devdata[2*n + x] += devdata[x] + devdata[n + x];\n            }\n        }\n        acc_memcpy_from_device_async(c, &(devdata[2*n]), n * sizeof(real_t), 3);\n        #pragma acc parallel async(6) wait(4, 5)\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                devdata[5*n + x] += devdata[3*n + x] + devdata[4*n + x];\n            }\n        }\n        acc_memcpy_from_device_async(f, &(devdata[5*n]), n * sizeof(real_t), 6);\n    }\n\n    #pragma acc wait(1)\n    for (int x = 0; x < n; ++x){\n        if (fabs(a[x] - hostdata_copy[x] * hostdata_copy[x]) > PRECISION){\n            err += 1;\n        }\n    }\n    #pragma acc wait(2)\n    for (int x = 0; x < n; ++x){\n        if (fabs(b[x] - hostdata_copy[n + x] * hostdata_copy[n + x]) > PRECISION){\n            err += 1;\n        }\n    }\n    #pragma acc wait(4)\n    for (int x = 0; x < n; ++x){\n        if (fabs(d[x] - hostdata_copy[3*n + x] * hostdata_copy[3*n + x]) > PRECISION){\n            err += 1;\n        }\n    }\n    #pragma acc wait(5)\n    for (int x = 0; x < n; ++x){\n        if (fabs(e[x] - hostdata_copy[4*n + x] * hostdata_copy[4*n + x]) > PRECISION){\n            err += 1;\n        }\n    }\n    #pragma acc wait(3)\n    for (int x = 0; x < n; ++x){\n        if (fabs(c[x] - (1 + a[x] + b[x])) > PRECISION){\n            err += 1;\n        }\n    }\n    #pragma acc wait(6)\n    for (int x = 0; x < n; ++x){\n        if (fabs(f[x] - (2 + d[x] + e[x])) > PRECISION){\n            err += 1;\n        }\n    }\n\n    #pragma acc exit data delete(hostdata[0:6*n])\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "runtime",
                            "data",
                            "executable-data",
                            "async",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "acc_memcpy_to_device.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:runtime,data,executable-data,construct-independent,V:2.0-2.7\nint test1(){\n    int err = 0;\n    real_t *a = (real_t *)malloc(n * sizeof(real_t));\n    real_t *b = (real_t *)malloc(n * sizeof(real_t));\n    real_t *c = (real_t *)malloc(n * sizeof(real_t));\n    real_t *hostdata = (real_t *)malloc(3 * n * sizeof(real_t));\n    real_t *devdata;\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n        c[x] = 1;\n    }\n\n    devdata = acc_create(hostdata, 3 * n * sizeof(real_t));\n\n    acc_memcpy_to_device(devdata, a, n * sizeof(real_t));\n    acc_memcpy_to_device(&(devdata[n]), b, n * sizeof(real_t));\n    acc_memcpy_to_device(&(devdata[2*n]), c, n * sizeof(real_t));\n\n    #pragma acc data deviceptr(devdata)\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                devdata[2*n + x] += devdata[x] + devdata[n + x];\n            }\n        }\n    }\n    #pragma acc exit data copyout(hostdata[0:3*n])\n    for (int x = 0; x < n; ++x){\n        if (fabs(hostdata[2 * n + x] - (1 + hostdata[n + x] + hostdata[x])) > PRECISION){\n            err += 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "runtime",
                            "data",
                            "executable-data",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "acc_memcpy_to_device_async.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:runtime,data,executable-data,async,construct-independent,V:2.5-2.7\nint test1(){\n    int err = 0;\n    real_t *a = (real_t *)malloc(n * sizeof(real_t));\n    real_t *b = (real_t *)malloc(n * sizeof(real_t));\n    real_t *c = (real_t *)malloc(n * sizeof(real_t));\n    real_t *d = (real_t *)malloc(n * sizeof(real_t));\n    real_t *e = (real_t *)malloc(n * sizeof(real_t));\n    real_t *f = (real_t *)malloc(n * sizeof(real_t));\n\n    real_t *a_host = (real_t *)malloc(n * sizeof(real_t));\n    real_t *b_host = (real_t *)malloc(n * sizeof(real_t));\n    real_t *d_host = (real_t *)malloc(n * sizeof(real_t));\n    real_t *e_host = (real_t *)malloc(n * sizeof(real_t));\n\n    real_t *hostdata = (real_t *)malloc(6 * n * sizeof(real_t));\n    real_t *devdata;\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n        c[x] = 1;\n        d[x] = rand() / (real_t)(RAND_MAX / 10);\n        e[x] = rand() / (real_t)(RAND_MAX / 10);\n        f[x] = 2;\n\n        a_host[x] = a[x];\n        b_host[x] = b[x];\n        d_host[x] = d[x];\n        e_host[x] = e[x];\n    }\n\n    devdata = acc_create(hostdata, 6 * n * sizeof(real_t));\n\n    acc_memcpy_to_device_async(devdata, a, n * sizeof(real_t), 1);\n    acc_memcpy_to_device_async(&(devdata[n]), b, n * sizeof(real_t), 2);\n    acc_memcpy_to_device_async(&(devdata[2*n]), c, n * sizeof(real_t), 3);\n    acc_memcpy_to_device_async(&(devdata[3*n]), d, n * sizeof(real_t), 4);\n    acc_memcpy_to_device_async(&(devdata[4*n]), e, n * sizeof(real_t), 5);\n    acc_memcpy_to_device_async(&(devdata[5*n]), f, n * sizeof(real_t), 6);\n\n    #pragma acc data deviceptr(devdata)\n    {\n        #pragma acc parallel async(1)\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                devdata[x] = devdata[x] * devdata[x];\n            }\n        }\n        #pragma acc parallel async(2)\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                devdata[n + x] = devdata[n + x] * devdata[n + x];\n            }\n        }\n        #pragma acc parallel async(4)\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                devdata[3*n + x] = devdata[3*n + x] * devdata[3*n + x];\n            }\n        }\n        #pragma acc parallel async(5)\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                devdata[4*n + x] = devdata[4*n + x] * devdata[4*n + x];\n            }\n        }\n        #pragma acc parallel async(3) wait(1, 2)\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                devdata[2*n + x] += devdata[x] + devdata[n + x];\n            }\n        }\n        #pragma acc parallel async(6) wait(4, 5)\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                devdata[5*n + x] += devdata[3*n + x] + devdata[4*n + x];\n            }\n        }\n    }\n\n    #pragma acc update host(hostdata[2*n:n]) async(3)\n    #pragma acc update host(hostdata[5*n:n]) async(6)\n\n    #pragma acc wait(3)\n    for (int x = 0; x < n; ++x){\n        if (fabs(hostdata[2*n + x] - (1 + a_host[x] * a_host[x] + b_host[x] * b_host[x])) > 4 * PRECISION){\n            err += 1;\n        }\n    }\n\n    #pragma acc wait(6)\n    for (int x = 0; x < n; ++x){\n        if (fabs(hostdata[5*n + x] - (2 + d_host[x] * d_host[x] + e_host[x] * e_host[x])) > PRECISION){\n            err += 1;\n        }\n    }\n\n    #pragma acc exit data delete(hostdata[0:6*n])\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "runtime",
                            "data",
                            "executable-data",
                            "async",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "acc_on_device.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:runtime,construct-independent,internal-control-values,present,V:1.0-2.7\n      LOGICAL FUNCTION test1()\n        USE OPENACC\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: errors\n        INTEGER :: device_type\n        errors = 0\n        device_type = acc_get_device_type()\n        IF (device_type .ne. acc_device_none) THEN\n          !$acc parallel\n            IF (acc_on_device(device_type) .eqv. .FALSE.) THEN\n              errors = errors + 1\n            END IF\n          !$acc end parallel\n        ELSE\n          !$acc parallel\n            IF (acc_on_device(acc_device_host) .eqv. .FALSE.) THEN\n              errors = errors + 1\n            END IF\n          !$acc end parallel\n        END IF\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "runtime",
                            "construct-independent",
                            "internal-control-values",
                            "present"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "acc_on_device.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:runtime,construct-independent,V:1.0-2.7\nint test1(){\n    int err = 0;\n    int device_type = acc_get_device_type();\n\n    if (device_type != acc_device_none){\n        #pragma acc data copy(err)\n        {\n            #pragma acc parallel\n            {\n                if (acc_on_device(device_type) == 0){\n                    err += 1;\n                }\n            }\n        }\n    }\n    else{\n        #pragma acc parallel\n        {\n            if (acc_on_device(acc_device_host) == 0){\n                err += 1;\n            }\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "runtime",
                            "construct-independent"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "acc_set_default_async.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:runtime,async,construct-independent,internal-control-values,set,V:2.5-2.7\n      LOGICAL FUNCTION test1()\n        USE OPENACC\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT):: a, b, c, a_host, b_host !Data\n        INTEGER :: errors = 0\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n        CALL RANDOM_NUMBER(a)\n        CALL RANDOM_NUMBER(b)\n        a_host = a\n        b_host = b\n        c = 0\n\n        !$acc data copyin(a(1:LOOPCOUNT), b(1:LOOPCOUNT)) copyout(c(1:LOOPCOUNT))\n          CALL acc_set_default_async(1)\n          !$acc parallel async\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              a(x) = a(x) * a(x)\n            END DO\n          !$acc end parallel\n          CALL acc_set_default_async(2)\n          !$acc parallel async\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              b(x) = b(x) * b(x)\n            END DO\n          !$acc end parallel\n          !$acc parallel async(1) wait(2)\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              c(x) = a(x) + b(x)\n            END DO\n          !$acc end parallel\n          !$acc wait(1)\n        !$acc end data\n\n        DO x = 1, LOOPCOUNT\n          IF (abs(c(x) - (a_host(x) * a_host(x) + b_host(x) * b_host(x))) .gt. 4 * PRECISION) THEN\n            errors = errors + 1\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "runtime",
                            "async",
                            "construct-independent",
                            "internal-control-values",
                            "set"
                        ],
                        "versions": [
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "acc_set_default_async.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:runtime,async,construct-independent,set,V:2.5-2.7\nint test1(){\n    int err = 0;\n    real_t *a = (real_t *)malloc(n * sizeof(real_t));\n    real_t *b = (real_t *)malloc(n * sizeof(real_t));\n    real_t *c = (real_t *)malloc(n * sizeof(real_t));\n    real_t *a_host = (real_t *)malloc(n * sizeof(real_t));\n    real_t *b_host = (real_t *)malloc(n * sizeof(real_t));\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n        c[x] = 0;\n        a_host[x] = a[x];\n        b_host[x] = b[x];\n    }\n\n    #pragma acc data copyin(a[0:n], b[0:n]) copyout(c[0:n])\n    {\n        acc_set_default_async(1);\n        #pragma acc parallel async\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                a[x] = a[x] * a[x];\n            }\n        }\n        acc_set_default_async(2);\n        #pragma acc parallel async\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                b[x] = b[x] * b[x];\n            }\n        }\n        #pragma acc parallel async(1) wait(2)\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                c[x] = a[x] + b[x];\n            }\n        }\n        #pragma acc wait(1)\n    }\n\n    for (int x = 0; x < n; ++x){\n        if (fabs(c[x] - (a_host[x] * a_host[x] + b_host[x] * b_host[x])) > 4*PRECISION){\n            err += 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "runtime",
                            "async",
                            "construct-independent",
                            "set"
                        ],
                        "versions": [
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "acc_set_device_num.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:runtime,construct-independent,internal-control-values,set,V:2.0-2.7\n      LOGICAL FUNCTION test1()\n        USE OPENACC\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x, y !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT):: a !Data\n        REAL(8),DIMENSION(:, :),ALLOCATABLE :: host_copy\n        INTEGER :: errors = 0\n\n        CALL RANDOM_SEED\n        ALLOCATE(host_copy(acc_get_num_devices(acc_get_device_type()), LOOPCOUNT))\n\n        IF (acc_get_device_type() .ne. acc_device_none) THEN\n          !host_copy(acc_get_num_devices(acc_get_device_type()), LOOPCOUNT)\n          DO x = 1, acc_get_num_devices(acc_get_device_type())\n            DO y = 1, LOOPCOUNT\n              CALL RANDOM_NUMBER(a)\n              host_copy(x) = a\n            END DO\n            acc_set_device_num(x, acc_get_device_type())\n            !$acc enter data copyin(a(1:LOOPCOUNT))\n          END DO\n\n          DO x = 1, acc_get_num_devices(acc_get_device_type)\n            acc_set_device_num(x, acc_get_device_type())\n            !$acc data present(a(1:LOOPCOUNT))\n              !$acc parallel\n                !$acc loop\n                DO y = 1, LOOPCOUNT\n                  a(y) = a(y) + 1\n                END DO\n              !$acc end parallel\n            !$acc end data\n          END DO\n\n          DO x = 1, acc_get_num_devices(acc_get_device_type())\n            acc_set_device_num(x, acc_get_device_type())\n            !$acc exit data copyout(a(1:LOOPCOUNT))\n            DO y = 1, LOOPCOUNT\n              IF (abs(a(y) - (host_copy(x, y) + 1)) .gt. PRECISION) THEN\n                errors = errors + 1\n              END IF\n            END DO\n          END DO\n        END IF\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "runtime",
                            "construct-independent",
                            "internal-control-values",
                            "set"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "acc_set_device_num.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:runtime,devonly,construct-independent,set,V:2.0-2.7\nint test1(){\n    int err = 0;\n\n    if (acc_get_device_type() != acc_device_none){\n        real_t **host_copy = (real_t **)malloc(acc_get_num_devices(acc_get_device_type()) * sizeof(real_t *));\n        for (int x = 0; x < acc_get_num_devices(acc_get_device_type()); ++x){\n            host_copy[x] = (real_t *)malloc(n * sizeof(real_t));\n        }\n        real_t *a = (real_t *)malloc(n * sizeof(real_t));\n        for (int x = 0; x < acc_get_num_devices(acc_get_device_type()); ++x){\n            for (int y = 0; y < n; ++y){\n                a[y] = rand() / (real_t)(RAND_MAX / 10);\n                host_copy[x][y] = a[y];\n            }\n            acc_set_device_num(x, acc_get_device_type());\n            #pragma acc enter data copyin(a[0:n])\n        }\n        for (int x = 0; x < acc_get_num_devices(acc_get_device_type()); ++x){\n            acc_set_device_num(x, acc_get_device_type());\n            #pragma acc data present(a[0:n])\n            {\n                #pragma acc parallel\n                {\n                    #pragma acc loop\n                    for (int y = 0; y < n; ++y){\n                        a[y] = a[y] + 1;\n                    }\n                }\n            }\n        }\n        for (int x = 0; x < acc_get_num_devices(acc_get_device_type()); ++x){\n            acc_set_device_num(x, acc_get_device_type());\n            #pragma acc exit data copyout(a[0:n])\n            for (int y = 0; y < n; ++y){\n                if (fabs(a[y] - (host_copy[x][y] + 1)) > PRECISION){\n                    err += 1;\n                }\n            }\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "runtime",
                            "devonly",
                            "construct-independent",
                            "set"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "acc_set_device_type.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:runtime,construct-independent,internal-control-values,set,V:1.0-2.7\n      LOGICAL FUNCTION test1()\n        USE OPENACC\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.fh\"\n        INTEGER :: errors = 0\n        INTEGER :: device_type\n\n        device_type = acc_get_device_type()\n        CALL acc_set_device_type(device_type)\n        IF (acc_get_device_type() .ne. device_type) THEN\n          errors = errors + 1\n        END IF\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "runtime",
                            "construct-independent",
                            "internal-control-values",
                            "set"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "acc_set_device_type.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:runtime,internal-control-values,syntactic,V:2.0-2.7\nint test1(){\n    int err = 0;\n\n    int device_type = acc_get_device_type();\n\n    acc_set_device_type(device_type);\n    if (acc_get_device_type() != device_type){\n        err += 1;\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "runtime",
                            "internal-control-values",
                            "syntactic"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "acc_shutdown.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:runtime,construct-independent,internal-control-values,shutdown,nonvalidating,V:1.0-2.7\n      LOGICAL FUNCTION test1()\n        USE OPENACC\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        IF (acc_get_device_type() .ne. acc_device_none) THEN\n          CALL acc_shutdown(acc_get_device_type())\n        END IF\n\n        test1 = .FALSE.\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "runtime",
                            "construct-independent",
                            "internal-control-values",
                            "shutdown",
                            "nonvalidating"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "acc_shutdown.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:runtime,devonly,shutdown,V:2.0-2.7\nint test1(){\n    int err = 0;\n\n    if (acc_get_device_type() != acc_device_none){\n        acc_shutdown(acc_get_device_type());\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "runtime",
                            "devonly",
                            "shutdown"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "acc_unmap_data.c": {
                "num tests": 3,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:runtime,data,executable-data,construct-independent,V:2.0-2.7\nint test1(){\n    int err = 0;\n    real_t *a = (real_t *)malloc(n * sizeof(real_t));\n    real_t *b = (real_t *)malloc(n * sizeof(real_t));\n    real_t *c = (real_t *)malloc(n * sizeof(real_t));\n    real_t *d;\n    real_t *e = (real_t *)malloc(n * sizeof(real_t));\n\n    d = (real_t *)acc_malloc(n * sizeof(real_t));\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n    }\n\n    acc_map_data(c, d, n * sizeof(real_t));\n\n    #pragma acc data copyin(a[0:n], b[0:n]) present(c[0:n])\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                c[x] = a[x] + b[x];\n            }\n        }\n    }\n\n    #pragma acc update host(c[0:n])\n    for (int x = 0; x < n; ++x){\n        if (fabs(c[x] - (a[x] + b[x]))> PRECISION){\n            err += 1;\n        }\n    }\n\n    acc_unmap_data(c);\n    acc_free(d);\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "runtime",
                            "data",
                            "executable-data",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "2": {
                        "content": "#ifndef T2\n//T2:runtime,data,executable-data,construct-independent,V:2.0-2.7\nint test2(){\n    int err = 0;\n    real_t *a = (real_t *)malloc(n * sizeof(real_t));\n    real_t *b = (real_t *)malloc(n * sizeof(real_t));\n    real_t *c = (real_t *)malloc(n * sizeof(real_t));\n    real_t *d;\n    real_t *e = (real_t *)malloc(n * sizeof(real_t));\n\n    d = (real_t *)acc_malloc(2 * n * sizeof(real_t));\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n    }\n    acc_map_data(c, d, n * sizeof(real_t));\n    acc_map_data(e, &(d[n]), n * sizeof(real_t));\n\n    #pragma acc data copyin(a[0:n], b[0:n]) present(c[0:n], e[0:n])\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                c[x] = a[x] + b[x];\n            }\n        }\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                e[x] = a[x] * b[x];\n            }\n        }\n    }\n\n    #pragma acc update host(c[0:n])\n    #pragma acc update host(e[0:n])\n\n    for (int x = 0; x < n; ++x){\n        if (fabs(c[x] - (a[x] + b[x])) > PRECISION){\n            err += 1;\n        }\n        if (fabs(e[x] - (a[x] * b[x])) > PRECISION){\n            err += 1;\n        }\n    }\n    acc_unmap_data(c);\n    acc_unmap_data(e);\n    acc_free(d);\n\n    return err;\n}\n#endif\n#ifndef T2\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test2();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 1);\n    }\n#endif\n",
                        "tags": [
                            "runtime",
                            "data",
                            "executable-data",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "3": {
                        "content": "#ifndef T3\n//T3:runtime,data,executable-data,construct-independent,V:2.0-2.7\nint test3(){\n    int err = 0;\n    real_t *a = (real_t *)malloc(n * sizeof(real_t));\n    real_t *b = (real_t *)malloc(n * sizeof(real_t));\n    real_t *c = (real_t *)malloc(n * sizeof(real_t));\n    real_t *d;\n    real_t *e = (real_t *)malloc(n * sizeof(real_t));\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n    }\n    d = (real_t *)acc_malloc(n * sizeof(real_t));\n\n    #pragma acc data copyin(a[0:n], b[0:n]) deviceptr(d)\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                d[x] = a[x] + b[x];\n            }\n        }\n    }\n\n    acc_map_data(c, d, n * sizeof(real_t));\n    #pragma acc data copyin(a[0:n], b[0:n]) present(c[0:n])\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                c[x] += a[x] + b[x];\n            }\n        }\n    }\n\n    #pragma acc update host(c[0:n])\n\n    for (int x = 0; x < n; ++x){\n        if (fabs(c[x] - 2 * (a[x] + b[x])) > 2 * PRECISION){\n            err += 1;\n        }\n    }\n\n    acc_unmap_data(c);\n    acc_free(d);\n\n    return err;\n}\n#endif\n#ifndef T3\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test3();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 2);\n    }\n#endif\n",
                        "tags": [
                            "runtime",
                            "data",
                            "executable-data",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "acc_update_device.F90": {
                "num tests": 2,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:runtime,data,executable-data,construct-independent,update,V:2.0-2.7\n      LOGICAL FUNCTION test1()\n        USE OPENACC\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT):: a, b, c !Data\n        INTEGER :: errors = 0\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n        CALL RANDOM_NUMBER(a)\n        CALL RANDOM_NUMBER(b)\n        c = 0\n\n        !$acc data copyout(c(1:LOOPCOUNT)) create(a(1:LOOPCOUNT), b(1:LOOPCOUNT))\n          CALL acc_update_device(a(1:LOOPCOUNT))\n          CALL acc_update_device(b(1:LOOPCOUNT))\n          !$acc parallel\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              c(x) = a(x) + b(x)\n            END DO\n          !$acc end parallel\n        !$acc end data\n\n        DO x = 1, LOOPCOUNT\n          IF (abs(c(x) - (a(x) + b(x))) .gt. PRECISION) THEN\n            errors = errors + 1\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "runtime",
                            "data",
                            "executable-data",
                            "construct-independent",
                            "update"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "2": {
                        "content": "#ifndef T2\n!T2:runtime,data,executable-data,devonly,construct-independent,update,V:2.0-2.7\n      LOGICAL FUNCTION test2()\n        USE OPENACC\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT):: a, b, c !Data\n        INTEGER,DIMENSION(1):: devtest\n        INTEGER :: errors = 0\n\n        devtest(1) = 1\n        !$acc enter data copyin(devtest(1:1))\n        !$acc parallel present(devtest(1:1))\n          devtest(1) = 0\n        !$acc end parallel\n\n        IF (devtest(1) .eq. 1) THEN\n          CALL RANDOM_NUMBER(a)\n          CALL RANDOM_NUMBER(b)\n          c = 0\n\n          !$acc data copyout(c(1:LOOPCOUNT)) copyin(a(1:LOOPCOUNT), b(1:LOOPCOUNT))\n            !$acc parallel\n              !$acc loop\n              DO x = 1, LOOPCOUNT\n                a(x) = a(x) * a(x)\n              END DO\n            !$acc end parallel\n            CALL acc_update_device(a(1:LOOPCOUNT))\n            !$acc parallel\n              !$acc loop\n              DO x = 1, LOOPCOUNT\n                b(x) = b(x) * b(x)\n              END DO\n            !$acc end parallel\n            CALL acc_update_device(b(1:LOOPCOUNT))\n            !$acc parallel\n              !$acc loop\n              DO x = 1, LOOPCOUNT\n                c(x) = a(x) + b(x)\n              END DO\n            !$acc end parallel\n          !$acc end data\n\n          DO x = 1, LOOPCOUNT\n            IF (abs(c(x) - (a(x) + b(x))) .gt. PRECISION) THEN\n              errors = errors + 1\n            END IF\n          END DO\n        END IF\n\n        IF (errors .eq. 0) THEN\n          test2 = .FALSE.\n        ELSE\n          test2 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T2\n        LOGICAL :: test2\n#endif\n#ifndef T2\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test2()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 1\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "runtime",
                            "data",
                            "executable-data",
                            "devonly",
                            "construct-independent",
                            "update"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "acc_update_device.c": {
                "num tests": 2,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:runtime,data,executable-data,construct-independent,V:2.0-2.7\nint test1(){\n    int err = 0;\n    real_t *a = (real_t *)malloc(n * sizeof(real_t));\n    real_t *b = (real_t *)malloc(n * sizeof(real_t));\n    real_t *c = (real_t *)malloc(n * sizeof(real_t));\n    int *devtest = (int *)malloc(sizeof(int));\n\n    devtest[0] = 1;\n    #pragma acc enter data copyin(devtest[0:1])\n    #pragma acc parallel\n    {\n        devtest[0] = 0;\n    }\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n        c[x] = 0;\n    }\n\n    #pragma acc data copyout(c[0:n]) create(a[0:n], b[0:n])\n    {\n        acc_update_device(a, n * sizeof(real_t));\n        acc_update_device(b, n * sizeof(real_t));\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                c[x] = a[x] + b[x];\n            }\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        if (fabs(c[x] - (a[x] + b[x])) > PRECISION){\n            err += 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "runtime",
                            "data",
                            "executable-data",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "2": {
                        "content": "#ifndef T2\n//T2:runtime,data,executable-data,construct-independent,V:2.0-2.7\nint test2(){\n    int err = 0;\n    real_t *a = (real_t *)malloc(n * sizeof(real_t));\n    real_t *b = (real_t *)malloc(n * sizeof(real_t));\n    real_t *c = (real_t *)malloc(n * sizeof(real_t));\n    int *devtest = (int *)malloc(sizeof(int));\n\n    devtest[0] = 1;\n    #pragma acc enter data copyin(devtest[0:1])\n    #pragma acc parallel\n    {\n        devtest[0] = 0;\n    }\n\n    if (devtest[0] == 1){\n        for (int x = 0; x < n; ++x){\n            a[x] = rand() / (real_t)(RAND_MAX / 10);\n            b[x] = rand() / (real_t)(RAND_MAX / 10);\n            c[x] = 0;\n        }\n\n        #pragma acc data copyout(c[0:n]) copyin(a[0:n], b[0:n])\n        {\n            #pragma acc parallel\n            {\n                #pragma acc loop\n                for (int x = 0; x < n; ++x){\n                    a[x] = a[x] * a[x];\n                }\n            }\n            acc_update_device(a, n * sizeof(real_t));\n            #pragma acc parallel\n            {\n                #pragma acc loop\n                for (int x = 0; x < n; ++x){\n                    b[x] = b[x] * b[x];\n                }\n            }\n            acc_update_device(b, n * sizeof(real_t));\n            #pragma acc parallel\n            {\n                #pragma acc loop\n                for (int x = 0; x < n; ++x){\n                    c[x] = a[x] + b[x];\n                }\n            }\n        }\n\n\n        for (int x = 0; x < n; ++x){\n            if (fabs(c[x] - (a[x] + b[x])) > PRECISION){\n                err += 1;\n            }\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T2\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test2();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 1);\n    }\n#endif\n",
                        "tags": [
                            "runtime",
                            "data",
                            "executable-data",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "acc_update_device_async.F90": {
                "num tests": 2,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:runtime,data,executable-data,async,construct-independent,update,V:2.5-2.7\n      LOGICAL FUNCTION test1()\n        USE OPENACC\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT):: a, b, c, a_host, b_host !Data\n        INTEGER :: errors = 0\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n        CALL RANDOM_NUMBER(a)\n        CALL RANDOM_NUMBER(b)\n        c = 0\n        a_host = a\n        b_host = b\n\n        !$acc data create(a(1:LOOPCOUNT), b(1:LOOPCOUNT)) copyout(c(1:LOOPCOUNT))\n          CALL acc_update_device_async(a(1:LOOPCOUNT), 1)\n          !$acc parallel async(1)\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              a(x) = a(x) * a(x)\n            END DO\n          !$acc end parallel\n          CALL acc_update_device_async(b(1:LOOPCOUNT), 2)\n          !$acc parallel async(2)\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              b(x) = b(x) * b(x)\n            END DO\n          !$acc end parallel\n          !$acc parallel async(1) wait(2)\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              c(x) = a(x) + b(x)\n            END DO\n          !$acc end parallel\n          !$acc wait(1)\n        !$acc end data\n\n        DO x = 1, LOOPCOUNT\n          IF (abs(c(x) - ((a_host(x) * a_host(x)) + (b_host(x) * b_host(x)))) .gt. PRECISION) THEN\n            errors = errors + 1\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "runtime",
                            "data",
                            "executable-data",
                            "async",
                            "construct-independent",
                            "update"
                        ],
                        "versions": [
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "2": {
                        "content": "#ifndef T2\n!T2:runtime,data,executable-data,devonly,async,construct-independent,update,V:2.5-2.7\n      LOGICAL FUNCTION test2()\n        USE OPENACC\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT):: a, b, c !Data\n        INTEGER,DIMENSION(1):: devtest\n        INTEGER :: errors = 0\n\n        devtest(1) = 1\n        !$acc enter data copyin(devtest(1:1))\n        !$acc parallel present(devtest(1:1))\n          devtest(1) = 0\n        !$acc end parallel\n        IF (devtest(1) .eq. 1) THEN\n          CALL RANDOM_NUMBER(a)\n          CALL RANDOM_NUMBER(b)\n          c = 0\n\n          !$acc data copyout(c(1:LOOPCOUNT)) copyin(a(1:LOOPCOUNT), b(1:LOOPCOUNT))\n            !$acc parallel async(1)\n              !$acc loop\n              DO x = 1, LOOPCOUNT\n                a(x) = a(x) * a(x)\n              END DO\n            !$acc end parallel\n            CALL acc_update_device_async(a(1:LOOPCOUNT), 1)\n            !$acc parallel async(2)\n              !$acc loop\n              DO x = 1, LOOPCOUNT\n                b(x) = b(x) * b(x)\n              END DO\n            !$acc end parallel\n            CALL acc_update_device_async(b(1:LOOPCOUNT), 2)\n            !$acc parallel async(1) wait(2)\n              !$acc loop\n              DO x = 1, LOOPCOUNT\n                c(x) = a(x) + b(x)\n              END DO\n            !$acc end parallel\n            !$acc wait(1)\n          !$acc end data\n\n          DO x = 1, LOOPCOUNT\n            IF (abs(c(x) - (a(x) + b(x))) .gt. PRECISION) THEN\n              errors = errors + 1\n            END IF\n          END DO\n        END IF\n\n        IF (errors .eq. 0) THEN\n          test2 = .FALSE.\n        ELSE\n          test2 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T2\n        LOGICAL :: test2\n#endif\n#ifndef T2\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test2()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 1\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "runtime",
                            "data",
                            "executable-data",
                            "devonly",
                            "async",
                            "construct-independent",
                            "update"
                        ],
                        "versions": [
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "acc_update_device_async.c": {
                "num tests": 2,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:runtime,data,executable-data,async,construct-independent,V:2.5-2.7\nint test1(){\n    int err = 0;\n    real_t *a = (real_t *)malloc(n * sizeof(real_t));\n    real_t *b = (real_t *)malloc(n * sizeof(real_t));\n    real_t *c = (real_t *)malloc(n * sizeof(real_t));\n    real_t *a_host = (real_t *)malloc(n * sizeof(real_t));\n    real_t *b_host = (real_t *)malloc(n * sizeof(real_t));\n\n    int *devtest = (int *)malloc(sizeof(int));\n\n    devtest[0] = 1;\n    #pragma acc enter data copyin(devtest[0:1])\n    #pragma acc parallel\n    {\n        devtest[0] = 0;\n    }\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n        c[x] = 0;\n        a_host[x] = a[x];\n        b_host[x] = b[x];\n    }\n\n\n\n    #pragma acc data copyout(c[0:n]) create(a[0:n], b[0:n])\n    {\n        acc_update_device_async(a, n * sizeof(real_t), 1);\n        #pragma acc parallel async(1)\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                a[x] = a[x] * a[x];\n            }\n        }\n        acc_update_device_async(b, n * sizeof(real_t), 2);\n        #pragma acc parallel async(2)\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                b[x] = b[x] * b[x];\n            }\n        }\n        #pragma acc parallel async(1) wait(2)\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                c[x] = a[x] + b[x];\n            }\n        }\n        #pragma acc wait(1)\n    }\n\n    for (int x = 0; x < n; ++x){\n        if (fabs(c[x] - (a_host[x] * a_host[x] + b_host[x] * b_host[x])) > PRECISION){\n            err += 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "runtime",
                            "data",
                            "executable-data",
                            "async",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "2": {
                        "content": "#ifndef T2\n//T2:runtime,data,executable-data,async,devonly,construct-independent,V:2.5-2.7\nint test2(){\n    int err = 0;\n    real_t *a = (real_t *)malloc(n * sizeof(real_t));\n    real_t *b = (real_t *)malloc(n * sizeof(real_t));\n    real_t *c = (real_t *)malloc(n * sizeof(real_t));\n    real_t *a_host = (real_t *)malloc(n * sizeof(real_t));\n    real_t *b_host = (real_t *)malloc(n * sizeof(real_t));\n\n    int *devtest = (int *)malloc(sizeof(int));\n\n    devtest[0] = 1;\n    #pragma acc enter data copyin(devtest[0:1])\n    #pragma acc parallel\n    {\n        devtest[0] = 0;\n    }\n\n    if (devtest[0] == 1){\n        for (int x = 0; x < n; ++x){\n            a[x] = rand() / (real_t)(RAND_MAX / 10);\n            b[x] = rand() / (real_t)(RAND_MAX / 10);\n            c[x] = 0;\n        }\n\n        #pragma acc data copyout(c[0:n]) copyin(a[0:n], b[0:n])\n        {\n            #pragma acc parallel async(1)\n            {\n                #pragma acc loop\n                for (int x = 0; x < n; ++x){\n                    a[x] = a[x] * a[x];\n                }\n            }\n            acc_update_device_async(a, n * sizeof(real_t), 1);\n            #pragma acc parallel async(2)\n            {\n                #pragma acc loop\n                for (int x = 0; x < n; ++x){\n                    b[x] = b[x] * b[x];\n                }\n            }\n            acc_update_device_async(b, n * sizeof(real_t), 2);\n            #pragma acc parallel async(1) wait(2)\n            {\n                #pragma acc loop\n                for (int x = 0; x < n; ++x){\n                    c[x] = a[x] + b[x];\n                }\n            }\n            #pragma acc wait(1)\n        }\n\n\n        for (int x = 0; x < n; ++x){\n            if (fabs(c[x] - (a[x] + b[x])) > PRECISION){\n                err += 1;\n            }\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T2\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test2();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 1);\n    }\n#endif\n",
                        "tags": [
                            "runtime",
                            "data",
                            "executable-data",
                            "async",
                            "devonly",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "acc_update_device_async_with_len.F90": {
                "num tests": 2,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:runtime,data,executable-data,async,construct-independent,update,V:2.5-2.7\n      LOGICAL FUNCTION test1()\n        USE OPENACC\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT):: a, b, c, a_host, b_host !Data\n        INTEGER :: errors\n        errors = 0\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n        CALL RANDOM_NUMBER(a)\n        CALL RANDOM_NUMBER(b)\n        c = 0\n        a_host = a\n        b_host = b\n\n        !$acc data copyin(a(1:LOOPCOUNT), b(1:LOOPCOUNT)) copyout(c(1:LOOPCOUNT))\n          CALL acc_update_device_async(a(1), LOOPCOUNT*8, 1)\n          !$acc parallel async(1)\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              a(x) = a(x) * a(x)\n            END DO\n          !$acc end parallel\n          CALL acc_update_device_async(b(1), LOOPCOUNT*8, 2)\n          !$acc parallel async(2)\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              b(x) = b(x) * b(x)\n            END DO\n          !$acc end parallel\n          !$acc parallel async(1) wait(2)\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              c(x) = a(x) + b(x)\n            END DO\n          !$acc end parallel\n          !$acc wait(1)\n        !$acc end data\n\n        DO x = 1, LOOPCOUNT\n          IF (abs(c(x) - ((a_host(x) * a_host(x)) + (b_host(x) * b_host(x)))) .gt. PRECISION) THEN\n            errors = errors + 1\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "runtime",
                            "data",
                            "executable-data",
                            "async",
                            "construct-independent",
                            "update"
                        ],
                        "versions": [
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "2": {
                        "content": "#ifndef T2\n!T2:runtime,data,executable-data,devonly,async,construct-independent,update,V:2.5-2.7\n      LOGICAL FUNCTION test2()\n        USE OPENACC\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT):: a, b, c !Data\n        INTEGER,DIMENSION(1):: devtest\n        INTEGER :: errors\n        errors = 0\n\n        devtest(1) = 1\n        !$acc enter data copyin(devtest(1:1))\n        !$acc parallel present(devtest(1:1))\n          devtest(1) = 0\n        !$acc end parallel\n        IF (devtest(1) .eq. 1) THEN\n          CALL RANDOM_NUMBER(a)\n          CALL RANDOM_NUMBER(b)\n          c = 0\n\n          !$acc data copyout(c(1:LOOPCOUNT)) copyin(a(1:LOOPCOUNT), b(1:LOOPCOUNT))\n            !$acc parallel async(1)\n              !$acc loop\n              DO x = 1, LOOPCOUNT\n                a(x) = a(x) * a(x)\n              END DO\n            !$acc end parallel\n            CALL acc_update_device_async(a(1), LOOPCOUNT*8, 1)\n            !$acc parallel async(2)\n              !$acc loop\n              DO x = 1, LOOPCOUNT\n                b(x) = b(x) * b(x)\n              END DO\n            !$acc end parallel\n            CALL acc_update_device_async(b(1), LOOPCOUNT*8, 2)\n            !$acc parallel async(1), wait(2)\n              !$acc loop\n               DO x = 1, LOOPCOUNT\n                 c(x) = a(x) + b(x)\n               END DO\n            !$acc end parallel\n            !$acc wait(1)\n          !$acc end data\n\n          DO x = 1, LOOPCOUNT\n            IF (abs(c(x) - (a(x) + b(x))) .gt. PRECISION) THEN\n              errors = errors + 1\n            END IF\n          END DO\n        END IF\n\n        IF (errors .eq. 0) THEN\n          test2 = .FALSE.\n        ELSE\n          test2 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T2\n        LOGICAL :: test2\n#endif\n#ifndef T2\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test2()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 1\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "runtime",
                            "data",
                            "executable-data",
                            "devonly",
                            "async",
                            "construct-independent",
                            "update"
                        ],
                        "versions": [
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "acc_update_device_with_len.F90": {
                "num tests": 2,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:runtime,data,executable-data,devonly,construct-independent,update,V:2.0-2.7\n      LOGICAL FUNCTION test1()\n        USE OPENACC\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT):: a, b, c !Data\n        INTEGER,DIMENSION(1):: devtest\n        REAL(8) :: RAND\n        INTEGER :: errors = 0\n\n        devtest(1) = 1\n        !$acc enter data copyin(devtest(1:1))\n        !$acc parallel\n          devtest(1) = 0\n        !$acc end parallel\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(a)\n        CALL RANDOM_NUMBER(b)\n        c = 0\n\n        !$acc data copyout(c(1:LOOPCOUNT)) create(a(1:LOOPCOUNT), b(1:LOOPCOUNT))\n          CALL acc_update_device(a(1), LOOPCOUNT*8)\n          CALL acc_update_device(b(1), LOOPCOUNT*8)\n          !$acc parallel\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              c(x) = a(x) + b(x)\n            END DO\n          !$acc end parallel\n        !$acc end data\n\n        DO x = 1, LOOPCOUNT\n          IF (abs(c(x) - (a(x) + b(x))) .gt. PRECISION) THEN\n            errors = errors + 1\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "runtime",
                            "data",
                            "executable-data",
                            "devonly",
                            "construct-independent",
                            "update"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "2": {
                        "content": "#ifndef T2\n!T2:runtime,data,executable-data,devonly,construct-independent,update,V:2.0-2.7\n      LOGICAL FUNCTION test2()\n        USE OPENACC\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT):: a, b, c !Data\n        INTEGER,DIMENSION(1):: devtest\n        REAL(8) :: RAND\n        INTEGER :: errors = 0\n\n        devtest(1) = 1\n        !$acc enter data copyin(devtest(1:1))\n        !$acc parallel\n          devtest(1) = 0\n        !$acc end parallel\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        IF (devtest(1) .eq. 1) THEN\n          CALL RANDOM_NUMBER(a)\n          CALL RANDOM_NUMBER(b)\n          c = 0\n\n          !$acc data copyout(c(1:LOOPCOUNT)) copyin(a(1:LOOPCOUNT), b(1:LOOPCOUNT))\n            !$acc parallel\n              !$acc loop\n              DO x = 1, LOOPCOUNT\n                a(x) = a(x) * a(x)\n              END DO\n            !$acc end parallel\n            CALL acc_update_device(a(1), LOOPCOUNT*8)\n            !$acc parallel\n              !$acc loop\n              DO x = 1, LOOPCOUNT\n                b(x) = b(x) * b(x)\n              END DO\n            !$acc end parallel\n            CALL acc_update_device(b(1), LOOPCOUNT*8)\n            !$acc parallel\n              !$acc loop\n              DO x = 1, LOOPCOUNT\n                c(x) = a(x) + b(x)\n              END DO\n            !$acc end parallel\n          !$acc end data\n\n          DO x = 1, LOOPCOUNT\n            IF (abs(c(x) - (a(x) + b(x))) .gt. PRECISION) THEN\n              errors = errors + 1\n            END IF\n          END DO\n        END IF\n\n        IF (errors .eq. 0) THEN\n          test2 = .FALSE.\n        ELSE\n          test2 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T2\n        LOGICAL :: test2\n#endif\n#ifndef T2\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test2()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 1\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "runtime",
                            "data",
                            "executable-data",
                            "devonly",
                            "construct-independent",
                            "update"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "acc_update_self.F90": {
                "num tests": 2,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:runtime,data,executable-data,construct-independent,update,V:2.0-2.7\n      LOGICAL FUNCTION test1()\n        USE OPENACC\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT):: a, b, c !Data\n        REAL(8) :: RAND\n        INTEGER :: errors = 0\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(a)\n        CALL RANDOM_NUMBER(b)\n        c = 0\n\n        !$acc data copyin(a(1:LOOPCOUNT), b(1:LOOPCOUNT)) create(c(1:LOOPCOUNT))\n          !$acc parallel\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              c(x) = a(x) + b(x)\n            END DO\n          !$acc end parallel\n          CALL acc_update_self(c(1:LOOPCOUNT))\n        !$acc end data\n\n        DO x = 1, LOOPCOUNT\n          IF (abs(c(x) - (a(x) + b(x))) .gt. PRECISION) THEN\n            errors = errors + 1\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "runtime",
                            "data",
                            "executable-data",
                            "construct-independent",
                            "update"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "2": {
                        "content": "#ifndef T2\n!T2:runtime,data,executable-data,construct-independent,update,V:2.0-2.7\n      LOGICAL FUNCTION test2()\n        USE OPENACC\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT):: a, b, c !Data\n        REAL(8) :: RAND\n        INTEGER :: errors = 0\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(a)\n        CALL RANDOM_NUMBER(b)\n        c = 0\n\n        !$acc data copyout(c(1:LOOPCOUNT)) copyin(a(1:LOOPCOUNT), b(1:LOOPCOUNT))\n          !$acc parallel\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              a(x) = a(x) * a(x)\n            END DO\n          !$acc end parallel\n          CALL acc_update_self(a(1:LOOPCOUNT))\n          !$acc parallel\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              b(x) = b(x) * b(x)\n            END DO\n          !$acc end parallel\n          CALL acc_update_self(b(1:LOOPCOUNT))\n          !$acc parallel\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              c(x) = a(x) + b(x)\n            END DO\n          !$acc end parallel\n        !$acc end data\n\n        DO x = 1, LOOPCOUNT\n          IF (abs(c(x) - (a(x) + b(x))) .gt. PRECISION) THEN\n            errors = errors + 1\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test2 = .FALSE.\n        ELSE\n          test2 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T2\n        LOGICAL :: test2\n#endif\n#ifndef T2\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test2()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 1\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "runtime",
                            "data",
                            "executable-data",
                            "construct-independent",
                            "update"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "acc_update_self.c": {
                "num tests": 2,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:runtime,data,executable-data,construct-independent,V:2.0-2.7\nint test1(){\n    int err = 0;\n    real_t *a = (real_t *)malloc(n * sizeof(real_t));\n    real_t *b = (real_t *)malloc(n * sizeof(real_t));\n    real_t *c = (real_t *)malloc(n * sizeof(real_t));\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n        c[x] = 0;\n    }\n\n    #pragma acc data create(c[0:n]) copyin(a[0:n], b[0:n])\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                c[x] = a[x] + b[x];\n            }\n        }\n        acc_update_self(c, n * sizeof(real_t));\n    }\n\n    for (int x = 0; x < n; ++x){\n        if (fabs(c[x] - (a[x] + b[x])) > PRECISION){\n            err += 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "runtime",
                            "data",
                            "executable-data",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "2": {
                        "content": "#ifndef T2\n//T2:runtime,data,executable-data,construct-independent,V:2.0-2.7\nint test2(){\n    int err = 0;\n    real_t *a = (real_t *)malloc(n * sizeof(real_t));\n    real_t *b = (real_t *)malloc(n * sizeof(real_t));\n    real_t *c = (real_t *)malloc(n * sizeof(real_t));\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n        c[x] = 0;\n    }\n\n    #pragma acc data copyout(c[0:n]) copyin(a[0:n], b[0:n])\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                a[x] = a[x] * a[x];\n            }\n        }\n        acc_update_self(a, n * sizeof(real_t));\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                b[x] = b[x] * b[x];\n            }\n        }\n        acc_update_self(b, n * sizeof(real_t));\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                c[x] = a[x] + b[x];\n            }\n        }\n    }\n\n\n    for (int x = 0; x < n; ++x){\n        if (fabs(c[x] - (a[x] + b[x])) > PRECISION){\n            err += 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T2\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test2();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 1);\n    }\n#endif\n",
                        "tags": [
                            "runtime",
                            "data",
                            "executable-data",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "acc_update_self_async.F90": {
                "num tests": 2,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:runtime,data,executable-data,devonly,async,construct-independent,update,V:2.5-2.7\n      LOGICAL FUNCTION test1()\n        USE OPENACC\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT):: a, b, c, d !Data\n        INTEGER,DIMENSION(1):: devtest\n        REAL(8) :: RAND\n        INTEGER :: errors = 0\n\n        devtest(1) = 1\n        !$acc enter data copyin(devtest(1:1))\n        !$acc parallel\n          devtest(1) = 0\n        !$acc end parallel\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(a)\n        CALL RANDOM_NUMBER(b)\n        c = 0\n        d = 0\n\n        !$acc data copyin(a(1:LOOPCOUNT), b(1:LOOPCOUNT)) create(c(1:LOOPCOUNT), d(1:LOOPCOUNT))\n          !$acc parallel async(1)\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              c(x) = a(x) + b(x)\n            END DO\n          !$acc end parallel\n          !$acc parallel async(2)\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              d(x) = a(x) * b(x)\n            END DO\n          !$acc end parallel\n          CALL acc_update_self_async(c(1:LOOPCOUNT), 1)\n          CALL acc_update_self_async(d(1:LOOPCOUNT), 2)\n          !$acc wait\n        !$acc end data\n\n        DO x = 1, LOOPCOUNT\n          IF (abs(c(x) - (a(x) + b(x))) .gt. PRECISION) THEN\n            errors = errors + 1\n          END IF\n          IF (abs(d(x) - (a(x) * b(x))) .gt. PRECISION) THEN\n            errors = errors + 1\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "runtime",
                            "data",
                            "executable-data",
                            "devonly",
                            "async",
                            "construct-independent",
                            "update"
                        ],
                        "versions": [
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "2": {
                        "content": "#ifndef T2\n!T2:runtime,data,executable-data,devonly,async,construct-independent,update,V:2.5-2.7\n      LOGICAL FUNCTION test2()\n        USE OPENACC\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT):: a, b, c, d !Data\n        INTEGER,DIMENSION(1):: devtest\n        REAL(8) :: RAND\n        INTEGER :: errors = 0\n\n        devtest(1) = 1\n        !$acc enter data copyin(devtest(1:1))\n        !$acc parallel\n          devtest(1) = 0\n        !$acc end parallel\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        IF (devtest(1) .eq. 1) THEN\n          CALL RANDOM_NUMBER(a)\n          CALL RANDOM_NUMBER(b)\n          c = 0\n\n          !$acc data copyout(c(1:LOOPCOUNT)) copyin(a(1:LOOPCOUNT), b(1:LOOPCOUNT))\n            !$acc parallel async(1)\n              !$acc loop\n              DO x = 1, LOOPCOUNT\n                a(x) = a(x) * a(x)\n              END DO\n            !$acc end parallel\n            CALL acc_update_self_async(a(1:LOOPCOUNT), 1)\n            !$acc parallel async(2)\n              !$acc loop\n              DO x = 1, LOOPCOUNT\n                b(x) = b(x) * b(x)\n              END DO\n            !$acc end parallel\n            CALL acc_update_self_async(b(1:LOOPCOUNT), 2)\n            !$acc parallel async(1)\n              !$acc loop\n              DO x = 1, LOOPCOUNT\n                a(x) = a(x) + 1\n              END DO\n            !$acc end parallel\n            !$acc parallel async(2)\n              !$acc loop\n              DO x = 1, LOOPCOUNT\n                b(x) = b(x) + 1\n              END DO\n            !$acc end parallel\n            !$acc parallel async(1) wait(2)\n              !$acc loop\n              DO x = 1, LOOPCOUNT\n                c(x) = a(x) * b(x)\n              END DO\n            !$acc end parallel\n          !$acc end data\n\n          DO x = 1, LOOPCOUNT\n            IF (abs(c(x) - ((a(x) + 1) * (b(x) + 1))) .gt. PRECISION) THEN\n              errors = errors + 1\n            END IF\n          END DO\n        END IF\n\n        IF (errors .eq. 0) THEN\n          test2 = .FALSE.\n        ELSE\n          test2 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T2\n        LOGICAL :: test2\n#endif\n#ifndef T2\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test2()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 1\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "runtime",
                            "data",
                            "executable-data",
                            "devonly",
                            "async",
                            "construct-independent",
                            "update"
                        ],
                        "versions": [
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "acc_update_self_async.c": {
                "num tests": 2,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:runtime,data,executable-data,async,construct-independent,V:2.5-2.7\nint test1(){\n    int err = 0;\n    real_t *a = (real_t *)malloc(n * sizeof(real_t));\n    real_t *b = (real_t *)malloc(n * sizeof(real_t));\n    real_t *c = (real_t *)malloc(n * sizeof(real_t));\n    real_t *d = (real_t *)malloc(n * sizeof(real_t));\n\n    int *devtest = (int *)malloc(sizeof(int));\n\n    devtest[0] = 1;\n    #pragma acc enter data copyin(devtest[0:1])\n    #pragma acc parallel\n    {\n        devtest[0] = 0;\n    }\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n        c[x] = 0;\n        d[x] = 0;\n    }\n\n\n\n    #pragma acc data create(c[0:n], d[0:n]) copyin(a[0:n], b[0:n])\n    {\n        #pragma acc parallel async(1)\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                c[x] = a[x] + b[x];\n            }\n        }\n        #pragma acc parallel async(2)\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                d[x] = a[x] * b[x];\n            }\n        }\n        acc_update_self_async(c, n * sizeof(real_t), 1);\n        acc_update_self_async(d, n * sizeof(real_t), 2);\n        #pragma acc wait\n    }\n\n    for (int x = 0; x < n; ++x){\n        if (fabs(c[x] - (a[x] + b[x])) > PRECISION){\n            err += 1;\n        }\n        if (fabs(d[x] - (a[x] * b[x])) > PRECISION){\n            err += 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "runtime",
                            "data",
                            "executable-data",
                            "async",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "2": {
                        "content": "#ifndef T2\n//T2:runtime,data,executable-data,devonly,async,construct-independent,V:2.5-2.7\nint test2(){\n\tint err = 0;\n    real_t *a = (real_t *)malloc(n * sizeof(real_t));\n    real_t *b = (real_t *)malloc(n * sizeof(real_t));\n    real_t *c = (real_t *)malloc(n * sizeof(real_t));\n    real_t *d = (real_t *)malloc(n * sizeof(real_t));\n\n    int *devtest = (int *)malloc(sizeof(int));\n\n    devtest[0] = 1;\n    #pragma acc enter data copyin(devtest[0:1])\n    #pragma acc parallel\n    {\n        devtest[0] = 0;\n    }\n\n    if (devtest[0] == 1){\n        for (int x = 0; x < n; ++x){\n            a[x] = rand() / (real_t)(RAND_MAX / 10);\n            b[x] = rand() / (real_t)(RAND_MAX / 10);\n            c[x] = 0;\n        }\n\n        #pragma acc data copyout(c[0:n]) copyin(a[0:n], b[0:n])\n        {\n            #pragma acc parallel async(1)\n            {\n                #pragma acc loop\n                for (int x = 0; x < n; ++x){\n                    a[x] = a[x] * a[x];\n                }\n            }\n            acc_update_self_async(a, n * sizeof(real_t), 1);\n            #pragma acc parallel async(2)\n            {\n                #pragma acc loop\n                for (int x = 0; x < n; ++x){\n                    b[x] = b[x] * b[x];\n                }\n            }\n            acc_update_self_async(b, n * sizeof(real_t), 2);\n            #pragma acc parallel async(1)\n            {\n                #pragma acc loop\n                for (int x = 0; x < n; ++x){\n                    a[x] = a[x] + 1;\n                }\n            }\n            #pragma acc parallel async(2)\n            {\n                #pragma acc loop\n                for (int x = 0; x < n; ++x){\n                    b[x] = b[x] + 1;\n                }\n            }\n            #pragma acc parallel async(1) wait(2)\n            {\n                #pragma acc loop\n                for (int x = 0; x < n; ++x){\n                    c[x] = a[x] * b[x];\n                }\n            }\n            #pragma acc wait(1)\n        }\n\n\n        for (int x = 0; x < n; ++x){\n            if (fabs(c[x] - ((a[x] + 1) * (b[x] + 1))) > 4 * PRECISION){\n                err += 1;\n            }\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T2\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test2();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 1);\n    }\n#endif\n",
                        "tags": [
                            "runtime",
                            "data",
                            "executable-data",
                            "devonly",
                            "async",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "acc_update_self_async_with_len.F90": {
                "num tests": 2,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:runtime,data,executable-data,devonly,async,construct-independent,update,V:2.5-2.7\n      LOGICAL FUNCTION test1()\n        USE OPENACC\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT):: a, b, c, d !Data\n        INTEGER,DIMENSION(1):: devtest\n        REAL(8) :: RAND\n        INTEGER :: errors = 0\n\n        devtest(1) = 1\n        !$acc enter data copyin(devtest(1:1))\n        !$acc parallel present(devtest(1:1))\n          devtest(1) = 0\n        !$acc end parallel\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(a)\n        CALL RANDOM_NUMBER(b)\n        c = 0\n        d = 0\n\n        !$acc data copyin(a(1:LOOPCOUNT), b(1:LOOPCOUNT)) create(c(1:LOOPCOUNT), d(1:LOOPCOUNT))\n          !$acc parallel async(1)\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              c(x) = a(x) + b(x)\n            END DO\n          !$acc end parallel\n          !$acc parallel async(2)\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              d(x) = a(x) * b(x)\n            END DO\n          !$acc end parallel\n          CALL acc_update_self_async(c(1), LOOPCOUNT*8, 1)\n          CALL acc_update_self_async(d(1), LOOPCOUNT*8, 2)\n          !$acc wait\n        !$acc end data\n        DO x = 1, LOOPCOUNT\n          IF (abs(c(x) - (a(x) + b(x))) .gt. PRECISION) THEN\n            errors = errors + 1\n          END IF\n          IF (abs(d(x) - (a(x) * b(x))) .gt. PRECISION) THEN\n            errors = errors + 1\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "runtime",
                            "data",
                            "executable-data",
                            "devonly",
                            "async",
                            "construct-independent",
                            "update"
                        ],
                        "versions": [
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "2": {
                        "content": "#ifndef T2\n!T2:runtime,data,executable-data,devonly,async,construct-independent,update,V:2.5-2.7\n      LOGICAL FUNCTION test2()\n        USE OPENACC\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT):: a, b, c, d !Data\n        INTEGER,DIMENSION(1):: devtest\n        REAL(8) :: RAND\n        INTEGER :: errors = 0\n\n        devtest(1) = 1\n        !$acc enter data copyin(devtest(1:1))\n        !$acc parallel present(devtest(1:1))\n          devtest(1) = 0\n        !$acc end parallel\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        IF (devtest(1) .eq. 1) THEN\n          CALL RANDOM_NUMBER(a)\n          CALL RANDOM_NUMBER(b)\n          c = 0\n\n          !$acc data copyout(c(1:LOOPCOUNT)) copyin(a(1:LOOPCOUNT), b(1:LOOPCOUNT))\n            !$acc parallel async(1)\n              !$acc loop\n              DO x = 1, LOOPCOUNT\n                a(x) = a(x) * a(x)\n              END DO\n            !$acc end parallel\n            CALL acc_update_self_async(a(1), LOOPCOUNT*8, 1)\n            !$acc parallel async(2)\n              !$acc loop\n              DO x = 1, LOOPCOUNT\n                b(x) = b(x) * b(x)\n              END DO\n            !$acc end parallel\n            CALL acc_update_self_async(b(1), LOOPCOUNT*8, 2)\n            !$acc parallel async(1)\n              !$acc loop\n              DO x = 1, LOOPCOUNT\n                a(x) = a(x) + 1\n              END DO\n            !$acc end parallel\n            !$acc parallel async(2)\n              !$acc loop\n              DO x = 1, LOOPCOUNT\n                b(x) = b(x) + 1\n              END DO\n            !$acc end parallel\n            !$acc parallel async(1) wait(2)\n              !$acc loop\n              DO x = 1, LOOPCOUNT\n                c(x) = a(x) * b(x)\n              END DO\n            !$acc end parallel\n            !$acc wait(1)\n          !$acc end data\n\n          DO x = 1, LOOPCOUNT\n            IF (abs(c(x) - ((a(x) + 1) * (b(x) + 1))) .gt. PRECISION) THEN\n              errors = errors + 1\n            END IF\n          END DO\n        END IF\n\n        IF (errors .eq. 0) THEN\n          test2 = .FALSE.\n        ELSE\n          test2 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T2\n        LOGICAL :: test2\n#endif\n#ifndef T2\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test2()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 1\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "runtime",
                            "data",
                            "executable-data",
                            "devonly",
                            "async",
                            "construct-independent",
                            "update"
                        ],
                        "versions": [
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "acc_update_self_with_len.F90": {
                "num tests": 2,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:runtime,data,executable-data,construct-independent,update,V:2.0-2.7\n      LOGICAL FUNCTION test1()\n        USE OPENACC\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT):: a, b, c !Data\n        REAL(8) :: RAND\n        INTEGER :: errors = 0\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(a)\n        CALL RANDOM_NUMBER(b)\n        c = 0\n\n        !$acc data copyin(a(1:LOOPCOUNT), b(1:LOOPCOUNT)) create(c(1:LOOPCOUNT))\n          !$acc parallel\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              c(x) = a(x) + b(x)\n            END DO\n          !$acc end parallel\n          CALL acc_update_self(c(1), LOOPCOUNT*8)\n        !$acc end data\n\n        DO x = 1, LOOPCOUNT\n          IF (abs(c(x) - (a(x) + b(x))) .gt. PRECISION) THEN\n            errors = errors + 1\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "runtime",
                            "data",
                            "executable-data",
                            "construct-independent",
                            "update"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "2": {
                        "content": "#ifndef T2\n!T2:runtime,data,executable-data,construct-independent,update,V:2.0-2.7\n      LOGICAL FUNCTION test2()\n        USE OPENACC\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT):: a, b, c !Data\n        REAL(8) :: RAND\n        INTEGER :: errors = 0\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(a)\n        CALL RANDOM_NUMBER(b)\n        c = 0\n\n        !$acc data copyout(c(1:LOOPCOUNT)) copyin(a(1:LOOPCOUNT), b(1:LOOPCOUNT))\n          !$acc parallel\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              a(x) = a(x) * a(x)\n            END DO\n          !$acc end parallel\n          CALL acc_update_self(a(1), LOOPCOUNT*8)\n          !$acc parallel\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              b(x) = b(x) * b(x)\n            END DO\n          !$acc end parallel\n          CALL acc_update_self(b(1), LOOPCOUNT*8)\n          !$acc parallel\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              c(x) = a(x) + b(x)\n            END DO\n          !$acc end parallel\n        !$acc end data\n\n        DO x = 1, LOOPCOUNT\n          IF (abs(c(x) - (a(x) + b(x))) .gt. PRECISION) THEN\n            errors = errors + 1\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test2 = .FALSE.\n        ELSE\n          test2 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T2\n        LOGICAL :: test2\n#endif\n#ifndef T2\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test2()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 1\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "runtime",
                            "data",
                            "executable-data",
                            "construct-independent",
                            "update"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "acc_wait.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:runtime,async,construct-independent,V:2.0-2.7\n      LOGICAL FUNCTION test1()\n        USE OPENACC\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT):: a, b, c, d, e !Data\n        REAL(8) :: RAND\n        INTEGER :: errors = 0\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(a)\n        CALL RANDOM_NUMBER(b)\n        c = 0\n        CALL RANDOM_NUMBER(d)\n        e = 0\n\n        !$acc enter data  copyin(a(1:LOOPCOUNT), b(1:LOOPCOUNT)) create(c(1:LOOPCOUNT)) async(1)\n        !$acc enter data copyin(d(1:LOOPCOUNT)) create(e(1:LOOPCOUNT)) async(2)\n        !$acc parallel present(a(1:LOOPCOUNT), b(1:LOOPCOUNT), c(1:LOOPCOUNT)) async(1)\n          !$acc loop\n          DO x = 1, LOOPCOUNT\n            c(x) = a(x) + b(x)\n          END DO\n        !$acc end parallel\n        !$acc parallel present(c(1:LOOPCOUNT), d(1:LOOPCOUNT), e(1:LOOPCOUNT)) async(1) wait(2)\n          !$acc loop\n          DO x = 1, LOOPCOUNT\n            e(x) = c(x) + d(x)\n          END DO\n        !$acc end parallel\n        !$acc exit data copyout(e(1:LOOPCOUNT)) async(1)\n\n        CALL acc_wait(1)\n\n        DO x = 1, LOOPCOUNT\n          IF (abs(e(x) - (a(x) + b(x) + d(x))) .gt. PRECISION) THEN\n            errors = errors + 1\n          END IF\n        END DO\n\n        !$acc exit data delete(a(1:LOOPCOUNT), b(1:LOOPCOUNT), c(1:LOOPCOUNT), d(1:LOOPCOUNT))\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "runtime",
                            "async",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "acc_wait.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:runtime,async,construct-independent,wait,V:2.0-2.7\nint test1(){\n    int err = 0;\n    real_t *a = (real_t *)malloc(n * sizeof(real_t));\n    real_t *b = (real_t *)malloc(n * sizeof(real_t));\n    real_t *c = (real_t *)malloc(n * sizeof(real_t));\n    real_t *d = (real_t *)malloc(n * sizeof(real_t));\n    real_t *e = (real_t *)malloc(n * sizeof(real_t));\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n        c[x] = 0;\n        d[x] = rand() / (real_t)(RAND_MAX / 10);\n        e[x] = 0;\n    }\n\n    #pragma acc enter data copyin(a[0:n], b[0:n]) create(c[0:n]) async(1)\n    #pragma acc enter data copyin(d[0:n]) create(e[0:n]) async(2)\n    #pragma acc parallel present(a[0:n], b[0:n], c[0:n]) async(1)\n    {\n        #pragma acc loop\n        for (int x = 0; x < n; ++x){\n            c[x] = a[x] + b[x];\n        }\n    }\n    #pragma acc parallel present(c[0:n], d[0:n], e[0:n]) async(1) wait(2)\n    {\n        #pragma acc loop\n        for (int x = 0; x < n; ++x){\n            e[x] = c[x] + d[x];\n        }\n    }\n    #pragma acc exit data copyout(e[0:n]) async(1)\n\n    acc_wait(1);\n    for (int x = 0; x < n; ++x){\n        if (fabs(e[x] - (a[x] + b[x] + d[x])) > PRECISION){\n            err += 1;\n        }\n    }\n\n    #pragma acc exit data delete(a[0:n], b[0:n], c[0:n], d[0:n])\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "runtime",
                            "async",
                            "construct-independent",
                            "wait"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "acc_wait_all.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:runtime,async,construct-independent,V:2.0-2.7\n      LOGICAL FUNCTION test1()\n        USE OPENACC\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT):: a, b, c, d, a_host, b_host, c_host !Data\n        REAL(8) :: RAND\n        INTEGER :: errors = 0\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(a)\n        CALL RANDOM_NUMBER(b)\n        CALL RANDOM_NUMBER(c)\n        d = 0\n        a_host = a\n        b_host = b\n        c_host = c\n\n        !$acc data copyin(a(1:LOOPCOUNT), b(1:LOOPCOUNT), c(1:LOOPCOUNT)) copyout(d(1:LOOPCOUNT))\n          !$acc parallel async(1)\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              a(x) = a(x) * a(x)\n            END DO\n          !$acc end parallel\n          !$acc parallel async(2)\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              b(x) = b(x) * b(x)\n            END DO\n          !$acc end parallel\n          !$acc parallel async(3)\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              c(x) = c(x) * c(x)\n            END DO\n          !$acc end parallel\n          CALL acc_wait_all()\n          !$acc parallel\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              d(x) = a(x) + b(x) + c(x)\n            END DO\n          !$acc end parallel\n        !$acc end data\n\n        DO x = 1, LOOPCOUNT\n          IF (abs(d(x) - ((a_host(x) * a_host(x)) + (b_host(x) * b_host(x)) + (c_host(x) * c_host(x)))) .gt. PRECISION) THEN\n            errors = errors + 1\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "runtime",
                            "async",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "acc_wait_all.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:runtime,async,construct-independent,wait,V:2.0-2.7\nint test1(){\n    int err = 0;\n    real_t *a = (real_t *)malloc(n * sizeof(real_t));\n    real_t *b = (real_t *)malloc(n * sizeof(real_t));\n    real_t *c = (real_t *)malloc(n * sizeof(real_t));\n    real_t *d = (real_t *)malloc(n * sizeof(real_t));\n    real_t *a_host = (real_t *)malloc(n * sizeof(real_t));\n    real_t *b_host = (real_t *)malloc(n * sizeof(real_t));\n    real_t *c_host = (real_t *)malloc(n * sizeof(real_t));\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n        c[x] = rand() / (real_t)(RAND_MAX / 10);\n        d[x] = 0;\n        a_host[x] = a[x];\n        b_host[x] = b[x];\n        c_host[x] = c[x];\n    }\n\n    #pragma acc data copyin(a[0:n], b[0:n], c[0:n]) copyout(d[0:n])\n    {\n        #pragma acc parallel async(1)\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                a[x] = a[x] * a[x];\n            }\n        }\n        #pragma acc parallel async(2)\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                b[x] = b[x] * b[x];\n            }\n        }\n        #pragma acc parallel async(3)\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                c[x] = c[x] * c[x];\n            }\n        }\n        acc_wait_all();\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                d[x] = a[x] + b[x] + c[x];\n            }\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        if (fabs(d[x] - (a_host[x] * a_host[x] + b_host[x] * b_host[x] + c_host[x] * c_host[x])) > PRECISION) {\n            err += 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "runtime",
                            "async",
                            "construct-independent",
                            "wait"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "acc_wait_all_async.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:runtime,async,construct-independent,V:2.0-2.7\n      LOGICAL FUNCTION test1()\n        USE OPENACC\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT):: a, b, c, d, e, f, g, h, i, j, k !Data\n        REAL(8),DIMENSION(LOOPCOUNT):: a_host, d_host, g_host\n        REAL(8) :: RAND\n        REAL(8) :: temp\n        INTEGER :: errors = 0\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(a)\n        CALL RANDOM_NUMBER(b)\n        c = 0\n        CALL RANDOM_NUMBER(d)\n        CALL RANDOM_NUMBER(e)\n        f = 0\n        CALL RANDOM_NUMBER(g)\n        CALL RANDOM_NUMBER(h)\n        i = 0\n        j = 0\n        k = 0\n        a_host = a\n        d_host = d\n        g_host = g\n\n        !$acc data copyin(a(1:LOOPCOUNT), b(1:LOOPCOUNT), d(1:LOOPCOUNT), e(1:LOOPCOUNT), g(1:LOOPCOUNT), h(1:LOOPCOUNT)) create(c(1:LOOPCOUNT), f(1:LOOPCOUNT), i(1:LOOPCOUNT), j(1:LOOPCOUNT)) copyout(k(1:LOOPCOUNT))\n          !$acc parallel async(1)\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              c(x) = a(x) + b(x)\n            END DO\n          !$acc end parallel\n          !$acc parallel async(2)\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              f(x) = d(x) + e(x)\n            END DO\n          !$acc end parallel\n          !$acc parallel async(3)\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              i(x) = g(x) + h(x)\n            END DO\n          !$acc end parallel\n          CALL acc_wait_all_async(4)\n          !$acc parallel async(4)\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              j(x) = c(x) + f(x) + i(x)\n            END DO\n          !$acc end parallel\n          !$acc parallel async(1)\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              a(x) = b(x) * c(x)\n            END DO\n          !$acc end parallel\n          !$acc parallel async(2)\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              d(x) = e(x) * f(x)\n            END DO\n          !$acc end parallel\n          !$acc parallel async(3)\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              g(x) = h(x) * i(x)\n            END DO\n          !$acc end parallel\n          CALL acc_wait_all_async(4)\n          !$acc parallel async(4)\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              k(x) = j(x) + a(x) + d(x) + g(x)\n            END DO\n          !$acc end parallel\n          !$acc wait(4)\n        !$acc end data\n\n        DO x = 1, LOOPCOUNT\n          temp = a_host(x) + b(x) + d_host(x) + e(x) + g_host(x) + h(x)\n          temp = temp + (b(x) * (a_host(x) + b(x))) + (e(x) * (d_host(x) + e(x))) + (h(x) * (g_host(x) + h(x)))\n          IF (abs(k(x) - temp) .gt. PRECISION * 10) THEN\n            errors = errors + 1\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "runtime",
                            "async",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "acc_wait_all_async.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:runtime,async,construct-independent,wait,V:2.0-2.7\nint test1(){\n    int err = 0;\n    real_t *a = (real_t *)malloc(n * sizeof(real_t));\n    real_t *b = (real_t *)malloc(n * sizeof(real_t));\n    real_t *c = (real_t *)malloc(n * sizeof(real_t));\n    real_t *d = (real_t *)malloc(n * sizeof(real_t));\n    real_t *e = (real_t *)malloc(n * sizeof(real_t));\n    real_t *f = (real_t *)malloc(n * sizeof(real_t));\n    real_t *g = (real_t *)malloc(n * sizeof(real_t));\n    real_t *h = (real_t *)malloc(n * sizeof(real_t));\n    real_t *i = (real_t *)malloc(n * sizeof(real_t));\n    real_t *j = (real_t *)malloc(n * sizeof(real_t));\n    real_t *k = (real_t *)malloc(n * sizeof(real_t));\n    real_t *a_host = (real_t *)malloc(n * sizeof(real_t));\n    real_t *d_host = (real_t *)malloc(n * sizeof(real_t));\n    real_t *g_host = (real_t *)malloc(n * sizeof(real_t));\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n        c[x] = 0;\n        d[x] = rand() / (real_t)(RAND_MAX / 10);\n        e[x] = rand() / (real_t)(RAND_MAX / 10);\n        f[x] = 0;\n        g[x] = rand() / (real_t)(RAND_MAX / 10);\n        h[x] = rand() / (real_t)(RAND_MAX / 10);\n        i[x] = 0;\n        j[x] = 0;\n        k[x] = 0;\n        a_host[x] = a[x];\n        d_host[x] = d[x];\n        g_host[x] = g[x];\n    }\n\n    #pragma acc data copyin(a[0:n], b[0:n], d[0:n], e[0:n], g[0:n], h[0:n]) create(c[0:n], f[0:n], i[0:n], j[0:n]) copyout(k[0:n])\n    {\n        #pragma acc parallel async(1)\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                c[x] = a[x] + b[x];\n            }\n        }\n        #pragma acc parallel async(2)\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                f[x] = d[x] + e[x];\n            }\n        }\n        #pragma acc parallel async(3)\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                i[x] = g[x] + h[x];\n            }\n        }\n        acc_wait_all_async(4);\n        #pragma acc parallel async(4)\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                j[x] = c[x] + f[x] + i[x];\n            }\n        }\n        #pragma acc parallel async(1)\n        {\n            for (int x = 0; x < n; ++x){\n                a[x] = b[x] * c[x];\n            }\n        }\n        #pragma acc parallel async(2)\n        {\n            for (int x = 0; x < n; ++x){\n                d[x] = e[x] * f[x];\n            }\n        }\n        #pragma acc parallel async(3)\n        {\n            for (int x = 0; x < n; ++x){\n                g[x] = h[x] * i[x];\n            }\n        }\n        acc_wait_all_async(4);\n        #pragma acc parallel async(4)\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                k[x] = j[x] + a[x] + d[x] + g[x];\n            }\n        }\n        #pragma acc wait(4)\n    }\n\n    real_t temp;\n    for (int x = 0; x < n; ++x){\n        temp = a_host[x] + b[x] + d_host[x] + e[x] + g_host[x] + h[x];\n        temp += b[x] * (a_host[x] + b[x]) + e[x] * (d_host[x] + e[x]) + h[x] * (g_host[x] + h[x]);\n        if (fabs(k[x] - temp) > PRECISION * 10){\n            err += 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "runtime",
                            "async",
                            "construct-independent",
                            "wait"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "acc_wait_async.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:runtime,async,construct-independent,V:2.0-2.7\n      LOGICAL FUNCTION test1()\n        USE OPENACC\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT):: a, b, c, d, e, f, g, h, i !Data\n        REAL(8) :: RAND\n        INTEGER :: errors = 0\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(a)\n        CALL RANDOM_NUMBER(b)\n        c = 0\n        CALL RANDOM_NUMBER(d)\n        CALL RANDOM_NUMBER(e)\n        f = 0\n        CALL RANDOM_NUMBER(g)\n        h = 0\n        i = 0\n\n        !$acc data copyin(a(1:LOOPCOUNT), b(1:LOOPCOUNT), d(1:LOOPCOUNT), e(1:LOOPCOUNT), g(1:LOOPCOUNT)) create(c(1:LOOPCOUNT), f(1:LOOPCOUNT), h(1:LOOPCOUNT)) copyout(i(1:LOOPCOUNT))\n          !$acc parallel async(1)\n            !$acc loop\n              DO x = 1, LOOPCOUNT\n                c(x) = a(x) + b(x)\n              END DO\n          !$acc end parallel\n          CALL acc_wait_async(1, 2)\n          !$acc parallel async(2)\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              h(x) = c(x) + g(x)\n            END DO\n          !$acc end parallel\n          !$acc parallel async(1)\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              f(x) = d(x) + e(x)\n            END DO\n          !$acc end parallel\n          CALL acc_wait_async(1, 2)\n          !$acc parallel async(2)\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              i(x) = h(x) + f(x)\n            END DO\n          !$acc end parallel\n          !$acc wait(2)\n        !$acc end data\n\n        DO x = 1, LOOPCOUNT\n          IF (abs(i(x) - (a(x) + b(x) + g(x) + d(x) + e(x))) .gt. PRECISION) THEN\n            errors = errors + 1\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "runtime",
                            "async",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "acc_wait_async.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:runtime,async,construct-independent,wait,V:2.0-2.7\nint test1(){\n    int err = 0;\n    real_t *a = (real_t *)malloc(n * sizeof(real_t));\n    real_t *b = (real_t *)malloc(n * sizeof(real_t));\n    real_t *c = (real_t *)malloc(n * sizeof(real_t));\n    real_t *d = (real_t *)malloc(n * sizeof(real_t));\n    real_t *e = (real_t *)malloc(n * sizeof(real_t));\n    real_t *f = (real_t *)malloc(n * sizeof(real_t));\n    real_t *g = (real_t *)malloc(n * sizeof(real_t));\n    real_t *h = (real_t *)malloc(n * sizeof(real_t));\n    real_t *i = (real_t *)malloc(n * sizeof(real_t));\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n        c[x] = 0;\n        d[x] = rand() / (real_t)(RAND_MAX / 10);\n        e[x] = rand() / (real_t)(RAND_MAX / 10);\n        f[x] = 0;\n        g[x] = rand() / (real_t)(RAND_MAX / 10);\n        h[x] = 0;\n        i[x] = 0;\n    }\n\n    #pragma acc data copyin(a[0:n], b[0:n], d[0:n], e[0:n], g[0:n]) create(c[0:n], f[0:n], h[0:n]) copyout(i[0:n])\n    {\n        #pragma acc parallel async(1)\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                c[x] = a[x] + b[x];\n            }\n        }\n        acc_wait_async(1, 2);\n        #pragma acc parallel async(2)\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                h[x] = c[x] + g[x];\n            }\n        }\n        #pragma acc parallel async(1)\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                f[x] = d[x] + e[x];\n            }\n        }\n        acc_wait_async(1, 2);\n        #pragma acc parallel async(2)\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                i[x] = h[x] + f[x];\n            }\n        }\n        #pragma acc wait(2)\n    }\n\n    for (int x = 0; x < n; ++x){\n        if (fabs(i[x] - (a[x] + b[x] + g[x] + d[x] + e[x])) > PRECISION){\n            err += 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "runtime",
                            "async",
                            "construct-independent",
                            "wait"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_bitand_equals.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:atomic,construct-independent,V:2.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    int  *a = (int *)malloc(n * sizeof(int));\n    int *totals = (int *)malloc((n/10 + 1) * sizeof(int));\n    int *totals_comparison = (int *)malloc((n/10 + 1) * sizeof(int));\n\n    for (int x = 0; x < n; ++x){\n        for (int y = 0; y < 8; ++y){\n            if (rand()/(real_t)(RAND_MAX) < .933){ //.933 gets close to a 50/50 distribution for a collescence of 10 values\n                a[x] += 1<<y;\n            }\n        }\n    }\n    for (int x = 0; x < n/10 + 1; ++x){\n        for (int y = 0; y < 8; ++y){\n            totals[x] +=  1<<y;\n        }\n\n    }\n\n    #pragma acc data copyin(a[0:n]) copy(totals[0:n/10 + 1])\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                #pragma acc atomic\n                    totals[x%(n/10 + 1)] &= a[x];\n            }\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        totals_comparison[x%(n/10 + 1)] &= a[x];\n    }\n    for (int x = 0; x < 10; ++x){\n        if (fabs(totals_comparison[x] - totals[x]) > PRECISION){\n            err += 1;\n            break;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "atomic",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_bitor_equals.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:atomic,construct-independent,V:2.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    int  *a = (int *)malloc(n * sizeof(int));\n    int *totals = (int *)malloc((n/10 + 1) * sizeof(int));\n    int *totals_comparison = (int *)malloc((n/10 + 1) * sizeof(int));\n\n    for (int x = 0; x < n; ++x){\n        for (int y = 0; y < 8; ++y){\n            if (rand()/(real_t)(RAND_MAX) > .933){ //.933 gets close to a 50/50 distribution for a collescence of 10 values\n                a[x] += 1<<y;\n            }\n        }\n    }\n    for (int x = 0; x < n/10 + 1; ++x){\n        totals[x] = 0;\n\n    }\n\n    #pragma acc data copyin(a[0:n]) copy(totals[0:n/10 + 1])\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                #pragma acc atomic\n                    totals[x%(n/10 + 1)] |= a[x];\n            }\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        totals_comparison[x%(n/10 + 1)] |= a[x];\n    }\n    for (int x = 0; x < 10; ++x){\n        if (fabs(totals_comparison[x] - totals[x]) > PRECISION){\n            err += 1;\n            break;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "atomic",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_bitxor_equals.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:atomic,construct-independent,V:2.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    int  *a = (int *)malloc(n * sizeof(int));\n    int *totals = (int *)malloc((n/10 + 1) * sizeof(int));\n    int *totals_comparison = (int *)malloc((n/10 + 1) * sizeof(int));\n\n    for (int x = 0; x < n; ++x){\n        for (int y = 0; y < 8; ++y){\n            if (rand()/(real_t)(RAND_MAX) > .5){\n                a[x] += 1<<y;\n            }\n        }\n    }\n    for (int x = 0; x < n/10 + 1; ++x){\n        totals[x] = 0;\n        totals_comparison[x] = 0;\n    }\n\n    #pragma acc data copyin(a[0:n]) copy(totals[0:n/10 + 1])\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                #pragma acc atomic\n                    totals[x%(n/10 + 1)] ^= a[x];\n            }\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        totals_comparison[x%(n/10 + 1)] ^= a[x];\n    }\n    for (int x = 0; x < 10; ++x){\n        if (fabs(totals_comparison[x] - totals[x]) > PRECISION){\n            err += 1;\n            break;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "atomic",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_capture_assign_expr_and_x.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:construct-independent,atomic,V:2.0-2.7\n      LOGICAL FUNCTION test1()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x, y !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT, 10):: randoms\n        LOGICAL,DIMENSION(LOOPCOUNT, 10):: a, b !Data\n        LOGICAL,DIMENSION(10):: passed_a, passed_b\n        LOGICAL IS_POSSIBLE\n        LOGICAL,DIMENSION(LOOPCOUNT):: totals, totals_comparison\n        INTEGER :: errors = 0\n        LOGICAL :: init\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(randoms)\n        DO x = 1, LOOPCOUNT\n          DO y = 1, 10\n            IF (randoms(x, y) < .933) THEN\n              a(x, y) = .TRUE.\n            ELSE\n              a(x, y) = .FALSE.\n            END IF\n          END DO\n        END DO\n\n        totals = .FALSE.\n        totals_comparison = .FALSE.\n\n        !$acc data copyin(a(1:LOOPCOUNT,1:10)) copy(totals(1:LOOPCOUNT)) copyout(b(1:LOOPCOUNT,1:10))\n          !$acc parallel\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              DO y = 1, 10\n                !$acc atomic capture\n                  b(x, y) = totals(x)\n                  totals(x) = a(x, y) .AND. totals(x)\n                !$acc end atomic\n              END DO\n            END DO\n          !$acc end parallel\n        !$acc end data\n\n        DO x = 1, LOOPCOUNT\n          DO y = 1, 10\n            totals_comparison(x) = totals_comparison(x) .AND. a(x, y)\n          END DO\n        END DO\n\n        DO x = 1, LOOPCOUNT\n          IF (totals_comparison(x) .NEQV. totals(x)) THEN\n            errors = errors + 1\n            WRITE(*, *) totals_comparison(x)\n          END IF\n        END DO\n\n        DO x = 1, LOOPCOUNT\n          DO y = 1, 10\n            passed_a(y) = a(x, y)\n            passed_b(y) = b(x, y)\n          END DO\n          init = .FALSE.\n          IF (.FALSE. .eqv. IS_POSSIBLE(a(x, 1:10), b(x, 1:10), 10, .FALSE.)) THEN\n            errors = errors + 1\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "construct-independent",
                            "atomic"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_capture_assign_expr_divided_x.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:construct-independent,atomic,V:2.0-2.7\n      LOGICAL FUNCTION test1()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x, y !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT, 10):: a !Data\n        REAL(8),DIMENSION(LOOPCOUNT, 10):: b\n        REAL(8),DIMENSION(LOOPCOUNT):: totals\n        REAL(8),DIMENSION(10):: passed\n        REAL(8),DIMENSION(10):: passed_b\n        REAL(8) :: holder\n        INTEGER :: errors = 0\n        LOGICAL IS_POSSIBLE\n        LOGICAL IS_POSSIBLE_2\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(a)\n\n        totals = 1\n\n        !$acc data copyin(a(1:LOOPCOUNT, 1:10)) copy(totals(1:LOOPCOUNT)) copyout(b(1:LOOPCOUNT,1:10))\n          !$acc parallel\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              DO y = 1, 10\n                !$acc atomic capture\n                  b(x, y) = totals(x)\n                  totals(x) = a(x, y) / totals(x)\n                !$acc end atomic\n              END DO\n            END DO\n          !$acc end parallel\n        !$acc end data\n\n        DO x = 1, LOOPCOUNT\n          DO y = 1, 10\n            passed(y) = a(x, y)\n          END DO\n          holder = 1\n          IF (IS_POSSIBLE(passed, totals(x), 10, holder) .eqv. .FALSE.) THEN\n            errors = errors + 1\n          END IF\n        END DO\n\n        DO x = 1, LOOPCOUNT\n          DO y = 1, 10\n            passed(y) = a(x, y)\n            passed_b(y) = b(x, y)\n          END DO\n          holder = 1\n          IF (IS_POSSIBLE_2(passed, passed_b, 10, holder) .eqv. .FALSE.) THEN\n            errors = errors + 1\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "construct-independent",
                            "atomic"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_capture_assign_expr_eqv_x.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:construct-independent,atomic,V:2.0-2.7\n      LOGICAL FUNCTION test1()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x, y !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT, 10):: randoms\n        LOGICAL,DIMENSION(LOOPCOUNT, 10):: a, b !Data\n        LOGICAL,DIMENSION(LOOPCOUNT):: totals, totals_comparison\n        LOGICAL,DIMENSION(10):: passed_a, passed_b\n        LOGICAL:: init\n        INTEGER :: errors = 0\n        LOGICAL IS_POSSIBLE\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(randoms)\n        DO x = 1, LOOPCOUNT\n          DO y = 1, 10\n            IF (randoms(x, y) > .5) THEN\n              a(x, y) = .TRUE.\n            ELSE\n              a(x, y) = .FALSE.\n            END IF\n          END DO\n        END DO\n\n        totals = .FALSE.\n        totals_comparison = .FALSE.\n\n        !$acc data copyin(a(1:LOOPCOUNT,1:10)) copy(totals(1:LOOPCOUNT)) copyout(b(1:LOOPCOUNT,1:10))\n          !$acc parallel\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              DO y = 1, 10\n                !$acc atomic capture\n                  b(x, y) = totals(x)\n                  totals(x) = a(x, y) .EQV. totals(x)\n                !$acc end atomic\n              END DO\n            END DO\n          !$acc end parallel\n        !$acc end data\n\n        DO x = 1, LOOPCOUNT\n          DO y = 1, 10\n            totals_comparison(x) = totals_comparison(x) .EQV. a(x, y)\n          END DO\n        END DO\n\n        DO x = 1, LOOPCOUNT\n          DO y = 1, 10\n            passed_a(y) = a(x, y)\n            passed_b(y) = b(x, y)\n          END DO\n          init = .FALSE.\n          IF (IS_POSSIBLE(passed_a, passed_b, 10, init) .EQV. .FALSE.) THEN\n            errors = errors + 1\n          END IF\n        END DO\n\n        DO x = 1, LOOPCOUNT\n          IF (totals_comparison(x) .NEQV. totals(x)) THEN\n            errors = errors + 1\n            WRITE(*, *) totals_comparison(x)\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "construct-independent",
                            "atomic"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_capture_assign_expr_minus_x.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:construct-independent,atomic,V:2.0-2.7\n      LOGICAL FUNCTION test1()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x, y !Iterators\n        LOGICAL IS_POSSIBLE\n        LOGICAL IS_POSSIBLE_2\n        REAL(8),DIMENSION(LOOPCOUNT, 10):: a, b !Data\n        REAL(8),DIMENSION(LOOPCOUNT):: totals\n        REAL(8),DIMENSION(10):: passed_a, passed_b\n        REAL(8):: init\n        INTEGER :: errors = 0\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(a)\n\n        totals = 0\n\n        !$acc data copyin(a(1:LOOPCOUNT, 1:10)) copy(totals(1:LOOPCOUNT)) copyout(b(1:LOOPCOUNT, 1:10))\n          !$acc parallel\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              DO y = 1, 10\n                !$acc atomic capture\n                  b(x, y) = totals(x)\n                  totals(x) = a(x, y) - totals(x)\n                !$acc end atomic\n              END DO\n            END DO\n          !$acc end parallel\n        !$acc end data\n\n        DO x = 1, LOOPCOUNT\n          DO y = 1, 10\n            passed_a(y) = a(x, y)\n          END DO\n          IF (IS_POSSIBLE(passed_a, totals(x), 10, 0) .eqv. .FALSE.) THEN\n            errors = errors + 1\n          END IF\n        END DO\n\n        DO x = 1, LOOPCOUNT\n          DO y = 1, 10\n            passed_a(y) = a(x, y)\n            passed_b(y) = b(x, y)\n          END DO\n          init = 0\n          IF (IS_POSSIBLE_2(passed_a, passed_b, 10, init) .EQV. .FALSE.) THEN\n            errors = errors + 1\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "construct-independent",
                            "atomic"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_capture_assign_expr_neqv_x.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:construct-independent,atomic,V:2.0-2.7\n      LOGICAL FUNCTION test1()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x, y !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT, 10):: randoms\n        LOGICAL,DIMENSION(LOOPCOUNT, 10):: a, b !Data\n        LOGICAL,DIMENSION(10):: passed_a, passed_b\n        LOGICAL,DIMENSION(LOOPCOUNT):: totals, totals_comparison\n        LOGICAL IS_POSSIBLE\n        INTEGER :: errors = 0\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(randoms)\n        DO x = 1, LOOPCOUNT\n          DO y = 1, 10\n            IF (randoms(x, y) > .5) THEN\n              a(x, y) = .TRUE.\n            ELSE\n              a(x, y) = .FALSE.\n            END IF\n          END DO\n        END DO\n\n        totals = .FALSE.\n        totals_comparison = .FALSE.\n\n        !$acc data copyin(a(1:LOOPCOUNT,1:10)) copy(totals(1:LOOPCOUNT)) copyout(b(1:LOOPCOUNT,1:10))\n          !$acc parallel\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              DO y = 1, 10\n                !$acc atomic capture\n                  b(x, y) = totals(x)\n                  totals(x) = a(x, y) .NEQV. totals(x)\n                !$acc end atomic\n              END DO\n            END DO\n          !$acc end parallel\n        !$acc end data\n\n        DO x = 1, LOOPCOUNT\n          DO y = 1, 10\n            totals_comparison(x) = totals_comparison(x) .NEQV. a(x, y)\n          END DO\n        END DO\n\n        DO x = 1, LOOPCOUNT\n          IF (totals_comparison(x) .NEQV. totals(x)) THEN\n            errors = errors + 1\n            WRITE(*, *) totals_comparison(x)\n          END IF\n        END DO\n\n        DO x = 1, LOOPCOUNT\n          DO y = 1, 10\n            passed_a(y) = a(x, y)\n            passed_b(y) = b(x, y)\n          END DO\n          IF (IS_POSSIBLE(passed_a, passed_b, 10, .FALSE.) .eqv. .FALSE.) THEN\n            errors = errors + 1\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "construct-independent",
                            "atomic"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_capture_assign_expr_or_x.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:construct-independent,atomic,V:2.0-2.7\n      LOGICAL FUNCTION test1()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x, y !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT, 10):: randoms\n        LOGICAL,DIMENSION(LOOPCOUNT, 10):: a, b !Data\n        LOGICAL,DIMENSION(LOOPCOUNT):: totals, totals_comparison\n        LOGICAL,DIMENSION(10):: passed_a, passed_b\n        LOGICAL IS_POSSIBLE\n        LOGICAL:: init\n        INTEGER :: errors = 0\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(randoms)\n        DO x = 1, LOOPCOUNT\n          DO y = 1, 10\n            IF (randoms(x, y) > .933) THEN\n              a(x, y) = .TRUE.\n            ELSE\n              a(x, y) = .FALSE.\n            END IF\n          END DO\n        END DO\n\n        totals = .FALSE.\n        totals_comparison = .FALSE.\n\n        !$acc data copyin(a(1:LOOPCOUNT,1:10)) copy(totals(1:LOOPCOUNT)) copyout(b(1:LOOPCOUNT,1:10))\n          !$acc parallel\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              DO y = 1, 10\n                !$acc atomic capture\n                  b(x, y) = totals(x)\n                  totals(x) = a(x, y) .OR. totals(x)\n                !$acc end atomic\n              END DO\n            END DO\n          !$acc end parallel\n        !$acc end data\n\n        DO x = 1, LOOPCOUNT\n          DO y = 1, 10\n            totals_comparison(x) = totals_comparison(x) .OR. a(x, y)\n          END DO\n        END DO\n\n        DO x = 1, LOOPCOUNT\n          IF (totals_comparison(x) .NEQV. totals(x)) THEN\n            errors = errors + 1\n            WRITE(*, *) totals_comparison(x)\n          END IF\n        END DO\n\n        DO x = 1, LOOPCOUNT\n          DO y = 1, 10\n            passed_a(y) = a(x, y)\n            passed_b(y) = b(x, y)\n          END DO\n          init = .FALSE.\n          IF (IS_POSSIBLE(passed_a, passed_b, 10, init) .eqv. .FALSE.) THEN\n            errors = errors + 1\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "construct-independent",
                            "atomic"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_capture_assign_expr_plus_x.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:construct-independent,atomic,V:2.0-2.7\n      LOGICAL FUNCTION test1()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x, y !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT, 10):: a, b !Data\n        REAL(8),DIMENSION(LOOPCOUNT):: totals, totals_comparison\n        REAL(8),DIMENSION(10):: passed_a, passed_b\n        REAL(8):: init\n        LOGICAL IS_POSSIBLE\n        INTEGER :: errors = 0\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(a)\n\n        totals = 0\n        totals_comparison = 0\n\n        !$acc data copyin(a(1:LOOPCOUNT, 1:10)) copy(totals(1:LOOPCOUNT)) copyout(b(1:LOOPCOUNT,1:10))\n          !$acc parallel\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              DO y = 1, 10\n                !$acc atomic capture\n                  b(x, y) = totals(x)\n                  totals(x) = a(x, y) + totals(x)\n                !$acc end atomic\n              END DO\n            END DO\n          !$acc end parallel\n        !$acc end data\n        DO x = 1, LOOPCOUNT\n          DO y = 1, 10\n            totals_comparison(x) = totals_comparison(x) + a(x, y)\n          END DO\n        END DO\n\n        DO x = 1, LOOPCOUNT\n          IF (totals_comparison(x) .NE. totals(x)) THEN\n            errors = errors + 1\n            WRITE(*, *) totals_comparison(x)\n          END IF\n        END DO\n\n        DO x = 1, LOOPCOUNT\n          DO y = 1, 10\n            passed_a(y) = a(x, y)\n            passed_b(y) = b(x, y)\n          END DO\n          init = 0\n          IF (IS_POSSIBLE(passed_a, passed_b, 10, init) .eqv. .FALSE.) THEN\n            errors = errors + 1\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "construct-independent",
                            "atomic"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_capture_assign_expr_times_x.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:construct-independent,atomic,V:2.0-2.7\n      LOGICAL FUNCTION test1()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x, y !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT, 10):: a, b !Data\n        REAL(8),DIMENSION(LOOPCOUNT):: totals, totals_comparison\n        REAL(8),DIMENSION(10):: passed_a, passed_b\n        REAL(8):: init\n        LOGICAL IS_POSSIBLE\n        INTEGER :: errors = 0\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(a)\n\n        totals = 1\n        totals_comparison = 1\n\n        !$acc data copyin(a(1:LOOPCOUNT, 1:10)) copy(totals(1:LOOPCOUNT)) copyout(b(1:LOOPCOUNT,1:10))\n          !$acc parallel\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              DO y = 1, 10\n                !$acc atomic capture\n                  b(x, y) = totals(x)\n                  totals(x) = a(x, y) * totals(x)\n                !$acc end atomic\n              END DO\n            END DO\n          !$acc end parallel\n        !$acc end data\n        DO x = 1, LOOPCOUNT\n          DO y = 1, 10\n            totals_comparison(x) = totals_comparison(x) * a(x, y)\n          END DO\n        END DO\n\n        DO x = 1, LOOPCOUNT\n          IF (totals_comparison(x) .NE. totals(x)) THEN\n            errors = errors + 1\n            WRITE(*, *) totals_comparison(x)\n          END IF\n        END DO\n\n        DO x = 1, LOOPCOUNT\n          DO y = 1, 10\n            passed_a(y) = a(x, y)\n            passed_b(y) = b(x, y)\n          END DO\n          init = 1\n          IF (IS_POSSIBLE(passed_a, passed_b, 10, init) .eqv. .TRUE.) THEN\n            errors = errors + 1\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "construct-independent",
                            "atomic"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_capture_assign_iand_expr_x.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:construct-independent,atomic,V:2.0-2.7\n      LOGICAL FUNCTION test1()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x, y, z !Iterators\n        INTEGER,DIMENSION(LOOPCOUNT, 10):: a, b !Data\n        REAL(8),DIMENSION(LOOPCOUNT, 10, 8):: randoms\n        INTEGER,DIMENSION(LOOPCOUNT):: totals, totals_comparison\n        INTEGER,DIMENSION(10):: passed_a, passed_b\n        INTEGER:: init\n        LOGICAL IS_POSSIBLE\n        INTEGER :: errors = 0\n\n        CALL RANDOM_NUMBER(randoms)\n        a = 0\n        DO x = 1, LOOPCOUNT\n          DO y = 1, 10\n            DO z = 1, 8\n              IF (randoms(x, y, z) .lt. .933) THEN\n                a(x, y) = a(x, y) + ISHFT(1, z - 1)\n              END IF\n            END DO\n          END DO\n        END DO\n        totals = 0\n        totals_comparison = 0\n        DO x = 1, LOOPCOUNT\n          DO y = 0, 7\n            totals(x) = totals(x) + ISHFT(1, y)\n            totals_comparison(x) = totals_comparison(x) + ISHFT(1, y)\n          END DO\n        END DO\n\n        !$acc data copyin(a(1:LOOPCOUNT, 1:10)) copy(totals(1:LOOPCOUNT)) copyout(b(1:LOOPCOUNT, 1:10))\n          !$acc parallel\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              DO y = 1, 10\n                !$acc atomic capture\n                  b(x, y) = totals(x)\n                  totals(x) = iand(a(x, y), totals(x))\n                !$acc end atomic\n              END DO\n            END DO\n          !$acc end parallel\n        !$acc end data\n        DO x = 1, LOOPCOUNT\n          DO y = 1, 10\n            totals_comparison(x) = iand(totals_comparison(x), a(x, y))\n          END DO\n        END DO\n        DO x = 1, LOOPCOUNT\n          IF (totals_comparison(x) .NE. totals(x)) THEN\n            errors = errors + 1\n            WRITE(*, *) totals_comparison(x)\n          END IF\n        END DO\n\n        DO x = 1, LOOPCOUNT\n          DO y = 1, 10\n            passed_a(y) = a(x, y)\n            passed_b(y) = b(x, y)\n          END DO\n          init = 0\n          DO y = 0, 7\n            init = init + ISHFT(1, y)\n          END DO\n          IF (IS_POSSIBLE(passed_a, passed_b, 10, init) .eqv. .FALSE.) THEN\n            errors = errors + 1\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "construct-independent",
                            "atomic"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_capture_assign_iand_x_expr.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:construct-independent,atomic,V:2.0-2.7\n      LOGICAL FUNCTION test1()\n  IMPLICIT NONE\n  INCLUDE \"acc_testsuite.Fh\"\n  INTEGER :: x, y, z !Iterators\n  INTEGER,DIMENSION(LOOPCOUNT, 10):: a, b !Data\n  REAL(8),DIMENSION(LOOPCOUNT, 10, 8):: randoms\n  INTEGER,DIMENSION(LOOPCOUNT):: totals, totals_comparison\n  INTEGER,DIMENSION(10):: passed_a, passed_b\n  INTEGER:: init\n  LOGICAL IS_POSSIBLE\n  INTEGER :: errors = 0\n\n  !Initilization\n  SEEDDIM(1) = 1\n# ifdef SEED\n  SEEDDIM(1) = SEED\n# endif\n  CALL RANDOM_SEED(PUT=SEEDDIM)\n\n  CALL RANDOM_NUMBER(randoms)\n  a = 0\n  DO x = 1, LOOPCOUNT\n    DO y = 1, 10\n      DO z = 1, 8\n        IF (randoms(x, y, z) .lt. .933) THEN\n          a(x, y) = a(x, y) + ISHFT(1, z - 1)\n        END IF\n      END DO\n    END DO\n  END DO\n  totals = 0\n  totals_comparison = 0\n  DO x = 1, LOOPCOUNT\n    DO y = 0, 7\n      totals(x) = totals(x) + ISHFT(1, y)\n      totals_comparison(x) = totals_comparison(x) + ISHFT(1, y)\n    END DO\n  END DO\n\n  !$acc data copyin(a(1:LOOPCOUNT, 1:10)) copy(totals(1:LOOPCOUNT)) copyout(b(1:LOOPCOUNT, 1:10))\n    !$acc parallel\n      !$acc loop\n      DO x = 1, LOOPCOUNT\n        DO y = 1, 10\n          !$acc atomic capture\n            b(x, y) = totals(x)\n            totals(x) = iand(totals(x), a(x, y))\n          !$acc end atomic\n        END DO\n      END DO\n    !$acc end parallel\n  !$acc end data\n  DO x = 1, LOOPCOUNT\n    DO y = 1, 10\n      totals_comparison(x) = iand(totals_comparison(x), a(x, y))\n    END DO\n  END DO\n  DO x = 1, LOOPCOUNT\n    IF (totals_comparison(x) .NE. totals(x)) THEN\n      errors = errors + 1\n      WRITE(*, *) totals_comparison(x)\n    END IF\n  END DO\n\n  DO x = 1, LOOPCOUNT\n    DO y = 1, 10\n      passed_a(y) = a(x, y)\n      passed_b(y) = b(x, y)\n    END DO\n    init = 0\n    DO y = 0, 7\n      init = init + ISHFT(1, y)\n    END DO\n    IF (IS_POSSIBLE(passed_a, passed_b, 10, init) .eqv. .FALSE.) THEN\n      errors = errors + 1\n    END IF\n  END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "construct-independent",
                            "atomic"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_capture_assign_ior_expr_x.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:construct-independent,atomic,V:2.0-2.7\n      LOGICAL FUNCTION test1()\n  IMPLICIT NONE\n  INCLUDE \"acc_testsuite.Fh\"\n  INTEGER :: x, y, z !Iterators\n  INTEGER,DIMENSION(LOOPCOUNT, 10):: a, b !Data\n  REAL(8),DIMENSION(LOOPCOUNT, 10, 8):: randoms\n  INTEGER,DIMENSION(LOOPCOUNT):: totals, totals_comparison\n  INTEGER,DIMENSION(10):: passed_a, passed_b\n  INTEGER:: init\n  LOGICAL IS_POSSIBLE\n  INTEGER :: errors = 0\n\n  !Initilization\n  SEEDDIM(1) = 1\n# ifdef SEED\n  SEEDDIM(1) = SEED\n# endif\n  CALL RANDOM_SEED(PUT=SEEDDIM)\n\n  CALL RANDOM_NUMBER(randoms)\n  a = 0\n  DO x = 1, LOOPCOUNT\n    DO y = 1, 10\n      DO z = 1, 8\n        IF (randoms(x, y, z) .gt. .933) THEN\n          a(x, y) = a(x, y) + ISHFT(1, z - 1)\n        END IF\n      END DO\n    END DO\n  END DO\n  totals = 0\n  totals_comparison = 0\n\n  !$acc data copyin(a(1:LOOPCOUNT, 1:10)) copy(totals(1:LOOPCOUNT)) copyout(b(1:LOOPCOUNT, 1:10))\n    !$acc parallel\n      !$acc loop\n      DO x = 1, LOOPCOUNT\n        DO y = 1, 10\n          !$acc atomic capture\n            b(x, y) = totals(x)\n            totals(x) = ior(a(x, y), totals(x))\n          !$acc end atomic\n        END DO\n      END DO\n    !$acc end parallel\n  !$acc end data\n  DO x = 1, LOOPCOUNT\n    DO y = 1, 10\n      totals_comparison(x) = ior(totals_comparison(x), a(x, y))\n    END DO\n  END DO\n  DO x = 1, LOOPCOUNT\n    IF (totals_comparison(x) .NE. totals(x)) THEN\n      errors = errors + 1\n      WRITE(*, *) totals_comparison(x)\n    END IF\n  END DO\n\n  DO x = 1, LOOPCOUNT\n    DO y = 1, 10\n      passed_a(y) = a(x, y)\n      passed_b(y) = b(x, y)\n    END DO\n    init = 0\n    IF (IS_POSSIBLE(passed_a, passed_b, 10, init) .eqv. .FALSE.) THEN\n      errors = errors + 1\n    END IF\n  END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "construct-independent",
                            "atomic"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_capture_assign_ior_x_expr.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:construct-independent,atomic,V:2.0-2.7\n      LOGICAL FUNCTION test1()\n  IMPLICIT NONE\n  INCLUDE \"acc_testsuite.Fh\"\n  INTEGER :: x, y, z !Iterators\n  INTEGER,DIMENSION(LOOPCOUNT, 10):: a, b !Data\n  REAL(8),DIMENSION(LOOPCOUNT, 10, 8):: randoms\n  INTEGER,DIMENSION(LOOPCOUNT):: totals, totals_comparison\n  INTEGER,DIMENSION(10):: passed_a, passed_b\n  INTEGER:: init\n  LOGICAL IS_POSSIBLE\n  INTEGER :: errors = 0\n\n  !Initilization\n  SEEDDIM(1) = 1\n# ifdef SEED\n  SEEDDIM(1) = SEED\n# endif\n  CALL RANDOM_SEED(PUT=SEEDDIM)\n\n  CALL RANDOM_NUMBER(randoms)\n  a = 0\n  DO x = 1, LOOPCOUNT\n    DO y = 1, 10\n      DO z = 1, 8\n        IF (randoms(x, y, z) .gt. .933) THEN\n          a(x, y) = a(x, y) + ISHFT(1, z - 1)\n        END IF\n      END DO\n    END DO\n  END DO\n  totals = 0\n  totals_comparison = 0\n\n  !$acc data copyin(a(1:LOOPCOUNT, 1:10)) copy(totals(1:LOOPCOUNT)) copyout(b(1:LOOPCOUNT, 1:10))\n    !$acc parallel\n      !$acc loop\n      DO x = 1, LOOPCOUNT\n        DO y = 1, 10\n          !$acc atomic capture\n            b(x, y) = totals(x)\n            totals(x) = ior(totals(x), a(x, y))\n          !$acc end atomic\n        END DO\n      END DO\n    !$acc end parallel\n  !$acc end data\n  DO x = 1, LOOPCOUNT\n    DO y = 1, 10\n      totals_comparison(x) = ior(totals_comparison(x), a(x, y))\n    END DO\n  END DO\n  DO x = 1, LOOPCOUNT\n    IF (totals_comparison(x) .NE. totals(x)) THEN\n      errors = errors + 1\n      WRITE(*, *) totals_comparison(x)\n    END IF\n  END DO\n\n  DO x = 1, LOOPCOUNT\n    DO y = 1, 10\n      passed_a(y) = a(x, y)\n      passed_b(y) = b(x, y)\n    END DO\n    init = 0\n    IF (IS_POSSIBLE(passed_a, passed_b, 10, init) .eqv. .FALSE.) THEN\n      errors = errors + 1\n    END IF\n  END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "construct-independent",
                            "atomic"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_capture_assign_ixor_expr_x.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:construct-independent,atomic,V:2.0-2.7\n      LOGICAL FUNCTION test1()\n  IMPLICIT NONE\n  INCLUDE \"acc_testsuite.Fh\"\n  INTEGER :: x, y, z !Iterators\n  INTEGER,DIMENSION(LOOPCOUNT, 10):: a, b !Data\n  REAL(8),DIMENSION(LOOPCOUNT, 10, 8):: randoms\n  INTEGER,DIMENSION(LOOPCOUNT):: totals, totals_comparison\n  INTEGER,DIMENSION(10):: passed_a, passed_b\n  INTEGER:: init\n  LOGICAL IS_POSSIBLE\n  INTEGER :: errors = 0\n\n  !Initilization\n  SEEDDIM(1) = 1\n# ifdef SEED\n  SEEDDIM(1) = SEED\n# endif\n  CALL RANDOM_SEED(PUT=SEEDDIM)\n\n  CALL RANDOM_NUMBER(randoms)\n  a = 0\n  DO x = 1, LOOPCOUNT\n    DO y = 1, 10\n      DO z = 1, 8\n        IF (randoms(x, y, z) .gt. .5) THEN\n          a(x, y) = a(x, y) + ISHFT(1, z - 1)\n        END IF\n      END DO\n    END DO\n  END DO\n  totals = 0\n  totals_comparison = 0\n\n  !$acc data copyin(a(1:LOOPCOUNT, 1:10)) copy(totals(1:LOOPCOUNT)) copyout(b(1:LOOPCOUNT, 1:10))\n    !$acc parallel\n      !$acc loop\n      DO x = 1, LOOPCOUNT\n        DO y = 1, 10\n          !$acc atomic capture\n            b(x, y) = totals(x)\n            totals(x) = ieor(a(x, y), totals(x))\n          !$acc end atomic\n        END DO\n      END DO\n    !$acc end parallel\n  !$acc end data\n  DO x = 1, LOOPCOUNT\n    DO y = 1, 10\n      totals_comparison(x) = ieor(totals_comparison(x), a(x, y))\n    END DO\n  END DO\n  DO x = 1, LOOPCOUNT\n    IF (totals_comparison(x) .NE. totals(x)) THEN\n      errors = errors + 1\n      WRITE(*, *) totals_comparison(x)\n    END IF\n  END DO\n\n  DO x = 1, LOOPCOUNT\n    DO y = 1, 10\n      passed_a(y) = a(x, y)\n      passed_b(y) = b(x, y)\n    END DO\n    init = 0\n    IF (IS_POSSIBLE(passed_a, passed_b, 10, init) .eqv. .FALSE.) THEN\n      errors = errors + 1\n    END IF\n  END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "construct-independent",
                            "atomic"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_capture_assign_ixor_x_expr.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:construct-independent,atomic,V:2.0-2.7\nLOGICAL FUNCTION test1()\n  IMPLICIT NONE\n  INCLUDE \"acc_testsuite.Fh\"\n  INTEGER :: x, y, z !Iterators\n  INTEGER,DIMENSION(LOOPCOUNT, 10):: a, b !Data\n  REAL(8),DIMENSION(LOOPCOUNT, 10, 8):: randoms\n  INTEGER,DIMENSION(LOOPCOUNT):: totals, totals_comparison\n  INTEGER,DIMENSION(10):: passed_a, passed_b\n  INTEGER:: init\n  LOGICAL IS_POSSIBLE\n  INTEGER :: errors = 0\n\n  !Initilization\n  SEEDDIM(1) = 1\n# ifdef SEED\n  SEEDDIM(1) = SEED\n# endif\n  CALL RANDOM_SEED(PUT=SEEDDIM)\n\n  CALL RANDOM_NUMBER(randoms)\n  a = 0\n  DO x = 1, LOOPCOUNT\n    DO y = 1, 10\n      DO z = 1, 8\n        IF (randoms(x, y, z) .gt. .5) THEN\n          a(x, y) = a(x, y) + ISHFT(1, z - 1)\n        END IF\n      END DO\n    END DO\n  END DO\n  totals = 0\n  totals_comparison = 0\n\n  !$acc data copyin(a(1:LOOPCOUNT, 1:10)) copy(totals(1:LOOPCOUNT)) copyout(b(1:LOOPCOUNT, 1:10))\n    !$acc parallel\n      !$acc loop\n      DO x = 1, LOOPCOUNT\n        DO y = 1, 10\n          !$acc atomic capture\n            b(x, y) = totals(x)\n            totals(x) = ieor(totals(x), a(x, y))\n          !$acc end atomic\n        END DO\n      END DO\n    !$acc end parallel\n  !$acc end data\n  DO x = 1, LOOPCOUNT\n    DO y = 1, 10\n      totals_comparison(x) = ieor(totals_comparison(x), a(x, y))\n    END DO\n  END DO\n  DO x = 1, LOOPCOUNT\n    IF (totals_comparison(x) .NE. totals(x)) THEN\n      errors = errors + 1\n      WRITE(*, *) totals_comparison(x)\n    END IF\n  END DO\n\n  DO x = 1, LOOPCOUNT\n    DO y = 1, 10\n      passed_a(y) = a(x, y)\n      passed_b(y) = b(x, y)\n    END DO\n    init = 0\n    IF (IS_POSSIBLE(passed_a, passed_b, 10, init) .eqv. .FALSE.) THEN\n      errors = errors + 1\n    END IF\n  END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "construct-independent",
                            "atomic"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_capture_assign_max_expr_list_x.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:construct-independent,atomic,V:2.0-2.7\n      LOGICAL FUNCTION test1()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x, y !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT, 10):: a, b, c !Data\n        REAL(8),DIMENSION(LOOPCOUNT):: totals, totals_comparison\n        REAL(8),DIMENSION(10):: passed_a, passed_b, passed_c\n        REAL(8):: init\n        LOGICAL IS_POSSIBLE\n        INTEGER :: errors = 0\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n        CALL RANDOM_NUMBER(a)\n        CALL RANDOM_NUMBER(b)\n\n        totals = 0\n        totals_comparison = 0\n\n        !$acc data copyin(a(1:LOOPCOUNT, 1:10), b(1:LOOPCOUNT, 1:10)) copy(totals(1:LOOPCOUNT)) copyout(c(1:LOOPCOUNT, 1:10))\n          !$acc parallel\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              DO y = 1, 10\n                !$acc atomic capture\n                  c(x, y) = totals(x)\n                  totals(x) = max(a(x, y), b(x, y), totals(x))\n                !$acc end atomic\n              END DO\n            END DO\n          !$acc end parallel\n        !$acc end data\n        DO x = 1, LOOPCOUNT\n          DO y = 1, 10\n            totals_comparison(x) = max(totals_comparison(x), a(x, y), b(x, y))\n          END DO\n        END DO\n        DO x = 1, LOOPCOUNT\n          IF (totals_comparison(x) .NE. totals(x)) THEN\n            errors = errors + 1\n            WRITE(*, *) totals_comparison(x)\n          END IF\n        END DO\n\n        DO x = 1, LOOPCOUNT\n          DO y = 1, 10\n            passed_a(y) = a(x, y)\n            passed_b(y) = b(x, y)\n            passed_c(y) = c(x, y)\n          END DO\n          init = 0\n          IF (IS_POSSIBLE(passed_a, passed_b, passed_c, 10, init) .eqv. .FALSE.) THEN\n            errors = errors + 1\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n      LOGICAL :: test1\n#endif\n#ifndef T1\n      DO testrun = 1, NUM_TEST_CALLS\n        failed = failed .or. test1()\n      END DO\n      IF (failed) THEN\n        failcode = failcode + 2 ** 0\n        failed = .FALSE.\n      END IF\n#endif\n",
                        "tags": [
                            "construct-independent",
                            "atomic"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_capture_assign_max_expr_x.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:construct-independent,atomic,V:2.0-2.7\n      LOGICAL FUNCTION test1()\n  IMPLICIT NONE\n  INCLUDE \"acc_testsuite.Fh\"\n  INTEGER :: x, y !Iterators\n  REAL(8),DIMENSION(LOOPCOUNT, 10):: a, b !Data\n  REAL(8),DIMENSION(LOOPCOUNT):: totals, totals_comparison\n  REAL(8),DIMENSION(10):: passed_a, passed_b\n  REAL(8):: init\n  LOGICAL IS_POSSIBLE\n  INTEGER :: errors = 0\n\n  !Initilization\n  SEEDDIM(1) = 1\n# ifdef SEED\n  SEEDDIM(1) = SEED\n# endif\n  CALL RANDOM_SEED(PUT=SEEDDIM)\n\n  CALL RANDOM_NUMBER(a)\n\n  totals = 0\n  totals_comparison = 0\n\n  !$acc data copyin(a(1:LOOPCOUNT, 1:10)) copy(totals(1:LOOPCOUNT)) copyout(b(1:LOOPCOUNT, 1:10))\n    !$acc parallel\n      !$acc loop\n      DO x = 1, LOOPCOUNT\n        DO y = 1, 10\n          !$acc atomic capture\n            b(x, y) = totals(x)\n            totals(x) = max(a(x, y), totals(x))\n          !$acc end atomic\n        END DO\n      END DO\n    !$acc end parallel\n  !$acc end data\n  DO x = 1, LOOPCOUNT\n    DO y = 1, 10\n      totals_comparison(x) = max(totals_comparison(x), a(x, y))\n    END DO\n  END DO\n  DO x = 1, LOOPCOUNT\n    IF (totals_comparison(x) .NE. totals(x)) THEN\n      errors = errors + 1\n      WRITE(*, *) totals_comparison(x)\n    END IF\n  END DO\n\n  DO x = 1, LOOPCOUNT\n    DO y = 1, 10\n      passed_a(y) = a(x, y)\n      passed_b(y) = b(x, y)\n    END DO\n    init = 0\n    IF (IS_POSSIBLE(passed_a, passed_b, 10, init) .eqv. .FALSE.) THEN\n      errors = errors + 1\n    END IF\n  END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "construct-independent",
                            "atomic"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_capture_assign_max_x_expr.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:construct-independent,atomic,V:2.0-2.7\n      LOGICAL FUNCTION test1()\n  IMPLICIT NONE\n  INCLUDE \"acc_testsuite.Fh\"\n  INTEGER :: x, y !Iterators\n  REAL(8),DIMENSION(LOOPCOUNT, 10):: a, b !Data\n  REAL(8),DIMENSION(LOOPCOUNT):: totals, totals_comparison\n  REAL(8),DIMENSION(10):: passed_a, passed_b\n  REAL(8):: init\n  LOGICAL IS_POSSIBLE\n  INTEGER :: errors = 0\n\n  !Initilization\n  SEEDDIM(1) = 1\n# ifdef SEED\n  SEEDDIM(1) = SEED\n# endif\n  CALL RANDOM_SEED(PUT=SEEDDIM)\n\n  CALL RANDOM_NUMBER(a)\n\n  totals = 0\n  totals_comparison = 0\n\n  !$acc data copyin(a(1:LOOPCOUNT, 1:10)) copy(totals(1:LOOPCOUNT)) copyout(b(1:LOOPCOUNT, 1:10))\n    !$acc parallel\n      !$acc loop\n      DO x = 1, LOOPCOUNT\n        DO y = 1, 10\n          !$acc atomic capture\n            b(x, y) = totals(x)\n            totals(x) = max(totals(x), a(x, y))\n          !$acc end atomic\n        END DO\n      END DO\n    !$acc end parallel\n  !$acc end data\n  DO x = 1, LOOPCOUNT\n    DO y = 1, 10\n      totals_comparison(x) = max(totals_comparison(x), a(x, y))\n    END DO\n  END DO\n  DO x = 1, LOOPCOUNT\n    IF (totals_comparison(x) .NE. totals(x)) THEN\n      errors = errors + 1\n      WRITE(*, *) totals_comparison(x)\n    END IF\n  END DO\n\n  DO x = 1, LOOPCOUNT\n    DO y = 1, 10\n      passed_a(y) = a(x, y)\n      passed_b(y) = b(x, y)\n    END DO\n    init = 0\n    IF (IS_POSSIBLE(passed_a, passed_b, 10, init) .eqv. .FALSE.) THEN\n      errors = errors + 1\n    END IF\n  END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "construct-independent",
                            "atomic"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_capture_assign_max_x_expr_list.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:construct-independent,atomic,V:2.0-2.7\n      LOGICAL FUNCTION test1()\nIMPLICIT NONE\nINCLUDE \"acc_testsuite.Fh\"\nINTEGER :: x, y !Iterators\nREAL(8),DIMENSION(LOOPCOUNT, 10):: a, b, c !Data\nREAL(8),DIMENSION(LOOPCOUNT):: totals, totals_comparison\nREAL(8),DIMENSION(10):: passed_a, passed_b, passed_c\nREAL(8):: init\nLOGICAL IS_POSSIBLE\nINTEGER :: errors = 0\n\n!Initilization\nSEEDDIM(1) = 1\n#ifdef SEED\nSEEDDIM(1) = SEED\n#endif\n",
                        "tags": [
                            "construct-independent",
                            "atomic"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_capture_assign_min_expr_list_x.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:construct-independent,atomic,V:2.0-2.7\n      LOGICAL FUNCTION test1()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x, y !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT, 10):: a, b, c !Data\n        REAL(8),DIMENSION(LOOPCOUNT):: totals, totals_comparison\n        REAL(8),DIMENSION(10):: passed_a, passed_b, passed_c\n        REAL(8):: init\n        LOGICAL IS_POSSIBLE\n        INTEGER :: errors = 0\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(a)\n        CALL RANDOM_NUMBER(b)\n\n        totals = 0\n        totals_comparison = 0\n\n        !$acc data copyin(a(1:LOOPCOUNT, 1:10), b(1:LOOPCOUNT, 1:10)) copy(totals(1:LOOPCOUNT)) copyout(c(1:LOOPCOUNT, 1:10))\n          !$acc parallel\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              DO y = 1, 10\n                !$acc atomic capture\n                  c(x, y) = totals(x)\n                  totals(x) = min(a(x, y), b(x, y), totals(x))\n                !$acc end atomic\n              END DO\n            END DO\n          !$acc end parallel\n        !$acc end data\n        DO x = 1, LOOPCOUNT\n          DO y = 1, 10\n            totals_comparison(x) = min(totals_comparison(x), a(x, y), b(x, y))\n          END DO\n        END DO\n        DO x = 1, LOOPCOUNT\n          IF (totals_comparison(x) .NE. totals(x)) THEN\n            errors = errors + 1\n            WRITE(*, *) totals_comparison(x)\n          END IF\n        END DO\n\n        DO x = 1, LOOPCOUNT\n          DO y = 1, 10\n            passed_a(y) = a(x, y)\n            passed_b(y) = b(x, y)\n            passed_c(y) = c(x, y)\n          END DO\n          init = 0\n          IF (IS_POSSIBLE(passed_a, passed_b, passed_c, 10, init) .eqv. .FALSE.) THEN\n            errors = errors + 1\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "construct-independent",
                            "atomic"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_capture_assign_min_expr_x.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:construct-independent,atomic,V:2.0-2.7\n      LOGICAL FUNCTION test1()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x, y !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT, 10):: a, b !Data\n        REAL(8),DIMENSION(LOOPCOUNT):: totals, totals_comparison\n        REAL(8),DIMENSION(10):: passed_a, passed_b\n        REAL(8):: init\n        LOGICAL IS_POSSIBLE\n        INTEGER :: errors = 0\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(a)\n\n        totals = 0\n        totals_comparison = 0\n\n        !$acc data copyin(a(1:LOOPCOUNT, 1:10)) copy(totals(1:LOOPCOUNT)) copyout(b(1:LOOPCOUNT, 1:10))\n          !$acc parallel\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              DO y = 1, 10\n                !$acc atomic capture\n                  b(x, y) = totals(x)\n                  totals(x) = min(a(x, y), totals(x))\n                !$acc end atomic\n              END DO\n            END DO\n          !$acc end parallel\n        !$acc end data\n        DO x = 1, LOOPCOUNT\n          DO y = 1, 10\n            totals_comparison(x) = min(totals_comparison(x), a(x, y))\n          END DO\n        END DO\n        DO x = 1, LOOPCOUNT\n          IF (totals_comparison(x) .NE. totals(x)) THEN\n            errors = errors + 1\n            WRITE(*, *) totals_comparison(x)\n          END IF\n        END DO\n\n        DO x = 1, LOOPCOUNT\n          DO y = 1, 10\n            passed_a(y) = a(x, y)\n            passed_b(y) = b(x, y)\n          END DO\n          init = 0\n          IF (IS_POSSIBLE(passed_a, passed_b, 10, init) .eqv. .FALSE.) THEN\n            errors = errors + 1\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "construct-independent",
                            "atomic"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_capture_assign_min_x_expr.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:construct-independent,atomic,V:2.0-2.7\n      LOGICAL FUNCTION test1()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x, y !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT, 10):: a, b !Data\n        REAL(8),DIMENSION(LOOPCOUNT):: totals, totals_comparison\n        REAL(8),DIMENSION(10):: passed_a, passed_b\n        REAL(8):: init\n        LOGICAL IS_POSSIBLE\n        INTEGER :: errors = 0\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(a)\n\n        totals = 0\n        totals_comparison = 0\n\n        !$acc data copyin(a(1:LOOPCOUNT, 1:10)) copy(totals(1:LOOPCOUNT)) copyout(b(1:LOOPCOUNT, 1:10))\n          !$acc parallel\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              DO y = 1, 10\n                !$acc atomic capture\n                  b(x, y) = totals(x)\n                  totals(x) = min(totals(x), a(x, y))\n                !$acc end atomic\n              END DO\n            END DO\n          !$acc end parallel\n        !$acc end data\n        DO x = 1, LOOPCOUNT\n          DO y = 1, 10\n            totals_comparison(x) = min(totals_comparison(x), a(x, y))\n          END DO\n        END DO\n        DO x = 1, LOOPCOUNT\n          IF (totals_comparison(x) .NE. totals(x)) THEN\n            errors = errors + 1\n            WRITE(*, *) totals_comparison(x)\n          END IF\n        END DO\n\n        DO x = 1, LOOPCOUNT\n          DO y = 1, 10\n            passed_a(y) = a(x, y)\n            passed_b(y) = b(x, y)\n          END DO\n          init = 0\n          IF (IS_POSSIBLE(passed_a, passed_b, 10, init) .eqv. .FALSE.) THEN\n            errors = errors + 1\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "construct-independent",
                            "atomic"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_capture_assign_min_x_expr_list.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:construct-independent,atomic,V:2.0-2.7\n      LOGICAL FUNCTION test1()\n      IMPLICIT NONE\n      INCLUDE \"acc_testsuite.Fh\"\n      INTEGER :: x, y !Iterators\n      REAL(8),DIMENSION(LOOPCOUNT, 10):: a, b, c !Data\n      REAL(8),DIMENSION(LOOPCOUNT):: totals, totals_comparison\n      REAL(8),DIMENSION(10):: passed_a, passed_b, passed_c\n      REAL(8):: init\n      LOGICAL IS_POSSIBLE\n      INTEGER :: errors = 0\n\n      !Initilization\n      SEEDDIM(1) = 1\n#     ifdef SEED\n      SEEDDIM(1) = SEED\n#     endif\n      CALL RANDOM_SEED(PUT=SEEDDIM)\n\n      CALL RANDOM_NUMBER(a)\n      CALL RANDOM_NUMBER(b)\n\n      totals = 1\n      totals_comparison = 1\n\n      !$acc data copyin(a(1:LOOPCOUNT, 1:10), b(1:LOOPCOUNT, 1:10)) copy(totals(1:LOOPCOUNT)) copyout(c(1:LOOPCOUNT, 1:10))\n        !$acc parallel\n          !$acc loop\n          DO x = 1, LOOPCOUNT\n            DO y = 1, 10\n              !$acc atomic capture\n                c(x, y) = totals(x)\n                totals(x) = min(totals(x), a(x, y), b(x, y))\n              !$acc end atomic\n            END DO\n          END DO\n        !$acc end parallel\n      !$acc end data\n      DO x = 1, LOOPCOUNT\n        DO y = 1, 10\n          totals_comparison(x) = min(totals_comparison(x), a(x, y), b(x, y))\n        END DO\n      END DO\n      DO x = 1, LOOPCOUNT\n        IF (totals_comparison(x) .NE. totals(x)) THEN\n          errors = errors + 1\n          WRITE(*, *) totals_comparison(x)\n        END IF\n      END DO\n\n      DO x = 1, LOOPCOUNT\n        DO y = 1, 10\n          passed_a(y) = a(x, y)\n          passed_b(y) = b(x, y)\n          passed_c(y) = c(x, y)\n        END DO\n        init = 1\n        IF (IS_POSSIBLE(passed_a, passed_b, passed_c, 10, init) .eqv. .FALSE.) THEN\n          errors = errors + 1\n        END IF\n      END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "construct-independent",
                            "atomic"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_capture_assign_x_and_expr.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:construct-independent,atomic,V:2.0-2.7\nLOGICAL FUNCTION test1()\n  IMPLICIT NONE\n  INCLUDE \"acc_testsuite.Fh\"\n  INTEGER :: x, y !Iterators\n  REAL(8),DIMENSION(LOOPCOUNT, 10):: randoms\n  LOGICAL,DIMENSION(LOOPCOUNT, 10):: a, b !Data\n  LOGICAL,DIMENSION(10):: passed_a, passed_b\n  LOGICAL IS_POSSIBLE\n  LOGICAL,DIMENSION(LOOPCOUNT):: totals, totals_comparison\n  INTEGER :: errors = 0\n  LOGICAL :: init\n\n  !Initilization\n  SEEDDIM(1) = 1\n# ifdef SEED\n  SEEDDIM(1) = SEED\n# endif\n  CALL RANDOM_SEED(PUT=SEEDDIM)\n\n  CALL RANDOM_NUMBER(randoms)\n  DO x = 1, LOOPCOUNT\n    DO y = 1, 10\n      IF (randoms(x, y) < .933) THEN\n        a(x, y) = .TRUE.\n      ELSE\n        a(x, y) = .FALSE.\n      END IF\n    END DO\n  END DO\n\n  totals = .FALSE.\n  totals_comparison = .FALSE.\n\n  !$acc data copyin(a(1:LOOPCOUNT,1:10)) copy(totals(1:LOOPCOUNT)) copyout(b(1:LOOPCOUNT,1:10))\n    !$acc parallel\n      !$acc loop\n      DO x = 1, LOOPCOUNT\n        DO y = 1, 10\n          !$acc atomic capture\n            b(x, y) = totals(x)\n            totals(x) = totals(x) .AND. a(x, y)\n          !$acc end atomic\n        END DO\n      END DO\n    !$acc end parallel\n  !$acc end data\n\n  DO x = 1, LOOPCOUNT\n    DO y = 1, 10\n      totals_comparison(x) = totals_comparison(x) .AND. a(x, y)\n    END DO\n  END DO\n\n  DO x = 1, LOOPCOUNT\n    IF (totals_comparison(x) .NEQV. totals(x)) THEN\n      errors = errors + 1\n      WRITE(*, *) totals_comparison(x)\n    END IF\n  END DO\n\n  DO x = 1, LOOPCOUNT\n    DO y = 1, 10\n      passed_a(y) = a(x, y)\n      passed_b(y) = b(x, y)\n    END DO\n    init = .FALSE.\n    IF (.FALSE. .eqv. IS_POSSIBLE(a(x, 1:10), b(x, 1:10), 10, .FALSE.)) THEN\n      errors = errors + 1\n    END IF\n  END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "construct-independent",
                            "atomic"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_capture_assign_x_divided_expr.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:construct-independent,atomic,V:2.0-2.7\n      LOGICAL FUNCTION test1()\n  IMPLICIT NONE\n  INCLUDE \"acc_testsuite.Fh\"\n  INTEGER :: x, y !Iterators\n  REAL(8),DIMENSION(LOOPCOUNT, 10):: a !Data\n  REAL(8),DIMENSION(LOOPCOUNT, 10):: b\n  REAL(8),DIMENSION(LOOPCOUNT):: totals\n  REAL(8),DIMENSION(10):: passed\n  REAL(8),DIMENSION(10):: passed_b\n  REAL(8) :: holder\n  INTEGER :: errors = 0\n  LOGICAL IS_POSSIBLE\n  LOGICAL IS_POSSIBLE_2\n\n  !Initilization\n  SEEDDIM(1) = 1\n# ifdef SEED\n  SEEDDIM(1) = SEED\n# endif\n  CALL RANDOM_SEED(PUT=SEEDDIM)\n\n  CALL RANDOM_NUMBER(a)\n\n  totals = 1\n\n  !$acc data copyin(a(1:LOOPCOUNT, 1:10)) copy(totals(1:LOOPCOUNT)) copyout(b(1:LOOPCOUNT,1:10))\n    !$acc parallel\n      !$acc loop\n      DO x = 1, LOOPCOUNT\n        DO y = 1, 10\n          !$acc atomic capture\n            b(x, y) = totals(x)\n            totals(x) = totals(x) / a(x, y)\n          !$acc end atomic\n        END DO\n      END DO\n    !$acc end parallel\n  !$acc end data\n\n  DO x = 1, LOOPCOUNT\n    DO y = 1, 10\n      passed(y) = a(x, y)\n    END DO\n    holder = 1\n    IF (IS_POSSIBLE(passed, totals(x), 10, holder) .eqv. .FALSE.) THEN\n      errors = errors + 1\n    END IF\n  END DO\n\n  DO x = 1, LOOPCOUNT\n    DO y = 1, 10\n      passed(y) = a(x, y)\n      passed_b(y) = b(x, y)\n    END DO\n    holder = 1\n    IF (IS_POSSIBLE_2(passed, passed_b, 10, holder) .eqv. .FALSE.) THEN\n      errors = errors + 1\n    END IF\n  END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "construct-independent",
                            "atomic"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_capture_assign_x_eqv_expr.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:construct-independent,atomic,V:2.0-2.7\n      LOGICAL FUNCTION test1()\n  IMPLICIT NONE\n  INCLUDE \"acc_testsuite.Fh\"\n  INTEGER :: x, y !Iterators\n  REAL(8),DIMENSION(LOOPCOUNT, 10):: randoms\n  LOGICAL,DIMENSION(LOOPCOUNT, 10):: a, b !Data\n  LOGICAL,DIMENSION(LOOPCOUNT):: totals, totals_comparison\n  LOGICAL,DIMENSION(10):: passed_a, passed_b\n  LOGICAL:: init\n  INTEGER :: errors = 0\n  LOGICAL IS_POSSIBLE\n\n  !Initilization\n  SEEDDIM(1) = 1\n# ifdef SEED\n  SEEDDIM(1) = SEED\n# endif\n  CALL RANDOM_SEED(PUT=SEEDDIM)\n\n  CALL RANDOM_NUMBER(randoms)\n  DO x = 1, LOOPCOUNT\n    DO y = 1, 10\n      IF (randoms(x, y) > .5) THEN\n        a(x, y) = .TRUE.\n      ELSE\n        a(x, y) = .FALSE.\n      END IF\n    END DO\n  END DO\n\n  totals = .FALSE.\n  totals_comparison = .FALSE.\n\n  !$acc data copyin(a(1:LOOPCOUNT,1:10)) copy(totals(1:LOOPCOUNT)) copyout(b(1:LOOPCOUNT,1:10))\n    !$acc parallel\n      !$acc loop\n      DO x = 1, LOOPCOUNT\n        DO y = 1, 10\n          !$acc atomic capture\n            b(x, y) = totals(x)\n            totals(x) = totals(x) .EQV. a(x, y)\n          !$acc end atomic\n        END DO\n      END DO\n    !$acc end parallel\n  !$acc end data\n\n  DO x = 1, LOOPCOUNT\n    DO y = 1, 10\n      totals_comparison(x) = totals_comparison(x) .EQV. a(x, y)\n    END DO\n  END DO\n\n  DO x = 1, LOOPCOUNT\n    DO y = 1, 10\n      passed_a(y) = a(x, y)\n      passed_b(y) = b(x, y)\n    END DO\n    init = .FALSE.\n    IF (IS_POSSIBLE(passed_a, passed_b, 10, init) .EQV. .FALSE.) THEN\n      errors = errors + 1\n    END IF\n  END DO\n\n  DO x = 1, LOOPCOUNT\n    IF (totals_comparison(x) .NEQV. totals(x)) THEN\n      errors = errors + 1\n      WRITE(*, *) totals_comparison(x)\n    END IF\n  END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "construct-independent",
                            "atomic"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_capture_assign_x_minus_expr.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:construct-independent,atomic,V:2.0-2.7\n      LOGICAL FUNCTION test1()\n  IMPLICIT NONE\n  INCLUDE \"acc_testsuite.Fh\"\n  INTEGER :: x, y !Iterators\n  LOGICAL IS_POSSIBLE\n  LOGICAL IS_POSSIBLE_2\n  REAL(8),DIMENSION(LOOPCOUNT, 10):: a, b !Data\n  REAL(8),DIMENSION(LOOPCOUNT):: totals\n  REAL(8),DIMENSION(10):: passed_a, passed_b\n  REAL(8):: init\n  INTEGER :: errors = 0\n\n  !Initilization\n  SEEDDIM(1) = 1\n# ifdef SEED\n  SEEDDIM(1) = SEED\n# endif\n  CALL RANDOM_SEED(PUT=SEEDDIM)\n\n  CALL RANDOM_NUMBER(a)\n\n  totals = 0\n\n  !$acc data copyin(a(1:LOOPCOUNT, 1:10)) copy(totals(1:LOOPCOUNT)) copyout(b(1:LOOPCOUNT, 1:10))\n    !$acc parallel\n      !$acc loop\n      DO x = 1, LOOPCOUNT\n        DO y = 1, 10\n          !$acc atomic capture\n            b(x, y) = totals(x)\n            totals(x) = totals(x) - a(x, y)\n          !$acc end atomic\n        END DO\n      END DO\n    !$acc end parallel\n  !$acc end data\n\n  DO x = 1, LOOPCOUNT\n    DO y = 1, 10\n      passed_a(y) = a(x, y)\n    END DO\n    IF (IS_POSSIBLE(passed_a, totals(x), 10, 0) .eqv. .FALSE.) THEN\n      errors = errors + 1\n    END IF\n  END DO\n\n  DO x = 1, LOOPCOUNT\n    DO y = 1, 10\n      passed_a(y) = a(x, y)\n      passed_b(y) = b(x, y)\n    END DO\n    init = 0\n    IF (IS_POSSIBLE_2(passed_a, passed_b, 10, init) .EQV. .FALSE.) THEN\n      errors = errors + 1\n    END IF\n  END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "construct-independent",
                            "atomic"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_capture_assign_x_neqv_expr.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:construct-independent,atomic,V:2.0-2.7\n      LOGICAL FUNCTION test1()\n  IMPLICIT NONE\n  INCLUDE \"acc_testsuite.Fh\"\n  INTEGER :: x, y !Iterators\n  REAL(8),DIMENSION(LOOPCOUNT, 10):: randoms\n  LOGICAL,DIMENSION(LOOPCOUNT, 10):: a, b !Data\n  LOGICAL,DIMENSION(10):: passed_a, passed_b\n  LOGICAL,DIMENSION(LOOPCOUNT):: totals, totals_comparison\n  LOGICAL IS_POSSIBLE\n  INTEGER :: errors = 0\n\n  !Initilization\n  SEEDDIM(1) = 1\n# ifdef SEED\n  SEEDDIM(1) = SEED\n# endif\n  CALL RANDOM_SEED(PUT=SEEDDIM)\n\n  CALL RANDOM_NUMBER(randoms)\n  DO x = 1, LOOPCOUNT\n    DO y = 1, 10\n      IF (randoms(x, y) > .5) THEN\n        a(x, y) = .TRUE.\n      ELSE\n        a(x, y) = .FALSE.\n      END IF\n    END DO\n  END DO\n\n  totals = .FALSE.\n  totals_comparison = .FALSE.\n\n  !$acc data copyin(a(1:LOOPCOUNT,1:10)) copy(totals(1:LOOPCOUNT)) copyout(b(1:LOOPCOUNT,1:10))\n    !$acc parallel\n      !$acc loop\n      DO x = 1, LOOPCOUNT\n        DO y = 1, 10\n          !$acc atomic capture\n            b(x, y) = totals(x)\n            totals(x) = totals(x) .NEQV. a(x, y)\n          !$acc end atomic\n        END DO\n      END DO\n    !$acc end parallel\n  !$acc end data\n\n  DO x = 1, LOOPCOUNT\n    DO y = 1, 10\n      totals_comparison(x) = totals_comparison(x) .NEQV. a(x, y)\n    END DO\n  END DO\n\n  DO x = 1, LOOPCOUNT\n    IF (totals_comparison(x) .NEQV. totals(x)) THEN\n      errors = errors + 1\n      WRITE(*, *) totals_comparison(x)\n    END IF\n  END DO\n\n  DO x = 1, LOOPCOUNT\n    DO y = 1, 10\n      passed_a(y) = a(x, y)\n      passed_b(y) = b(x, y)\n    END DO\n    IF (IS_POSSIBLE(passed_a, passed_b, 10, .FALSE.) .eqv. .FALSE.) THEN\n      errors = errors + 1\n    END IF\n  END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "construct-independent",
                            "atomic"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_capture_assign_x_or_expr.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:construct-independent,atomic,V:2.0-2.7\n      LOGICAL FUNCTION test1()\n  IMPLICIT NONE\n  INCLUDE \"acc_testsuite.Fh\"\n  INTEGER :: x, y !Iterators\n  REAL(8),DIMENSION(LOOPCOUNT, 10):: randoms\n  LOGICAL,DIMENSION(LOOPCOUNT, 10):: a, b !Data\n  LOGICAL,DIMENSION(LOOPCOUNT):: totals, totals_comparison\n  LOGICAL,DIMENSION(10):: passed_a, passed_b\n  LOGICAL IS_POSSIBLE\n  LOGICAL:: init\n  INTEGER :: errors = 0\n\n  !Initilization\n  SEEDDIM(1) = 1\n# ifdef SEED\n  SEEDDIM(1) = SEED\n# endif\n  CALL RANDOM_SEED(PUT=SEEDDIM)\n\n  CALL RANDOM_NUMBER(randoms)\n  DO x = 1, LOOPCOUNT\n    DO y = 1, 10\n      IF (randoms(x, y) > .933) THEN\n        a(x, y) = .TRUE.\n      ELSE\n        a(x, y) = .FALSE.\n      END IF\n    END DO\n  END DO\n\n  totals = .FALSE.\n  totals_comparison = .FALSE.\n\n  !$acc data copyin(a(1:LOOPCOUNT,1:10)) copy(totals(1:LOOPCOUNT)) copyout(b(1:LOOPCOUNT,1:10))\n    !$acc parallel\n      !$acc loop\n      DO x = 1, LOOPCOUNT\n        DO y = 1, 10\n          !$acc atomic capture\n            b(x, y) = totals(x)\n            totals(x) = totals(x) .OR. a(x, y)\n          !$acc end atomic\n        END DO\n      END DO\n    !$acc end parallel\n  !$acc end data\n\n  DO x = 1, LOOPCOUNT\n    DO y = 1, 10\n      totals_comparison(x) = totals_comparison(x) .OR. a(x, y)\n    END DO\n  END DO\n\n  DO x = 1, LOOPCOUNT\n    IF (totals_comparison(x) .NEQV. totals(x)) THEN\n      errors = errors + 1\n      WRITE(*, *) totals_comparison(x)\n    END IF\n  END DO\n\n  DO x = 1, LOOPCOUNT\n    DO y = 1, 10\n      passed_a(y) = a(x, y)\n      passed_b(y) = b(x, y)\n    END DO\n    init = .FALSE.\n    IF (IS_POSSIBLE(passed_a, passed_b, 10, init) .eqv. .FALSE.) THEN\n      errors = errors + 1\n    END IF\n  END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "construct-independent",
                            "atomic"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_capture_assign_x_plus_expr.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:construct-independent,atomic,V:2.0-2.7\n      LOGICAL FUNCTION test1()\n  IMPLICIT NONE\n  INCLUDE \"acc_testsuite.Fh\"\n  INTEGER :: x, y !Iterators\n  REAL(8),DIMENSION(LOOPCOUNT, 10):: a, b !Data\n  REAL(8),DIMENSION(LOOPCOUNT):: totals, totals_comparison\n  REAL(8),DIMENSION(10):: passed_a, passed_b\n  REAL(8):: init\n  LOGICAL IS_POSSIBLE\n  INTEGER :: errors = 0\n\n  !Initilization\n  SEEDDIM(1) = 1\n# ifdef SEED\n  SEEDDIM(1) = SEED\n# endif\n  CALL RANDOM_SEED(PUT=SEEDDIM)\n\n  CALL RANDOM_NUMBER(a)\n\n  totals = 0\n  totals_comparison = 0\n\n  !$acc data copyin(a(1:LOOPCOUNT, 1:10)) copy(totals(1:LOOPCOUNT)) copyout(b(1:LOOPCOUNT,1:10))\n    !$acc parallel\n      !$acc loop\n      DO x = 1, LOOPCOUNT\n        DO y = 1, 10\n          !$acc atomic capture\n            b(x, y) = totals(x)\n            totals(x) = totals(x) + a(x, y)\n          !$acc end atomic\n        END DO\n      END DO\n    !$acc end parallel\n  !$acc end data\n  DO x = 1, LOOPCOUNT\n    DO y = 1, 10\n      totals_comparison(x) = totals_comparison(x) + a(x, y)\n    END DO\n  END DO\n\n  DO x = 1, LOOPCOUNT\n    IF (totals_comparison(x) .NE. totals(x)) THEN\n      errors = errors + 1\n      WRITE(*, *) totals_comparison(x)\n    END IF\n  END DO\n\n  DO x = 1, LOOPCOUNT\n    DO y = 1, 10\n      passed_a(y) = a(x, y)\n      passed_b(y) = b(x, y)\n    END DO\n    init = 0\n    IF (IS_POSSIBLE(passed_a, passed_b, 10, init) .eqv. .FALSE.) THEN\n      errors = errors + 1\n    END IF\n  END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "construct-independent",
                            "atomic"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_capture_assign_x_times_expr.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:construct-independent,atomic,V:2.0-2.7\n      LOGICAL FUNCTION test1()\n  IMPLICIT NONE\n  INCLUDE \"acc_testsuite.Fh\"\n  INTEGER :: x, y !Iterators\n  REAL(8),DIMENSION(LOOPCOUNT, 10):: a, b !Data\n  REAL(8),DIMENSION(LOOPCOUNT):: totals, totals_comparison\n  REAL(8),DIMENSION(10):: passed_a, passed_b\n  REAL(8):: init\n  LOGICAL IS_POSSIBLE\n  INTEGER :: errors = 0\n\n  !Initilization\n  SEEDDIM(1) = 1\n# ifdef SEED\n  SEEDDIM(1) = SEED\n# endif\n  CALL RANDOM_SEED(PUT=SEEDDIM)\n\n  CALL RANDOM_NUMBER(a)\n\n  totals = 1\n  totals_comparison = 1\n\n  !$acc data copyin(a(1:LOOPCOUNT, 1:10)) copy(totals(1:LOOPCOUNT)) copyout(b(1:LOOPCOUNT,1:10))\n    !$acc parallel\n      !$acc loop\n      DO x = 1, LOOPCOUNT\n        DO y = 1, 10\n          !$acc atomic capture\n            b(x, y) = totals(x)\n            totals(x) = totals(x) * a(x, y)\n          !$acc end atomic\n        END DO\n      END DO\n    !$acc end parallel\n  !$acc end data\n  DO x = 1, LOOPCOUNT\n    DO y = 1, 10\n      totals_comparison(x) = totals_comparison(x) * a(x, y)\n    END DO\n  END DO\n\n  DO x = 1, LOOPCOUNT\n    IF (totals_comparison(x) .NE. totals(x)) THEN\n      errors = errors + 1\n      WRITE(*, *) totals_comparison(x)\n    END IF\n  END DO\n\n  DO x = 1, LOOPCOUNT\n    DO y = 1, 10\n      passed_a(y) = a(x, y)\n      passed_b(y) = b(x, y)\n    END DO\n    init = 1\n    IF (IS_POSSIBLE(passed_a, passed_b, 10, init) .eqv. .TRUE.) THEN\n      errors = errors + 1\n    END IF\n  END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "construct-independent",
                            "atomic"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_capture_bitand_equals.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:atomic,construct-independent,V:2.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    int *a = (int *)malloc(n * sizeof(int));\n    int *b = (int *)malloc(n * sizeof(int));\n    int *totals = (int *)malloc((n/10 + 1) * sizeof(int));\n    int *totals_comparison = (int *)malloc((n/10 + 1) * sizeof(int));\n    int *temp_a = (int *)malloc(10 * sizeof(int));\n    int *temp_b = (int *)malloc(10 * sizeof(int));\n    int iterator;\n    int iterator2;\n    int init;\n\n    for (int x = 0; x < n; ++x){\n        for (int y = 0; y < 8; ++y){\n            if (rand()/(real_t)(RAND_MAX) < .933){ //.933 gets close to a 50/50 distribution for a collescence of 10 values\n                a[x] += 1<<y;\n            }\n        }\n    }\n    for (int x = 0; x < n/10 + 1; ++x){\n        for (int y = 0; y < 8; ++y){\n            totals[x] +=  1<<y;\n            totals_comparison[x] += 1<<y;\n        }\n    }\n    for (int x = 0; x < n; ++x){\n        for (int y = 0; y < 8; ++y){\n            b[x] += 1<<y;\n        }\n    }\n    #pragma acc data copyin(a[0:n]) copy(totals[0:n/10 + 1]) copyout(b[0:n])\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                #pragma acc atomic capture\n                    b[x] = totals[x%(n/10 + 1)] &= a[x];\n            }\n        }\n    }\n    for (int x = 0; x < n; ++x){\n        totals_comparison[x%(n/10 + 1)] &= a[x];\n    }\n    for (int x = 0; x < (n/10 + 1); ++x){\n        if (totals_comparison[x] != totals[x]){\n            err += 1;\n            break;\n        }\n    }\n\n    for (int x = 0; x < 8; ++x){\n        init += 1<<x;\n    }\n    for (int x = 0; x < (n/10 + 1); ++x){\n        for (iterator = x, iterator2 = 0; iterator < n; iterator += n/10 + 1, iterator2++){\n            temp_a[iterator2] = a[iterator];\n            temp_b[iterator2] = b[iterator];\n        }\n        if (!is_possible(temp_a, temp_b, iterator2, init)){\n            err += 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "atomic",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_capture_bitor_equals.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:atomic,construct-independent,V:2.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    int *a = (int *)malloc(n * sizeof(int));\n    int *b = (int *)malloc(n * sizeof(int));\n    int *totals = (int *)malloc((n/10 + 1) * sizeof(int));\n    int *totals_comparison = (int *)malloc((n/10 + 1) * sizeof(int));\n    int *temp_a = (int *)malloc(10 * sizeof(int));\n    int *temp_b = (int *)malloc(10 * sizeof(int));\n    int temp_indexer = 0;\n    int absolute_indexer = 0;\n\n    for (int x = 0; x < n; ++x){\n        for (int y = 0; y < 8; ++y){\n            if (rand()/(real_t)(RAND_MAX) > .933){ //.933 gets close to a 50/50 distribution for a collescence of 10 values\n                a[x] += 1<<y;\n            }\n        }\n    }\n    for (int x = 0; x < n/10 + 1; ++x){\n        totals[x] = 0;\n        totals_comparison[x] = 0;\n    }\n    for (int x = 0; x < n; ++x){\n        b[x] = 0;\n    }\n\n    #pragma acc data copyin(a[0:n]) copy(totals[0:n/10 + 1]) copyout(b[0:n])\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                #pragma acc atomic capture\n                    b[x] = totals[x%(n/10 + 1)] |= a[x];\n            }\n        }\n    }\n    for (int x = 0; x < n; ++x){\n        totals_comparison[x%(n/10 + 1)] |= a[x];\n    }\n    for (int x = 0; x < 10; ++x){\n        if (fabs(totals_comparison[x] - totals[x]) > PRECISION){\n            err += 1;\n            break;\n        }\n    }\n\n    for (int x = 0; x < (n/10 + 1); ++x){\n        for (absolute_indexer = x, temp_indexer = 0; absolute_indexer < n; absolute_indexer += n/10 + 1, temp_indexer++){\n            temp_a[temp_indexer] = a[absolute_indexer];\n            temp_b[temp_indexer] = b[absolute_indexer];\n        }\n        if (!(is_possible(temp_a, temp_b, temp_indexer, 0))){\n            err += 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "atomic",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_capture_bitxor_equals.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:atomic,construct-independent,V:2.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    int *a = (int *)malloc(n * sizeof(int));\n    int *b = (int *)malloc(n * sizeof(int));\n    int *totals = (int *)malloc((n/10 + 1) * sizeof(int));\n    int *totals_comparison = (int *)malloc((n/10 + 1) * sizeof(int));\n    int * temp_a = (int *)malloc(10 * sizeof(int));\n    int * temp_b = (int *)malloc(10 * sizeof(int));\n    int temp_iterator;\n    int ab_iterator;\n\n    for (int x = 0; x < n; ++x){\n        for (int y = 0; y < 8; ++y){\n            if (rand()/(real_t)(RAND_MAX) > .5){\n                a[x] += 1<<y;\n            }\n        }\n    }\n    for (int x = 0; x < n/10 + 1; ++x){\n        totals[x] = 0;\n        totals_comparison[x] = 0;\n    }\n\n    #pragma acc data copyin(a[0:n]) copy(totals[0:n/10 + 1]) copyout(b[0:n])\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                #pragma acc atomic capture\n                    b[x] = totals[x%(n/10 + 1)] ^= a[x];\n            }\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        totals_comparison[x%(n/10 + 1)] ^= a[x];\n    }\n    for (int x = 0; x < 10; ++x){\n        if (fabs(totals_comparison[x] - totals[x]) > PRECISION){\n            err += 1;\n            break;\n        }\n    }\n\n    for (int x = 0; x < n/10 + 1; ++x){\n        for (temp_iterator = 0, ab_iterator = x; ab_iterator < n; temp_iterator++, ab_iterator += n/10 + 1){\n            temp_a[temp_iterator] = a[ab_iterator];\n            temp_b[temp_iterator] = b[ab_iterator];\n        }\n        if (!(is_possible(temp_a, temp_b, temp_iterator, 0))){\n            err++;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "atomic",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_capture_divided_equals.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:atomic,construct-independent,V:2.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t *a = (real_t *)malloc(n * sizeof(real_t));\n    real_t *b = (real_t *)malloc(n * sizeof(real_t));\n    real_t *c = (real_t *)malloc(n * sizeof(real_t));\n    real_t *totals = (real_t *)malloc((n/10 + 1) * sizeof(real_t));\n    real_t *totals_comparison = (real_t *)malloc((n/10 + 1) * sizeof(real_t));\n    real_t *temp_a = (real_t *)malloc(10 * sizeof(real_t));\n    real_t *temp_b = (real_t *)malloc(10 * sizeof(real_t));\n    real_t *temp_c = (real_t *)malloc(10 * sizeof(real_t));\n    int temp_iterator;\n    int ab_iterator;\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n        c[x] = 0;\n    }\n    for (int x = 0; x < n/10 + 1; ++x){\n        totals[x] = 1;\n        totals_comparison[x] = 1;\n    }\n\n    #pragma acc data copyin(a[0:n], b[0:n]) copy(totals[0:n/10 + 1]) copyout(c[0:n])\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                #pragma acc atomic capture\n                    c[x] = totals[x%(n/10 + 1)] /= (a[x] + b[x]);\n            }\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        totals_comparison[x%(n/10 + 1)] /= a[x] + b[x];\n    }\n    for (int x = 0; x < 10; ++x){\n        if (fabs(totals_comparison[x] - totals[x]) > PRECISION){\n            err += 1;\n            break;\n        }\n    }\n\n    for (int x = 0; x < (n/10 + 1); ++x){\n        temp_iterator = 0;\n        for (ab_iterator = x; ab_iterator < n;  ab_iterator+=((n/10) + 1)){\n            temp_a[temp_iterator] = a[ab_iterator];\n            temp_b[temp_iterator] = b[ab_iterator];\n            temp_c[temp_iterator] = c[ab_iterator];\n            temp_iterator++;\n        }\n        if (!(is_possible(temp_a, temp_b, temp_c, temp_iterator, 1))){\n            err++;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "atomic",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_capture_expr_and_x_assign.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:construct-independent,atomic,V:2.0-2.7\n      LOGICAL FUNCTION test1()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x, y !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT, 10):: randoms\n        LOGICAL,DIMENSION(LOOPCOUNT, 10):: a !Data\n        LOGICAL,DIMENSION(LOOPCOUNT, 10):: b\n        LOGICAL IS_POSSIBLE\n        LOGICAL,DIMENSION(LOOPCOUNT):: totals, totals_comparison\n        INTEGER :: errors = 0\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(randoms)\n        DO x = 1, LOOPCOUNT\n          DO y = 1, 10\n            IF (randoms(x, y) < .933) THEN\n              a(x, y) = .TRUE.\n            ELSE\n              a(x, y) = .FALSE.\n            END IF\n          END DO\n        END DO\n\n        totals = .FALSE.\n        totals_comparison = .FALSE.\n\n        !$acc data copyin(a(1:LOOPCOUNT,1:10)) copy(totals(1:LOOPCOUNT)) copyout(b(1:LOOPCOUNT,1:10))\n          !$acc parallel\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              DO y = 1, 10\n                !$acc atomic capture\n                  totals(x) = a(x, y) .AND. totals(x)\n                  b(x, y) = totals(x)\n                !$acc end atomic\n              END DO\n            END DO\n          !$acc end parallel\n        !$acc end data\n\n        DO x = 1, LOOPCOUNT\n          DO y = 1, 10\n            totals_comparison(x) = totals_comparison(x) .AND. a(x, y)\n          END DO\n        END DO\n\n        DO x = 1, LOOPCOUNT\n          IF (totals_comparison(x) .NEQV. totals(x)) THEN\n            errors = errors + 1\n            WRITE(*, *) totals_comparison(x)\n          END IF\n        END DO\n\n        DO x = 1, LOOPCOUNT\n          IF (.FALSE. .eqv. IS_POSSIBLE(a(x, 1:10), b(x, 1:10), 10, .FALSE.)) THEN\n            errors = errors + 1\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "construct-independent",
                            "atomic"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_capture_expr_bitand_x.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:atomic,construct-independent,V:2.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    int *a = (int *)malloc(n * sizeof(int));\n    int *b = (int *)malloc(n * sizeof(int));\n    int *totals = (int *)malloc((n/10 + 1) * sizeof(int));\n    int *totals_comparison = (int *)malloc((n/10 + 1) * sizeof(int));\n    int *passed_a = (int *)malloc(10 * sizeof(int));\n    int *passed_b = (int *)malloc(10 * sizeof(int));\n    int passed_total = 0;\n    int absolute_indexer;\n    int passed_indexer;\n\n    for (int x = 0; x < n; ++x){\n        for (int y = 0; y < 8; ++y){\n            if (rand()/(real_t)(RAND_MAX) < .933){ //.933 gets close to a 50/50 distribution for a collescence of 10 values\n                a[x] += 1<<y;\n            }\n        }\n    }\n    for (int x = 0; x < n/10 + 1; ++x){\n        for (int y = 0; y < 8; ++y){\n            totals[x] +=  1<<y;\n            totals_comparison[x] += 1<<y;\n        }\n    }\n\n    #pragma acc data copyin(a[0:n]) copy(totals[0:n/10 + 1]) copyout(b[0:n])\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                #pragma acc atomic capture\n                     b[x] = totals[x%(n/10 + 1)] = a[x] & totals[x%(n/10 + 1)];\n            }\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        totals_comparison[x%(n/10 + 1)] &= a[x];\n    }\n\n    for (int x = 0; x < 10; ++x){\n        if (fabs(totals_comparison[x] - totals[x]) > PRECISION){\n            err += 1;\n            break;\n        }\n    }\n\n    for (int x = 0; x < 8; ++x){\n        passed_total += 1<<x;\n    }\n    for (int x = 0; x < (n/10 + 1); ++x){\n        for (absolute_indexer = x, passed_indexer = 0; absolute_indexer < n; absolute_indexer += (n/10 + 1), passed_indexer++){\n            passed_a[passed_indexer] = a[absolute_indexer];\n            passed_b[passed_indexer] = b[absolute_indexer];\n        }\n        if (!is_possible(passed_a, passed_b, passed_indexer - 1, passed_total)){\n            err += 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "atomic",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_capture_expr_bitor_x.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:atomic,construct-independent,V:2.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    int *a = (int *)malloc(n * sizeof(int));\n    int *b = (int *)malloc(n * sizeof(int));\n    int *totals = (int *)malloc((n/10 + 1) * sizeof(int));\n    int *totals_comparison = (int *)malloc((n/10 + 1) * sizeof(int));\n    int *passed_a = (int *)malloc(10 * sizeof(int));\n    int *passed_b = (int *)malloc(10 * sizeof(int));\n    int passed_indexer;\n    int absolute_indexer;\n\n    for (int x = 0; x < n; ++x){\n        for (int y = 0; y < 8; ++y){\n            if (rand()/(real_t)(RAND_MAX) > .933){ //.933 gets close to a 50/50 distribution for a collescence of 10 values\n                a[x] += 1<<y;\n            }\n        }\n    }\n    for (int x = 0; x < n/10 + 1; ++x){\n        totals[x] = 0;\n\n    }\n\n    #pragma acc data copyin(a[0:n]) copy(totals[0:n/10 + 1])\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                #pragma acc atomic capture\n                    b[x] = totals[x%(n/10 + 1)] = totals[x%(n/10 + 1)] | a[x];\n            }\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        totals_comparison[x%(n/10 + 1)] |= a[x];\n    }\n    for (int x = 0; x < 10; ++x){\n        if (fabs(totals_comparison[x] - totals[x]) > PRECISION){\n            err += 1;\n            break;\n        }\n    }\n    for (int x = 0; x < (n/10 + 1); ++x){\n        for (passed_indexer = 0, absolute_indexer = x; absolute_indexer < n; passed_indexer++, absolute_indexer += n/10 + 1){\n            passed_a[passed_indexer] = a[absolute_indexer];\n            passed_b[passed_indexer] = b[absolute_indexer];\n        }\n        if (!is_possible(passed_a, passed_b, passed_indexer - 1, 0)){\n            err++;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "atomic",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_capture_expr_bitxor_x.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:atomic,construct-independent,V:2.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    int *a = (int *)malloc(n * sizeof(int));\n    int *b = (int *)malloc(n * sizeof(int));\n    int *totals = (int *)malloc((n/10 + 1) * sizeof(int));\n    int *totals_comparison = (int *)malloc((n/10 + 1) * sizeof(int));\n    int *passed_a = (int *)malloc(10 * sizeof(int));\n    int *passed_b = (int *)malloc(10 * sizeof(int));\n    int passed_indexer;\n    int absolute_indexer;\n\n    for (int x = 0; x < n; ++x){\n        for (int y = 0; y < 8; ++y){\n            if (rand()/(real_t)(RAND_MAX) > .5){\n                a[x] += 1<<y;\n            }\n        }\n    }\n    for (int x = 0; x < n/10 + 1; ++x){\n        totals[x] = 0;\n        totals_comparison[x] = 0;\n    }\n\n    #pragma acc data copyin(a[0:n]) copy(totals[0:n/10 + 1]) copyout(b[0:n])\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                #pragma acc atomic capture\n                    b[x] = totals[x%(n/10 + 1)] = a[x] ^ totals[x%(n/10 + 1)];\n            }\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        totals_comparison[x%(n/10 + 1)] ^= a[x];\n    }\n    for (int x = 0; x < 10; ++x){\n        if (fabs(totals_comparison[x] - totals[x]) > PRECISION){\n            err += 1;\n            break;\n        }\n    }\n\n    for (int x = 0; x < n/10 + 1; ++x){\n        for (passed_indexer = 0, absolute_indexer = x; absolute_indexer < n; passed_indexer++, absolute_indexer += n/10 + 1){\n            passed_a[passed_indexer] = a[absolute_indexer];\n            passed_b[passed_indexer] = b[absolute_indexer];\n        }\n        if (!(is_possible(passed_a, passed_b, passed_indexer - 1, 0))){\n            err++;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "atomic",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_capture_expr_divided_x.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:atomic,construct-independent,V:2.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t *a = (real_t *)malloc(n * sizeof(real_t));\n    real_t *b = (real_t *)malloc(n * sizeof(real_t));\n    real_t *c = (real_t *)malloc(n * sizeof(real_t));\n    real_t *totals = (real_t *)malloc((n/10 + 1) * sizeof(real_t));\n    real_t *passed_ab = (real_t *)malloc(10 * sizeof(real_t));\n    real_t *passed_c = (real_t *)malloc(10 * sizeof(real_t));\n    int passed_indexer;\n    int absolute_indexer;\n    real_t * passed = (real_t *)malloc(10 * sizeof(real_t));\n    int indexer;\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n    }\n    for (int x = 0; x < n/10 + 1; ++x){\n        totals[x] = 1;\n    }\n\n    #pragma acc data copyin(a[0:n], b[0:n]) copy(totals[0:n/10 + 1]) copyout(c[0:n])\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                #pragma acc atomic capture\n                    c[x] = totals[x%(n/10 + 1)] = (a[x] + b[x]) / totals[x%(n/10 + 1)];\n            }\n        }\n    }\n\n\n    for (int x = 0; x < (n/10 + 1); ++x){\n        indexer = x;\n        while (indexer < n){\n            passed[indexer/(n/10 + 1)] = (a[x] + b[x]);\n            indexer += (n/10 + 1);\n        }\n        if (!(possible_result(passed, 10, 1, totals[x]))){\n            err += 1;\n        }\n    }\n\n    for (int x = 0; x < (n/10 + 1); ++x){\n        for (passed_indexer = 0, absolute_indexer = x; absolute_indexer < n; passed_indexer++, absolute_indexer += n/10 + 1){\n            passed_ab[passed_indexer] = a[absolute_indexer] + b[absolute_indexer];\n            passed_c[passed_indexer] = c[absolute_indexer];\n        }\n        if (!is_possible(passed_ab, passed_c, passed_indexer - 1, 1)){\n            err++;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "atomic",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_capture_expr_divided_x_assign.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:construct-independent,atomic,V:2.0-2.7\n      LOGICAL FUNCTION test1()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x, y !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT, 10):: a !Data\n        REAL(8),DIMENSION(LOOPCOUNT, 10):: b\n        REAL(8),DIMENSION(LOOPCOUNT):: totals\n        REAL(8),DIMENSION(10):: passed\n        REAL(8),DIMENSION(10):: passed_b\n        REAL(8) :: holder\n        INTEGER :: errors = 0\n        LOGICAL IS_POSSIBLE\n        LOGICAL IS_POSSIBLE_2\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(a)\n\n        totals = 1\n\n        !$acc data copyin(a(1:LOOPCOUNT, 1:10)) copy(totals(1:LOOPCOUNT)) copyout(b(1:LOOPCOUNT,1:10))\n          !$acc parallel\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              DO y = 1, 10\n                !$acc atomic capture\n                  totals(x) = a(x, y) / totals(x)\n                  b(x, y) = totals(x)\n                !$acc end atomic\n              END DO\n            END DO\n          !$acc end parallel\n        !$acc end data\n\n        DO x = 1, LOOPCOUNT\n          DO y = 1, 10\n            passed(y) = a(x, y)\n          END DO\n          holder = 1\n          IF (IS_POSSIBLE(passed, totals(x), 10, holder) .eqv. .FALSE.) THEN\n            errors = errors + 1\n          END IF\n        END DO\n\n        DO x = 1, LOOPCOUNT\n          DO y = 1, 10\n            passed(y) = a(x, y)\n            passed_b(y) = b(x, y)\n          END DO\n          holder = 1\n          IF (IS_POSSIBLE_2(passed, passed_b, 10, holder) .eqv. .FALSE.) THEN\n            errors = errors + 1\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "construct-independent",
                            "atomic"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_capture_expr_eqv_x_assign.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:construct-independent,atomic,V:2.0-2.7\n      LOGICAL FUNCTION test1()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x, y !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT, 10):: randoms\n        LOGICAL,DIMENSION(LOOPCOUNT, 10):: a, b !Data\n        LOGICAL,DIMENSION(LOOPCOUNT):: totals, totals_comparison\n        LOGICAL,DIMENSION(10):: passed_a, passed_b\n        LOGICAL:: init\n        INTEGER :: errors = 0\n        LOGICAL IS_POSSIBLE\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(randoms)\n        DO x = 1, LOOPCOUNT\n          DO y = 1, 10\n            IF (randoms(x, y) > .5) THEN\n              a(x, y) = .TRUE.\n            ELSE\n              a(x, y) = .FALSE.\n            END IF\n          END DO\n        END DO\n\n        totals = .FALSE.\n        totals_comparison = .FALSE.\n\n        !$acc data copyin(a(1:LOOPCOUNT,1:10)) copy(totals(1:LOOPCOUNT)) copyout(b(1:LOOPCOUNT,1:10))\n          !$acc parallel\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              DO y = 1, 10\n                !$acc atomic capture\n                  totals(x) = a(x, y) .EQV. totals(x)\n                  b(x, y) = totals(x)\n                !$acc end atomic\n              END DO\n            END DO\n          !$acc end parallel\n        !$acc end data\n\n        DO x = 1, LOOPCOUNT\n          DO y = 1, 10\n            totals_comparison(x) = totals_comparison(x) .EQV. a(x, y)\n          END DO\n        END DO\n\n        DO x = 1, LOOPCOUNT\n          DO y = 1, 10\n            passed_a(y) = a(x, y)\n            passed_b(y) = b(x, y)\n          END DO\n          init = .FALSE.\n          IF (IS_POSSIBLE(passed_a, passed_b, 10, init) .EQV. .FALSE.) THEN\n            errors = errors + 1\n          END IF\n        END DO\n\n        DO x = 1, LOOPCOUNT\n          IF (totals_comparison(x) .NEQV. totals(x)) THEN\n            errors = errors + 1\n            WRITE(*, *) totals_comparison(x)\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "construct-independent",
                            "atomic"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_capture_expr_lshift_x.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:atomic,construct-independent,V:2.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    unsigned int *a = (unsigned int *)malloc(3 * n * sizeof(int));\n    unsigned int *b = (unsigned int *)malloc(n * sizeof(int));\n    unsigned int *c = (unsigned int *)malloc(3 * n * sizeof(int));\n    int orders[18] = {1, 2, 0, 1, 0, 2, 2, 1, 0, 2, 0, 1, 0, 1, 2, 0, 2, 1};\n    int result;\n\n    for (int x = 0; x < n; ++x){\n        for (int y = 0; y < 3; ++y){\n            a[x * 3 + y] = (int) (rand() / (unsigned int) (RAND_MAX / 4));\n        }\n        b[x] = 0;\n    }\n\n    #pragma acc data copyin(a[0:3 * n]) copy(b[0:n]) copyout(c[0:3*n])\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                #pragma acc loop\n                for (int y = 0; y < 3; ++y){\n                    #pragma acc atomic capture\n                        c[x * 3 + y] = b[x] = a[x * 3 + y] << b[x];\n                }\n            }\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        for (int y = 0; y < 6; ++y){\n            result = 0;\n            for (int z = 0; z < 3; ++z){\n                result = a[x * 3 + orders[y * 3 + z]] << result;\n            }\n            if (result == b[x]){\n                break;\n            }\n        }\n        if (result != b[x]){\n            err += 1;\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        if (!(is_possible(&(a[x*3]), &(c[x*3]), 3, 0))){\n            err += 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "atomic",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_capture_expr_minus_x.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:atomic,construct-independent,V:2.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t *a = (real_t *)malloc(n * sizeof(real_t));\n    real_t *b = (real_t *)malloc(n * sizeof(real_t));\n    real_t *totals = (real_t *)malloc(((n/10) + 1) * sizeof(real_t));\n    int indexer = 0;\n    real_t * passed = (real_t *)malloc(10 * sizeof(real_t));\n    real_t *passed_a = (real_t *)malloc(10 * sizeof(real_t));\n    real_t *passed_b = (real_t *)malloc(10 * sizeof(real_t));\n    int passed_indexer;\n    int absolute_indexer;\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n    }\n    for (int x = 0; x < (n/10) + 1; ++x){\n        totals[x] = 0;\n    }\n\n    #pragma acc data copyin(a[0:n]) copy(totals[0:(n/10) + 1]) copyout(b[0:n])\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                #pragma acc atomic capture\n                    b[x] = totals[x%((int) (n/10) + 1)] = a[x] - totals[x%((int) (n/10) + 1)];\n            }\n        }\n    }\n    for (int x = 0; x < (n/10) + 1; ++x){\n        indexer = x;\n        while (indexer < n){\n            passed[indexer/((int) (n/10) + 1)] = a[indexer];\n            indexer += (n/10) + 1;\n        }\n        if (!(possible_result(passed, 10, 0, totals[x]))){\n            err += 1;\n        }\n    }\n\n    for (int x = 0; x < n/10 + 1; ++x){\n        for (passed_indexer = 0, absolute_indexer = x; absolute_indexer < n; passed_indexer++, absolute_indexer += n/10 + 1){\n            passed_a[passed_indexer] = a[absolute_indexer];\n            passed_b[passed_indexer] = b[absolute_indexer];\n        }\n        if (!is_possible(passed_a, passed_b, passed_indexer - 1, 0)){\n            err += 1;\n        }\n        break;\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "atomic",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_capture_expr_minus_x_assign.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:construct-independent,atomic,V:2.0-2.7\n      LOGICAL FUNCTION test1()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x, y !Iterators\n        LOGICAL IS_POSSIBLE\n        LOGICAL IS_POSSIBLE_2\n        REAL(8),DIMENSION(LOOPCOUNT, 10):: a, b !Data\n        REAL(8),DIMENSION(LOOPCOUNT):: totals\n        REAL(8),DIMENSION(10):: passed_a, passed_b\n        REAL(8):: init\n        INTEGER :: errors = 0\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(a)\n\n        totals = 0\n\n        !$acc data copyin(a(1:LOOPCOUNT, 1:10)) copy(totals(1:LOOPCOUNT)) copyout(b(1:LOOPCOUNT, 1:10))\n          !$acc parallel\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              DO y = 1, 10\n                !$acc atomic capture\n                  totals(x) = a(x, y) - totals(x)\n                  b(x, y) = totals(x)\n                !$acc end atomic\n              END DO\n            END DO\n          !$acc end parallel\n        !$acc end data\n\n        DO x = 1, LOOPCOUNT\n          DO y = 1, 10\n            passed_a(y) = a(x, y)\n          END DO\n          IF (IS_POSSIBLE(passed_a, totals(x), 10, 0) .eqv. .FALSE.) THEN\n            errors = errors + 1\n          END IF\n        END DO\n\n        DO x = 1, LOOPCOUNT\n          DO y = 1, 10\n            passed_a(y) = a(x, y)\n            passed_b(y) = b(x, y)\n          END DO\n          init = 0\n          IF (IS_POSSIBLE_2(passed_a, passed_b, 10, init) .EQV. .FALSE.) THEN\n            errors = errors + 1\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "construct-independent",
                            "atomic"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_capture_expr_multiply_x.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:atomic,construct-independent,V:2.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t *a = (real_t *)malloc(n * sizeof(real_t));\n    real_t *b = (real_t *)malloc(n * sizeof(real_t));\n    real_t *c = (real_t *)malloc(n * sizeof(real_t));\n    real_t *totals = (real_t *)malloc((n/10 + 1) * sizeof(real_t));\n    real_t *totals_comparison = (real_t *)malloc((n/10 + 1) * sizeof(real_t));\n    real_t *passed_ab = (real_t *)malloc(10 * sizeof(real_t));\n    real_t *passed_c = (real_t *)malloc(10 * sizeof(real_t));\n    int passed_indexer;\n    int absolute_indexer;\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n    }\n    for (int x = 0; x < n/10 + 1; ++x){\n        totals[x] = 1;\n        totals_comparison[x] = 1;\n    }\n\n    #pragma acc data copyin(a[0:n], b[0:n]) copy(totals[0:n/10 + 1]) copyout(c[0:n])\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                #pragma acc atomic capture\n                    c[x] = totals[x%(n/10 + 1)] = (a[x] + b[x]) * totals[x%(n/10 + 1)];\n            }\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        totals_comparison[x%(n/10 + 1)] *= a[x] + b[x];\n    }\n    for (int x = 0; x < 10; ++x){\n        if (fabs(totals_comparison[x] - totals[x]) > PRECISION * totals_comparison[x]){\n            err += 1;\n            break;\n        }\n    }\n\n    for (int x = 0; x < n/10 + 1; ++x){\n        for (passed_indexer = 0, absolute_indexer = x; absolute_indexer < n; passed_indexer++, absolute_indexer += n/10 + 1){\n            passed_ab[passed_indexer] = a[absolute_indexer] + b[absolute_indexer];\n            passed_c[passed_indexer] = c[absolute_indexer];\n        }\n        if (!is_possible(passed_ab, passed_c, passed_indexer - 1, 1)){\n            err++;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "atomic",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_capture_expr_neqv_x_assign.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:construct-independent,atomic,V:2.0-2.7\n      LOGICAL FUNCTION test1()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x, y !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT, 10):: randoms\n        LOGICAL,DIMENSION(LOOPCOUNT, 10):: a, b !Data\n        LOGICAL,DIMENSION(10):: passed_a, passed_b\n        LOGICAL,DIMENSION(LOOPCOUNT):: totals, totals_comparison\n        LOGICAL IS_POSSIBLE\n        INTEGER :: errors = 0\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(randoms)\n        DO x = 1, LOOPCOUNT\n          DO y = 1, 10\n            IF (randoms(x, y) > .5) THEN\n              a(x, y) = .TRUE.\n            ELSE\n              a(x, y) = .FALSE.\n            END IF\n          END DO\n        END DO\n\n        totals = .FALSE.\n        totals_comparison = .FALSE.\n\n        !$acc data copyin(a(1:LOOPCOUNT,1:10)) copy(totals(1:LOOPCOUNT)) copyout(b(1:LOOPCOUNT,1:10))\n          !$acc parallel\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              DO y = 1, 10\n                !$acc atomic capture\n                  totals(x) = a(x, y) .NEQV. totals(x)\n                  b(x, y) = totals(x)\n                !$acc end atomic\n              END DO\n            END DO\n          !$acc end parallel\n        !$acc end data\n\n        DO x = 1, LOOPCOUNT\n          DO y = 1, 10\n            totals_comparison(x) = totals_comparison(x) .NEQV. a(x, y)\n          END DO\n        END DO\n\n        DO x = 1, LOOPCOUNT\n          IF (totals_comparison(x) .NEQV. totals(x)) THEN\n            errors = errors + 1\n            WRITE(*, *) totals_comparison(x)\n          END IF\n        END DO\n\n        DO x = 1, LOOPCOUNT\n          DO y = 1, 10\n            passed_a(y) = a(x, y)\n            passed_b(y) = b(x, y)\n          END DO\n          IF (IS_POSSIBLE(passed_a, passed_b, 10, .FALSE.) .eqv. .FALSE.) THEN\n            errors = errors + 1\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "construct-independent",
                            "atomic"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_capture_expr_or_x_assign.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:construct-independent,atomic,V:2.0-2.7\n      LOGICAL FUNCTION test1()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x, y !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT, 10):: randoms\n        LOGICAL,DIMENSION(LOOPCOUNT, 10):: a, b !Data\n        LOGICAL,DIMENSION(LOOPCOUNT):: totals, totals_comparison\n        LOGICAL,DIMENSION(10):: passed_a, passed_b\n        LOGICAL IS_POSSIBLE\n        LOGICAL:: init\n        INTEGER :: errors = 0\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(randoms)\n        DO x = 1, LOOPCOUNT\n          DO y = 1, 10\n            IF (randoms(x, y) > .933) THEN\n              a(x, y) = .TRUE.\n            ELSE\n              a(x, y) = .FALSE.\n            END IF\n          END DO\n        END DO\n\n        totals = .FALSE.\n        totals_comparison = .FALSE.\n\n        !$acc data copyin(a(1:LOOPCOUNT,1:10)) copy(totals(1:LOOPCOUNT)) copyout(b(1:LOOPCOUNT,1:10))\n          !$acc parallel\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              DO y = 1, 10\n                !$acc atomic capture\n                  totals(x) = a(x, y) .OR. totals(x)\n                  b(x, y) = totals(x)\n                !$acc end atomic\n              END DO\n            END DO\n          !$acc end parallel\n        !$acc end data\n\n        DO x = 1, LOOPCOUNT\n          DO y = 1, 10\n            totals_comparison(x) = totals_comparison(x) .OR. a(x, y)\n          END DO\n        END DO\n\n        DO x = 1, LOOPCOUNT\n          IF (totals_comparison(x) .NEQV. totals(x)) THEN\n            errors = errors + 1\n            WRITE(*, *) totals_comparison(x)\n          END IF\n        END DO\n\n        DO x = 1, LOOPCOUNT\n          DO y = 1, 10\n            passed_a(y) = a(x, y)\n            passed_b(y) = b(x, y)\n          END DO\n          init = .FALSE.\n          IF (IS_POSSIBLE(passed_a, passed_b, 10, init) .eqv. .FALSE.) THEN\n            errors = errors + 1\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "construct-independent",
                            "atomic"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_capture_expr_plus_x.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:atomic,construct-independent,V:2.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t *a = (real_t *)malloc(n * sizeof(real_t));\n    real_t *b = (real_t *)malloc(n * sizeof(real_t));\n    real_t *c = (real_t *)malloc(n * sizeof(real_t));\n    real_t *totals = (real_t *)malloc((int)(n/10 + 1) * sizeof(real_t));\n    real_t *totals_comparison = (real_t *)malloc((int)(n/10 + 1) * sizeof(real_t));\n    real_t *passed_ab = (real_t *)malloc(10 * sizeof(real_t));\n    real_t *passed_c = (real_t *)malloc(10 * sizeof(real_t));\n    int passed_indexer;\n    int absolute_indexer;\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n    }\n    for (int x = 0; x < n/10 + 1; ++x){\n        totals[x] = 0;\n        totals_comparison[x] = 0;\n    }\n\n    #pragma acc data copyin(a[0:n], b[0:n]) copy(totals[0:10]) copyout(c[0:n])\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                #pragma acc atomic capture\n                    c[x] = totals[x%((int)(n/10 + 1))] = (a[x] + b[x]) + totals[x%((int) n/10 + 1)];\n            }\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        totals_comparison[x%((int)(n/10 + 1))] += (a[x] + b[x]);\n    }\n    for (int x = 0; x < 10; ++x){\n        if (fabs(totals_comparison[x] - totals[x]) > PRECISION){\n            err += 1;\n            break;\n        }\n    }\n\n    for (int x = 0; x < n/10 + 1; ++x){\n        for (passed_indexer = 0, absolute_indexer = x; absolute_indexer < n; passed_indexer++, absolute_indexer += n/10 + 1){\n            passed_ab[passed_indexer] = a[absolute_indexer] + b[absolute_indexer];\n            passed_c[passed_indexer] = c[absolute_indexer];\n        }\n        if (!is_possible(passed_ab, passed_c, passed_indexer - 1, 0)){\n            err++;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "atomic",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_capture_expr_plus_x_assign.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:construct-independent,atomic,V:2.0-2.7\n      LOGICAL FUNCTION test1()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x, y !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT, 10):: a, b !Data\n        REAL(8),DIMENSION(LOOPCOUNT):: totals, totals_comparison\n        REAL(8),DIMENSION(10):: passed_a, passed_b\n        REAL(8):: init\n        LOGICAL IS_POSSIBLE\n        INTEGER :: errors = 0\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(a)\n\n        totals = 0\n        totals_comparison = 0\n\n        !$acc data copyin(a(1:LOOPCOUNT, 1:10)) copy(totals(1:LOOPCOUNT)) copyout(b(1:LOOPCOUNT,1:10))\n          !$acc parallel\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              DO y = 1, 10\n                !$acc atomic capture\n                  totals(x) = a(x, y) + totals(x)\n                  b(x, y) = totals(x)\n                !$acc end atomic\n              END DO\n            END DO\n          !$acc end parallel\n        !$acc end data\n        DO x = 1, LOOPCOUNT\n          DO y = 1, 10\n            totals_comparison(x) = totals_comparison(x) + a(x, y)\n          END DO\n        END DO\n\n        DO x = 1, LOOPCOUNT\n          IF (totals_comparison(x) .NE. totals(x)) THEN\n            errors = errors + 1\n            WRITE(*, *) totals_comparison(x)\n          END IF\n        END DO\n\n        DO x = 1, LOOPCOUNT\n          DO y = 1, 10\n            passed_a(y) = a(x, y)\n            passed_b(y) = b(x, y)\n          END DO\n          init = 0\n          IF (IS_POSSIBLE(passed_a, passed_b, 10, init) .eqv. .FALSE.) THEN\n            errors = errors + 1\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "construct-independent",
                            "atomic"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_capture_expr_rshift_x.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:atomic,construct-independent,V:2.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    unsigned int *a = (unsigned int *)malloc(3 * n * sizeof(int));\n    unsigned int *b = (unsigned int *)malloc(n * sizeof(int));\n    unsigned int *c = (unsigned int *)malloc(3 * n * sizeof(int));\n    int orders[18] = {1, 2, 0, 1, 0, 2, 2, 1, 0, 2, 0, 1, 0, 1, 2, 0, 2, 1};\n    int result;\n\n    for (int x = 0; x < n; ++x){\n        for (int y = 0; y < 3; ++y){\n            a[x * 3 + y] = (int) (rand() / (unsigned int) (RAND_MAX / 4));\n        }\n        b[x] = 0;\n    }\n\n    #pragma acc data copyin(a[0:3 * n]) copy(b[0:n]) copyout(c[0:3*n])\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                #pragma acc loop independent\n                for (int y = 0; y < 3; ++y){\n                    #pragma acc atomic capture\n                        c[x * 3 + y] = b[x] = a[x * 3 + y] >> b[x];\n                }\n            }\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        for (int y = 0; y < 6; ++y){\n            result = 0;\n            for (int z = 0; z < 3; ++z){\n                result = a[x * 3 + orders[y * 3 + z]] >> result;\n            }\n            if (result == b[x]){\n                break;\n            }\n        }\n        if (result != b[x]){\n            err += 1;\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        if (!is_possible(&(a[3*x]), &(c[3*x]), 3, 0)){\n            err += 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "atomic",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_capture_expr_times_x_assign.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:construct-independent,atomic,V:2.0-2.7\n      LOGICAL FUNCTION test1()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x, y !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT, 10):: a, b !Data\n        REAL(8),DIMENSION(LOOPCOUNT):: totals, totals_comparison\n        REAL(8),DIMENSION(10):: passed_a, passed_b\n        REAL(8):: init\n        LOGICAL IS_POSSIBLE\n        INTEGER :: errors = 0\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(a)\n\n        totals = 1\n        totals_comparison = 1\n\n        !$acc data copyin(a(1:LOOPCOUNT, 1:10)) copy(totals(1:LOOPCOUNT)) copyout(b(1:LOOPCOUNT,1:10))\n          !$acc parallel\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              DO y = 1, 10\n                !$acc atomic capture\n                  totals(x) = a(x, y) * totals(x)\n                  b(x, y) = totals(x)\n                !$acc end atomic\n              END DO\n            END DO\n          !$acc end parallel\n        !$acc end data\n        DO x = 1, LOOPCOUNT\n          DO y = 1, 10\n            totals_comparison(x) = totals_comparison(x) * a(x, y)\n          END DO\n        END DO\n\n        DO x = 1, LOOPCOUNT\n          IF (totals_comparison(x) .NE. totals(x)) THEN\n            errors = errors + 1\n            WRITE(*, *) totals_comparison(x)\n          END IF\n        END DO\n\n        DO x = 1, LOOPCOUNT\n          DO y = 1, 10\n            passed_a(y) = a(x, y)\n            passed_b(y) = b(x, y)\n          END DO\n          init = 1\n          IF (IS_POSSIBLE(passed_a, passed_b, 10, init) .eqv. .TRUE.) THEN\n            errors = errors + 1\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "construct-independent",
                            "atomic"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_capture_iand_expr_x_assign.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:construct-independent,atomic,V:2.0-2.7\n      LOGICAL FUNCTION test1()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x, y, z !Iterators\n        INTEGER,DIMENSION(LOOPCOUNT, 10):: a, b !Data\n        REAL(8),DIMENSION(LOOPCOUNT, 10, 8):: randoms\n        INTEGER,DIMENSION(LOOPCOUNT):: totals, totals_comparison\n        INTEGER,DIMENSION(10):: passed_a, passed_b\n        INTEGER:: init\n        LOGICAL IS_POSSIBLE\n        INTEGER :: errors = 0\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(randoms)\n        a = 0\n        DO x = 1, LOOPCOUNT\n          DO y = 1, 10\n            DO z = 1, 8\n              IF (randoms(x, y, z) .lt. .933) THEN\n                a(x, y) = a(x, y) + ISHFT(1, z - 1)\n              END IF\n            END DO\n          END DO\n        END DO\n        totals = 0\n        totals_comparison = 0\n        DO x = 1, LOOPCOUNT\n          DO y = 0, 7\n            totals(x) = totals(x) + ISHFT(1, y)\n            totals_comparison(x) = totals_comparison(x) + ISHFT(1, y)\n          END DO\n        END DO\n\n        !$acc data copyin(a(1:LOOPCOUNT, 1:10)) copy(totals(1:LOOPCOUNT)) copyout(b(1:LOOPCOUNT, 1:10))\n          !$acc parallel\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              DO y = 1, 10\n                !$acc atomic capture\n                  totals(x) = iand(a(x, y), totals(x))\n                  b(x, y) = totals(x)\n                !$acc end atomic\n              END DO\n            END DO\n          !$acc end parallel\n        !$acc end data\n        DO x = 1, LOOPCOUNT\n          DO y = 1, 10\n            totals_comparison(x) = iand(totals_comparison(x), a(x, y))\n          END DO\n        END DO\n        DO x = 1, LOOPCOUNT\n          IF (totals_comparison(x) .NE. totals(x)) THEN\n            errors = errors + 1\n            WRITE(*, *) totals_comparison(x)\n          END IF\n        END DO\n\n        DO x = 1, LOOPCOUNT\n          DO y = 1, 10\n            passed_a(y) = a(x, y)\n            passed_b(y) = b(x, y)\n          END DO\n          init = 0\n          DO y = 0, 7\n            init = init + ISHFT(1, y)\n          END DO\n          IF (IS_POSSIBLE(passed_a, passed_b, 10, init) .eqv. .FALSE.) THEN\n            errors = errors + 1\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "construct-independent",
                            "atomic"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_capture_iand_x_expr_assign.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:construct-independent,atomic,V:2.0-2.7\n      LOGICAL FUNCTION test1()\n  IMPLICIT NONE\n  INCLUDE \"acc_testsuite.Fh\"\n  INTEGER :: x, y, z !Iterators\n  INTEGER,DIMENSION(LOOPCOUNT, 10):: a, b !Data\n  REAL(8),DIMENSION(LOOPCOUNT, 10, 8):: randoms\n  INTEGER,DIMENSION(LOOPCOUNT):: totals, totals_comparison\n  INTEGER,DIMENSION(10):: passed_a, passed_b\n  INTEGER:: init\n  LOGICAL IS_POSSIBLE\n  INTEGER :: errors = 0\n\n  !Initilization\n  SEEDDIM(1) = 1\n# ifdef SEED\n  SEEDDIM(1) = SEED\n# endif\n  CALL RANDOM_SEED(PUT=SEEDDIM)\n\n  CALL RANDOM_NUMBER(randoms)\n  a = 0\n  DO x = 1, LOOPCOUNT\n    DO y = 1, 10\n      DO z = 1, 8\n        IF (randoms(x, y, z) .lt. .933) THEN\n          a(x, y) = a(x, y) + ISHFT(1, z - 1)\n        END IF\n      END DO\n    END DO\n  END DO\n  totals = 0\n  totals_comparison = 0\n  DO x = 1, LOOPCOUNT\n    DO y = 0, 7\n      totals(x) = totals(x) + ISHFT(1, y)\n      totals_comparison(x) = totals_comparison(x) + ISHFT(1, y)\n    END DO\n  END DO\n\n  !$acc data copyin(a(1:LOOPCOUNT, 1:10)) copy(totals(1:LOOPCOUNT)) copyout(b(1:LOOPCOUNT, 1:10))\n    !$acc parallel\n      !$acc loop\n      DO x = 1, LOOPCOUNT\n        DO y = 1, 10\n          !$acc atomic capture\n            totals(x) = iand(totals(x), a(x, y))\n            b(x, y) = totals(x)\n          !$acc end atomic\n        END DO\n      END DO\n    !$acc end parallel\n  !$acc end data\n  DO x = 1, LOOPCOUNT\n    DO y = 1, 10\n      totals_comparison(x) = iand(totals_comparison(x), a(x, y))\n    END DO\n  END DO\n  DO x = 1, LOOPCOUNT\n    IF (totals_comparison(x) .NE. totals(x)) THEN\n      errors = errors + 1\n      WRITE(*, *) totals_comparison(x)\n    END IF\n  END DO\n\n  DO x = 1, LOOPCOUNT\n    DO y = 1, 10\n      passed_a(y) = a(x, y)\n      passed_b(y) = b(x, y)\n    END DO\n    init = 0\n    DO y = 0, 7\n      init = init + ISHFT(1, y)\n    END DO\n    IF (IS_POSSIBLE(passed_a, passed_b, 10, init) .eqv. .FALSE.) THEN\n      errors = errors + 1\n    END IF\n  END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "construct-independent",
                            "atomic"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_capture_ior_expr_x_assign.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:construct-independent,atomic,V:2.0-2.7\n      LOGICAL FUNCTION test1()\n  IMPLICIT NONE\n  INCLUDE \"acc_testsuite.Fh\"\n  INTEGER :: x, y, z !Iterators\n  INTEGER,DIMENSION(LOOPCOUNT, 10):: a, b !Data\n  REAL(8),DIMENSION(LOOPCOUNT, 10, 8):: randoms\n  INTEGER,DIMENSION(LOOPCOUNT):: totals, totals_comparison\n  INTEGER,DIMENSION(10):: passed_a, passed_b\n  INTEGER:: init\n  LOGICAL IS_POSSIBLE\n  INTEGER :: errors = 0\n\n  !Initilization\n  SEEDDIM(1) = 1\n# ifdef SEED\n  SEEDDIM(1) = SEED\n# endif\n  CALL RANDOM_SEED(PUT=SEEDDIM)\n\n  CALL RANDOM_NUMBER(randoms)\n  a = 0\n  DO x = 1, LOOPCOUNT\n    DO y = 1, 10\n      DO z = 1, 8\n        IF (randoms(x, y, z) .gt. .933) THEN\n          a(x, y) = a(x, y) + ISHFT(1, z - 1)\n        END IF\n      END DO\n    END DO\n  END DO\n  totals = 0\n  totals_comparison = 0\n\n  !$acc data copyin(a(1:LOOPCOUNT, 1:10)) copy(totals(1:LOOPCOUNT)) copyout(b(1:LOOPCOUNT, 1:10))\n    !$acc parallel\n      !$acc loop\n      DO x = 1, LOOPCOUNT\n        DO y = 1, 10\n          !$acc atomic capture\n            totals(x) = ior(a(x, y), totals(x))\n            b(x, y) = totals(x)\n          !$acc end atomic\n        END DO\n      END DO\n    !$acc end parallel\n  !$acc end data\n  DO x = 1, LOOPCOUNT\n    DO y = 1, 10\n      totals_comparison(x) = ior(totals_comparison(x), a(x, y))\n    END DO\n  END DO\n  DO x = 1, LOOPCOUNT\n    IF (totals_comparison(x) .NE. totals(x)) THEN\n      errors = errors + 1\n      WRITE(*, *) totals_comparison(x)\n    END IF\n  END DO\n\n  DO x = 1, LOOPCOUNT\n    DO y = 1, 10\n      passed_a(y) = a(x, y)\n      passed_b(y) = b(x, y)\n    END DO\n    init = 0\n    IF (IS_POSSIBLE(passed_a, passed_b, 10, init) .eqv. .FALSE.) THEN\n      errors = errors + 1\n    END IF\n  END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "construct-independent",
                            "atomic"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_capture_ior_x_expr_assign.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:construct-independent,atomic,V:2.0-2.7\n      LOGICAL FUNCTION test1()\n  IMPLICIT NONE\n  INCLUDE \"acc_testsuite.Fh\"\n  INTEGER :: x, y, z !Iterators\n  INTEGER,DIMENSION(LOOPCOUNT, 10):: a, b !Data\n  REAL(8),DIMENSION(LOOPCOUNT, 10, 8):: randoms\n  INTEGER,DIMENSION(LOOPCOUNT):: totals, totals_comparison\n  INTEGER,DIMENSION(10):: passed_a, passed_b\n  INTEGER:: init\n  LOGICAL IS_POSSIBLE\n  INTEGER :: errors = 0\n\n  !Initilization\n  SEEDDIM(1) = 1\n# ifdef SEED\n  SEEDDIM(1) = SEED\n# endif\n  CALL RANDOM_SEED(PUT=SEEDDIM)\n\n  CALL RANDOM_NUMBER(randoms)\n  a = 0\n  DO x = 1, LOOPCOUNT\n    DO y = 1, 10\n      DO z = 1, 8\n        IF (randoms(x, y, z) .gt. .933) THEN\n          a(x, y) = a(x, y) + ISHFT(1, z - 1)\n        END IF\n      END DO\n    END DO\n  END DO\n  totals = 0\n  totals_comparison = 0\n\n  !$acc data copyin(a(1:LOOPCOUNT, 1:10)) copy(totals(1:LOOPCOUNT)) copyout(b(1:LOOPCOUNT, 1:10))\n    !$acc parallel\n      !$acc loop\n      DO x = 1, LOOPCOUNT\n        DO y = 1, 10\n          !$acc atomic capture\n            totals(x) = ior(totals(x), a(x, y))\n            b(x, y) = totals(x)\n          !$acc end atomic\n        END DO\n      END DO\n    !$acc end parallel\n  !$acc end data\n  DO x = 1, LOOPCOUNT\n    DO y = 1, 10\n      totals_comparison(x) = ior(totals_comparison(x), a(x, y))\n    END DO\n  END DO\n  DO x = 1, LOOPCOUNT\n    IF (totals_comparison(x) .NE. totals(x)) THEN\n      errors = errors + 1\n      WRITE(*, *) totals_comparison(x)\n    END IF\n  END DO\n\n  DO x = 1, LOOPCOUNT\n    DO y = 1, 10\n      passed_a(y) = a(x, y)\n      passed_b(y) = b(x, y)\n    END DO\n    init = 0\n    IF (IS_POSSIBLE(passed_a, passed_b, 10, init) .eqv. .FALSE.) THEN\n      errors = errors + 1\n    END IF\n  END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "construct-independent",
                            "atomic"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_capture_ixor_expr_x_assign.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:construct-independent,atomic,V:2.0-2.7\n      LOGICAL FUNCTION test1()\n  IMPLICIT NONE\n  INCLUDE \"acc_testsuite.Fh\"\n  INTEGER :: x, y, z !Iterators\n  INTEGER,DIMENSION(LOOPCOUNT, 10):: a, b !Data\n  REAL(8),DIMENSION(LOOPCOUNT, 10, 8):: randoms\n  INTEGER,DIMENSION(LOOPCOUNT):: totals, totals_comparison\n  INTEGER,DIMENSION(10):: passed_a, passed_b\n  INTEGER:: init\n  LOGICAL IS_POSSIBLE\n  INTEGER :: errors = 0\n\n  !Initilization\n  SEEDDIM(1) = 1\n# ifdef SEED\n  SEEDDIM(1) = SEED\n# endif\n  CALL RANDOM_SEED(PUT=SEEDDIM)\n\n  CALL RANDOM_NUMBER(randoms)\n  a = 0\n  DO x = 1, LOOPCOUNT\n    DO y = 1, 10\n      DO z = 1, 8\n        IF (randoms(x, y, z) .gt. .5) THEN\n          a(x, y) = a(x, y) + ISHFT(1, z - 1)\n        END IF\n      END DO\n    END DO\n  END DO\n  totals = 0\n  totals_comparison = 0\n\n  !$acc data copyin(a(1:LOOPCOUNT, 1:10)) copy(totals(1:LOOPCOUNT)) copyout(b(1:LOOPCOUNT, 1:10))\n    !$acc parallel\n      !$acc loop\n      DO x = 1, LOOPCOUNT\n        DO y = 1, 10\n          !$acc atomic capture\n            totals(x) = ieor(a(x, y), totals(x))\n            b(x, y) = totals(x)\n          !$acc end atomic\n        END DO\n      END DO\n    !$acc end parallel\n  !$acc end data\n  DO x = 1, LOOPCOUNT\n    DO y = 1, 10\n      totals_comparison(x) = ieor(totals_comparison(x), a(x, y))\n    END DO\n  END DO\n  DO x = 1, LOOPCOUNT\n    IF (totals_comparison(x) .NE. totals(x)) THEN\n      errors = errors + 1\n      WRITE(*, *) totals_comparison(x)\n    END IF\n  END DO\n\n  DO x = 1, LOOPCOUNT\n    DO y = 1, 10\n      passed_a(y) = a(x, y)\n      passed_b(y) = b(x, y)\n    END DO\n    init = 0\n    IF (IS_POSSIBLE(passed_a, passed_b, 10, init) .eqv. .FALSE.) THEN\n      errors = errors + 1\n    END IF\n  END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "construct-independent",
                            "atomic"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_capture_ixor_x_expr_assign.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:construct-independent,atomic,V:2.0-2.7\n      LOGICAL FUNCTION test1()\n  IMPLICIT NONE\n  INCLUDE \"acc_testsuite.Fh\"\n  INTEGER :: x, y, z !Iterators\n  INTEGER,DIMENSION(LOOPCOUNT, 10):: a, b !Data\n  REAL(8),DIMENSION(LOOPCOUNT, 10, 8):: randoms\n  INTEGER,DIMENSION(LOOPCOUNT):: totals, totals_comparison\n  INTEGER,DIMENSION(10):: passed_a, passed_b\n  INTEGER:: init\n  LOGICAL IS_POSSIBLE\n  INTEGER :: errors = 0\n\n  !Initilization\n  SEEDDIM(1) = 1\n# ifdef SEED\n  SEEDDIM(1) = SEED\n# endif\n  CALL RANDOM_SEED(PUT=SEEDDIM)\n\n  CALL RANDOM_NUMBER(randoms)\n  a = 0\n  DO x = 1, LOOPCOUNT\n    DO y = 1, 10\n      DO z = 1, 8\n        IF (randoms(x, y, z) .gt. .5) THEN\n          a(x, y) = a(x, y) + ISHFT(1, z - 1)\n        END IF\n      END DO\n    END DO\n  END DO\n  totals = 0\n  totals_comparison = 0\n\n  !$acc data copyin(a(1:LOOPCOUNT, 1:10)) copy(totals(1:LOOPCOUNT)) copyout(b(1:LOOPCOUNT, 1:10))\n    !$acc parallel\n      !$acc loop\n      DO x = 1, LOOPCOUNT\n        DO y = 1, 10\n          !$acc atomic capture\n            totals(x) = ieor(totals(x), a(x, y))\n            b(x, y) = totals(x)\n          !$acc end atomic\n        END DO\n      END DO\n    !$acc end parallel\n  !$acc end data\n  DO x = 1, LOOPCOUNT\n    DO y = 1, 10\n      totals_comparison(x) = ieor(totals_comparison(x), a(x, y))\n    END DO\n  END DO\n  DO x = 1, LOOPCOUNT\n    IF (totals_comparison(x) .NE. totals(x)) THEN\n      errors = errors + 1\n      WRITE(*, *) totals_comparison(x)\n    END IF\n  END DO\n\n  DO x = 1, LOOPCOUNT\n    DO y = 1, 10\n      passed_a(y) = a(x, y)\n      passed_b(y) = b(x, y)\n    END DO\n    init = 0\n    IF (IS_POSSIBLE(passed_a, passed_b, 10, init) .eqv. .FALSE.) THEN\n      errors = errors + 1\n    END IF\n  END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "construct-independent",
                            "atomic"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_capture_lshift_equals.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:atomic,construct-independent,V:2.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    unsigned int *a = (unsigned int *)malloc(n * sizeof(int));\n    unsigned int *b = (unsigned int *)malloc(n * sizeof(int));\n    unsigned int *c = (unsigned int *)malloc(7 * n * sizeof(int));\n    unsigned int passed = 1;\n\n    for (int x = 0; x < n; ++x){\n        a[x] = 1;\n        for (int y = 0; y < 7; ++y){\n            if ((rand()/(real_t) (RAND_MAX)) > .5){\n                b[x] += 1<<y;\n            }\n        }\n    }\n\n    #pragma acc data copyin(b[0:n]) copy(a[0:n]) copyout(c[0:7*n])\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                #pragma acc loop\n                for (int y = 0; y < 7; ++y){\n                    c[x * 7 + y] = a[x];\n                    if ((b[x]>>y)%2 == 1){\n                        #pragma acc atomic capture\n                            c[x * 7 + y] = a[x] <<= 1;\n                    }\n                }\n            }\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        for (int y = 0; y < 7; ++y){\n            if ((b[x]>>y)%2 == 1){\n                a[x] >>= 1;\n            }\n        }\n        if (a[x] != 1){\n            err += 1;\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        if (!is_possible(b[x], &(c[x * 7]), 7, passed)){\n            err++;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "atomic",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_capture_max_expr_list_x_assign.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:construct-independent,atomic,V:2.0-2.7\n      LOGICAL FUNCTION test1()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x, y !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT, 10):: a, b, c !Data\n        REAL(8),DIMENSION(LOOPCOUNT):: totals, totals_comparison\n        REAL(8),DIMENSION(10):: passed_a, passed_b, passed_c\n        REAL(8):: init\n        LOGICAL IS_POSSIBLE\n        INTEGER :: errors = 0\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(a)\n        CALL RANDOM_NUMBER(b)\n\n        totals = 0\n        totals_comparison = 0\n\n        !$acc data copyin(a(1:LOOPCOUNT, 1:10), b(1:LOOPCOUNT, 1:10)) copy(totals(1:LOOPCOUNT)) copyout(c(1:LOOPCOUNT, 1:10))\n          !$acc parallel\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              DO y = 1, 10\n                !$acc atomic capture\n                  totals(x) = max(a(x, y), b(x, y), totals(x))\n                  c(x, y) = totals(x)\n                !$acc end atomic\n              END DO\n            END DO\n          !$acc end parallel\n        !$acc end data\n        DO x = 1, LOOPCOUNT\n          DO y = 1, 10\n            totals_comparison(x) = max(totals_comparison(x), a(x, y), b(x, y))\n          END DO\n        END DO\n        DO x = 1, LOOPCOUNT\n          IF (totals_comparison(x) .NE. totals(x)) THEN\n            errors = errors + 1\n            WRITE(*, *) totals_comparison(x)\n          END IF\n        END DO\n\n        DO x = 1, LOOPCOUNT\n          DO y = 1, 10\n            passed_a(y) = a(x, y)\n            passed_b(y) = b(x, y)\n            passed_c(y) = c(x, y)\n          END DO\n          init = 0\n          IF (IS_POSSIBLE(passed_a, passed_b, passed_c, 10, init) .eqv. .FALSE.) THEN\n            errors = errors + 1\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "construct-independent",
                            "atomic"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_capture_max_expr_x_assign.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:construct-independent,atomic,V:2.0-2.7\n      LOGICAL FUNCTION test1()\n  IMPLICIT NONE\n  INCLUDE \"acc_testsuite.Fh\"\n  INTEGER :: x, y !Iterators\n  REAL(8),DIMENSION(LOOPCOUNT, 10):: a, b !Data\n  REAL(8),DIMENSION(LOOPCOUNT):: totals, totals_comparison\n  REAL(8),DIMENSION(10):: passed_a, passed_b\n  REAL(8):: init\n  LOGICAL IS_POSSIBLE\n  INTEGER :: errors = 0\n\n  !Initilization\n  SEEDDIM(1) = 1\n# ifdef SEED\n  SEEDDIM(1) = SEED\n# endif\n  CALL RANDOM_SEED(PUT=SEEDDIM)\n\n  CALL RANDOM_NUMBER(a)\n\n  totals = 0\n  totals_comparison = 0\n\n  !$acc data copyin(a(1:LOOPCOUNT, 1:10)) copy(totals(1:LOOPCOUNT)) copyout(b(1:LOOPCOUNT, 1:10))\n    !$acc parallel\n      !$acc loop\n      DO x = 1, LOOPCOUNT\n        DO y = 1, 10\n          !$acc atomic capture\n            totals(x) = max(a(x, y), totals(x))\n            b(x, y) = totals(x)\n          !$acc end atomic\n        END DO\n      END DO\n    !$acc end parallel\n  !$acc end data\n  DO x = 1, LOOPCOUNT\n    DO y = 1, 10\n      totals_comparison(x) = max(totals_comparison(x), a(x, y))\n    END DO\n  END DO\n  DO x = 1, LOOPCOUNT\n    IF (totals_comparison(x) .NE. totals(x)) THEN\n      errors = errors + 1\n      WRITE(*, *) totals_comparison(x)\n    END IF\n  END DO\n\n  DO x = 1, LOOPCOUNT\n    DO y = 1, 10\n      passed_a(y) = a(x, y)\n      passed_b(y) = b(x, y)\n    END DO\n    init = 0\n    IF (IS_POSSIBLE(passed_a, passed_b, 10, init) .eqv. .FALSE.) THEN\n      errors = errors + 1\n    END IF\n  END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "construct-independent",
                            "atomic"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_capture_max_x_expr_assign.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:construct-independent,atomic,V:2.0-2.7\n      LOGICAL FUNCTION test1()\n  IMPLICIT NONE\n  INCLUDE \"acc_testsuite.Fh\"\n  INTEGER :: x, y !Iterators\n  REAL(8),DIMENSION(LOOPCOUNT, 10):: a, b !Data\n  REAL(8),DIMENSION(LOOPCOUNT):: totals, totals_comparison\n  REAL(8),DIMENSION(10):: passed_a, passed_b\n  REAL(8):: init\n  LOGICAL IS_POSSIBLE\n  INTEGER :: errors = 0\n\n  !Initilization\n  SEEDDIM(1) = 1\n# ifdef SEED\n  SEEDDIM(1) = SEED\n# endif\n  CALL RANDOM_SEED(PUT=SEEDDIM)\n\n  CALL RANDOM_NUMBER(a)\n\n  totals = 0\n  totals_comparison = 0\n\n  !$acc data copyin(a(1:LOOPCOUNT, 1:10)) copy(totals(1:LOOPCOUNT)) copyout(b(1:LOOPCOUNT, 1:10))\n    !$acc parallel\n      !$acc loop\n      DO x = 1, LOOPCOUNT\n        DO y = 1, 10\n          !$acc atomic capture\n            totals(x) = max(totals(x), a(x, y))\n            b(x, y) = totals(x)\n          !$acc end atomic\n        END DO\n      END DO\n    !$acc end parallel\n  !$acc end data\n  DO x = 1, LOOPCOUNT\n    DO y = 1, 10\n      totals_comparison(x) = max(totals_comparison(x), a(x, y))\n    END DO\n  END DO\n  DO x = 1, LOOPCOUNT\n    IF (totals_comparison(x) .NE. totals(x)) THEN\n      errors = errors + 1\n      WRITE(*, *) totals_comparison(x)\n    END IF\n  END DO\n\n  DO x = 1, LOOPCOUNT\n    DO y = 1, 10\n      passed_a(y) = a(x, y)\n      passed_b(y) = b(x, y)\n    END DO\n    init = 0\n    IF (IS_POSSIBLE(passed_a, passed_b, 10, init) .eqv. .FALSE.) THEN\n      errors = errors + 1\n    END IF\n  END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "construct-independent",
                            "atomic"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_capture_max_x_expr_list_assign.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:construct-independent,atomic,V:2.0-2.7\n      LOGICAL FUNCTION test1()\nIMPLICIT NONE\nINCLUDE \"acc_testsuite.Fh\"\nINTEGER :: x, y !Iterators\nREAL(8),DIMENSION(LOOPCOUNT, 10):: a, b, c !Data\nREAL(8),DIMENSION(LOOPCOUNT):: totals, totals_comparison\nREAL(8),DIMENSION(10):: passed_a, passed_b, passed_c\nREAL(8):: init\nLOGICAL IS_POSSIBLE\nINTEGER :: errors = 0\n\n!Initilization\nSEEDDIM(1) = 1\n#ifdef SEED\nSEEDDIM(1) = SEED\n#endif\n",
                        "tags": [
                            "construct-independent",
                            "atomic"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_capture_min_expr_list_x_assign.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:construct-independent,atomic,V:2.0-2.7\n      LOGICAL FUNCTION test1()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x, y !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT, 10):: a, b, c !Data\n        REAL(8),DIMENSION(LOOPCOUNT):: totals, totals_comparison\n        REAL(8),DIMENSION(10):: passed_a, passed_b, passed_c\n        REAL(8):: init\n        LOGICAL IS_POSSIBLE\n        INTEGER :: errors = 0\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(a)\n        CALL RANDOM_NUMBER(b)\n\n        totals = 0\n        totals_comparison = 0\n\n        !$acc data copyin(a(1:LOOPCOUNT, 1:10), b(1:LOOPCOUNT, 1:10)) copy(totals(1:LOOPCOUNT)) copyout(c(1:LOOPCOUNT, 1:10))\n          !$acc parallel\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              DO y = 1, 10\n                !$acc atomic capture\n                  totals(x) = min(a(x, y), b(x, y), totals(x))\n                  c(x, y) = totals(x)\n                !$acc end atomic\n              END DO\n            END DO\n          !$acc end parallel\n        !$acc end data\n        DO x = 1, LOOPCOUNT\n          DO y = 1, 10\n            totals_comparison(x) = min(totals_comparison(x), a(x, y), b(x, y))\n          END DO\n        END DO\n        DO x = 1, LOOPCOUNT\n          IF (totals_comparison(x) .NE. totals(x)) THEN\n            errors = errors + 1\n            WRITE(*, *) totals_comparison(x)\n          END IF\n        END DO\n\n        DO x = 1, LOOPCOUNT\n          DO y = 1, 10\n            passed_a(y) = a(x, y)\n            passed_b(y) = b(x, y)\n            passed_c(y) = c(x, y)\n          END DO\n          init = 0\n          IF (IS_POSSIBLE(passed_a, passed_b, passed_c, 10, init) .eqv. .FALSE.) THEN\n            errors = errors + 1\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "construct-independent",
                            "atomic"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_capture_min_expr_x_assign.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:construct-independent,atomic,V:2.0-2.7\n      LOGICAL FUNCTION test1()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x, y !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT, 10):: a, b !Data\n        REAL(8),DIMENSION(LOOPCOUNT):: totals, totals_comparison\n        REAL(8),DIMENSION(10):: passed_a, passed_b\n        REAL(8):: init\n        LOGICAL IS_POSSIBLE\n        INTEGER :: errors = 0\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(a)\n\n        totals = 0\n        totals_comparison = 0\n\n        !$acc data copyin(a(1:LOOPCOUNT, 1:10)) copy(totals(1:LOOPCOUNT)) copyout(b(1:LOOPCOUNT, 1:10))\n          !$acc parallel\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              DO y = 1, 10\n                !$acc atomic capture\n                  totals(x) = min(a(x, y), totals(x))\n                  b(x, y) = totals(x)\n                !$acc end atomic\n              END DO\n            END DO\n          !$acc end parallel\n        !$acc end data\n        DO x = 1, LOOPCOUNT\n          DO y = 1, 10\n            totals_comparison(x) = min(totals_comparison(x), a(x, y))\n          END DO\n        END DO\n        DO x = 1, LOOPCOUNT\n          IF (totals_comparison(x) .NE. totals(x)) THEN\n            errors = errors + 1\n            WRITE(*, *) totals_comparison(x)\n          END IF\n        END DO\n\n        DO x = 1, LOOPCOUNT\n          DO y = 1, 10\n            passed_a(y) = a(x, y)\n            passed_b(y) = b(x, y)\n          END DO\n          init = 0\n          IF (IS_POSSIBLE(passed_a, passed_b, 10, init) .eqv. .FALSE.) THEN\n            errors = errors + 1\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "construct-independent",
                            "atomic"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_capture_min_x_expr_assign.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:construct-independent,atomic,V:2.0-2.7\n      LOGICAL FUNCTION test1()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x, y !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT, 10):: a, b !Data\n        REAL(8),DIMENSION(LOOPCOUNT):: totals, totals_comparison\n        REAL(8),DIMENSION(10):: passed_a, passed_b\n        REAL(8):: init\n        LOGICAL IS_POSSIBLE\n        INTEGER :: errors = 0\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(a)\n\n        totals = 0\n        totals_comparison = 0\n\n        !$acc data copyin(a(1:LOOPCOUNT, 1:10)) copy(totals(1:LOOPCOUNT)) copyout(b(1:LOOPCOUNT, 1:10))\n          !$acc parallel\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              DO y = 1, 10\n                !$acc atomic capture\n                  totals(x) = min(totals(x), a(x, y))\n                  b(x, y) = totals(x)\n                !$acc end atomic\n              END DO\n            END DO\n          !$acc end parallel\n        !$acc end data\n        DO x = 1, LOOPCOUNT\n          DO y = 1, 10\n            totals_comparison(x) = min(totals_comparison(x), a(x, y))\n          END DO\n        END DO\n        DO x = 1, LOOPCOUNT\n          IF (totals_comparison(x) .NE. totals(x)) THEN\n            errors = errors + 1\n            WRITE(*, *) totals_comparison(x)\n          END IF\n        END DO\n\n        DO x = 1, LOOPCOUNT\n          DO y = 1, 10\n            passed_a(y) = a(x, y)\n            passed_b(y) = b(x, y)\n          END DO\n          init = 0\n          IF (IS_POSSIBLE(passed_a, passed_b, 10, init) .eqv. .FALSE.) THEN\n            errors = errors + 1\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "construct-independent",
                            "atomic"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_capture_min_x_expr_list_assign.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:construct-independent,atomic,V:2.0-2.7\n      LOGICAL FUNCTION test1()\n      IMPLICIT NONE\n      INCLUDE \"acc_testsuite.Fh\"\n      INTEGER :: x, y !Iterators\n      REAL(8),DIMENSION(LOOPCOUNT, 10):: a, b, c !Data\n      REAL(8),DIMENSION(LOOPCOUNT):: totals, totals_comparison\n      REAL(8),DIMENSION(10):: passed_a, passed_b, passed_c\n      REAL(8):: init\n      LOGICAL IS_POSSIBLE\n      INTEGER :: errors = 0\n\n      !Initilization\n      SEEDDIM(1) = 1\n#     ifdef SEED\n      SEEDDIM(1) = SEED\n#     endif\n      CALL RANDOM_SEED(PUT=SEEDDIM)\n\n      CALL RANDOM_NUMBER(a)\n      CALL RANDOM_NUMBER(b)\n\n      totals = 1\n      totals_comparison = 1\n\n      !$acc data copyin(a(1:LOOPCOUNT, 1:10), b(1:LOOPCOUNT, 1:10)) copy(totals(1:LOOPCOUNT)) copyout(c(1:LOOPCOUNT, 1:10))\n        !$acc parallel\n          !$acc loop\n          DO x = 1, LOOPCOUNT\n            DO y = 1, 10\n              !$acc atomic capture\n                totals(x) = min(totals(x), a(x, y), b(x, y))\n                c(x, y) = totals(x)\n              !$acc end atomic\n            END DO\n          END DO\n        !$acc end parallel\n      !$acc end data\n      DO x = 1, LOOPCOUNT\n        DO y = 1, 10\n          totals_comparison(x) = min(totals_comparison(x), a(x, y), b(x, y))\n        END DO\n      END DO\n      DO x = 1, LOOPCOUNT\n        IF (totals_comparison(x) .NE. totals(x)) THEN\n          errors = errors + 1\n          WRITE(*, *) totals_comparison(x)\n        END IF\n      END DO\n\n      DO x = 1, LOOPCOUNT\n        DO y = 1, 10\n          passed_a(y) = a(x, y)\n          passed_b(y) = b(x, y)\n          passed_c(y) = c(x, y)\n        END DO\n        init = 1\n        IF (IS_POSSIBLE(passed_a, passed_b, passed_c, 10, init) .eqv. .FALSE.) THEN\n          errors = errors + 1\n        END IF\n      END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "construct-independent",
                            "atomic"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_capture_minus_equals.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:atomic,construct-independent,V:2.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t *a = (real_t *)malloc(n * sizeof(real_t));\n    real_t *b = (real_t *)malloc(n * sizeof(real_t));\n    real_t *c = (real_t *)malloc(n * sizeof(real_t));\n    real_t *totals = (real_t *)malloc(10 * sizeof(real_t));\n    real_t *totals_host = (real_t *)malloc(10 * sizeof(real_t));\n    real_t * passed_ab = (real_t *)malloc((n/10 + 1) * sizeof(real_t));\n    real_t * passed_c = (real_t *)malloc((n/10 + 1) * sizeof(real_t));\n    int passed_indexer;\n    int absolute_indexer;\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n    }\n    for (int x = 0; x < 10; ++x){\n        totals[x] = 0;\n    }\n\n    #pragma acc data copyin(a[0:n], b[0:n]) copy(totals[0:10])\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                #pragma acc atomic capture\n                    c[x] = totals[x%10] -= (a[x] + b[x]);\n            }\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        totals_host[x%10] = totals_host[x%10] - (a[x] + b[x]);\n    }\n    for (int x = 0; x < 10; ++x){\n        if (fabs(totals_host[x] - totals[x]) > PRECISION){\n            err += 1;\n        }\n    }\n\n    for (int x = 0; x < 10; ++x){\n        for (passed_indexer = 0, absolute_indexer = x; absolute_indexer < n; passed_indexer++, absolute_indexer+= 10){\n            passed_ab[passed_indexer] = a[absolute_indexer] + b[absolute_indexer];\n            passed_c[passed_indexer] = c[absolute_indexer];\n        }\n        if (!is_possible(passed_ab, passed_c, passed_indexer - 1, 0)){\n            err++;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "atomic",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_capture_multiply_equals.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:atomic,construct-independent,V:2.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t *a = (real_t *)malloc(n * sizeof(real_t));\n    real_t *b = (real_t *)malloc(n * sizeof(real_t));\n    real_t *c = (real_t *)malloc(n * sizeof(real_t));\n    real_t *totals = (real_t *)malloc((n/10 + 1) * sizeof(real_t));\n    real_t *totals_comparison = (real_t *)malloc((n/10 + 1) * sizeof(real_t));\n    real_t * passed_ab = (real_t *)malloc(10 * sizeof(real_t));\n    real_t * passed_c = (real_t *)malloc(10 * sizeof(real_t));\n    int passed_indexer;\n    int absolute_indexer;\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n    }\n    for (int x = 0; x < n/10 + 1; ++x){\n        totals[x] = 1;\n        totals_comparison[x] = 1;\n    }\n\n    #pragma acc data copyin(a[0:n], b[0:n]) copy(totals[0:n/10 + 1]) copyout(c[0:n])\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                #pragma acc atomic capture\n                    c[x] = totals[x%(n/10 + 1)] *= a[x] + b[x];\n            }\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        totals_comparison[x%(n/10 + 1)] *= a[x] + b[x];\n    }\n    for (int x = 0; x < 10; ++x){\n        if (fabs(totals_comparison[x] - totals[x]) > PRECISION * totals_comparison[x]){\n            err += 1;\n            break;\n        }\n    }\n\n    for (int x = 0; x < n/10 + 1; ++x){\n        for (passed_indexer = 0, absolute_indexer = x; absolute_indexer < n; passed_indexer++, absolute_indexer += n/10 + 1){\n            passed_ab[passed_indexer] = a[absolute_indexer] + b[absolute_indexer];\n            passed_c[passed_indexer] = c[absolute_indexer];\n        }\n        if (!is_possible(passed_ab, passed_c, passed_indexer - 1, 1)){\n            err++;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "atomic",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_capture_plus_equals.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:atomic,construct-independent,V:2.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t *a = (real_t *)malloc(n * sizeof(real_t));\n    real_t *b = (real_t *)malloc(n * sizeof(real_t));\n    real_t *c = (real_t *)malloc(n * sizeof(real_t));\n    real_t *totals = (real_t *)malloc((n/10 + 1) * sizeof(real_t));\n    real_t *totals_comparison = (real_t *)malloc((n/10 + 1) * sizeof(real_t));\n    real_t *passed_ab = (real_t *)malloc(10 * sizeof(real_t));\n    real_t *passed_c = (real_t *)malloc(10 * sizeof(real_t));\n    int passed_indexer;\n    int absolute_indexer;\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n    }\n    for (int x = 0; x < n/10 + 1; ++x){\n        totals[x] = 0;\n        totals_comparison[x] = 0;\n    }\n\n    #pragma acc data copyin(a[0:n], b[0:n]) copy(totals[0:n/10 + 1]) copyout(c[0:n])\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                #pragma acc atomic capture\n                    c[x] = totals[x%(n/10 + 1)] += a[x] * b[x];\n            }\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        totals_comparison[x%(n/10 + 1)] += a[x] * b[x];\n    }\n    for (int x = 0; x < n/10 + 1; ++x){\n        if (fabs(totals_comparison[x] - totals[x]) > PRECISION){\n            err += 1;\n            break;\n        }\n    }\n\n    for (int x = 0; x < n/10 + 1; ++x){\n        for (passed_indexer = 0, absolute_indexer = x; absolute_indexer < n; passed_indexer++, absolute_indexer+= (n/10 + 1)){\n            passed_ab[passed_indexer] = a[absolute_indexer] * b[absolute_indexer];\n            passed_c[passed_indexer] = c[absolute_indexer];\n        }\n        if (!is_possible(passed_ab, passed_c, passed_indexer - 1, 0)){\n            err++;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "atomic",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_capture_postdecrement.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:atomic,construct-independent,V:2.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t *a = (real_t *)malloc(n * sizeof(real_t));\n    real_t *b = (real_t *)malloc(n * sizeof(real_t));\n    int *c = (int *)malloc(n * sizeof(int));\n    int *distribution = (int *)malloc(10 * sizeof(int));\n    int *distribution_comparison = (int *)malloc(10 * sizeof(int));\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n    }\n    for (int x = 0; x < 10; ++x){\n        distribution[x] = 0;\n        distribution_comparison[x] = 0;\n    }\n\n    #pragma acc data copyin(a[0:n], b[0:n]) copy(distribution[0:10]) copyout(c[0:n])\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                #pragma acc atomic capture\n                    c[x] = (distribution[(int) (a[x]*b[x]/10)])--;\n            }\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        distribution_comparison[(int) (a[x]*b[x]/10)]--;\n    }\n    for (int x = 0; x < 10; ++x){\n        if (distribution_comparison[x] != distribution[x]){\n            err += 1;\n            break;\n        }\n    }\n\n    bool found = false;\n    for (int x = 0; x < 10; ++x){\n        for (int y = 0; y > -distribution_comparison[x]; --y){\n            for (int z = 0; z < n; ++z){\n                if (y == c[z] && x == (int) (a[x] * b[x] / 10)){\n                    found = true;\n                    break;\n                }\n            }\n            if (!found){\n                err++;\n            }\n            found = false;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "atomic",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_capture_postincrement.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:atomic,construct-independent,V:2.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t *a = (real_t *)malloc(n * sizeof(real_t));\n    real_t *b = (real_t *)malloc(n * sizeof(real_t));\n    int *c = (int *)malloc(n * sizeof(int));\n    int *distribution = (int *)malloc(10 * sizeof(int));\n    int *distribution_comparison = (int *)malloc(10 * sizeof(int));\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n    }\n    for (int x = 0; x < 10; ++x){\n        distribution[x] = 0;\n        distribution_comparison[x] = 0;\n    }\n\n    #pragma acc data copyin(a[0:n], b[0:n]) copy(distribution[0:10]) copyout(c[0:n])\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                #pragma acc atomic capture\n                    c[x] = distribution[(int) (a[x]*b[x]/10)]++;\n            }\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        distribution_comparison[(int) (a[x]*b[x]/10)]++;\n    }\n    for (int x = 0; x < 10; ++x){\n        if (distribution_comparison[x] != distribution[x]){\n            err += 1;\n            break;\n        }\n    }\n\n    bool found = false;\n    for (int x = 0; x < 10; ++x){\n        for (int y = 0; y < distribution_comparison[x]; ++y){\n            for (int z = 0; z < n; ++z){\n                if (c[z] == y && (int) (a[z]*b[z]/10) == x){\n                    found = true;\n                    break;\n                }\n            }\n            if (!found){\n                err++;\n            }\n            found = false;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "atomic",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_capture_predecrement.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:atomic,construct-independent,V:2.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t *a = (real_t *)malloc(n * sizeof(real_t));\n    real_t *b = (real_t *)malloc(n * sizeof(real_t));\n    int *c = (int *)malloc(n * sizeof(int));\n    int *distribution = (int *)malloc(10 * sizeof(int));\n    int *distribution_comparison = (int *)malloc(10 * sizeof(int));\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n    }\n    for (int x = 0; x < 10; ++x){\n        distribution[x] = 0;\n        distribution_comparison[x] = 0;\n    }\n\n    #pragma acc data copyin(a[0:n], b[0:n]) copy(distribution[0:10]) copyout(c[0:n])\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                #pragma acc atomic capture\n                    c[x] = --distribution[(int) (a[x]*b[x]/10)];\n            }\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        distribution_comparison[(int) (a[x]*b[x]/10)]--;\n    }\n    for (int x = 0; x < 10; ++x){\n        if (distribution_comparison[x] != distribution[x]){\n            err += 1;\n            break;\n        }\n    }\n\n    bool found = false;\n    for (int x = 0; x < 10; ++x){\n        for (int y = 0; y > distribution[x]; --y){\n            for (int z = 0; z < n; ++z){\n                if (c[z] == y - 1 && x == (int) (a[z] * b[z] / 10)){\n                    found = true;\n                    break;\n                }\n            }\n            if (!found){\n                err++;\n            }\n            found = false;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "atomic",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_capture_preincrement.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:atomic,construct-independent,V:2.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t *a = (real_t *)malloc(n * sizeof(real_t));\n    real_t *b = (real_t *)malloc(n * sizeof(real_t));\n    int *c = (int *)malloc(n * sizeof(int));\n    int *distribution = (int *)malloc(10 * sizeof(int));\n    int *distribution_comparison = (int *)malloc(10 * sizeof(int));\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n    }\n    for (int x = 0; x < 10; ++x){\n        distribution[x] = 0;\n        distribution_comparison[x] = 0;\n    }\n\n    #pragma acc data copyin(a[0:n], b[0:n]) copy(distribution[0:10]) copyout(c[0:n])\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                #pragma acc atomic capture\n                    c[x] = ++distribution[(int) (a[x]*b[x]/10)];\n            }\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        distribution_comparison[(int) (a[x]*b[x]/10)]++;\n    }\n    for (int x = 0; x < 10; ++x){\n        if (distribution_comparison[x] != distribution[x]){\n            err += 1;\n            break;\n        }\n    }\n\n    bool found = false;\n    for (int x = 0; x < 10; ++x){\n        for (int y = 0; y < distribution[x]; ++y){\n            for (int z = 0; z < n; ++z){\n                if (c[z] == y + 1 && x == (int) (a[z] * b[z] / 10)){\n                    found = true;\n                    break;\n                }\n            }\n            if (!found){\n                err++;\n            }\n            found = false;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "atomic",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_capture_rshift_equals.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:atomic,construct-independent,V:2.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    unsigned int *a = (unsigned int *)malloc(n * sizeof(int));\n    unsigned int *b = (unsigned int *)malloc(n * sizeof(int));\n    unsigned int *c = (unsigned int *)malloc(7 * n * sizeof(int));\n    unsigned int passed = 1<<8;\n\n    for (int x = 0; x < n; ++x){\n        a[x] = 1<<8;\n        for (int y = 0; y < 7; ++y){\n            if ((rand()/(real_t) (RAND_MAX)) > .5){\n                b[x] += 1<<y;\n            }\n        }\n    }\n\n    #pragma acc data copyin(b[0:n]) copy(a[0:n]) copyout(c[0:7*n])\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                #pragma acc loop\n                for (int y = 0; y < 7; ++y){\n                    c[x * 7 + y] = a[x];\n                    if ((b[x]>>y)%2 == 1){\n                        #pragma acc atomic capture\n                            c[x * 7 + y] = a[x] >>= 1;\n                    }\n                }\n            }\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        for (int y = 0; y < 7; ++y){\n            if ((b[x]>>y)%2 == 1){\n                a[x] <<= 1;\n            }\n        }\n        if (a[x] != 1<<8){\n            err += 1;\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        if (!is_possible(b[x], &(c[x * 7]), 7, passed)){\n            err++;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "atomic",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_capture_x_and_expr_assign.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:construct-independent,atomic,V:2.0-2.7\n      LOGICAL FUNCTION test1()\n  IMPLICIT NONE\n  INCLUDE \"acc_testsuite.Fh\"\n  INTEGER :: x, y !Iterators\n  REAL(8),DIMENSION(LOOPCOUNT, 10):: randoms\n  LOGICAL,DIMENSION(LOOPCOUNT, 10):: a, b !Data\n  LOGICAL,DIMENSION(10):: passed_a, passed_b\n  LOGICAL IS_POSSIBLE\n  LOGICAL,DIMENSION(LOOPCOUNT):: totals, totals_comparison\n  INTEGER :: errors = 0\n  LOGICAL :: init\n\n  !Initilization\n  SEEDDIM(1) = 1\n# ifdef SEED\n  SEEDDIM(1) = SEED\n# endif\n  CALL RANDOM_SEED(PUT=SEEDDIM)\n\n  CALL RANDOM_NUMBER(randoms)\n  DO x = 1, LOOPCOUNT\n    DO y = 1, 10\n      IF (randoms(x, y) < .933) THEN\n        a(x, y) = .TRUE.\n      ELSE\n        a(x, y) = .FALSE.\n      END IF\n    END DO\n  END DO\n\n  totals = .FALSE.\n  totals_comparison = .FALSE.\n\n  !$acc data copyin(a(1:LOOPCOUNT,1:10)) copy(totals(1:LOOPCOUNT)) copyout(b(1:LOOPCOUNT,1:10))\n    !$acc parallel\n      !$acc loop\n      DO x = 1, LOOPCOUNT\n        DO y = 1, 10\n          !$acc atomic capture\n            totals(x) = totals(x) .AND. a(x, y)\n            b(x, y) = totals(x)\n          !$acc end atomic\n        END DO\n      END DO\n    !$acc end parallel\n  !$acc end data\n\n  DO x = 1, LOOPCOUNT\n    DO y = 1, 10\n      totals_comparison(x) = totals_comparison(x) .AND. a(x, y)\n    END DO\n  END DO\n\n  DO x = 1, LOOPCOUNT\n    IF (totals_comparison(x) .NEQV. totals(x)) THEN\n      errors = errors + 1\n      WRITE(*, *) totals_comparison(x)\n    END IF\n  END DO\n\n  DO x = 1, LOOPCOUNT\n    DO y = 1, 10\n      passed_a(y) = a(x, y)\n      passed_b(y) = b(x, y)\n    END DO\n    init = .FALSE.\n    IF (.FALSE. .eqv. IS_POSSIBLE(a(x, 1:10), b(x, 1:10), 10, .FALSE.)) THEN\n      errors = errors + 1\n    END IF\n  END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "construct-independent",
                            "atomic"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_capture_x_divided_expr_assign.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:construct-independent,atomic,V:2.0-2.7\n      LOGICAL FUNCTION test1()\n  IMPLICIT NONE\n  INCLUDE \"acc_testsuite.Fh\"\n  INTEGER :: x, y !Iterators\n  REAL(8),DIMENSION(LOOPCOUNT, 10):: a !Data\n  REAL(8),DIMENSION(LOOPCOUNT, 10):: b\n  REAL(8),DIMENSION(LOOPCOUNT):: totals\n  REAL(8),DIMENSION(10):: passed\n  REAL(8),DIMENSION(10):: passed_b\n  REAL(8) :: holder\n  INTEGER :: errors = 0\n  LOGICAL IS_POSSIBLE\n  LOGICAL IS_POSSIBLE_2\n\n  !Initilization\n  SEEDDIM(1) = 1\n# ifdef SEED\n  SEEDDIM(1) = SEED\n# endif\n  CALL RANDOM_SEED(PUT=SEEDDIM)\n\n  CALL RANDOM_NUMBER(a)\n\n  totals = 1\n\n  !$acc data copyin(a(1:LOOPCOUNT, 1:10)) copy(totals(1:LOOPCOUNT)) copyout(b(1:LOOPCOUNT,1:10))\n    !$acc parallel\n      !$acc loop\n      DO x = 1, LOOPCOUNT\n        DO y = 1, 10\n          !$acc atomic capture\n            totals(x) = totals(x) / a(x, y)\n            b(x, y) = totals(x)\n          !$acc end atomic\n        END DO\n      END DO\n    !$acc end parallel\n  !$acc end data\n\n  DO x = 1, LOOPCOUNT\n    DO y = 1, 10\n      passed(y) = a(x, y)\n    END DO\n    holder = 1\n    IF (IS_POSSIBLE(passed, totals(x), 10, holder) .eqv. .FALSE.) THEN\n      errors = errors + 1\n    END IF\n  END DO\n\n  DO x = 1, LOOPCOUNT\n    DO y = 1, 10\n      passed(y) = a(x, y)\n      passed_b(y) = b(x, y)\n    END DO\n    holder = 1\n    IF (IS_POSSIBLE_2(passed, passed_b, 10, holder) .eqv. .FALSE.) THEN\n      errors = errors + 1\n    END IF\n  END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "construct-independent",
                            "atomic"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_capture_x_eqv_expr_assign.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:construct-independent,atomic,V:2.0-2.7\n      LOGICAL FUNCTION test1()\n  IMPLICIT NONE\n  INCLUDE \"acc_testsuite.Fh\"\n  INTEGER :: x, y !Iterators\n  REAL(8),DIMENSION(LOOPCOUNT, 10):: randoms\n  LOGICAL,DIMENSION(LOOPCOUNT, 10):: a, b !Data\n  LOGICAL,DIMENSION(LOOPCOUNT):: totals, totals_comparison\n  LOGICAL,DIMENSION(10):: passed_a, passed_b\n  LOGICAL:: init\n  INTEGER :: errors = 0\n  LOGICAL IS_POSSIBLE\n\n  !Initilization\n  SEEDDIM(1) = 1\n# ifdef SEED\n  SEEDDIM(1) = SEED\n# endif\n  CALL RANDOM_SEED(PUT=SEEDDIM)\n\n  CALL RANDOM_NUMBER(randoms)\n  DO x = 1, LOOPCOUNT\n    DO y = 1, 10\n      IF (randoms(x, y) > .5) THEN\n        a(x, y) = .TRUE.\n      ELSE\n        a(x, y) = .FALSE.\n      END IF\n    END DO\n  END DO\n\n  totals = .FALSE.\n  totals_comparison = .FALSE.\n\n  !$acc data copyin(a(1:LOOPCOUNT,1:10)) copy(totals(1:LOOPCOUNT)) copyout(b(1:LOOPCOUNT,1:10))\n    !$acc parallel\n      !$acc loop\n      DO x = 1, LOOPCOUNT\n        DO y = 1, 10\n          !$acc atomic capture\n            totals(x) = totals(x) .EQV. a(x, y)\n            b(x, y) = totals(x)\n          !$acc end atomic\n        END DO\n      END DO\n    !$acc end parallel\n  !$acc end data\n\n  DO x = 1, LOOPCOUNT\n    DO y = 1, 10\n      totals_comparison(x) = totals_comparison(x) .EQV. a(x, y)\n    END DO\n  END DO\n\n  DO x = 1, LOOPCOUNT\n    DO y = 1, 10\n      passed_a(y) = a(x, y)\n      passed_b(y) = b(x, y)\n    END DO\n    init = .FALSE.\n    IF (IS_POSSIBLE(passed_a, passed_b, 10, init) .EQV. .FALSE.) THEN\n      errors = errors + 1\n    END IF\n  END DO\n\n  DO x = 1, LOOPCOUNT\n    IF (totals_comparison(x) .NEQV. totals(x)) THEN\n      errors = errors + 1\n      WRITE(*, *) totals_comparison(x)\n    END IF\n  END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "construct-independent",
                            "atomic"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_capture_x_minus_expr_assign.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:construct-independent,atomic,V:2.0-2.7\n      LOGICAL FUNCTION test1()\n  IMPLICIT NONE\n  INCLUDE \"acc_testsuite.Fh\"\n  INTEGER :: x, y !Iterators\n  LOGICAL IS_POSSIBLE\n  LOGICAL IS_POSSIBLE_2\n  REAL(8),DIMENSION(LOOPCOUNT, 10):: a, b !Data\n  REAL(8),DIMENSION(LOOPCOUNT):: totals\n  REAL(8),DIMENSION(10):: passed_a, passed_b\n  REAL(8):: init\n  INTEGER :: errors = 0\n\n  !Initilization\n  SEEDDIM(1) = 1\n# ifdef SEED\n  SEEDDIM(1) = SEED\n# endif\n  CALL RANDOM_SEED(PUT=SEEDDIM)\n\n  CALL RANDOM_NUMBER(a)\n\n  totals = 0\n\n  !$acc data copyin(a(1:LOOPCOUNT, 1:10)) copy(totals(1:LOOPCOUNT)) copyout(b(1:LOOPCOUNT, 1:10))\n    !$acc parallel\n      !$acc loop\n      DO x = 1, LOOPCOUNT\n        DO y = 1, 10\n          !$acc atomic capture\n            totals(x) = totals(x) - a(x, y)\n            b(x, y) = totals(x)\n          !$acc end atomic\n        END DO\n      END DO\n    !$acc end parallel\n  !$acc end data\n\n  DO x = 1, LOOPCOUNT\n    DO y = 1, 10\n      passed_a(y) = a(x, y)\n    END DO\n    IF (IS_POSSIBLE(passed_a, totals(x), 10, 0) .eqv. .FALSE.) THEN\n      errors = errors + 1\n    END IF\n  END DO\n\n  DO x = 1, LOOPCOUNT\n    DO y = 1, 10\n      passed_a(y) = a(x, y)\n      passed_b(y) = b(x, y)\n    END DO\n    init = 0\n    IF (IS_POSSIBLE_2(passed_a, passed_b, 10, init) .EQV. .FALSE.) THEN\n      errors = errors + 1\n    END IF\n  END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "construct-independent",
                            "atomic"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_capture_x_neqv_expr_assign.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:construct-independent,atomic,V:2.0-2.7\n      LOGICAL FUNCTION test1()\n  IMPLICIT NONE\n  INCLUDE \"acc_testsuite.Fh\"\n  INTEGER :: x, y !Iterators\n  REAL(8),DIMENSION(LOOPCOUNT, 10):: randoms\n  LOGICAL,DIMENSION(LOOPCOUNT, 10):: a, b !Data\n  LOGICAL,DIMENSION(10):: passed_a, passed_b\n  LOGICAL,DIMENSION(LOOPCOUNT):: totals, totals_comparison\n  LOGICAL IS_POSSIBLE\n  INTEGER :: errors = 0\n\n  !Initilization\n  SEEDDIM(1) = 1\n# ifdef SEED\n  SEEDDIM(1) = SEED\n# endif\n  CALL RANDOM_SEED(PUT=SEEDDIM)\n\n  CALL RANDOM_NUMBER(randoms)\n  DO x = 1, LOOPCOUNT\n    DO y = 1, 10\n      IF (randoms(x, y) > .5) THEN\n        a(x, y) = .TRUE.\n      ELSE\n        a(x, y) = .FALSE.\n      END IF\n    END DO\n  END DO\n\n  totals = .FALSE.\n  totals_comparison = .FALSE.\n\n  !$acc data copyin(a(1:LOOPCOUNT,1:10)) copy(totals(1:LOOPCOUNT)) copyout(b(1:LOOPCOUNT,1:10))\n    !$acc parallel\n      !$acc loop\n      DO x = 1, LOOPCOUNT\n        DO y = 1, 10\n          !$acc atomic capture\n            totals(x) = totals(x) .NEQV. a(x, y)\n            b(x, y) = totals(x)\n          !$acc end atomic\n        END DO\n      END DO\n    !$acc end parallel\n  !$acc end data\n\n  DO x = 1, LOOPCOUNT\n    DO y = 1, 10\n      totals_comparison(x) = totals_comparison(x) .NEQV. a(x, y)\n    END DO\n  END DO\n\n  DO x = 1, LOOPCOUNT\n    IF (totals_comparison(x) .NEQV. totals(x)) THEN\n      errors = errors + 1\n      WRITE(*, *) totals_comparison(x)\n    END IF\n  END DO\n\n  DO x = 1, LOOPCOUNT\n    DO y = 1, 10\n      passed_a(y) = a(x, y)\n      passed_b(y) = b(x, y)\n    END DO\n    IF (IS_POSSIBLE(passed_a, passed_b, 10, .FALSE.) .eqv. .FALSE.) THEN\n      errors = errors + 1\n    END IF\n  END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "construct-independent",
                            "atomic"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_capture_x_or_expr_assign.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:construct-independent,atomic,V:2.0-2.7\n      LOGICAL FUNCTION test1()\n  IMPLICIT NONE\n  INCLUDE \"acc_testsuite.Fh\"\n  INTEGER :: x, y !Iterators\n  REAL(8),DIMENSION(LOOPCOUNT, 10):: randoms\n  LOGICAL,DIMENSION(LOOPCOUNT, 10):: a, b !Data\n  LOGICAL,DIMENSION(LOOPCOUNT):: totals, totals_comparison\n  LOGICAL,DIMENSION(10):: passed_a, passed_b\n  LOGICAL IS_POSSIBLE\n  LOGICAL:: init\n  INTEGER :: errors = 0\n\n  !Initilization\n  SEEDDIM(1) = 1\n# ifdef SEED\n  SEEDDIM(1) = SEED\n# endif\n  CALL RANDOM_SEED(PUT=SEEDDIM)\n\n  CALL RANDOM_NUMBER(randoms)\n  DO x = 1, LOOPCOUNT\n    DO y = 1, 10\n      IF (randoms(x, y) > .933) THEN\n        a(x, y) = .TRUE.\n      ELSE\n        a(x, y) = .FALSE.\n      END IF\n    END DO\n  END DO\n\n  totals = .FALSE.\n  totals_comparison = .FALSE.\n\n  !$acc data copyin(a(1:LOOPCOUNT,1:10)) copy(totals(1:LOOPCOUNT)) copyout(b(1:LOOPCOUNT,1:10))\n    !$acc parallel\n      !$acc loop\n      DO x = 1, LOOPCOUNT\n        DO y = 1, 10\n          !$acc atomic capture\n            totals(x) = totals(x) .OR. a(x, y)\n            b(x, y) = totals(x)\n          !$acc end atomic\n        END DO\n      END DO\n    !$acc end parallel\n  !$acc end data\n\n  DO x = 1, LOOPCOUNT\n    DO y = 1, 10\n      totals_comparison(x) = totals_comparison(x) .OR. a(x, y)\n    END DO\n  END DO\n\n  DO x = 1, LOOPCOUNT\n    IF (totals_comparison(x) .NEQV. totals(x)) THEN\n      errors = errors + 1\n      WRITE(*, *) totals_comparison(x)\n    END IF\n  END DO\n\n  DO x = 1, LOOPCOUNT\n    DO y = 1, 10\n      passed_a(y) = a(x, y)\n      passed_b(y) = b(x, y)\n    END DO\n    init = .FALSE.\n    IF (IS_POSSIBLE(passed_a, passed_b, 10, init) .eqv. .FALSE.) THEN\n      errors = errors + 1\n    END IF\n  END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "construct-independent",
                            "atomic"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_capture_x_plus_expr_assign.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:construct-independent,atomic,V:2.0-2.7\n      LOGICAL FUNCTION test1()\n  IMPLICIT NONE\n  INCLUDE \"acc_testsuite.Fh\"\n  INTEGER :: x, y !Iterators\n  REAL(8),DIMENSION(LOOPCOUNT, 10):: a, b !Data\n  REAL(8),DIMENSION(LOOPCOUNT):: totals, totals_comparison\n  REAL(8),DIMENSION(10):: passed_a, passed_b\n  REAL(8):: init\n  LOGICAL IS_POSSIBLE\n  INTEGER :: errors = 0\n\n  !Initilization\n  SEEDDIM(1) = 1\n# ifdef SEED\n  SEEDDIM(1) = SEED\n# endif\n  CALL RANDOM_SEED(PUT=SEEDDIM)\n\n  CALL RANDOM_NUMBER(a)\n\n  totals = 0\n  totals_comparison = 0\n\n  !$acc data copyin(a(1:LOOPCOUNT, 1:10)) copy(totals(1:LOOPCOUNT)) copyout(b(1:LOOPCOUNT,1:10))\n    !$acc parallel\n      !$acc loop\n      DO x = 1, LOOPCOUNT\n        DO y = 1, 10\n          !$acc atomic capture\n            totals(x) = totals(x) + a(x, y)\n            b(x, y) = totals(x)\n          !$acc end atomic\n        END DO\n      END DO\n    !$acc end parallel\n  !$acc end data\n  DO x = 1, LOOPCOUNT\n    DO y = 1, 10\n      totals_comparison(x) = totals_comparison(x) + a(x, y)\n    END DO\n  END DO\n\n  DO x = 1, LOOPCOUNT\n    IF (totals_comparison(x) .NE. totals(x)) THEN\n      errors = errors + 1\n      WRITE(*, *) totals_comparison(x)\n    END IF\n  END DO\n\n  DO x = 1, LOOPCOUNT\n    DO y = 1, 10\n      passed_a(y) = a(x, y)\n      passed_b(y) = b(x, y)\n    END DO\n    init = 0\n    IF (IS_POSSIBLE(passed_a, passed_b, 10, init) .eqv. .FALSE.) THEN\n      errors = errors + 1\n    END IF\n  END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "construct-independent",
                            "atomic"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_capture_x_times_expr_assign.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:construct-independent,atomic,V:2.0-2.7\n      LOGICAL FUNCTION test1()\n  IMPLICIT NONE\n  INCLUDE \"acc_testsuite.Fh\"\n  INTEGER :: x, y !Iterators\n  REAL(8),DIMENSION(LOOPCOUNT, 10):: a, b !Data\n  REAL(8),DIMENSION(LOOPCOUNT):: totals, totals_comparison\n  REAL(8),DIMENSION(10):: passed_a, passed_b\n  REAL(8):: init\n  LOGICAL IS_POSSIBLE\n  INTEGER :: errors = 0\n\n  !Initilization\n  SEEDDIM(1) = 1\n# ifdef SEED\n  SEEDDIM(1) = SEED\n# endif\n  CALL RANDOM_SEED(PUT=SEEDDIM)\n\n  CALL RANDOM_NUMBER(a)\n\n  totals = 1\n  totals_comparison = 1\n\n  !$acc data copyin(a(1:LOOPCOUNT, 1:10)) copy(totals(1:LOOPCOUNT)) copyout(b(1:LOOPCOUNT,1:10))\n    !$acc parallel\n      !$acc loop\n      DO x = 1, LOOPCOUNT\n        DO y = 1, 10\n          !$acc atomic capture\n            totals(x) = totals(x) * a(x, y)\n            b(x, y) = totals(x)\n          !$acc end atomic\n        END DO\n      END DO\n    !$acc end parallel\n  !$acc end data\n  DO x = 1, LOOPCOUNT\n    DO y = 1, 10\n      totals_comparison(x) = totals_comparison(x) * a(x, y)\n    END DO\n  END DO\n\n  DO x = 1, LOOPCOUNT\n    IF (totals_comparison(x) .NE. totals(x)) THEN\n      errors = errors + 1\n      WRITE(*, *) totals_comparison(x)\n    END IF\n  END DO\n\n  DO x = 1, LOOPCOUNT\n    DO y = 1, 10\n      passed_a(y) = a(x, y)\n      passed_b(y) = b(x, y)\n    END DO\n    init = 1\n    IF (IS_POSSIBLE(passed_a, passed_b, 10, init) .eqv. .TRUE.) THEN\n      errors = errors + 1\n    END IF\n  END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "construct-independent",
                            "atomic"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_divided_equals.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:atomic,construct-independent,V:2.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t *a = (real_t *)malloc(n * sizeof(real_t));\n    real_t *b = (real_t *)malloc(n * sizeof(real_t));\n    real_t *totals = (real_t *)malloc((n/10 + 1) * sizeof(real_t));\n    real_t *totals_comparison = (real_t *)malloc((n/10 + 1) * sizeof(real_t));\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n    }\n    for (int x = 0; x < n/10 + 1; ++x){\n        totals[x] = 1;\n        totals_comparison[x] = 1;\n    }\n\n    #pragma acc data copyin(a[0:n], b[0:n]) copy(totals[0:n/10 + 1])\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                #pragma acc atomic\n                    totals[x%(n/10 + 1)] /= (a[x] + b[x]);\n            }\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        totals_comparison[x%(n/10 + 1)] /= a[x] + b[x];\n    }\n    for (int x = 0; x < 10; ++x){\n        if (fabs(totals_comparison[x] - totals[x]) > PRECISION){\n            err += 1;\n            break;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "atomic",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_expr_and_x.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:construct-independent,atomic,V:2.0-2.7\n      LOGICAL FUNCTION test1()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x, y !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT, 10):: randoms\n        LOGICAL,DIMENSION(LOOPCOUNT, 10):: a !Data\n        LOGICAL,DIMENSION(LOOPCOUNT):: totals, totals_comparison\n        INTEGER :: errors = 0\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(randoms)\n        DO x = 1, LOOPCOUNT\n          DO y = 1, 10\n            IF (randoms(x, y) < .933) THEN\n              a(x, y) = .TRUE.\n            ELSE\n              a(x, y) = .FALSE.\n            END IF\n          END DO\n        END DO\n\n        totals = .FALSE.\n        totals_comparison = .FALSE.\n\n        !$acc data copyin(a(1:LOOPCOUNT,1:10)) copy(totals(1:LOOPCOUNT))\n          !$acc parallel\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              DO y = 1, 10\n                !$acc atomic\n                  totals(x) = a(x, y) .AND. totals(x)\n              END DO\n            END DO\n          !$acc end parallel\n        !$acc end data\n\n        DO x = 1, LOOPCOUNT\n          DO y = 1, 10\n            totals_comparison(x) = totals_comparison(x) .AND. a(x, y)\n          END DO\n        END DO\n\n        DO x = 1, LOOPCOUNT\n          IF (totals_comparison(x) .NEQV. totals(x)) THEN\n            errors = errors + 1\n            WRITE(*, *) totals_comparison(x)\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "construct-independent",
                            "atomic"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_expr_and_x_end.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:construct-independent,atomic,V:2.0-2.7\n      LOGICAL FUNCTION test1()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x, y !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT, 10):: randoms\n        LOGICAL,DIMENSION(LOOPCOUNT, 10):: a !Data\n        LOGICAL,DIMENSION(LOOPCOUNT):: totals, totals_comparison\n        INTEGER :: errors = 0\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(randoms)\n        DO x = 1, LOOPCOUNT\n          DO y = 1, 10\n            IF (randoms(x, y) < .933) THEN\n              a(x, y) = .TRUE.\n            ELSE\n              a(x, y) = .FALSE.\n            END IF\n          END DO\n        END DO\n\n        totals = .FALSE.\n        totals_comparison = .FALSE.\n\n        !$acc data copyin(a(1:LOOPCOUNT,1:10)) copy(totals(1:LOOPCOUNT))\n          !$acc parallel\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              DO y = 1, 10\n                !$acc atomic\n                  totals(x) = a(x, y) .AND. totals(x)\n                !$acc end atomic\n              END DO\n            END DO\n          !$acc end parallel\n        !$acc end data\n\n        DO x = 1, LOOPCOUNT\n          DO y = 1, 10\n            totals_comparison(x) = totals_comparison(x) .AND. a(x, y)\n          END DO\n        END DO\n\n        DO x = 1, LOOPCOUNT\n          IF (totals_comparison(x) .NEQV. totals(x)) THEN\n            errors = errors + 1\n            WRITE(*, *) totals_comparison(x)\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "construct-independent",
                            "atomic"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_expr_bitand_x.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:atomic,construct-independent,V:2.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    int  *a = (int *)malloc(n * sizeof(int));\n    int *totals = (int *)malloc((n/10 + 1) * sizeof(int));\n    int *totals_comparison = (int *)malloc((n/10 + 1) * sizeof(int));\n\n    for (int x = 0; x < n; ++x){\n        for (int y = 0; y < 8; ++y){\n            if (rand()/(real_t)(RAND_MAX) < .933){ //.933 gets close to a 50/50 distribution for a collescence of 10 values\n                a[x] += 1<<y;\n            }\n        }\n    }\n    for (int x = 0; x < n/10 + 1; ++x){\n        for (int y = 0; y < 8; ++y){\n            totals[x] +=  1<<y;\n            totals_comparison[x] += 1<<y;\n        }\n\n    }\n\n    #pragma acc data copyin(a[0:n]) copy(totals[0:n/10 + 1])\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                #pragma acc atomic\n                    totals[x%(n/10 + 1)] = a[x] & totals[x%(n/10 + 1)];\n            }\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        totals_comparison[x%(n/10 + 1)] &= a[x];\n    }\n    for (int x = 0; x < 10; ++x){\n        if (fabs(totals_comparison[x] - totals[x]) > PRECISION){\n            err += 1;\n            break;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "atomic",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_expr_bitor_x.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:atomic,construct-independent,V:2.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    int  *a = (int *)malloc(n * sizeof(int));\n    int *totals = (int *)malloc((n/10 + 1) * sizeof(int));\n    int *totals_comparison = (int *)malloc((n/10 + 1) * sizeof(int));\n\n    for (int x = 0; x < n; ++x){\n        for (int y = 0; y < 8; ++y){\n            if (rand()/(real_t)(RAND_MAX) > .933){ //.933 gets close to a 50/50 distribution for a collescence of 10 values\n                a[x] += 1<<y;\n            }\n        }\n    }\n    for (int x = 0; x < n/10 + 1; ++x){\n        totals[x] = 0;\n\n    }\n\n    #pragma acc data copyin(a[0:n]) copy(totals[0:n/10 + 1])\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                #pragma acc atomic\n                    totals[x%(n/10 + 1)] = totals[x%(n/10 + 1)] | a[x];\n            }\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        totals_comparison[x%(n/10 + 1)] |= a[x];\n    }\n    for (int x = 0; x < 10; ++x){\n        if (fabs(totals_comparison[x] - totals[x]) > PRECISION){\n            err += 1;\n            break;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "atomic",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_expr_bitxor_x.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:atomic,construct-independent,V:2.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    int  *a = (int *)malloc(n * sizeof(int));\n    int *totals = (int *)malloc((n/10 + 1) * sizeof(int));\n    int *totals_comparison = (int *)malloc((n/10 + 1) * sizeof(int));\n\n    for (int x = 0; x < n; ++x){\n        for (int y = 0; y < 8; ++y){\n            if (rand()/(real_t)(RAND_MAX) > .5){\n                a[x] += 1<<y;\n            }\n        }\n    }\n    for (int x = 0; x < n/10 + 1; ++x){\n        totals[x] = 0;\n        totals_comparison[x] = 0;\n    }\n\n    #pragma acc data copyin(a[0:n]) copy(totals[0:n/10 + 1])\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                #pragma acc atomic\n                    totals[x%(n/10 + 1)] = a[x] ^ totals[x%(n/10 + 1)];\n            }\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        totals_comparison[x%(n/10 + 1)] ^= a[x];\n    }\n    for (int x = 0; x < 10; ++x){\n        if (fabs(totals_comparison[x] - totals[x]) > PRECISION){\n            err += 1;\n            break;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "atomic",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_expr_divided_x.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:construct-independent,atomic,V:2.0-2.7\n      LOGICAL FUNCTION test1()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x, y !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT, 10):: a !Data\n        REAL(8),DIMENSION(LOOPCOUNT):: totals\n        REAL(8),DIMENSION(10):: passed\n        INTEGER :: errors = 0\n        LOGICAL IS_POSSIBLE\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(a)\n\n        totals = 1\n\n        !$acc data copyin(a(1:LOOPCOUNT, 1:10)) copy(totals(1:LOOPCOUNT))\n          !$acc parallel\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              DO y = 1, 10\n                !$acc atomic\n                  totals(x) = a(x, y) / totals(x)\n              END DO\n            END DO\n          !$acc end parallel\n        !$acc end data\n\n\n        DO x = 1, LOOPCOUNT\n          DO y = 1, 10\n            passed(y) = a(x, y)\n          END DO\n          IF (IS_POSSIBLE(passed, totals(x), 10, 1) .eqv. .FALSE.) THEN\n            errors = errors + 1\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "construct-independent",
                            "atomic"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_expr_divided_x.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:atomic,construct-independent,V:2.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t *a = (real_t *)malloc(n * sizeof(real_t));\n    real_t *b = (real_t *)malloc(n * sizeof(real_t));\n    real_t *totals = (real_t *)malloc((n/10 + 1) * sizeof(real_t));\n    real_t * passed = (real_t *)malloc(10 * sizeof(real_t));\n    int indexer;\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n    }\n    for (int x = 0; x < n/10 + 1; ++x){\n        totals[x] = 1;\n    }\n\n    #pragma acc data copyin(a[0:n], b[0:n]) copy(totals[0:n/10 + 1])\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                #pragma acc atomic\n                    totals[x%(n/10 + 1)] = (a[x] + b[x]) / totals[x%(n/10 + 1)];\n            }\n        }\n    }\n\n\n    for (int x = 0; x < (n/10 + 1); ++x){\n        indexer = x;\n        while (indexer < n){\n            passed[indexer/(n/10 + 1)] = (a[x] + b[x]);\n            indexer += (n/10 + 1);\n        }\n        if (!(possible_result(passed, 10, 1, totals[x]))){\n            err += 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "atomic",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_expr_divided_x_end.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:construct-independent,atomic,V:2.0-2.7\n      LOGICAL FUNCTION test1()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x, y !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT, 10):: a !Data\n        REAL(8),DIMENSION(LOOPCOUNT):: totals\n        REAL(8),DIMENSION(10):: passed\n        INTEGER :: errors = 0\n        LOGICAL IS_POSSIBLE\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(a)\n\n        totals = 1\n\n        !$acc data copyin(a(1:LOOPCOUNT, 1:10)) copy(totals(1:LOOPCOUNT))\n          !$acc parallel\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              DO y = 1, 10\n                !$acc atomic\n                  totals(x) = a(x, y) / totals(x)\n                !$acc end atomic\n              END DO\n            END DO\n          !$acc end parallel\n        !$acc end data\n\n\n        DO x = 1, LOOPCOUNT\n          DO y = 1, 10\n            passed(y) = a(x, y)\n          END DO\n          IF (IS_POSSIBLE(passed, totals(x), 10, 1) .eqv. .FALSE.) THEN\n            errors = errors + 1\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "construct-independent",
                            "atomic"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_expr_eqv_x.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:construct-independent,atomic,V:2.0-2.7\n      LOGICAL FUNCTION test1()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x, y !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT, 10):: randoms\n        LOGICAL,DIMENSION(LOOPCOUNT, 10):: a !Data\n        LOGICAL,DIMENSION(LOOPCOUNT):: totals, totals_comparison\n        INTEGER :: errors = 0\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(randoms)\n        DO x = 1, LOOPCOUNT\n          DO y = 1, 10\n            IF (randoms(x, y) > .5) THEN\n              a(x, y) = .TRUE.\n            ELSE\n              a(x, y) = .FALSE.\n            END IF\n          END DO\n        END DO\n\n        totals = .FALSE.\n        totals_comparison = .FALSE.\n\n        !$acc data copyin(a(1:LOOPCOUNT,1:10)) copy(totals(1:LOOPCOUNT))\n          !$acc parallel\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              DO y = 1, 10\n                !$acc atomic\n                  totals(x) = a(x, y) .EQV. totals(x)\n              END DO\n            END DO\n          !$acc end parallel\n        !$acc end data\n\n        DO x = 1, LOOPCOUNT\n          DO y = 1, 10\n            totals_comparison(x) = totals_comparison(x) .EQV. a(x, y)\n          END DO\n        END DO\n\n        DO x = 1, LOOPCOUNT\n          IF (totals_comparison(x) .NEQV. totals(x)) THEN\n            errors = errors + 1\n            WRITE(*, *) totals_comparison(x)\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "construct-independent",
                            "atomic"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_expr_eqv_x_end.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:construct-independent,atomic,V:2.0-2.7\n      LOGICAL FUNCTION test1()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x, y !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT, 10):: randoms\n        LOGICAL,DIMENSION(LOOPCOUNT, 10):: a !Data\n        LOGICAL,DIMENSION(LOOPCOUNT):: totals, totals_comparison\n        INTEGER :: errors = 0\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(randoms)\n        DO x = 1, LOOPCOUNT\n          DO y = 1, 10\n            IF (randoms(x, y) > .5) THEN\n              a(x, y) = .TRUE.\n            ELSE\n              a(x, y) = .FALSE.\n            END IF\n          END DO\n        END DO\n\n        totals = .FALSE.\n        totals_comparison = .FALSE.\n\n        !$acc data copyin(a(1:LOOPCOUNT,1:10)) copy(totals(1:LOOPCOUNT))\n          !$acc parallel\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              DO y = 1, 10\n                !$acc atomic\n                  totals(x) = a(x, y) .EQV. totals(x)\n                !$acc end atomic\n              END DO\n            END DO\n          !$acc end parallel\n        !$acc end data\n\n        DO x = 1, LOOPCOUNT\n          DO y = 1, 10\n            totals_comparison(x) = totals_comparison(x) .EQV. a(x, y)\n          END DO\n        END DO\n\n        DO x = 1, LOOPCOUNT\n          IF (totals_comparison(x) .NEQV. totals(x)) THEN\n            errors = errors + 1\n            WRITE(*, *) totals_comparison(x)\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "construct-independent",
                            "atomic"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_expr_lshift_x.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:atomic,construct-independent,V:2.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    unsigned int *a = (unsigned int *)malloc(3 * n * sizeof(int));\n    unsigned int *b = (unsigned int *)malloc(n * sizeof(int));\n    int orders[18] = {1, 2, 0, 1, 0, 2, 2, 1, 0, 2, 0, 1, 0, 1, 2, 0, 2, 1};\n    int result;\n\n    for (int x = 0; x < n; ++x){\n        for (int y = 0; y < 3; ++y){\n            a[x * 3 + y] = (int) (rand() / (unsigned int) (RAND_MAX / 4));\n        }\n        b[x] = 0;\n    }\n\n    #pragma acc data copyin(a[0:3 * n]) copy(b[0:n])\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                #pragma acc loop\n                for (int y = 0; y < 3; ++y){\n                    #pragma acc atomic\n                        b[x] = a[x * 3 + y] << b[x];\n                }\n            }\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        for (int y = 0; y < 6; ++y){\n            result = 0;\n            for (int z = 0; z < 3; ++z){\n                result = a[x * 3 + orders[y * 3 + z]] << result;\n            }\n            if (result == b[x]){\n                break;\n            }\n        }\n        if (result != b[x]){\n            err += 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "atomic",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_expr_minus_x.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:construct-independent,atomic,V:2.0-2.7\n      LOGICAL FUNCTION test1()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x, y !Iterators\n        LOGICAL IS_POSSIBLE\n        REAL(8),DIMENSION(LOOPCOUNT, 10):: a !Data\n        REAL(8),DIMENSION(LOOPCOUNT):: totals\n        INTEGER :: errors = 0\n        REAL(8),DIMENSION(10):: passed\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(a)\n\n        totals = 0\n\n        !$acc data copyin(a(1:LOOPCOUNT, 1:10)) copy(totals(1:LOOPCOUNT))\n          !$acc parallel\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              DO y = 1, 10\n                !$acc atomic\n                  totals(x) = a(x, y) - totals(x)\n              END DO\n            END DO\n          !$acc end parallel\n        !$acc end data\n\n        DO x = 1, LOOPCOUNT\n          DO y = 1, 10\n            passed(y) = a(x, y)\n          END DO\n          IF (IS_POSSIBLE(passed, totals(x), 10, 0) .eqv. .FALSE.) THEN\n            errors = errors + 1\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "construct-independent",
                            "atomic"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_expr_minus_x.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:atomic,construct-independent,V:2.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t *a = (real_t *)malloc(n * sizeof(real_t));\n    real_t *totals = (real_t *)malloc(((n/10) + 1) * sizeof(real_t));\n    int indexer = 0;\n    real_t * passed = (real_t *)malloc(10 * sizeof(real_t));\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n    }\n    for (int x = 0; x < (n/10) + 1; ++x){\n        totals[x] = 0;\n    }\n\n    #pragma acc data copyin(a[0:n]) copy(totals[0:(n/10) + 1])\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                #pragma acc atomic\n                    totals[x%((int) (n/10) + 1)] = a[x] - totals[x%((int) (n/10) + 1)];\n            }\n        }\n    }\n    for (int x = 0; x < (n/10) + 1; ++x){\n        indexer = x;\n        while (indexer < n){\n            passed[indexer/((int) (n/10) + 1)] = a[indexer];\n            indexer += (n/10) + 1;\n        }\n        if (!(possible_result(passed, 10, 0, totals[x]))){\n            err += 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "atomic",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_expr_minus_x_end.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:construct-independent,atomic,V:2.0-2.7\n      LOGICAL FUNCTION test1()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x, y !Iterators\n        LOGICAL IS_POSSIBLE\n        REAL(8),DIMENSION(LOOPCOUNT, 10):: a !Data\n        REAL(8),DIMENSION(LOOPCOUNT):: totals\n        INTEGER :: errors = 0\n        REAL(8),DIMENSION(10):: passed\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(a)\n\n        totals = 0\n\n        !$acc data copyin(a(1:LOOPCOUNT, 1:10)) copy(totals(1:LOOPCOUNT))\n          !$acc parallel\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              DO y = 1, 10\n                !$acc atomic\n                  totals(x) = a(x, y) - totals(x)\n                !$acc end atomic\n              END DO\n            END DO\n          !$acc end parallel\n        !$acc end data\n\n        DO x = 1, LOOPCOUNT\n          DO y = 1, 10\n            passed(y) = a(x, y)\n          END DO\n          IF (IS_POSSIBLE(passed, totals(x), 10, 0) .eqv. .FALSE.) THEN\n            errors = errors + 1\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "construct-independent",
                            "atomic"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_expr_multiply_x.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:atomic,construct-independent,V:2.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t *a = (real_t *)malloc(n * sizeof(real_t));\n    real_t *b = (real_t *)malloc(n * sizeof(real_t));\n    real_t *totals = (real_t *)malloc((n/10 + 1) * sizeof(real_t));\n    real_t *totals_comparison = (real_t *)malloc((n/10 + 1) * sizeof(real_t));\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n    }\n    for (int x = 0; x < n/10 + 1; ++x){\n        totals[x] = 1;\n        totals_comparison[x] = 1;\n    }\n\n    #pragma acc data copyin(a[0:n], b[0:n]) copy(totals[0:n/10 + 1])\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                #pragma acc atomic\n                    totals[x%(n/10 + 1)] = (a[x] + b[x]) * totals[x%(n/10 + 1)];\n            }\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        totals_comparison[x%(n/10 + 1)] *= a[x] + b[x];\n    }\n    for (int x = 0; x < 10; ++x){\n        if (fabs(totals_comparison[x] - totals[x]) > PRECISION * totals_comparison[x]){\n            err += 1;\n            break;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "atomic",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_expr_neqv_x.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:construct-independent,atomic,V:2.0-2.7\n      LOGICAL FUNCTION test1()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x, y !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT, 10):: randoms\n        LOGICAL,DIMENSION(LOOPCOUNT, 10):: a !Data\n        LOGICAL,DIMENSION(LOOPCOUNT):: totals, totals_comparison\n        INTEGER :: errors = 0\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(randoms)\n        DO x = 1, LOOPCOUNT\n          DO y = 1, 10\n            IF (randoms(x, y) > .5) THEN\n              a(x, y) = .TRUE.\n            ELSE\n              a(x, y) = .FALSE.\n            END IF\n          END DO\n        END DO\n\n        totals = .FALSE.\n        totals_comparison = .FALSE.\n\n        !$acc data copyin(a(1:LOOPCOUNT,1:10)) copy(totals(1:LOOPCOUNT))\n          !$acc parallel\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              DO y = 1, 10\n                !$acc atomic\n                  totals(x) = a(x, y) .NEQV. totals(x)\n              END DO\n            END DO\n          !$acc end parallel\n        !$acc end data\n\n        DO x = 1, LOOPCOUNT\n          DO y = 1, 10\n            totals_comparison(x) = totals_comparison(x) .NEQV. a(x, y)\n          END DO\n        END DO\n\n        DO x = 1, LOOPCOUNT\n          IF (totals_comparison(x) .NE. totals(x)) THEN\n            errors = errors + 1\n            WRITE(*, *) totals_comparison(x)\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "construct-independent",
                            "atomic"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_expr_neqv_x_end.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:construct-independent,atomic,V:2.0-2.7\n      LOGICAL FUNCTION test1()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x, y !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT, 10):: randoms\n        LOGICAL,DIMENSION(LOOPCOUNT, 10):: a !Data\n        LOGICAL,DIMENSION(LOOPCOUNT):: totals, totals_comparison\n        INTEGER :: errors = 0\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(randoms)\n        DO x = 1, LOOPCOUNT\n          DO y = 1, 10\n            IF (randoms(x, y) > .5) THEN\n              a(x, y) = .TRUE.\n            ELSE\n              a(x, y) = .FALSE.\n            END IF\n          END DO\n        END DO\n\n        totals = .FALSE.\n        totals_comparison = .FALSE.\n\n        !$acc data copyin(a(1:LOOPCOUNT,1:10)) copy(totals(1:LOOPCOUNT))\n          !$acc parallel\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              DO y = 1, 10\n                !$acc atomic\n                  totals(x) = a(x, y) .NEQV. totals(x)\n                !$acc end atomic\n              END DO\n            END DO\n          !$acc end parallel\n        !$acc end data\n\n        DO x = 1, LOOPCOUNT\n          DO y = 1, 10\n            totals_comparison(x) = totals_comparison(x) .NEQV. a(x, y)\n          END DO\n        END DO\n\n        DO x = 1, LOOPCOUNT\n          IF (totals_comparison(x) .NE. totals(x)) THEN\n            errors = errors + 1\n            WRITE(*, *) totals_comparison(x)\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "construct-independent",
                            "atomic"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_expr_or_x.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:construct-independent,atomic,V:2.0-2.7\n      LOGICAL FUNCTION test1()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x, y !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT, 10):: randoms\n        LOGICAL,DIMENSION(LOOPCOUNT, 10):: a !Data\n        LOGICAL,DIMENSION(LOOPCOUNT):: totals, totals_comparison\n        INTEGER :: errors = 0\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(randoms)\n        DO x = 1, LOOPCOUNT\n          DO y = 1, 10\n            IF (randoms(x, y) > .933) THEN\n              a(x, y) = .TRUE.\n            ELSE\n              a(x, y) = .FALSE.\n            END IF\n          END DO\n        END DO\n\n        totals = .FALSE.\n        totals_comparison = .FALSE.\n\n        !$acc data copyin(a(1:LOOPCOUNT,1:10)) copy(totals(1:LOOPCOUNT))\n          !$acc parallel\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              DO y = 1, 10\n                !$acc atomic\n                  totals(x) = a(x, y) .OR. totals(x)\n              END DO\n            END DO\n          !$acc end parallel\n        !$acc end data\n\n        DO x = 1, LOOPCOUNT\n          DO y = 1, 10\n            totals_comparison(x) = totals_comparison(x) .OR. a(x, y)\n          END DO\n        END DO\n\n        DO x = 1, LOOPCOUNT\n          IF (totals_comparison(x) .NEQV. totals(x)) THEN\n            errors = errors + 1\n            WRITE(*, *) totals_comparison(x)\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "construct-independent",
                            "atomic"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_expr_or_x_end.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:construct-independent,atomic,V:2.0-2.7\n      LOGICAL FUNCTION test1()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x, y !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT, 10):: randoms\n        LOGICAL,DIMENSION(LOOPCOUNT, 10):: a !Data\n        LOGICAL,DIMENSION(LOOPCOUNT):: totals, totals_comparison\n        INTEGER :: errors = 0\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(randoms)\n        DO x = 1, LOOPCOUNT\n          DO y = 1, 10\n            IF (randoms(x, y) > .933) THEN\n              a(x, y) = .TRUE.\n            ELSE\n              a(x, y) = .FALSE.\n            END IF\n          END DO\n        END DO\n\n        totals = .FALSE.\n        totals_comparison = .FALSE.\n\n        !$acc data copyin(a(1:LOOPCOUNT,1:10)) copy(totals(1:LOOPCOUNT))\n          !$acc parallel\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              DO y = 1, 10\n                !$acc atomic\n                  totals(x) = a(x, y) .OR. totals(x)\n                !$acc end atomic\n              END DO\n            END DO\n          !$acc end parallel\n        !$acc end data\n\n        DO x = 1, LOOPCOUNT\n          DO y = 1, 10\n            totals_comparison(x) = totals_comparison(x) .OR. a(x, y)\n          END DO\n        END DO\n\n        DO x = 1, LOOPCOUNT\n          IF (totals_comparison(x) .NEQV. totals(x)) THEN\n            errors = errors + 1\n            WRITE(*, *) totals_comparison(x)\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "construct-independent",
                            "atomic"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_expr_plus_x.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:construct-independent,atomic,V:2.0-2.7\n      LOGICAL FUNCTION test1()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x, y !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT, 10):: a !Data\n        REAL(8),DIMENSION(LOOPCOUNT):: totals, totals_comparison\n        INTEGER :: errors = 0\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(a)\n\n        totals = 0\n        totals_comparison = 0\n\n        !$acc data copyin(a(1:LOOPCOUNT, 1:10)) copy(totals(1:LOOPCOUNT))\n          !$acc parallel\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              DO y = 1, 10\n                !$acc atomic\n                  totals(x) = a(x, y) + totals(x)\n              END DO\n            END DO\n          !$acc end parallel\n        !$acc end data\n        DO x = 1, LOOPCOUNT\n          DO y = 1, 10\n            totals_comparison(x) = totals_comparison(x) + a(x, y)\n          END DO\n        END DO\n\n        DO x = 1, LOOPCOUNT\n          IF (totals_comparison(x) .NE. totals(x)) THEN\n            errors = errors + 1\n            WRITE(*, *) totals_comparison(x)\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "construct-independent",
                            "atomic"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_expr_plus_x.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:atomic,construct-independent,V:2.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t *a = (real_t *)malloc(n * sizeof(real_t));\n    real_t *b = (real_t *)malloc(n * sizeof(real_t));\n    real_t *totals = (real_t *)malloc(10 * sizeof(real_t));\n    real_t *totals_comparison = (real_t *)malloc(10 * sizeof(real_t));\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n    }\n    for (int x = 0; x < 10; ++x){\n        totals[x] = 0;\n        totals_comparison[x] = 0;\n    }\n\n    #pragma acc data copyin(a[0:n], b[0:n]) copy(totals[0:10])\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                #pragma acc loop\n                for (int y = 0; y < n; ++y){\n                    #pragma acc atomic\n                        totals[(int) ((a[x] + b[x])/2)] = a[x] * b[x] + totals[(int) ((a[x] + b[x])/2)];\n                }\n            }\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        for (int y = 0; y < n; ++y){\n            totals_comparison[(int) ((a[x] + b[x])/2)] += a[x] * b[x];\n        }\n    }\n    for (int x = 0; x < 10; ++x){\n        if (fabs(totals_comparison[x] != totals[x]) > PRECISION){\n            err += 1;\n            break;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "atomic",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_expr_plus_x_end.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:construct-independent,atomic,V:2.0-2.7\n      LOGICAL FUNCTION test1()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x, y !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT, 10):: a !Data\n        REAL(8),DIMENSION(LOOPCOUNT):: totals, totals_comparison\n        INTEGER :: errors = 0\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(a)\n\n        totals = 0\n        totals_comparison = 0\n\n        !$acc data copyin(a(1:LOOPCOUNT, 1:10)) copy(totals(1:LOOPCOUNT))\n          !$acc parallel\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              DO y = 1, 10\n                !$acc atomic\n                  totals(x) = a(x, y) + totals(x)\n                !$acc end atomic\n              END DO\n            END DO\n          !$acc end parallel\n        !$acc end data\n        DO x = 1, LOOPCOUNT\n          DO y = 1, 10\n            totals_comparison(x) = totals_comparison(x) + a(x, y)\n          END DO\n        END DO\n\n        DO x = 1, LOOPCOUNT\n          IF (totals_comparison(x) .NE. totals(x)) THEN\n            errors = errors + 1\n            WRITE(*, *) totals_comparison(x)\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "construct-independent",
                            "atomic"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_expr_rshift_x.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:atomic,construct-independent,V:2.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    unsigned int *a = (unsigned int *)malloc(3 * n * sizeof(int));\n    unsigned int *b = (unsigned int *)malloc(n * sizeof(int));\n    int orders[18] = {1, 2, 0, 1, 0, 2, 2, 1, 0, 2, 0, 1, 0, 1, 2, 0, 2, 1};\n    int result;\n\n    for (int x = 0; x < n; ++x){\n        for (int y = 0; y < 3; ++y){\n            a[x * 3 + y] = (int) (rand() / (unsigned int) (RAND_MAX / 4));\n        }\n        b[x] = 0;\n    }\n\n    #pragma acc data copyin(a[0:3 * n]) copy(b[0:n])\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                #pragma acc loop independent\n                for (int y = 0; y < 3; ++y){\n                    #pragma acc atomic\n                        b[x] = a[x * 3 + y] >> b[x];\n                }\n            }\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        for (int y = 0; y < 6; ++y){\n            result = 0;\n            for (int z = 0; z < 3; ++z){\n                result = a[x * 3 + orders[y * 3 + z]] >> result;\n            }\n            if (result == b[x]){\n                break;\n            }\n        }\n        if (result != b[x]){\n            err += 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "atomic",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_expr_times_x.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:construct-independent,atomic,V:2.0-2.7\n      LOGICAL FUNCTION test1()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x, y !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT, 10):: a !Data\n        REAL(8),DIMENSION(LOOPCOUNT):: totals, totals_comparison\n        INTEGER :: errors = 0\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(a)\n\n        totals = 1\n        totals_comparison = 1\n\n        !$acc data copyin(a(1:LOOPCOUNT, 1:10)) copy(totals(1:LOOPCOUNT))\n          !$acc parallel\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              DO y = 1, 10\n                !$acc atomic\n                  totals(x) = a(x, y) * totals(x)\n              END DO\n            END DO\n          !$acc end parallel\n        !$acc end data\n        DO x = 1, LOOPCOUNT\n          DO y = 1, 10\n            totals_comparison(x) = totals_comparison(x) * a(x, y)\n          END DO\n        END DO\n\n        DO x = 1, LOOPCOUNT\n          IF (totals_comparison(x) .NE. totals(x)) THEN\n            errors = errors + 1\n            WRITE(*, *) totals_comparison(x)\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "construct-independent",
                            "atomic"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_expr_times_x_end.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:construct-independent,atomic,V:2.0-2.7\n      LOGICAL FUNCTION test1()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x, y !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT, 10):: a !Data\n        REAL(8),DIMENSION(LOOPCOUNT):: totals, totals_comparison\n        INTEGER :: errors = 0\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(a)\n\n        totals = 1\n        totals_comparison = 1\n\n        !$acc data copyin(a(1:LOOPCOUNT, 1:10)) copy(totals(1:LOOPCOUNT))\n          !$acc parallel\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              DO y = 1, 10\n                !$acc atomic\n                  totals(x) = a(x, y) * totals(x)\n                !$acc end atomic\n              END DO\n            END DO\n          !$acc end parallel\n        !$acc end data\n        DO x = 1, LOOPCOUNT\n          DO y = 1, 10\n            totals_comparison(x) = totals_comparison(x) * a(x, y)\n          END DO\n        END DO\n\n        DO x = 1, LOOPCOUNT\n          IF (totals_comparison(x) .NE. totals(x)) THEN\n            errors = errors + 1\n            WRITE(*, *) totals_comparison(x)\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "construct-independent",
                            "atomic"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_iand_expr_x.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:construct-independent,atomic,V:2.0-2.7\n      LOGICAL FUNCTION test1()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x, y !Iterators\n        INTEGER,DIMENSION(LOOPCOUNT):: a !Data\n        REAL(8),DIMENSION(LOOPCOUNT, 8):: randoms\n        INTEGER,DIMENSION(LOOPCOUNT/10 + 1):: totals, totals_comparison\n        INTEGER :: errors = 0\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(randoms)\n        a = 0\n        DO x = 1, LOOPCOUNT\n          DO y = 1, 8\n            IF (randoms(x, y) .gt. .933) THEN\n              a(x) = a(x) + ISHFT(1, y - 1)\n            END IF\n          END DO\n        END DO\n        totals = 0\n        totals_comparison = 0\n        DO x = 1, LOOPCOUNT/10 + 1\n          DO y = 0, 7\n            totals(x) = totals(x) + ISHFT(1, y)\n            totals_comparison(x) = totals_comparison(x) + ISHFT(1, y)\n          END DO\n        END DO\n\n        !$acc data copyin(a(1:LOOPCOUNT)) copy(totals(1:(LOOPCOUNT/10 + 1)))\n          !$acc parallel\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              !$acc atomic\n                totals(MOD(x, LOOPCOUNT/10 + 1) + 1) = iand(a(x), totals(MOD(x, LOOPCOUNT/10 + 1) + 1))\n            END DO\n          !$acc end parallel\n        !$acc end data\n        DO x = 1, LOOPCOUNT\n          totals_comparison(MOD(x, LOOPCOUNT/10 + 1) + 1) = iand(totals_comparison(MOD(x, LOOPCOUNT/10 + 1) + 1), a(x))\n        END DO\n        DO x = 1, LOOPCOUNT/10 + 1\n          IF (totals_comparison(x) .NE. totals(x)) THEN\n            errors = errors + 1\n            WRITE(*, *) totals_comparison(x)\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "construct-independent",
                            "atomic"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_iand_expr_x_end.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:construct-independent,atomic,V:2.0-2.7\n      LOGICAL FUNCTION test1()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x, y !Iterators\n        INTEGER,DIMENSION(LOOPCOUNT):: a !Data\n        REAL(8),DIMENSION(LOOPCOUNT, 8):: randoms\n        INTEGER,DIMENSION(LOOPCOUNT/10 + 1):: totals, totals_comparison\n        INTEGER :: errors = 0\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(randoms)\n        a = 0\n        DO x = 1, LOOPCOUNT\n          DO y = 1, 8\n            IF (randoms(x, y) .gt. .933) THEN\n              a(x) = a(x) + ISHFT(1, y - 1)\n            END IF\n          END DO\n        END DO\n        totals = 0\n        totals_comparison = 0\n        DO x = 1, LOOPCOUNT/10 + 1\n          DO y = 0, 7\n            totals(x) = totals(x) + ISHFT(1, y)\n            totals_comparison(x) = totals_comparison(x) + ISHFT(1, y)\n          END DO\n        END DO\n\n        !$acc data copyin(a(1:LOOPCOUNT)) copy(totals(1:(LOOPCOUNT/10 + 1)))\n          !$acc parallel\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              !$acc atomic\n                totals(MOD(x, LOOPCOUNT/10 + 1) + 1) = iand(a(x), totals(MOD(x, LOOPCOUNT/10 + 1) + 1))\n              !$acc end atomic\n            END DO\n          !$acc end parallel\n        !$acc end data\n        DO x = 1, LOOPCOUNT\n          totals_comparison(MOD(x, LOOPCOUNT/10 + 1) + 1) = iand(totals_comparison(MOD(x, LOOPCOUNT/10 + 1) + 1), a(x))\n        END DO\n        DO x = 1, LOOPCOUNT/10 + 1\n          IF (totals_comparison(x) .NE. totals(x)) THEN\n            errors = errors + 1\n            WRITE(*, *) totals_comparison(x)\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "construct-independent",
                            "atomic"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_iand_x_expr.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:construct-independent,atomic,V:2.0-2.7\n      LOGICAL FUNCTION test1()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x, y !Iterators\n        INTEGER,DIMENSION(LOOPCOUNT):: a !Data\n        REAL(8),DIMENSION(LOOPCOUNT, 8):: randoms\n        INTEGER,DIMENSION(LOOPCOUNT/10 + 1):: totals, totals_comparison\n        INTEGER :: errors = 0\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(randoms)\n        a = 0\n        DO x = 1, LOOPCOUNT\n          DO y = 1, 8\n            IF (randoms(x, y) .gt. .933) THEN\n              a(x) = a(x) + ISHFT(1, y - 1)\n            END IF\n          END DO\n        END DO\n        totals = 0\n        totals_comparison = 0\n        DO x = 1, LOOPCOUNT/10 + 1\n          DO y = 0, 7\n            totals(x) = totals(x) + ISHFT(1, y)\n            totals_comparison(x) = totals_comparison(x) + ISHFT(1, y)\n          END DO\n        END DO\n\n        !$acc data copyin(a(1:LOOPCOUNT)) copy(totals(1:(LOOPCOUNT/10 + 1)))\n          !$acc parallel\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              !$acc atomic\n                totals(MOD(x, LOOPCOUNT/10 + 1) + 1) = iand(totals(MOD(x, LOOPCOUNT/10 + 1) + 1), a(x))\n            END DO\n          !$acc end parallel\n        !$acc end data\n        DO x = 1, LOOPCOUNT\n          totals_comparison(MOD(x, LOOPCOUNT/10 + 1) + 1) = iand(totals_comparison(MOD(x, LOOPCOUNT/10 + 1) + 1), a(x))\n        END DO\n        DO x = 1, LOOPCOUNT/10 + 1\n          IF (totals_comparison(x) .NE. totals(x)) THEN\n            errors = errors + 1\n            WRITE(*, *) totals_comparison(x)\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "construct-independent",
                            "atomic"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_iand_x_expr_end.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:construct-independent,atomic,V:2.0-2.7\n      LOGICAL FUNCTION test1()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x, y !Iterators\n        INTEGER,DIMENSION(LOOPCOUNT):: a !Data\n        REAL(8),DIMENSION(LOOPCOUNT, 8):: randoms\n        INTEGER,DIMENSION(LOOPCOUNT/10 + 1):: totals, totals_comparison\n        INTEGER :: errors = 0\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(randoms)\n        a = 0\n        DO x = 1, LOOPCOUNT\n          DO y = 1, 8\n            IF (randoms(x, y) .gt. .933) THEN\n              a(x) = a(x) + ISHFT(1, y - 1)\n            END IF\n          END DO\n        END DO\n        totals = 0\n        totals_comparison = 0\n        DO x = 1, LOOPCOUNT/10 + 1\n          DO y = 0, 7\n            totals(x) = totals(x) + ISHFT(1, y)\n            totals_comparison(x) = totals_comparison(x) + ISHFT(1, y)\n          END DO\n        END DO\n\n        !$acc data copyin(a(1:LOOPCOUNT)) copy(totals(1:(LOOPCOUNT/10 + 1)))\n          !$acc parallel\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              !$acc atomic\n                totals(MOD(x, LOOPCOUNT/10 + 1) + 1) = iand(totals(MOD(x, LOOPCOUNT/10 + 1) + 1), a(x))\n              !$acc end atomic\n            END DO\n          !$acc end parallel\n        !$acc end data\n        DO x = 1, LOOPCOUNT\n          totals_comparison(MOD(x, LOOPCOUNT/10 + 1) + 1) = iand(totals_comparison(MOD(x, LOOPCOUNT/10 + 1) + 1), a(x))\n        END DO\n        DO x = 1, LOOPCOUNT/10 + 1\n          IF (totals_comparison(x) .NE. totals(x)) THEN\n            errors = errors + 1\n            WRITE(*, *) totals_comparison(x)\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "construct-independent",
                            "atomic"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_ior_expr_x.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:construct-independent,atomic,V:2.0-2.7\n      LOGICAL FUNCTION test1()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x, y !Iterators\n        INTEGER,DIMENSION(LOOPCOUNT):: a !Data\n        REAL(8),DIMENSION(LOOPCOUNT, 8):: randoms\n        INTEGER,DIMENSION(LOOPCOUNT/10 + 1):: totals, totals_comparison\n        INTEGER :: errors = 0\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(randoms)\n        a = 0\n        DO x = 1, LOOPCOUNT\n          DO y = 1, 8\n            IF (randoms(x, y) .lt. .933) THEN\n              a(x) = a(x) + ISHFT(1, y - 1)\n            END IF\n          END DO\n        END DO\n        totals = 0\n        totals_comparison = 0\n        DO x = 1, LOOPCOUNT/10 + 1\n          totals(x) = 0\n          totals_comparison(x) = 0\n        END DO\n\n        !$acc data copyin(a(1:LOOPCOUNT)) copy(totals(1:(LOOPCOUNT/10 + 1)))\n          !$acc parallel\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              !$acc atomic\n                totals(MOD(x, LOOPCOUNT/10 + 1) + 1) = ior(a(x), totals(MOD(x, LOOPCOUNT/10 + 1) + 1))\n            END DO\n          !$acc end parallel\n        !$acc end data\n        DO x = 1, LOOPCOUNT\n          totals_comparison(MOD(x, LOOPCOUNT/10 + 1) + 1) = ior(totals_comparison(MOD(x, LOOPCOUNT/10 + 1) + 1), a(x))\n        END DO\n        DO x = 1, LOOPCOUNT/10 + 1\n          IF (totals_comparison(x) .NE. totals(x)) THEN\n            errors = errors + 1\n            WRITE(*, *) totals_comparison(x)\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "construct-independent",
                            "atomic"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_ior_expr_x_end.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:construct-independent,atomic,V:2.0-2.7\n      LOGICAL FUNCTION test1()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x, y !Iterators\n        INTEGER,DIMENSION(LOOPCOUNT):: a !Data\n        REAL(8),DIMENSION(LOOPCOUNT, 8):: randoms\n        INTEGER,DIMENSION(LOOPCOUNT/10 + 1):: totals, totals_comparison\n        INTEGER :: errors = 0\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(randoms)\n        a = 0\n        DO x = 1, LOOPCOUNT\n          DO y = 1, 8\n            IF (randoms(x, y) .lt. .933) THEN\n              a(x) = a(x) + ISHFT(1, y - 1)\n            END IF\n          END DO\n        END DO\n        totals = 0\n        totals_comparison = 0\n        DO x = 1, LOOPCOUNT/10 + 1\n          totals(x) = 0\n          totals_comparison(x) = 0\n        END DO\n\n        !$acc data copyin(a(1:LOOPCOUNT)) copy(totals(1:(LOOPCOUNT/10 + 1)))\n          !$acc parallel\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              !$acc atomic\n                totals(MOD(x, LOOPCOUNT/10 + 1) + 1) = ior(a(x), totals(MOD(x, LOOPCOUNT/10 + 1) + 1))\n              !$acc end atomic\n            END DO\n          !$acc end parallel\n        !$acc end data\n        DO x = 1, LOOPCOUNT\n          totals_comparison(MOD(x, LOOPCOUNT/10 + 1) + 1) = ior(totals_comparison(MOD(x, LOOPCOUNT/10 + 1) + 1), a(x))\n        END DO\n        DO x = 1, LOOPCOUNT/10 + 1\n          IF (totals_comparison(x) .NE. totals(x)) THEN\n            errors = errors + 1\n            WRITE(*, *) totals_comparison(x)\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "construct-independent",
                            "atomic"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_ior_x_expr.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:construct-independent,atomic,V:2.0-2.7\n      LOGICAL FUNCTION test1()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x, y !Iterators\n        INTEGER,DIMENSION(LOOPCOUNT):: a !Data\n        REAL(8),DIMENSION(LOOPCOUNT, 8):: randoms\n        INTEGER,DIMENSION(LOOPCOUNT/10 + 1):: totals, totals_comparison\n        INTEGER :: errors = 0\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(randoms)\n        a = 0\n        DO x = 1, LOOPCOUNT\n          DO y = 1, 8\n            IF (randoms(x, y) .lt. .933) THEN\n              a(x) = a(x) + ISHFT(1, y - 1)\n            END IF\n          END DO\n        END DO\n        totals = 0\n        totals_comparison = 0\n        DO x = 1, LOOPCOUNT/10 + 1\n          totals(x) = 0\n          totals_comparison(x) = 0\n        END DO\n\n        !$acc data copyin(a(1:LOOPCOUNT)) copy(totals(1:(LOOPCOUNT/10 + 1)))\n          !$acc parallel\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              !$acc atomic\n                totals(MOD(x, LOOPCOUNT/10 + 1) + 1) = ior(totals(MOD(x, LOOPCOUNT/10 + 1) + 1), a(x))\n            END DO\n          !$acc end parallel\n        !$acc end data\n        DO x = 1, LOOPCOUNT\n          totals_comparison(MOD(x, LOOPCOUNT/10 + 1) + 1) = ior(totals_comparison(MOD(x, LOOPCOUNT/10 + 1) + 1), a(x))\n        END DO\n        DO x = 1, LOOPCOUNT/10 + 1\n          IF (totals_comparison(x) .NE. totals(x)) THEN\n            errors = errors + 1\n            WRITE(*, *) totals_comparison(x)\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "construct-independent",
                            "atomic"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_ior_x_expr_end.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:construct-independent,atomic,V:2.0-2.7\n      LOGICAL FUNCTION test1()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x, y !Iterators\n        INTEGER,DIMENSION(LOOPCOUNT):: a !Data\n        REAL(8),DIMENSION(LOOPCOUNT, 8):: randoms\n        INTEGER,DIMENSION(LOOPCOUNT/10 + 1):: totals, totals_comparison\n        INTEGER :: errors = 0\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(randoms)\n        a = 0\n        DO x = 1, LOOPCOUNT\n          DO y = 1, 8\n            IF (randoms(x, y) .lt. .933) THEN\n              a(x) = a(x) + ISHFT(1, y - 1)\n            END IF\n          END DO\n        END DO\n        totals = 0\n        totals_comparison = 0\n        DO x = 1, LOOPCOUNT/10 + 1\n          totals(x) = 0\n          totals_comparison(x) = 0\n        END DO\n\n        !$acc data copyin(a(1:LOOPCOUNT)) copy(totals(1:(LOOPCOUNT/10 + 1)))\n          !$acc parallel\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              !$acc atomic\n                totals(MOD(x, LOOPCOUNT/10 + 1) + 1) = ior(totals(MOD(x, LOOPCOUNT/10 + 1) + 1), a(x))\n              !$acc end atomic\n            END DO\n          !$acc end parallel\n        !$acc end data\n        DO x = 1, LOOPCOUNT\n          totals_comparison(MOD(x, LOOPCOUNT/10 + 1) + 1) = ior(totals_comparison(MOD(x, LOOPCOUNT/10 + 1) + 1), a(x))\n        END DO\n        DO x = 1, LOOPCOUNT/10 + 1\n          IF (totals_comparison(x) .NE. totals(x)) THEN\n            errors = errors + 1\n            WRITE(*, *) totals_comparison(x)\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "construct-independent",
                            "atomic"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_ixor_expr_x.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:construct-independent,atomic,V:2.0-2.7\n      LOGICAL FUNCTION test1()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x, y !Iterators\n        INTEGER,DIMENSION(LOOPCOUNT):: a !Data\n        REAL(8),DIMENSION(LOOPCOUNT, 8):: randoms\n        INTEGER,DIMENSION(LOOPCOUNT/10 + 1):: totals, totals_comparison\n        INTEGER :: errors = 0\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(randoms)\n        a = 0\n        DO x = 1, LOOPCOUNT\n          DO y = 1, 8\n            IF (randoms(x, y) .lt. .5) THEN\n              a(x) = a(x) + ISHFT(1, y - 1)\n            END IF\n          END DO\n        END DO\n        totals = 0\n        totals_comparison = 0\n        DO x = 1, LOOPCOUNT/10 + 1\n          totals(x) = 0\n          totals_comparison(x) = 0\n        END DO\n\n        !$acc data copyin(a(1:LOOPCOUNT)) copy(totals(1:(LOOPCOUNT/10 + 1)))\n          !$acc parallel\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              !$acc atomic\n                totals(MOD(x, LOOPCOUNT/10 + 1) + 1) = ieor(a(x), totals(MOD(x, LOOPCOUNT/10 + 1) + 1))\n            END DO\n          !$acc end parallel\n        !$acc end data\n        DO x = 1, LOOPCOUNT\n          totals_comparison(MOD(x, LOOPCOUNT/10 + 1) + 1) = ieor(totals_comparison(MOD(x, LOOPCOUNT/10 + 1) + 1), a(x))\n        END DO\n        DO x = 1, LOOPCOUNT/10 + 1\n          IF (totals_comparison(x) .NE. totals(x)) THEN\n            errors = errors + 1\n            WRITE(*, *) totals_comparison(x)\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "construct-independent",
                            "atomic"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_ixor_expr_x_end.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:construct-independent,atomic,V:2.0-2.7\n      LOGICAL FUNCTION test1()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x, y !Iterators\n        INTEGER,DIMENSION(LOOPCOUNT):: a !Data\n        REAL(8),DIMENSION(LOOPCOUNT, 8):: randoms\n        INTEGER,DIMENSION(LOOPCOUNT/10 + 1):: totals, totals_comparison\n        INTEGER :: errors = 0\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(randoms)\n        a = 0\n        DO x = 1, LOOPCOUNT\n          DO y = 1, 8\n            IF (randoms(x, y) .lt. .5) THEN\n              a(x) = a(x) + ISHFT(1, y - 1)\n            END IF\n          END DO\n        END DO\n        totals = 0\n        totals_comparison = 0\n        DO x = 1, LOOPCOUNT/10 + 1\n          totals(x) = 0\n          totals_comparison(x) = 0\n        END DO\n\n        !$acc data copyin(a(1:LOOPCOUNT)) copy(totals(1:(LOOPCOUNT/10 + 1)))\n          !$acc parallel\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              !$acc atomic\n                totals(MOD(x, LOOPCOUNT/10 + 1) + 1) = ieor(a(x), totals(MOD(x, LOOPCOUNT/10 + 1) + 1))\n              !$acc end atomic\n            END DO\n          !$acc end parallel\n        !$acc end data\n        DO x = 1, LOOPCOUNT\n          totals_comparison(MOD(x, LOOPCOUNT/10 + 1) + 1) = ieor(totals_comparison(MOD(x, LOOPCOUNT/10 + 1) + 1), a(x))\n        END DO\n        DO x = 1, LOOPCOUNT/10 + 1\n          IF (totals_comparison(x) .NE. totals(x)) THEN\n            errors = errors + 1\n            WRITE(*, *) totals_comparison(x)\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "construct-independent",
                            "atomic"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_ixor_x_expr.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:construct-independent,atomic,V:2.0-2.7\n      LOGICAL FUNCTION test1()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x, y !Iterators\n        INTEGER,DIMENSION(LOOPCOUNT):: a !Data\n        REAL(8),DIMENSION(LOOPCOUNT, 8):: randoms\n        INTEGER,DIMENSION(LOOPCOUNT/10 + 1):: totals, totals_comparison\n        INTEGER :: errors = 0\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(randoms)\n        a = 0\n        DO x = 1, LOOPCOUNT\n          DO y = 1, 8\n            IF (randoms(x, y) .lt. .5) THEN\n              a(x) = a(x) + ISHFT(1, y - 1)\n            END IF\n          END DO\n        END DO\n        totals = 0\n        totals_comparison = 0\n        DO x = 1, LOOPCOUNT/10 + 1\n          totals(x) = 0\n          totals_comparison(x) = 0\n        END DO\n\n        !$acc data copyin(a(1:LOOPCOUNT)) copy(totals(1:(LOOPCOUNT/10 + 1)))\n          !$acc parallel\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              !$acc atomic\n                totals(MOD(x, LOOPCOUNT/10 + 1) + 1) = ieor(totals(MOD(x, LOOPCOUNT/10 + 1) + 1), a(x))\n            END DO\n          !$acc end parallel\n        !$acc end data\n        DO x = 1, LOOPCOUNT\n          totals_comparison(MOD(x, LOOPCOUNT/10 + 1) + 1) = ieor(totals_comparison(MOD(x, LOOPCOUNT/10 + 1) + 1), a(x))\n        END DO\n        DO x = 1, LOOPCOUNT/10 + 1\n          IF (totals_comparison(x) .NE. totals(x)) THEN\n            errors = errors + 1\n            WRITE(*, *) totals_comparison(x)\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "construct-independent",
                            "atomic"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_ixor_x_expr_end.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:construct-independent,atomic,V:2.0-2.7\n      LOGICAL FUNCTION test1()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x, y !Iterators\n        INTEGER,DIMENSION(LOOPCOUNT):: a !Data\n        REAL(8),DIMENSION(LOOPCOUNT, 8):: randoms\n        INTEGER,DIMENSION(LOOPCOUNT/10 + 1):: totals, totals_comparison\n        INTEGER :: errors = 0\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(randoms)\n        a = 0\n        DO x = 1, LOOPCOUNT\n          DO y = 1, 8\n            IF (randoms(x, y) .lt. .5) THEN\n              a(x) = a(x) + ISHFT(1, y - 1)\n            END IF\n          END DO\n        END DO\n        totals = 0\n        totals_comparison = 0\n        DO x = 1, LOOPCOUNT/10 + 1\n          totals(x) = 0\n          totals_comparison(x) = 0\n        END DO\n\n        !$acc data copyin(a(1:LOOPCOUNT)) copy(totals(1:(LOOPCOUNT/10 + 1)))\n          !$acc parallel\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              !$acc atomic\n                totals(MOD(x, LOOPCOUNT/10 + 1) + 1) = ieor(totals(MOD(x, LOOPCOUNT/10 + 1) + 1), a(x))\n              !$acc end atomic\n            END DO\n          !$acc end parallel\n        !$acc end data\n        DO x = 1, LOOPCOUNT\n          totals_comparison(MOD(x, LOOPCOUNT/10 + 1) + 1) = ieor(totals_comparison(MOD(x, LOOPCOUNT/10 + 1) + 1), a(x))\n        END DO\n        DO x = 1, LOOPCOUNT/10 + 1\n          IF (totals_comparison(x) .NE. totals(x)) THEN\n            errors = errors + 1\n            WRITE(*, *) totals_comparison(x)\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "construct-independent",
                            "atomic"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_lshift_equals.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:atomic,construct-independent,V:2.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    unsigned int *a = (unsigned int *)malloc(n * sizeof(int));\n    unsigned int *b = (unsigned int *)malloc(n * sizeof(int));\n\n    for (int x = 0; x < n; ++x){\n        a[x] = 1;\n        for (int y = 0; y < 7; ++y){\n            if ((rand()/(unsigned int) (RAND_MAX)) > .5){\n                b[x] += 1<<y;\n            }\n        }\n    }\n\n    #pragma acc data copyin(b[0:n]) copy(a[0:n])\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                #pragma acc loop\n                for (int y = 0; y < 7; ++y){\n                    if ((b[x]>>y)%2 == 1){\n                        #pragma acc atomic\n                            a[x] <<= 1;\n                    }\n                }\n            }\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        for (int y = 0; y < 7; ++y){\n            if ((b[x]>>y)%2 == 1){\n                a[x] >>= 1;\n            }\n        }\n        if (a[x] != 1){\n            err += 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "atomic",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_max_expr_list_x.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:construct-independent,atomic,V:2.0-2.7\n      LOGICAL FUNCTION test1()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.f90\"\n        INTEGER :: x, y !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT):: a, b !Data\n        REAL(8),DIMENSION(LOOPCOUNT/10 + 1):: totals, totals_comparison\n        INTEGER :: errors = 0\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n        CALL RANDOM_NUMBER(a)\n        CALL RANDOM_NUMBER(b)\n\n        totals = 0\n        totals_comparison = 0\n\n        !$acc data copyin(a(1:LOOPCOUNT), b(1:LOOPCOUNT)) copy(totals(1:(LOOPCOUNT/10 + 1)))\n          !$acc parallel\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              !$acc atomic\n                totals(MOD(x, LOOPCOUNT/10 + 1) + 1) = max(a(x), b(x), totals(MOD(x, LOOPCOUNT/10 + 1) + 1))\n            END DO\n          !$acc end parallel\n        !$acc end data\n        DO x = 1, LOOPCOUNT\n          totals_comparison(MOD(x, LOOPCOUNT/10 + 1) + 1) = max(totals_comparison(MOD(x, LOOPCOUNT/10 + 1) + 1), a(x), b(x))\n        END DO\n        DO x = 1, LOOPCOUNT/10 + 1\n          IF (totals_comparison(x) .NE. totals(x)) THEN\n            errors = errors + 1\n            WRITE(*, *) totals_comparison(x)\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "construct-independent",
                            "atomic"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_max_expr_list_x_end.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:construct-independent,atomic,V:2.0-2.7\n      LOGICAL FUNCTION test1()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x, y !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT):: a, b !Data\n        REAL(8),DIMENSION(LOOPCOUNT/10 + 1):: totals, totals_comparison\n        INTEGER :: errors = 0\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(a)\n        CALL RANDOM_NUMBER(b)\n\n        totals = 0\n        totals_comparison = 0\n\n        !$acc data copyin(a(1:LOOPCOUNT), b(1:LOOPCOUNT)) copy(totals(1:(LOOPCOUNT/10 + 1)))\n          !$acc parallel\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              !$acc atomic\n                totals(MOD(x, LOOPCOUNT/10 + 1) + 1) = max(a(x), b(x), totals(MOD(x, LOOPCOUNT/10 + 1) + 1))\n              !$acc end atomic\n            END DO\n          !$acc end parallel\n        !$acc end data\n        DO x = 1, LOOPCOUNT\n          totals_comparison(MOD(x, LOOPCOUNT/10 + 1) + 1) = max(totals_comparison(MOD(x, LOOPCOUNT/10 + 1) + 1), a(x), b(x))\n        END DO\n        DO x = 1, LOOPCOUNT/10 + 1\n          IF (totals_comparison(x) .NE. totals(x)) THEN\n            errors = errors + 1\n            WRITE(*, *) totals_comparison(x)\n          END IF\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "construct-independent",
                            "atomic"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_max_expr_x.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:construct-independent,atomic,V:2.0-2.7\n      LOGICAL FUNCTION test1()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x, y !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT):: a !Data\n        REAL(8),DIMENSION(LOOPCOUNT/10 + 1):: totals, totals_comparison\n        INTEGER :: errors = 0\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(a)\n\n        totals = 0\n        totals_comparison = 0\n\n        !$acc data copyin(a(1:LOOPCOUNT)) copy(totals(1:(LOOPCOUNT/10 + 1)))\n          !$acc parallel\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              !$acc atomic\n                totals(MOD(x, LOOPCOUNT/10 + 1) + 1) = max(a(x), totals(MOD(x, LOOPCOUNT/10 + 1) + 1))\n            END DO\n          !$acc end parallel\n        !$acc end data\n        DO x = 1, LOOPCOUNT\n          totals_comparison(MOD(x, LOOPCOUNT/10 + 1) + 1) = max(totals_comparison(MOD(x, LOOPCOUNT/10 + 1) + 1), a(x))\n        END DO\n        DO x = 1, LOOPCOUNT/10 + 1\n          IF (totals_comparison(x) .NE. totals(x)) THEN\n            errors = errors + 1\n            WRITE(*, *) totals_comparison(x)\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "construct-independent",
                            "atomic"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_max_expr_x_end.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:construct-independent,atomic,V:2.0-2.7\n      LOGICAL FUNCTION test1()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x, y !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT):: a !Data\n        REAL(8),DIMENSION(LOOPCOUNT/10 + 1):: totals, totals_comparison\n        INTEGER :: errors = 0\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(a)\n\n        totals = 0\n        totals_comparison = 0\n\n        !$acc data copyin(a(1:LOOPCOUNT)) copy(totals(1:(LOOPCOUNT/10 + 1)))\n          !$acc parallel\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              !$acc atomic\n                totals(MOD(x, LOOPCOUNT/10 + 1) + 1) = max(a(x), totals(MOD(x, LOOPCOUNT/10 + 1) + 1))\n              !$acc end atomic\n            END DO\n          !$acc end parallel\n        !$acc end data\n        DO x = 1, LOOPCOUNT\n          totals_comparison(MOD(x, LOOPCOUNT/10 + 1) + 1) = max(totals_comparison(MOD(x, LOOPCOUNT/10 + 1) + 1), a(x))\n        END DO\n        DO x = 1, LOOPCOUNT/10 + 1\n          IF (totals_comparison(x) .NE. totals(x)) THEN\n            errors = errors + 1\n            WRITE(*, *) totals_comparison(x)\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "construct-independent",
                            "atomic"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_max_x_expr.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:construct-independent,atomic,V:2.0-2.7\n      LOGICAL FUNCTION test1()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x, y !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT):: a !Data\n        REAL(8),DIMENSION(LOOPCOUNT/10 + 1):: totals, totals_comparison\n        INTEGER :: errors = 0\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(a)\n\n        totals = 0\n        totals_comparison = 0\n\n        !$acc data copyin(a(1:LOOPCOUNT)) copy(totals(1:(LOOPCOUNT/10 + 1)))\n          !$acc parallel\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              !$acc atomic\n                totals(MOD(x, LOOPCOUNT/10 + 1) + 1) = max(totals(MOD(x, LOOPCOUNT/10 + 1) + 1), a(x))\n            END DO\n          !$acc end parallel\n        !$acc end data\n        DO x = 1, LOOPCOUNT\n          totals_comparison(MOD(x, LOOPCOUNT/10 + 1) + 1) = max(totals_comparison(MOD(x, LOOPCOUNT/10 + 1) + 1), a(x))\n        END DO\n        DO x = 1, LOOPCOUNT/10 + 1\n          IF (totals_comparison(x) .NE. totals(x)) THEN\n            errors = errors + 1\n            WRITE(*, *) totals_comparison(x)\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "construct-independent",
                            "atomic"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_max_x_expr_end.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:construct-independent,atomic,V:2.0-2.7\n      LOGICAL FUNCTION test1()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x, y !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT):: a !Data\n        REAL(8),DIMENSION(LOOPCOUNT/10 + 1):: totals, totals_comparison\n        INTEGER :: errors = 0\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(a)\n\n        totals = 0\n        totals_comparison = 0\n\n        !$acc data copyin(a(1:LOOPCOUNT)) copy(totals(1:(LOOPCOUNT/10 + 1)))\n          !$acc parallel\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              !$acc atomic\n                totals(MOD(x, LOOPCOUNT/10 + 1) + 1) = max(totals(MOD(x, LOOPCOUNT/10 + 1) + 1), a(x))\n              !$acc end atomic\n            END DO\n          !$acc end parallel\n        !$acc end data\n        DO x = 1, LOOPCOUNT\n          totals_comparison(MOD(x, LOOPCOUNT/10 + 1) + 1) = max(totals_comparison(MOD(x, LOOPCOUNT/10 + 1) + 1), a(x))\n        END DO\n        DO x = 1, LOOPCOUNT/10 + 1\n          IF (totals_comparison(x) .NE. totals(x)) THEN\n            errors = errors + 1\n            WRITE(*, *) totals_comparison(x)\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "construct-independent",
                            "atomic"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_max_x_expr_list.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:construct-independent,atomic,V:2.0-2.7\n      LOGICAL FUNCTION test1()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x, y !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT):: a, b !Data\n        REAL(8),DIMENSION(LOOPCOUNT/10 + 1):: totals, totals_comparison\n        INTEGER :: errors = 0\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(a)\n        CALL RANDOM_NUMBER(b)\n\n        totals = 0\n        totals_comparison = 0\n\n        !$acc data copyin(a(1:LOOPCOUNT), b(1:LOOPCOUNT)) copy(totals(1:(LOOPCOUNT/10 + 1)))\n          !$acc parallel\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              !$acc atomic\n                totals(MOD(x, LOOPCOUNT/10 + 1) + 1) = max(totals(MOD(x, LOOPCOUNT/10 + 1) + 1), a(x), b(x))\n            END DO\n          !$acc end parallel\n        !$acc end data\n        DO x = 1, LOOPCOUNT\n          totals_comparison(MOD(x, LOOPCOUNT/10 + 1) + 1) = max(totals_comparison(MOD(x, LOOPCOUNT/10 + 1) + 1), a(x), b(x))\n        END DO\n        DO x = 1, LOOPCOUNT/10 + 1\n          IF (totals_comparison(x) .NE. totals(x)) THEN\n            errors = errors + 1\n            WRITE(*, *) totals_comparison(x)\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "construct-independent",
                            "atomic"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_max_x_expr_list_end.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:construct-independent,atomic,V:2.0-2.7\n      LOGICAL FUNCTION test1()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x, y !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT):: a, b !Data\n        REAL(8),DIMENSION(LOOPCOUNT/10 + 1):: totals, totals_comparison\n        INTEGER :: errors = 0\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(a)\n        CALL RANDOM_NUMBER(b)\n\n        totals = 0\n        totals_comparison = 0\n\n        !$acc data copyin(a(1:LOOPCOUNT), b(1:LOOPCOUNT)) copy(totals(1:(LOOPCOUNT/10 + 1)))\n          !$acc parallel\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              !$acc atomic\n                totals(MOD(x, LOOPCOUNT/10 + 1) + 1) = max(totals(MOD(x, LOOPCOUNT/10 + 1) + 1), a(x), b(x))\n              !$acc end atomic\n            END DO\n          !$acc end parallel\n        !$acc end data\n        DO x = 1, LOOPCOUNT\n          totals_comparison(MOD(x, LOOPCOUNT/10 + 1) + 1) = max(totals_comparison(MOD(x, LOOPCOUNT/10 + 1) + 1), a(x), b(x))\n        END DO\n        DO x = 1, LOOPCOUNT/10 + 1\n          IF (totals_comparison(x) .NE. totals(x)) THEN\n            errors = errors + 1\n            WRITE(*, *) totals_comparison(x)\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "construct-independent",
                            "atomic"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_min_expr_list_x.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:construct-independent,atomic,V:2.0-2.7\n      LOGICAL FUNCTION test1()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x, y !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT):: a, b !Data\n        REAL(8),DIMENSION(LOOPCOUNT/10 + 1):: totals, totals_comparison\n        INTEGER :: errors = 0\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(a)\n        CALL RANDOM_NUMBER(b)\n\n        totals = 1\n        totals_comparison = 1\n\n        !$acc data copyin(a(1:LOOPCOUNT), b(1:LOOPCOUNT)) copy(totals(1:(LOOPCOUNT/10 + 1)))\n          !$acc parallel\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              !$acc atomic\n                totals(MOD(x, LOOPCOUNT/10 + 1) + 1) = min(a(x), b(x), totals(MOD(x, LOOPCOUNT/10 + 1) + 1))\n            END DO\n          !$acc end parallel\n        !$acc end data\n        DO x = 1, LOOPCOUNT\n          totals_comparison(MOD(x, LOOPCOUNT/10 + 1) + 1) = min(totals_comparison(MOD(x, LOOPCOUNT/10 + 1) + 1), a(x), b(x))\n        END DO\n        DO x = 1, LOOPCOUNT/10 + 1\n          IF (totals_comparison(x) .NE. totals(x)) THEN\n            errors = errors + 1\n            WRITE(*, *) totals_comparison(x)\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "construct-independent",
                            "atomic"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_min_expr_list_x_end.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:construct-independent,atomic,V:2.0-2.7\n      LOGICAL FUNCTION test1()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x, y !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT):: a, b !Data\n        REAL(8),DIMENSION(LOOPCOUNT/10 + 1):: totals, totals_comparison\n        INTEGER :: errors = 0\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(a)\n        CALL RANDOM_NUMBER(b)\n\n        totals = 1\n        totals_comparison = 1\n\n        !$acc data copyin(a(1:LOOPCOUNT), b(1:LOOPCOUNT)) copy(totals(1:(LOOPCOUNT/10 + 1)))\n          !$acc parallel\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              !$acc atomic\n                totals(MOD(x, LOOPCOUNT/10 + 1) + 1) = min(a(x), b(x), totals(MOD(x, LOOPCOUNT/10 + 1) + 1))\n              !$acc end atomic\n            END DO\n          !$acc end parallel\n        !$acc end data\n        DO x = 1, LOOPCOUNT\n          totals_comparison(MOD(x, LOOPCOUNT/10 + 1) + 1) = min(totals_comparison(MOD(x, LOOPCOUNT/10 + 1) + 1), a(x), b(x))\n        END DO\n        DO x = 1, LOOPCOUNT/10 + 1\n          IF (totals_comparison(x) .NE. totals(x)) THEN\n            errors = errors + 1\n            WRITE(*, *) totals_comparison(x)\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "construct-independent",
                            "atomic"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_min_expr_x.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:construct-independent,atomic,V:2.0-2.7\n      LOGICAL FUNCTION test1()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x, y !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT):: a !Data\n        REAL(8),DIMENSION(LOOPCOUNT/10 + 1):: totals, totals_comparison\n        INTEGER :: errors = 0\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(a)\n\n        totals = 1\n        totals_comparison = 1\n\n        !$acc data copyin(a(1:LOOPCOUNT)) copy(totals(1:(LOOPCOUNT/10 + 1)))\n          !$acc parallel\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              !$acc atomic\n                totals(MOD(x, LOOPCOUNT/10 + 1) + 1) = min(a(x), totals(MOD(x, LOOPCOUNT/10 + 1) + 1))\n            END DO\n          !$acc end parallel\n        !$acc end data\n        DO x = 1, LOOPCOUNT\n          totals_comparison(MOD(x, LOOPCOUNT/10 + 1) + 1) = min(totals_comparison(MOD(x, LOOPCOUNT/10 + 1) + 1), a(x))\n        END DO\n        DO x = 1, LOOPCOUNT/10 + 1\n          IF (totals_comparison(x) .NE. totals(x)) THEN\n            errors = errors + 1\n            WRITE(*, *) totals_comparison(x)\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "construct-independent",
                            "atomic"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_min_expr_x_end.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:construct-independent,atomic,V:2.0-2.7\n      LOGICAL FUNCTION test1()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x, y !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT):: a !Data\n        REAL(8),DIMENSION(LOOPCOUNT/10 + 1):: totals, totals_comparison\n        INTEGER :: errors = 0\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(a)\n\n        totals = 1\n        totals_comparison = 1\n\n        !$acc data copyin(a(1:LOOPCOUNT)) copy(totals(1:(LOOPCOUNT/10 + 1)))\n          !$acc parallel\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              !$acc atomic\n                totals(MOD(x, LOOPCOUNT/10 + 1) + 1) = min(a(x), totals(MOD(x, LOOPCOUNT/10 + 1) + 1))\n              !$acc end atomic\n            END DO\n          !$acc end parallel\n        !$acc end data\n        DO x = 1, LOOPCOUNT\n          totals_comparison(MOD(x, LOOPCOUNT/10 + 1) + 1) = min(totals_comparison(MOD(x, LOOPCOUNT/10 + 1) + 1), a(x))\n        END DO\n        DO x = 1, LOOPCOUNT/10 + 1\n          IF (totals_comparison(x) .NE. totals(x)) THEN\n            errors = errors + 1\n            WRITE(*, *) totals_comparison(x)\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "construct-independent",
                            "atomic"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_min_x_expr.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:construct-independent,atomic,V:2.0-2.7\n      LOGICAL FUNCTION test1()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x, y !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT):: a !Data\n        REAL(8),DIMENSION(LOOPCOUNT/10 + 1):: totals, totals_comparison\n        INTEGER :: errors = 0\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(a)\n\n        totals = 0\n        totals_comparison = 0\n\n        !$acc data copyin(a(1:LOOPCOUNT)) copy(totals(1:(LOOPCOUNT/10 + 1)))\n          !$acc parallel\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              !$acc atomic\n                totals(MOD(x, LOOPCOUNT/10 + 1) + 1) = min(totals(MOD(x, LOOPCOUNT/10 + 1) + 1), a(x))\n            END DO\n          !$acc end parallel\n        !$acc end data\n        DO x = 1, LOOPCOUNT\n          totals_comparison(MOD(x, LOOPCOUNT/10 + 1) + 1) = min(totals_comparison(MOD(x, LOOPCOUNT/10 + 1) + 1), a(x))\n        END DO\n        DO x = 1, LOOPCOUNT/10 + 1\n          IF (totals_comparison(x) .NE. totals(x)) THEN\n            errors = errors + 1\n            WRITE(*, *) totals_comparison(x)\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "construct-independent",
                            "atomic"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_min_x_expr_end.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:construct-independent,atomic,V:2.0-2.7\n      LOGICAL FUNCTION test1()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x, y !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT):: a !Data\n        REAL(8),DIMENSION(LOOPCOUNT/10 + 1):: totals, totals_comparison\n        INTEGER :: errors = 0\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(a)\n\n        totals = 0\n        totals_comparison = 0\n\n        !$acc data copyin(a(1:LOOPCOUNT)) copy(totals(1:(LOOPCOUNT/10 + 1)))\n          !$acc parallel\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              !$acc atomic\n                totals(MOD(x, LOOPCOUNT/10 + 1) + 1) = min(totals(MOD(x, LOOPCOUNT/10 + 1) + 1), a(x))\n              !$acc end atomic\n            END DO\n          !$acc end parallel\n        !$acc end data\n        DO x = 1, LOOPCOUNT\n          totals_comparison(MOD(x, LOOPCOUNT/10 + 1) + 1) = min(totals_comparison(MOD(x, LOOPCOUNT/10 + 1) + 1), a(x))\n        END DO\n        DO x = 1, LOOPCOUNT/10 + 1\n          IF (totals_comparison(x) .NE. totals(x)) THEN\n            errors = errors + 1\n            WRITE(*, *) totals_comparison(x)\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "construct-independent",
                            "atomic"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_min_x_expr_list.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:construct-independent,atomic,V:2.0-2.7\n      LOGICAL FUNCTION test1()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x, y !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT):: a, b !Data\n        REAL(8),DIMENSION(LOOPCOUNT/10 + 1):: totals, totals_comparison\n        INTEGER :: errors = 0\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(a)\n        CALL RANDOM_NUMBER(b)\n\n        totals = 1\n        totals_comparison = 1\n\n        !$acc data copyin(a(1:LOOPCOUNT), b(1:LOOPCOUNT)) copy(totals(1:(LOOPCOUNT/10 + 1)))\n          !$acc parallel\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              !$acc atomic\n                totals(MOD(x, LOOPCOUNT/10 + 1) + 1) = min(totals(MOD(x, LOOPCOUNT/10 + 1) + 1), a(x), b(x))\n            END DO\n          !$acc end parallel\n        !$acc end data\n        DO x = 1, LOOPCOUNT\n          totals_comparison(MOD(x, LOOPCOUNT/10 + 1) + 1) = min(totals_comparison(MOD(x, LOOPCOUNT/10 + 1) + 1), a(x), b(x))\n        END DO\n        DO x = 1, LOOPCOUNT/10 + 1\n          IF (totals_comparison(x) .NE. totals(x)) THEN\n            errors = errors + 1\n            WRITE(*, *) totals_comparison(x)\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "construct-independent",
                            "atomic"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_min_x_expr_list_end.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:construct-independent,atomic,V:2.0-2.7\n      LOGICAL FUNCTION test1()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x, y !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT):: a, b !Data\n        REAL(8),DIMENSION(LOOPCOUNT/10 + 1):: totals, totals_comparison\n        INTEGER :: errors = 0\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(a)\n        CALL RANDOM_NUMBER(b)\n\n        totals = 1\n        totals_comparison = 1\n\n        !$acc data copyin(a(1:LOOPCOUNT), b(1:LOOPCOUNT)) copy(totals(1:(LOOPCOUNT/10 + 1)))\n          !$acc parallel\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              !$acc atomic\n                totals(MOD(x, LOOPCOUNT/10 + 1) + 1) = min(totals(MOD(x, LOOPCOUNT/10 + 1) + 1), a(x), b(x))\n              !$acc end atomic\n            END DO\n          !$acc end parallel\n        !$acc end data\n        DO x = 1, LOOPCOUNT\n          totals_comparison(MOD(x, LOOPCOUNT/10 + 1) + 1) = min(totals_comparison(MOD(x, LOOPCOUNT/10 + 1) + 1), a(x), b(x))\n        END DO\n        DO x = 1, LOOPCOUNT/10 + 1\n          IF (totals_comparison(x) .NE. totals(x)) THEN\n            errors = errors + 1\n            WRITE(*, *) totals_comparison(x)\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "construct-independent",
                            "atomic"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_minus_equals.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:atomic,construct-independent,V:2.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t *a = (real_t *)malloc(n * sizeof(real_t));\n    real_t *b = (real_t *)malloc(n * sizeof(real_t));\n    real_t *totals = (real_t *)malloc(10 * sizeof(real_t));\n    real_t *totals_host = (real_t *)malloc(10 * sizeof(real_t));\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n    }\n    for (int x = 0; x < 10; ++x){\n        totals[x] = 0;\n    }\n\n    #pragma acc data copyin(a[0:n], b[0:n]) copy(totals[0:10])\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                #pragma acc atomic\n                    totals[x%10] -= (a[x] + b[x]);\n            }\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        totals_host[x%10] = totals_host[x%10] - (a[x] + b[x]);\n    }\n    for (int x = 0; x < 10; ++x){\n        if (fabs(totals_host[x] - totals[x]) > PRECISION){\n            err += 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "atomic",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_multiply_equals.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:atomic,construct-independent,V:2.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t *a = (real_t *)malloc(n * sizeof(real_t));\n    real_t *b = (real_t *)malloc(n * sizeof(real_t));\n    real_t *totals = (real_t *)malloc((n/10 + 1) * sizeof(real_t));\n    real_t *totals_comparison = (real_t *)malloc((n/10 + 1) * sizeof(real_t));\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n    }\n    for (int x = 0; x < n/10 + 1; ++x){\n        totals[x] = 1;\n        totals_comparison[x] = 1;\n    }\n\n    #pragma acc data copyin(a[0:n], b[0:n]) copy(totals[0:n/10 + 1])\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                #pragma acc atomic\n                    totals[x%(n/10 + 1)] *= a[x] + b[x];\n            }\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        totals_comparison[x%(n/10 + 1)] *= a[x] + b[x];\n    }\n    for (int x = 0; x < 10; ++x){\n        if (fabs(totals_comparison[x] - totals[x]) > PRECISION * totals_comparison[x]){\n            err += 1;\n            break;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "atomic",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_plus_equals.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:atomic,construct-independent,V:2.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t *a = (real_t *)malloc(n * sizeof(real_t));\n    real_t *b = (real_t *)malloc(n * sizeof(real_t));\n    real_t *totals = (real_t *)malloc((n/10 + 1) * sizeof(real_t));\n    real_t *totals_comparison = (real_t *)malloc((n/10 + 1) * sizeof(real_t));\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n    }\n    for (int x = 0; x < n/10 + 1; ++x){\n        totals[x] = 0;\n        totals_comparison[x] = 0;\n    }\n\n    #pragma acc data copyin(a[0:n], b[0:n]) copy(totals[0:n/10 + 1])\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                #pragma acc atomic\n                    totals[x%(n/10 + 1)] += a[x] * b[x];\n            }\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        totals_comparison[x%(n/10 + 1)] += a[x] * b[x];\n    }\n    for (int x = 0; x < n/10 + 1; ++x){\n        if (fabs(totals_comparison[x] - totals[x]) > (n/10 + 1) * PRECISION){\n            err += 1;\n            break;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "atomic",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_postdecrement.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:atomic,construct-independent,V:2.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t *a = (real_t *)malloc(n * sizeof(real_t));\n    real_t *b = (real_t *)malloc(n * sizeof(real_t));\n    int *distribution = (int *)malloc(10 * sizeof(int));\n    int *distribution_comparison = (int *)malloc(10 * sizeof(int));\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n    }\n    for (int x = 0; x < 10; ++x){\n        distribution[x] = 0;\n        distribution_comparison[x] = 0;\n    }\n\n    #pragma acc data copyin(a[0:n], b[0:n]) copy(distribution[0:10])\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                #pragma acc atomic\n                    distribution[(int) (a[x] * b[x] / 10)]--;\n            }\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        distribution_comparison[(int) (a[x]*b[x]/10)]--;\n    }\n    for (int x = 0; x < 10; ++x){\n        if (distribution_comparison[x] != distribution[x]){\n            err += 1;\n            break;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "atomic",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_postincrement.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:atomic,construct-independent,V:2.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t *a = (real_t *)malloc(n * sizeof(real_t));\n    real_t *b = (real_t *)malloc(n * sizeof(real_t));\n    int *distribution = (int *)malloc(10 * sizeof(int));\n    int *distribution_comparison = (int *)malloc(10 * sizeof(int));\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n    }\n    for (int x = 0; x < 10; ++x){\n        distribution[x] = 0;\n        distribution_comparison[x] = 0;\n    }\n\n    #pragma acc data copyin(a[0:n], b[0:n]) copy(distribution[0:10])\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                #pragma acc loop\n                for (int y = 0; y < n; ++y){\n                    #pragma acc atomic\n                        distribution[(int) (a[x]*b[y]/10)]++;\n                }\n            }\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        for (int y = 0; y < n; ++y){\n            distribution_comparison[(int) (a[x]*b[y]/10)]++;\n        }\n    }\n    for (int x = 0; x < 10; ++x){\n        if (distribution_comparison[x] != distribution[x]){\n            err += 1;\n            break;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "atomic",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_predecrement.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:atomic,construct-independent,V:2.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t *a = (real_t *)malloc(n * sizeof(real_t));\n    real_t *b = (real_t *)malloc(n * sizeof(real_t));\n    int *distribution = (int *)malloc(10 * sizeof(int));\n    int *distribution_comparison = (int *)malloc(10 * sizeof(int));\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n    }\n    for (int x = 0; x < 10; ++x){\n        distribution[x] = 0;\n        distribution_comparison[x] = 0;\n    }\n\n    #pragma acc data copyin(a[0:n], b[0:n]) copy(distribution[0:10])\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                #pragma acc loop\n                for (int y = 0; y < n; ++y){\n                    #pragma acc atomic\n                        --distribution[(int) (a[x]*b[y]/10)];\n                }\n            }\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        for (int y = 0; y < n; ++y){\n            distribution_comparison[(int) (a[x]*b[y]/10)]--;\n        }\n    }\n    for (int x = 0; x < 10; ++x){\n        if (distribution_comparison[x] != distribution[x]){\n            err += 1;\n            break;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "atomic",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_preincrement.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:atomic,construct-independent,V:2.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t *a = (real_t *)malloc(n * sizeof(real_t));\n    real_t *b = (real_t *)malloc(n * sizeof(real_t));\n    int *distribution = (int *)malloc(10 * sizeof(int));\n    int *distribution_comparison = (int *)malloc(10 * sizeof(int));\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n    }\n    for (int x = 0; x < 10; ++x){\n        distribution[x] = 0;\n        distribution_comparison[x] = 0;\n    }\n\n    #pragma acc data copyin(a[0:n], b[0:n]) copy(distribution[0:10])\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                #pragma acc loop\n                for (int y = 0; y < n; ++y){\n                    #pragma acc atomic\n                        ++distribution[(int) (a[x]*b[y]/10)];\n                }\n            }\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        for (int y = 0; y < n; ++y){\n            distribution_comparison[(int) (a[x]*b[y]/10)]++;\n        }\n    }\n    for (int x = 0; x < 10; ++x){\n        if (distribution_comparison[x] != distribution[x]){\n            err += 1;\n            break;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "atomic",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_rshift_equals.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:atomic,construct-independent,V:2.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    unsigned int *a = (unsigned int *)malloc(n * sizeof(int));\n    unsigned int *b = (unsigned int *)malloc(n * sizeof(int));\n\n    for (int x = 0; x < n; ++x){\n        a[x] = 1<<7;\n        for (int y = 0; y < 7; ++y){\n            if ((rand()/(unsigned int) (RAND_MAX)) > .5){\n                b[x] += 1<<y;\n            }\n        }\n    }\n\n    #pragma acc data copyin(b[0:n]) copy(a[0:n])\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                #pragma acc loop\n                for (int y = 0; y < 7; ++y){\n                    if ((b[x]>>y)%2 == 1){\n                        #pragma acc atomic\n                            a[x] >>= 1;\n                    }\n                }\n            }\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        for (int y = 0; y < 7; ++y){\n            if ((b[x]>>y)%2 == 1){\n                a[x] <<= 1;\n            }\n        }\n        if (a[x] != 1<<7){\n            err += 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "atomic",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_structured_assign_assign.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:atomic,construct-independent,V:2.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t *a = (real_t *)malloc(n * sizeof(real_t));\n    real_t *b = (real_t *)malloc(n * sizeof(real_t));\n    real_t *c = (real_t *)malloc(n * sizeof(real_t));\n    real_t *b_copy = (real_t *)malloc(n * sizeof(real_t));\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n        b_copy[x] = b[x];\n    }\n\n    #pragma acc data copyin(a[0:n]) copy(b[0:n]) copyout(c[0:n])\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                #pragma acc atomic update capture\n                {\n                    c[x] = b[x];\n                    b[x] = a[x];\n                }\n            }\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        if (abs(c[x] - b_copy[x]) > PRECISION){\n            err++;\n        }\n        if (abs(b[x] - a[x]) > PRECISION){\n            err++;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "atomic",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_structured_assign_bitand_equals.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:atomic,construct-independent,V:2.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    int *a = (int *)malloc(n * sizeof(int));\n    int *b = (int *)malloc(n * sizeof(int));\n    int *totals = (int *)malloc((n/10 + 1) * sizeof(int));\n    int *totals_comparison = (int *)malloc((n/10 + 1) * sizeof(int));\n    int *temp_a = (int *)malloc(10 * sizeof(int));\n    int *temp_b = (int *)malloc(10 * sizeof(int));\n    int iterator;\n    int iterator2;\n    int init;\n\n    for (int x = 0; x < n; ++x){\n        for (int y = 0; y < 8; ++y){\n            if (rand()/(real_t)(RAND_MAX) < .933){ //.933 gets close to a 50/50 distribution for a collescence of 10 values\n                a[x] += 1<<y;\n            }\n        }\n    }\n    for (int x = 0; x < n/10 + 1; ++x){\n        for (int y = 0; y < 8; ++y){\n            totals[x] +=  1<<y;\n            totals_comparison[x] += 1<<y;\n        }\n    }\n    for (int x = 0; x < n; ++x){\n        b[x] = 0;\n    }\n    #pragma acc data copyin(a[0:n]) copy(totals[0:n/10 + 1]) copyout(b[0:n])\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                #pragma acc atomic update capture\n                    {\n                        b[x] = totals[x/10];\n                        totals[x/10] &= a[x];\n                    }\n            }\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        totals_comparison[x/10] &= a[x];\n    }\n    for (int x = 0; x < (n/10 + 1); ++x){\n        if (totals_comparison[x] != totals[x]){\n            err += 1;\n            break;\n        }\n    }\n    for (int x = 0; x < 8; ++x){\n        init += 1<<x;\n    }\n\n    for (int x = 0; x < n; x = x + 10){\n        int y = x;\n        for (; y < x + 10 && y < n; y++){\n            temp_a[y - x] = a[y];\n            temp_b[y - x] = b[y];\n        }\n        if (!is_possible(temp_a, temp_b, y - x, init)){\n            err += 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "atomic",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_structured_assign_bitor_equals.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:atomic,construct-independent,V:2.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    int *a = (int *)malloc(n * sizeof(int));\n    int *b = (int *)malloc(n * sizeof(int));\n    int *totals = (int *)malloc((n/10 + 1) * sizeof(int));\n    int *totals_comparison = (int *)malloc((n/10 + 1) * sizeof(int));\n    int *temp_a = (int *)malloc(10 * sizeof(int));\n    int *temp_b = (int *)malloc(10 * sizeof(int));\n    int iterator;\n    int iterator2;\n    int init;\n\n    for (int x = 0; x < n; ++x){\n        for (int y = 0; y < 8; ++y){\n            if (rand()/(real_t)(RAND_MAX) < .933){ //.933 gets close to a 50/50 distribution for a collescence of 10 values\n                a[x] += 1<<y;\n            }\n        }\n    }\n    for (int x = 0; x < n/10 + 1; ++x){\n        for (int y = 0; y < 8; ++y){\n            totals[x] +=  1<<y;\n            totals_comparison[x] += 1<<y;\n        }\n    }\n    for (int x = 0; x < n; ++x){\n        b[x] = 0;\n    }\n    #pragma acc data copyin(a[0:n]) copy(totals[0:n/10 + 1]) copyout(b[0:n])\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                #pragma acc atomic update capture\n                    {\n                        b[x] = totals[x/10];\n                        totals[x/10] |= a[x];\n                    }\n            }\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        totals_comparison[x/10] |= a[x];\n    }\n    for (int x = 0; x < (n/10 + 1); ++x){\n        if (totals_comparison[x] != totals[x]){\n            err += 1;\n            break;\n        }\n    }\n    for (int x = 0; x < 8; ++x){\n        init += 1<<x;\n    }\n    int y;\n    for (int x = 0; x < n; x = x + 10){\n        y = x;\n        for (; y < x + 10 && y < n; y++){\n            temp_a[y - x] = a[y];\n            temp_b[y - x] = b[y];\n        }\n        if (!is_possible(temp_a, temp_b, (y - x) - 1, init)){\n            err += 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "atomic",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_structured_assign_bitxor_equals.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:atomic,construct-independent,V:2.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    int *a = (int *)malloc(n * sizeof(int));\n    int *b = (int *)malloc(n * sizeof(int));\n    int *totals = (int *)malloc((n/10 + 1) * sizeof(int));\n    int *totals_comparison = (int *)malloc((n/10 + 1) * sizeof(int));\n    int *temp_a = (int *)malloc(10 * sizeof(int));\n    int *temp_b = (int *)malloc(10 * sizeof(int));\n    int iterator;\n    int iterator2;\n    int init;\n\n    for (int x = 0; x < n; ++x){\n        for (int y = 0; y < 8; ++y){\n            if (rand()/(real_t)(RAND_MAX) < .933){ //.933 gets close to a 50/50 distribution for a collescence of 10 values\n                a[x] += 1<<y;\n            }\n        }\n    }\n    for (int x = 0; x < n/10 + 1; ++x){\n        for (int y = 0; y < 8; ++y){\n            totals[x] +=  1<<y;\n            totals_comparison[x] += 1<<y;\n        }\n    }\n    for (int x = 0; x < n; ++x){\n        b[x] = 0;\n    }\n    #pragma acc data copyin(a[0:n]) copy(totals[0:n/10 + 1]) copyout(b[0:n])\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                #pragma acc atomic update capture\n                    {\n                        b[x] = totals[x/10];\n                        totals[x/10] ^= a[x];\n                    }\n            }\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        totals_comparison[x/10] ^= a[x];\n    }\n    for (int x = 0; x < (n/10 + 1); ++x){\n        if (totals_comparison[x] != totals[x]){\n            err += 1;\n            break;\n        }\n    }\n    for (int x = 0; x < 8; ++x){\n        init += 1<<x;\n    }\n    int y;\n    for (int x = 0; x < n; x = x + 10){\n        y = x;\n        for (; y < x + 10 && y < n; y++){\n            temp_a[y - x] = a[y];\n            temp_b[y - x] = b[y];\n        }\n        if (!is_possible(temp_a, temp_b, (y - x) - 1, init)){\n            err += 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "atomic",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_structured_assign_divided_equals.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:atomic,construct-independent,V:2.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t *a = (real_t *)malloc(n * sizeof(real_t));\n    real_t *b = (real_t *)malloc(n * sizeof(real_t));\n    real_t *c = (real_t *)malloc(n * sizeof(real_t));\n    real_t *totals = (real_t *)malloc((n/10 + 1) * sizeof(real_t));\n    real_t *totals_comparison = (real_t *)malloc((n/10 + 1) * sizeof(real_t));\n    real_t *temp_a = (real_t *)malloc(10 * sizeof(real_t));\n    real_t *temp_b = (real_t *)malloc(10 * sizeof(real_t));\n    real_t *temp_c = (real_t *)malloc(10 * sizeof(real_t));\n    int temp_iterator;\n    int ab_iterator;\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n        c[x] = 0;\n    }\n    for (int x = 0; x < n/10 + 1; ++x){\n        totals[x] = 1;\n        totals_comparison[x] = 1;\n    }\n\n    #pragma acc data copyin(a[0:n], b[0:n]) copy(totals[0:n/10 + 1]) copyout(c[0:n])\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                #pragma acc atomic update capture\n                {\n                    c[x] = totals[x/10];\n                    totals[x/10] /= (a[x] + b[x]);\n                }\n            }\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        totals_comparison[x/10] /= a[x] + b[x];\n    }\n    for (int x = 0; x < 10; ++x){\n        if (fabs(totals_comparison[x] - totals[x]) > PRECISION){\n            err += 1;\n            break;\n        }\n    }\n\n    for (int x = 0; x < n; x = x + 10){\n        temp_iterator = 0;\n        for (ab_iterator = x; ab_iterator < n && ab_iterator < x + 10;  ab_iterator+= 1){\n            temp_a[temp_iterator] = a[ab_iterator];\n            temp_b[temp_iterator] = b[ab_iterator];\n            temp_c[temp_iterator] = c[ab_iterator];\n            temp_iterator++;\n        }\n        if (!(is_possible(temp_a, temp_b, temp_c, temp_iterator, 1))){\n            err++;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "atomic",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_structured_assign_expr_bitand_x.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:atomic,construct-independent,V:2.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    int *a = (int *)malloc(n * sizeof(int));\n    int *b = (int *)malloc(n * sizeof(int));\n    int *totals = (int *)malloc((n/10 + 1) * sizeof(int));\n    int *totals_comparison = (int *)malloc((n/10 + 1) * sizeof(int));\n    int *temp_a = (int *)malloc(10 * sizeof(int));\n    int *temp_b = (int *)malloc(10 * sizeof(int));\n    int iterator;\n    int iterator2;\n    int init;\n\n    for (int x = 0; x < n; ++x){\n        for (int y = 0; y < 8; ++y){\n            if (rand()/(real_t)(RAND_MAX) < .933){ //.933 gets close to a 50/50 distribution for a collescence of 10 values\n                a[x] += 1<<y;\n            }\n        }\n    }\n    for (int x = 0; x < n/10 + 1; ++x){\n        for (int y = 0; y < 8; ++y){\n            totals[x] +=  1<<y;\n            totals_comparison[x] += 1<<y;\n        }\n    }\n    for (int x = 0; x < n; ++x){\n        b[x] = 0;\n    }\n    #pragma acc data copyin(a[0:n]) copy(totals[0:n/10 + 1]) copyout(b[0:n])\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                #pragma acc atomic update capture\n                    {\n                        b[x] = totals[x/10];\n                        totals[x/10] = a[x] & totals[x/10];\n                    }\n            }\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        totals_comparison[x/10] &= a[x];\n    }\n    for (int x = 0; x < (n/10 + 1); ++x){\n        if (totals_comparison[x] != totals[x]){\n            err += 1;\n            break;\n        }\n    }\n    for (int x = 0; x < 8; ++x){\n        init += 1<<x;\n    }\n\n    for (int x = 0; x < n; x = x + 10){\n        int y = x;\n        for (; y < x + 10 && y < n; y++){\n            temp_a[y - x] = a[y];\n            temp_b[y - x] = b[y];\n        }\n        if (!is_possible(temp_a, temp_b, y - x, init)){\n            err += 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "atomic",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_structured_assign_expr_bitor_x.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:atomic,construct-independent,V:2.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    int *a = (int *)malloc(n * sizeof(int));\n    int *b = (int *)malloc(n * sizeof(int));\n    int *totals = (int *)malloc((n/10 + 1) * sizeof(int));\n    int *totals_comparison = (int *)malloc((n/10 + 1) * sizeof(int));\n    int *temp_a = (int *)malloc(10 * sizeof(int));\n    int *temp_b = (int *)malloc(10 * sizeof(int));\n    int iterator;\n    int iterator2;\n    int init;\n\n    for (int x = 0; x < n; ++x){\n        for (int y = 0; y < 8; ++y){\n            if (rand()/(real_t)(RAND_MAX) < .933){ //.933 gets close to a 50/50 distribution for a collescence of 10 values\n                a[x] += 1<<y;\n            }\n        }\n    }\n    for (int x = 0; x < n/10 + 1; ++x){\n        for (int y = 0; y < 8; ++y){\n            totals[x] +=  1<<y;\n            totals_comparison[x] += 1<<y;\n        }\n    }\n    for (int x = 0; x < n; ++x){\n        b[x] = 0;\n    }\n    #pragma acc data copyin(a[0:n]) copy(totals[0:n/10 + 1]) copyout(b[0:n])\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                #pragma acc atomic update capture\n                    {\n                        b[x] = totals[x/10];\n                        totals[x/10] = a[x] | totals[x/10];\n                    }\n            }\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        totals_comparison[x/10] |= a[x];\n    }\n    for (int x = 0; x < (n/10 + 1); ++x){\n        if (totals_comparison[x] != totals[x]){\n            err += 1;\n            break;\n        }\n    }\n    for (int x = 0; x < 8; ++x){\n        init += 1<<x;\n    }\n    int y;\n    for (int x = 0; x < n; x = x + 10){\n        y = x;\n        for (; y < x + 10 && y < n; y++){\n            temp_a[y - x] = a[y];\n            temp_b[y - x] = b[y];\n        }\n        if (!is_possible(temp_a, temp_b, (y - x) - 1, init)){\n            err += 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "atomic",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_structured_assign_expr_bitxor_x.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:atomic,construct-independent,V:2.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    int *a = (int *)malloc(n * sizeof(int));\n    int *b = (int *)malloc(n * sizeof(int));\n    int *totals = (int *)malloc((n/10 + 1) * sizeof(int));\n    int *totals_comparison = (int *)malloc((n/10 + 1) * sizeof(int));\n    int *temp_a = (int *)malloc(10 * sizeof(int));\n    int *temp_b = (int *)malloc(10 * sizeof(int));\n    int iterator;\n    int iterator2;\n    int init;\n\n    for (int x = 0; x < n; ++x){\n        for (int y = 0; y < 8; ++y){\n            if (rand()/(real_t)(RAND_MAX) < .933){ //.933 gets close to a 50/50 distribution for a collescence of 10 values\n                a[x] += 1<<y;\n            }\n        }\n    }\n    for (int x = 0; x < n/10 + 1; ++x){\n        for (int y = 0; y < 8; ++y){\n            totals[x] +=  1<<y;\n            totals_comparison[x] += 1<<y;\n        }\n    }\n    for (int x = 0; x < n; ++x){\n        b[x] = 0;\n    }\n    #pragma acc data copyin(a[0:n]) copy(totals[0:n/10 + 1]) copyout(b[0:n])\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                #pragma acc atomic update capture\n                    {\n                        b[x] = totals[x/10];\n                        totals[x/10] = a[x] ^ totals[x/10];\n                    }\n            }\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        totals_comparison[x/10] ^= a[x];\n    }\n    for (int x = 0; x < (n/10 + 1); ++x){\n        if (totals_comparison[x] != totals[x]){\n            err += 1;\n            break;\n        }\n    }\n    for (int x = 0; x < 8; ++x){\n        init += 1<<x;\n    }\n    int y;\n    for (int x = 0; x < n; x = x + 10){\n        y = x;\n        for (; y < x + 10 && y < n; y++){\n            temp_a[y - x] = a[y];\n            temp_b[y - x] = b[y];\n        }\n        if (!is_possible(temp_a, temp_b, (y - x) - 1, init)){\n            err += 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "atomic",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_structured_assign_expr_divided_x.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:atomic,construct-independent,V:2.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t *a = (real_t *)malloc(n * sizeof(real_t));\n    real_t *b = (real_t *)malloc(n * sizeof(real_t));\n    real_t *c = (real_t *)malloc(n * sizeof(real_t));\n    real_t *totals = (real_t *)malloc((n/10 + 1) * sizeof(real_t));\n    real_t* passed_a = (real_t *)malloc(10 * sizeof(real_t));\n    real_t* passed_b = (real_t *)malloc(10 * sizeof(real_t));\n    real_t *temp_a = (real_t *)malloc(10 * sizeof(real_t));\n    real_t *temp_b = (real_t *)malloc(10 * sizeof(real_t));\n    real_t *temp_c = (real_t *)malloc(10 * sizeof(real_t));\n    int temp_iterator;\n    int ab_iterator;\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n        c[x] = 0;\n    }\n    for (int x = 0; x < n/10 + 1; ++x){\n        totals[x] = 1;\n    }\n\n    #pragma acc data copyin(a[0:n], b[0:n]) copy(totals[0:n/10 + 1]) copyout(c[0:n])\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                #pragma acc atomic update capture\n                {\n                    c[x] = totals[x/10];\n                    totals[x/10] = (a[x] + b[x]) / totals[x/10];\n                }\n            }\n        }\n    }\n\n    for (int x = 0; x < n; x = x + 10){\n        for (int y = 0; y < 10 && (x + y) < n; ++y){\n            passed_a[y] = a[x + y];\n            passed_b[y] = b[x + y];\n        }\n        if (!(is_possible_2(passed_a, passed_b, 10, 1, totals[x/10]))){\n            err += 1;\n            break;\n        }\n    }\n\n    for (int x = 0; x < n; x = x + 10){\n        temp_iterator = 0;\n        for (ab_iterator = x; ab_iterator < n && ab_iterator < x + 10;  ab_iterator+= 1){\n            temp_a[temp_iterator] = a[ab_iterator];\n            temp_b[temp_iterator] = b[ab_iterator];\n            temp_c[temp_iterator] = c[ab_iterator];\n            temp_iterator++;\n        }\n        if (!(is_possible(temp_a, temp_b, temp_c, temp_iterator, 1))){\n            err++;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "atomic",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_structured_assign_expr_multiply_x.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:atomic,construct-independent,V:2.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t *a = (real_t *)malloc(n * sizeof(real_t));\n    real_t *b = (real_t *)malloc(n * sizeof(real_t));\n    real_t *c = (real_t *)malloc(n * sizeof(real_t));\n    real_t *totals = (real_t *)malloc((n/10 + 1) * sizeof(real_t));\n    real_t *totals_comparison = (real_t *)malloc((n/10 + 1) * sizeof(real_t));\n    real_t * passed_ab = (real_t *)malloc(10 * sizeof(real_t));\n    real_t * passed_c = (real_t *)malloc(10 * sizeof(real_t));\n    int passed_indexer;\n    int absolute_indexer;\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n    }\n    for (int x = 0; x < n/10 + 1; ++x){\n        totals[x] = 1;\n        totals_comparison[x] = 1;\n    }\n\n    #pragma acc data copyin(a[0:n], b[0:n]) copy(totals[0:n/10 + 1]) copyout(c[0:n])\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                #pragma acc atomic update capture\n                {\n                    c[x] = totals[x%(n/10 + 1)];\n                    totals[x%(n/10 + 1)] = (a[x] + b[x]) * totals[x%(n/10 + 1)];\n                }\n            }\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        totals_comparison[x%(n/10 + 1)] *= a[x] + b[x];\n    }\n    for (int x = 0; x < 10; ++x){\n        if (fabs(totals_comparison[x] - totals[x]) > PRECISION * totals_comparison[x]){\n            err += 1;\n            break;\n        }\n    }\n\n    for (int x = 0; x < n/10 + 1; ++x){\n        for (passed_indexer = 0, absolute_indexer = x; absolute_indexer < n; passed_indexer++, absolute_indexer += n/10 + 1){\n            passed_ab[passed_indexer] = a[absolute_indexer] + b[absolute_indexer];\n            passed_c[passed_indexer] = c[absolute_indexer];\n        }\n        if (!is_possible(passed_ab, passed_c, passed_indexer - 1, 1)){\n            err++;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "atomic",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_structured_assign_expr_plus_x.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:atomic,construct-independent,V:2.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t *a = (real_t *)malloc(n * sizeof(real_t));\n    real_t *b = (real_t *)malloc(n * sizeof(real_t));\n    real_t *c = (real_t *)malloc(n * sizeof(real_t));\n    real_t *totals = (real_t *)malloc((n/10 + 1) * sizeof(real_t));\n    real_t *totals_comparison = (real_t *)malloc((n/10 + 1) * sizeof(real_t));\n    real_t *passed_ab = (real_t *)malloc(10 * sizeof(real_t));\n    real_t *passed_c = (real_t *)malloc(10 * sizeof(real_t));\n    int passed_indexer;\n    int absolute_indexer;\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n    }\n    for (int x = 0; x < n/10 + 1; ++x){\n        totals[x] = 0;\n        totals_comparison[x] = 0;\n    }\n\n    #pragma acc data copyin(a[0:n], b[0:n]) copy(totals[0:n/10 + 1]) copyout(c[0:n])\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                #pragma acc atomic update capture\n                {\n                    c[x] = totals[x%(n/10 + 1)];\n                    totals[x%(n/10 + 1)] = (a[x] * b[x]) + totals[x%(n/10 + 1)];\n                }\n            }\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        totals_comparison[x%(n/10 + 1)] += a[x] * b[x];\n    }\n    for (int x = 0; x < n/10 + 1; ++x){\n        if (fabs(totals_comparison[x] - totals[x]) > PRECISION){\n            err += 1;\n            break;\n        }\n    }\n\n    for (int x = 0; x < n/10 + 1; ++x){\n        for (passed_indexer = 0, absolute_indexer = x; absolute_indexer < n; passed_indexer++, absolute_indexer+= (n/10 + 1)){\n            passed_ab[passed_indexer] = a[absolute_indexer] * b[absolute_indexer];\n            passed_c[passed_indexer] = c[absolute_indexer];\n        }\n        if (!is_possible(passed_ab, passed_c, passed_indexer - 1, 0)){\n            err++;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "atomic",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_structured_assign_lshift_equals.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:atomic,construct-independent,V:2.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    unsigned int *a = (unsigned int *)malloc(n * sizeof(int));\n    unsigned int *b = (unsigned int *)malloc(n * sizeof(int));\n    unsigned int *c = (unsigned int *)malloc(7 * n * sizeof(int));\n    unsigned int passed = 1;\n\n    for (int x = 0; x < n; ++x){\n        a[x] = 1;\n        for (int y = 0; y < 7; ++y){\n            if ((rand()/(real_t) (RAND_MAX)) > .5){\n                b[x] += 1<<y;\n            }\n        }\n    }\n\n    #pragma acc data copyin(b[0:n]) copy(a[0:n]) copyout(c[0:7*n])\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                #pragma acc loop\n                for (int y = 0; y < 7; ++y){\n                    c[x * 7 + y] = a[x];\n                    if ((b[x]>>y)%2 == 1){\n                        #pragma acc atomic update capture\n                        {\n                            c[x * 7 + y] = a[x];\n                            a[x] <<= 1;\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        for (int y = 0; y < 7; ++y){\n            if ((b[x]>>y)%2 == 1){\n                a[x] >>= 1;\n            }\n        }\n        if (a[x] != 1){\n            err += 1;\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        if (!is_possible(b[x], &(c[x * 7]), 7, passed)){\n            err++;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "atomic",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_structured_assign_minus_equals.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:atomic,construct-independent,V:2.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t *a = (real_t *)malloc(n * sizeof(real_t));\n    real_t *b = (real_t *)malloc(n * sizeof(real_t));\n    real_t *c = (real_t *)malloc(n * sizeof(real_t));\n    real_t *totals = (real_t *)malloc(10 * sizeof(real_t));\n    real_t *totals_host = (real_t *)malloc(10 * sizeof(real_t));\n    real_t * passed_ab = (real_t *)malloc((n/10 + 1) * sizeof(real_t));\n    real_t * passed_c = (real_t *)malloc((n/10 + 1) * sizeof(real_t));\n    int passed_indexer;\n    int absolute_indexer;\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n    }\n    for (int x = 0; x < 10; ++x){\n        totals[x] = 0;\n    }\n\n    #pragma acc data copyin(a[0:n], b[0:n]) copy(totals[0:10])\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                #pragma acc atomic update capture\n                {\n                    c[x] = totals[x%10];\n                    totals[x%10] -= (a[x] + b[x]);\n                }\n            }\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        totals_host[x%10] = totals_host[x%10] - (a[x] + b[x]);\n    }\n    for (int x = 0; x < 10; ++x){\n        if (fabs(totals_host[x] - totals[x]) > PRECISION){\n            err += 1;\n        }\n    }\n\n    for (int x = 0; x < 10; ++x){\n        for (passed_indexer = 0, absolute_indexer = x; absolute_indexer < n; passed_indexer++, absolute_indexer+= 10){\n            passed_ab[passed_indexer] = a[absolute_indexer] + b[absolute_indexer];\n            passed_c[passed_indexer] = c[absolute_indexer];\n        }\n        if (!is_possible(passed_ab, passed_c, passed_indexer - 1, 0)){\n            err++;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "atomic",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_structured_assign_multiply_equals.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:atomic,construct-independent,V:2.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t *a = (real_t *)malloc(n * sizeof(real_t));\n    real_t *b = (real_t *)malloc(n * sizeof(real_t));\n    real_t *c = (real_t *)malloc(n * sizeof(real_t));\n    real_t *totals = (real_t *)malloc((n/10 + 1) * sizeof(real_t));\n    real_t *totals_comparison = (real_t *)malloc((n/10 + 1) * sizeof(real_t));\n    real_t * passed_ab = (real_t *)malloc(10 * sizeof(real_t));\n    real_t * passed_c = (real_t *)malloc(10 * sizeof(real_t));\n    int passed_indexer;\n    int absolute_indexer;\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n    }\n    for (int x = 0; x < n/10 + 1; ++x){\n        totals[x] = 1;\n        totals_comparison[x] = 1;\n    }\n\n    #pragma acc data copyin(a[0:n], b[0:n]) copy(totals[0:n/10 + 1]) copyout(c[0:n])\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                #pragma acc atomic update capture\n                {\n                    c[x] = totals[x%(n/10 + 1)];\n                    totals[x%(n/10 + 1)] *= a[x] + b[x];\n                }\n            }\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        totals_comparison[x%(n/10 + 1)] *= a[x] + b[x];\n    }\n    for (int x = 0; x < 10; ++x){\n        if (fabs(totals_comparison[x] - totals[x]) > PRECISION * totals_comparison[x]){\n            err += 1;\n            break;\n        }\n    }\n\n    for (int x = 0; x < n/10 + 1; ++x){\n        for (passed_indexer = 0, absolute_indexer = x; absolute_indexer < n; passed_indexer++, absolute_indexer += n/10 + 1){\n            passed_ab[passed_indexer] = a[absolute_indexer] + b[absolute_indexer];\n            passed_c[passed_indexer] = c[absolute_indexer];\n        }\n        if (!is_possible(passed_ab, passed_c, passed_indexer - 1, 1)){\n            err++;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "atomic",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_structured_assign_plus_equals.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:atomic,construct-independent,V:2.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t *a = (real_t *)malloc(n * sizeof(real_t));\n    real_t *b = (real_t *)malloc(n * sizeof(real_t));\n    real_t *c = (real_t *)malloc(n * sizeof(real_t));\n    real_t *totals = (real_t *)malloc((n/10 + 1) * sizeof(real_t));\n    real_t *totals_comparison = (real_t *)malloc((n/10 + 1) * sizeof(real_t));\n    real_t *passed_ab = (real_t *)malloc(10 * sizeof(real_t));\n    real_t *passed_c = (real_t *)malloc(10 * sizeof(real_t));\n    int passed_indexer;\n    int absolute_indexer;\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n    }\n    for (int x = 0; x < n/10 + 1; ++x){\n        totals[x] = 0;\n        totals_comparison[x] = 0;\n    }\n\n    #pragma acc data copyin(a[0:n], b[0:n]) copy(totals[0:n/10 + 1]) copyout(c[0:n])\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                #pragma acc atomic update capture\n                {\n                    c[x] = totals[x%(n/10 + 1)];\n                    totals[x%(n/10 + 1)] += a[x] * b[x];\n                }\n            }\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        totals_comparison[x%(n/10 + 1)] += a[x] * b[x];\n    }\n    for (int x = 0; x < n/10 + 1; ++x){\n        if (fabs(totals_comparison[x] - totals[x]) > PRECISION){\n            err += 1;\n            break;\n        }\n    }\n\n    for (int x = 0; x < n/10 + 1; ++x){\n        for (passed_indexer = 0, absolute_indexer = x; absolute_indexer < n; passed_indexer++, absolute_indexer+= (n/10 + 1)){\n            passed_ab[passed_indexer] = a[absolute_indexer] * b[absolute_indexer];\n            passed_c[passed_indexer] = c[absolute_indexer];\n        }\n        if (!is_possible(passed_ab, passed_c, passed_indexer - 1, 0)){\n            err++;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "atomic",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_structured_assign_postdecrement.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:atomic,construct-independent,V:2.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t *a = (real_t *)malloc(n * sizeof(real_t));\n    real_t *b = (real_t *)malloc(n * sizeof(real_t));\n    int *c = (int *)malloc(n * sizeof(int));\n    int *distribution = (int *)malloc(10 * sizeof(int));\n    int *distribution_comparison = (int *)malloc(10 * sizeof(int));\n    bool found = false;\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n    }\n    for (int x = 0; x < 10; ++x){\n        distribution[x] = 0;\n        distribution_comparison[x] = 0;\n    }\n\n    #pragma acc data copyin(a[0:n], b[0:n]) copy(distribution[0:10]) copyout(c[0:n])\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                #pragma acc atomic update capture\n                {\n                    c[x] = distribution[(int) (a[x]*b[x]/10)];\n                    (distribution[(int) (a[x]*b[x]/10)])--;\n                }\n            }\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        distribution_comparison[(int) (a[x]*b[x]/10)]--;\n    }\n    for (int x = 0; x < 10; ++x){\n        if (distribution_comparison[x] != distribution[x]){\n            err += 1;\n            break;\n        }\n    }\n\n    for (int x = 0; x < 10; ++x){\n        for (int y = 0; y > -distribution_comparison[x]; --y){\n            for (int z = 0; z < n; ++z){\n                if (y == c[z] && x == (int) (a[x] * b[x] / 10)){\n                    found = true;\n                    break;\n                }\n            }\n            if (!found){\n                err++;\n            }\n            found = false;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "atomic",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_structured_assign_postincrement.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:atomic,construct-independent,V:2.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t *a = (real_t *)malloc(n * sizeof(real_t));\n    real_t *b = (real_t *)malloc(n * sizeof(real_t));\n    int *c = (int *)malloc(n * sizeof(int));\n    int *distribution = (int *)malloc(10 * sizeof(int));\n    int *distribution_comparison = (int *)malloc(10 * sizeof(int));\n    bool found = false;\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n    }\n    for (int x = 0; x < 10; ++x){\n        distribution[x] = 0;\n        distribution_comparison[x] = 0;\n    }\n\n    #pragma acc data copyin(a[0:n], b[0:n]) copy(distribution[0:10]) copyout(c[0:n])\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                #pragma acc atomic update capture\n                {\n                    c[x] = distribution[(int) (a[x]*b[x]/10)];\n                    distribution[(int) (a[x]*b[x]/10)]++;\n                }\n            }\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        distribution_comparison[(int) (a[x]*b[x]/10)]++;\n    }\n    for (int x = 0; x < 10; ++x){\n        if (distribution_comparison[x] != distribution[x]){\n            err += 1;\n            break;\n        }\n    }\n\n    for (int x = 0; x < 10; ++x){\n        for (int y = 0; y < distribution_comparison[x]; ++y){\n            for (int z = 0; z < n; ++z){\n                if (c[z] == y && (int) (a[z]*b[z]/10) == x){\n                    found = true;\n                    break;\n                }\n            }\n            if (!found){\n                err++;\n            }\n            found = false;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "atomic",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_structured_assign_predecrement.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:atomic,construct-independent,V:2.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t *a = (real_t *)malloc(n * sizeof(real_t));\n    real_t *b = (real_t *)malloc(n * sizeof(real_t));\n    int *c = (int *)malloc(n * sizeof(int));\n    int *distribution = (int *)malloc(10 * sizeof(int));\n    int *distribution_comparison = (int *)malloc(10 * sizeof(int));\n    bool found = false;\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n    }\n    for (int x = 0; x < 10; ++x){\n        distribution[x] = 0;\n        distribution_comparison[x] = 0;\n    }\n\n    #pragma acc data copyin(a[0:n], b[0:n]) copy(distribution[0:10]) copyout(c[0:n])\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                #pragma acc atomic update capture\n                {\n                    c[x] = distribution[(int) (a[x]*b[x]/10)];\n                    --distribution[(int) (a[x]*b[x]/10)];\n                }\n            }\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        distribution_comparison[(int) (a[x]*b[x]/10)]--;\n    }\n    for (int x = 0; x < 10; ++x){\n        if (distribution_comparison[x] != distribution[x]){\n            err += 1;\n            break;\n        }\n    }\n\n    for (int x = 0; x < 10; ++x){\n        for (int y = 0; y > distribution[x]; --y){\n            for (int z = 0; z < n; ++z){\n                if (c[z] == y && x == (int) (a[z] * b[z] / 10)){\n                    found = true;\n                    break;\n                }\n            }\n            if (!found){\n                err++;\n            }\n            found = false;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "atomic",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_structured_assign_preincrement.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:atomic,construct-independent,V:2.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t *a = (real_t *)malloc(n * sizeof(real_t));\n    real_t *b = (real_t *)malloc(n * sizeof(real_t));\n    int *c = (int *)malloc(n * sizeof(int));\n    int *distribution = (int *)malloc(10 * sizeof(int));\n    int *distribution_comparison = (int *)malloc(10 * sizeof(int));\n    bool found = false;\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n    }\n    for (int x = 0; x < 10; ++x){\n        distribution[x] = 0;\n        distribution_comparison[x] = 0;\n    }\n\n    #pragma acc data copyin(a[0:n], b[0:n]) copy(distribution[0:10]) copyout(c[0:n])\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                #pragma acc atomic update capture\n                {\n                    c[x] = distribution[(int) (a[x]*b[x]/10)];\n                    ++distribution[(int) (a[x]*b[x]/10)];\n                }\n            }\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        distribution_comparison[(int) (a[x]*b[x]/10)]++;\n    }\n    for (int x = 0; x < 10; ++x){\n        if (distribution_comparison[x] != distribution[x]){\n            err += 1;\n            break;\n        }\n    }\n\n    for (int x = 0; x < 10; ++x){\n        for (int y = 0; y < distribution[x]; ++y){\n            for (int z = 0; z < n; ++z){\n                if (c[z] == y && x == (int) (a[z] * b[z] / 10)){\n                    found = true;\n                    break;\n                }\n            }\n            if (!found){\n                err++;\n            }\n            found = false;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "atomic",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_structured_assign_rshift_equals.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:atomic,construct-independent,V:2.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    unsigned int *a = (unsigned int *)malloc(n * sizeof(int));\n    unsigned int *b = (unsigned int *)malloc(n * sizeof(int));\n    unsigned int *c = (unsigned int *)malloc(7 * n * sizeof(int));\n    unsigned int passed = 1<<8;\n\n    for (int x = 0; x < n; ++x){\n        a[x] = 1<<8;\n        for (int y = 0; y < 7; ++y){\n            if ((rand()/(real_t) (RAND_MAX)) > .5){\n                b[x] += 1<<y;\n            }\n        }\n    }\n\n    #pragma acc data copyin(b[0:n]) copy(a[0:n]) copyout(c[0:7*n])\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                #pragma acc loop\n                for (int y = 0; y < 7; ++y){\n                    c[x * 7 + y] = a[x];\n                    if ((b[x]>>y)%2 == 1){\n                        #pragma acc atomic update capture\n                        {\n                            c[x * 7 + y] = a[x];\n                            a[x] >>= 1;\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        for (int y = 0; y < 7; ++y){\n            if ((b[x]>>y)%2 == 1){\n                a[x] <<= 1;\n            }\n        }\n        if (a[x] != 1<<8){\n            err += 1;\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        if (!is_possible(b[x], &(c[x * 7]), 7, passed)){\n            err++;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "atomic",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_structured_assign_x_bitand_expr.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:atomic,construct-independent,V:2.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    int *a = (int *)malloc(n * sizeof(int));\n    int *b = (int *)malloc(n * sizeof(int));\n    int *totals = (int *)malloc((n/10 + 1) * sizeof(int));\n    int *totals_comparison = (int *)malloc((n/10 + 1) * sizeof(int));\n    int *temp_a = (int *)malloc(10 * sizeof(int));\n    int *temp_b = (int *)malloc(10 * sizeof(int));\n    int iterator;\n    int iterator2;\n    int init;\n\n    for (int x = 0; x < n; ++x){\n        for (int y = 0; y < 8; ++y){\n            if (rand()/(real_t)(RAND_MAX) < .933){ //.933 gets close to a 50/50 distribution for a collescence of 10 values\n                a[x] += 1<<y;\n            }\n        }\n    }\n    for (int x = 0; x < n/10 + 1; ++x){\n        for (int y = 0; y < 8; ++y){\n            totals[x] +=  1<<y;\n            totals_comparison[x] += 1<<y;\n        }\n    }\n    for (int x = 0; x < n; ++x){\n        b[x] = 0;\n    }\n    #pragma acc data copyin(a[0:n]) copy(totals[0:n/10 + 1]) copyout(b[0:n])\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                #pragma acc atomic update capture\n                    {\n                        b[x] = totals[x/10];\n                        totals[x/10] = totals[x/10] & a[x];\n                    }\n            }\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        totals_comparison[x/10] &= a[x];\n    }\n    for (int x = 0; x < (n/10 + 1); ++x){\n        if (totals_comparison[x] != totals[x]){\n            err += 1;\n            break;\n        }\n    }\n    for (int x = 0; x < 8; ++x){\n        init += 1<<x;\n    }\n\n    for (int x = 0; x < n; x = x + 10){\n        int y = x;\n        for (; y < x + 10 && y < n; y++){\n            temp_a[y - x] = a[y];\n            temp_b[y - x] = b[y];\n        }\n        if (!is_possible(temp_a, temp_b, y - x, init)){\n            err += 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "atomic",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_structured_assign_x_bitor_expr.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:atomic,construct-independent,V:2.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    int *a = (int *)malloc(n * sizeof(int));\n    int *b = (int *)malloc(n * sizeof(int));\n    int *totals = (int *)malloc((n/10 + 1) * sizeof(int));\n    int *totals_comparison = (int *)malloc((n/10 + 1) * sizeof(int));\n    int *temp_a = (int *)malloc(10 * sizeof(int));\n    int *temp_b = (int *)malloc(10 * sizeof(int));\n    int iterator;\n    int iterator2;\n    int init;\n    int y;\n\n    for (int x = 0; x < n; ++x){\n        for (int y = 0; y < 8; ++y){\n            if (rand()/(real_t)(RAND_MAX) < .933){ //.933 gets close to a 50/50 distribution for a collescence of 10 values\n                a[x] += 1<<y;\n            }\n        }\n    }\n    for (int x = 0; x < n/10 + 1; ++x){\n        for (int y = 0; y < 8; ++y){\n            totals[x] +=  1<<y;\n            totals_comparison[x] += 1<<y;\n        }\n    }\n    for (int x = 0; x < n; ++x){\n        b[x] = 0;\n    }\n    #pragma acc data copyin(a[0:n]) copy(totals[0:n/10 + 1]) copyout(b[0:n])\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                #pragma acc atomic update capture\n                    {\n                        b[x] = totals[x/10];\n                        totals[x/10] = totals[x/10] | a[x];\n                    }\n            }\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        totals_comparison[x/10] |= a[x];\n    }\n    for (int x = 0; x < (n/10 + 1); ++x){\n        if (totals_comparison[x] != totals[x]){\n            err += 1;\n            break;\n        }\n    }\n    for (int x = 0; x < 8; ++x){\n        init += 1<<x;\n    }\n    for (int x = 0; x < n; x = x + 10){\n        y = x;\n        for (; y < x + 10 && y < n; y++){\n            temp_a[y - x] = a[y];\n            temp_b[y - x] = b[y];\n        }\n        if (!is_possible(temp_a, temp_b, (y - x) - 1, init)){\n            err += 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "atomic",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_structured_assign_x_bitxor_expr.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:atomic,construct-independent,V:2.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    int *a = (int *)malloc(n * sizeof(int));\n    int *b = (int *)malloc(n * sizeof(int));\n    int *totals = (int *)malloc((n/10 + 1) * sizeof(int));\n    int *totals_comparison = (int *)malloc((n/10 + 1) * sizeof(int));\n    int *temp_a = (int *)malloc(10 * sizeof(int));\n    int *temp_b = (int *)malloc(10 * sizeof(int));\n    int iterator;\n    int iterator2;\n    int init;\n    int y;\n\n    for (int x = 0; x < n; ++x){\n        for (int y = 0; y < 8; ++y){\n            if (rand()/(real_t)(RAND_MAX) < .933){ //.933 gets close to a 50/50 distribution for a collescence of 10 values\n                a[x] += 1<<y;\n            }\n        }\n    }\n    for (int x = 0; x < n/10 + 1; ++x){\n        for (int y = 0; y < 8; ++y){\n            totals[x] +=  1<<y;\n            totals_comparison[x] += 1<<y;\n        }\n    }\n    for (int x = 0; x < n; ++x){\n        b[x] = 0;\n    }\n    #pragma acc data copyin(a[0:n]) copy(totals[0:n/10 + 1]) copyout(b[0:n])\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                #pragma acc atomic update capture\n                    {\n                        b[x] = totals[x/10];\n                        totals[x/10] = totals[x/10] ^ a[x];\n                    }\n            }\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        totals_comparison[x/10] ^= a[x];\n    }\n    for (int x = 0; x < (n/10 + 1); ++x){\n        if (totals_comparison[x] != totals[x]){\n            err += 1;\n            break;\n        }\n    }\n    for (int x = 0; x < 8; ++x){\n        init += 1<<x;\n    }\n    for (int x = 0; x < n; x = x + 10){\n        y = x;\n        for (; y < x + 10 && y < n; y++){\n            temp_a[y - x] = a[y];\n            temp_b[y - x] = b[y];\n        }\n        if (!is_possible(temp_a, temp_b, (y - x) - 1, init)){\n            err += 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "atomic",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_structured_assign_x_divided_expr.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:atomic,construct-independent,V:2.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t *a = (real_t *)malloc(n * sizeof(real_t));\n    real_t *b = (real_t *)malloc(n * sizeof(real_t));\n    real_t *c = (real_t *)malloc(n * sizeof(real_t));\n    real_t *totals = (real_t *)malloc((n/10 + 1) * sizeof(real_t));\n    real_t *totals_comparison = (real_t *)malloc((n/10 + 1) * sizeof(real_t));\n    real_t *temp_a = (real_t *)malloc(10 * sizeof(real_t));\n    real_t *temp_b = (real_t *)malloc(10 * sizeof(real_t));\n    real_t *temp_c = (real_t *)malloc(10 * sizeof(real_t));\n    int temp_iterator;\n    int ab_iterator;\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n        c[x] = 0;\n    }\n    for (int x = 0; x < n/10 + 1; ++x){\n        totals[x] = 1;\n        totals_comparison[x] = 1;\n    }\n\n    #pragma acc data copyin(a[0:n], b[0:n]) copy(totals[0:n/10 + 1]) copyout(c[0:n])\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                #pragma acc atomic update capture\n                {\n                    c[x] = totals[x/10];\n                    totals[x/10] = totals[x/10] / (a[x] + b[x]);\n                }\n            }\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        totals_comparison[x/10] /= a[x] + b[x];\n    }\n    for (int x = 0; x < 10; ++x){\n        if (fabs(totals_comparison[x] - totals[x]) > PRECISION){\n            err += 1;\n            break;\n        }\n    }\n\n    for (int x = 0; x < n; x = x + 10){\n        temp_iterator = 0;\n        for (ab_iterator = x; ab_iterator < n && ab_iterator < x + 10;  ab_iterator+= 1){\n            temp_a[temp_iterator] = a[ab_iterator];\n            temp_b[temp_iterator] = b[ab_iterator];\n            temp_c[temp_iterator] = c[ab_iterator];\n            temp_iterator++;\n        }\n        if (!(is_possible(temp_a, temp_b, temp_c, temp_iterator, 1))){\n            err++;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "atomic",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_structured_assign_x_lshift_expr.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:atomic,construct-independent,V:2.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    unsigned int *a = (unsigned int *)malloc(n * sizeof(int));\n    unsigned int *b = (unsigned int *)malloc(n * sizeof(int));\n    unsigned int *c = (unsigned int *)malloc(7 * n * sizeof(int));\n    unsigned int passed = 1;\n\n    for (int x = 0; x < n; ++x){\n        a[x] = 1;\n        for (int y = 0; y < 7; ++y){\n            if ((rand()/(real_t) (RAND_MAX)) > .5){\n                b[x] += 1<<y;\n            }\n        }\n    }\n\n    #pragma acc data copyin(b[0:n]) copy(a[0:n]) copyout(c[0:7*n])\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                #pragma acc loop\n                for (int y = 0; y < 7; ++y){\n                    c[x * 7 + y] = a[x];\n                    if ((b[x]>>y)%2 == 1){\n                        #pragma acc atomic update capture\n                        {\n                            c[x * 7 + y] = a[x];\n                            a[x] = a[x] << 1;\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        for (int y = 0; y < 7; ++y){\n            if ((b[x]>>y)%2 == 1){\n                a[x] >>= 1;\n            }\n        }\n        if (a[x] != 1){\n            err += 1;\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        if (!is_possible(b[x], &(c[x * 7]), 7, passed)){\n            err++;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "atomic",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_structured_assign_x_minus_expr.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:atomic,construct-independent,V:2.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t *a = (real_t *)malloc(n * sizeof(real_t));\n    real_t *b = (real_t *)malloc(n * sizeof(real_t));\n    real_t *c = (real_t *)malloc(n * sizeof(real_t));\n    real_t *totals = (real_t *)malloc(10 * sizeof(real_t));\n    real_t *totals_host = (real_t *)malloc(10 * sizeof(real_t));\n    real_t * passed_ab = (real_t *)malloc((n/10 + 1) * sizeof(real_t));\n    real_t * passed_c = (real_t *)malloc((n/10 + 1) * sizeof(real_t));\n    int passed_indexer;\n    int absolute_indexer;\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n    }\n    for (int x = 0; x < 10; ++x){\n        totals[x] = 0;\n    }\n\n    #pragma acc data copyin(a[0:n], b[0:n]) copy(totals[0:10])\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                #pragma acc atomic update capture\n                {\n                    c[x] = totals[x%10];\n                    totals[x%10] = totals[x%10] - (a[x] + b[x]);\n                }\n            }\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        totals_host[x%10] = totals_host[x%10] - (a[x] + b[x]);\n    }\n    for (int x = 0; x < 10; ++x){\n        if (fabs(totals_host[x] - totals[x]) > PRECISION){\n            err += 1;\n        }\n    }\n\n    for (int x = 0; x < 10; ++x){\n        for (passed_indexer = 0, absolute_indexer = x; absolute_indexer < n; passed_indexer++, absolute_indexer+= 10){\n            passed_ab[passed_indexer] = a[absolute_indexer] + b[absolute_indexer];\n            passed_c[passed_indexer] = c[absolute_indexer];\n        }\n        if (!is_possible(passed_ab, passed_c, passed_indexer - 1, 0)){\n            err++;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "atomic",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_structured_assign_x_multiply_expr.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:atomic,construct-independent,V:2.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t *a = (real_t *)malloc(n * sizeof(real_t));\n    real_t *b = (real_t *)malloc(n * sizeof(real_t));\n    real_t *c = (real_t *)malloc(n * sizeof(real_t));\n    real_t *totals = (real_t *)malloc((n/10 + 1) * sizeof(real_t));\n    real_t *totals_comparison = (real_t *)malloc((n/10 + 1) * sizeof(real_t));\n    real_t * passed_ab = (real_t *)malloc(10 * sizeof(real_t));\n    real_t * passed_c = (real_t *)malloc(10 * sizeof(real_t));\n    int passed_indexer;\n    int absolute_indexer;\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n    }\n    for (int x = 0; x < n/10 + 1; ++x){\n        totals[x] = 1;\n        totals_comparison[x] = 1;\n    }\n\n    #pragma acc data copyin(a[0:n], b[0:n]) copy(totals[0:n/10 + 1]) copyout(c[0:n])\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                #pragma acc atomic update capture\n                {\n                    c[x] = totals[x%(n/10 + 1)];\n                    totals[x%(n/10 + 1)] = totals[x%(n/10 + 1)] * (a[x] + b[x]);\n                }\n            }\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        totals_comparison[x%(n/10 + 1)] *= a[x] + b[x];\n    }\n    for (int x = 0; x < 10; ++x){\n        if (fabs(totals_comparison[x] - totals[x]) > PRECISION * totals_comparison[x]){\n            err += 1;\n            break;\n        }\n    }\n\n    for (int x = 0; x < n/10 + 1; ++x){\n        for (passed_indexer = 0, absolute_indexer = x; absolute_indexer < n; passed_indexer++, absolute_indexer += n/10 + 1){\n            passed_ab[passed_indexer] = a[absolute_indexer] + b[absolute_indexer];\n            passed_c[passed_indexer] = c[absolute_indexer];\n        }\n        if (!is_possible(passed_ab, passed_c, passed_indexer - 1, 1)){\n            err++;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "atomic",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_structured_assign_x_plus_expr.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:atomic,construct-independent,V:2.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t *a = (real_t *)malloc(n * sizeof(real_t));\n    real_t *b = (real_t *)malloc(n * sizeof(real_t));\n    real_t *c = (real_t *)malloc(n * sizeof(real_t));\n    real_t *totals = (real_t *)malloc((n/10 + 1) * sizeof(real_t));\n    real_t *totals_comparison = (real_t *)malloc((n/10 + 1) * sizeof(real_t));\n    real_t *passed_ab = (real_t *)malloc(10 * sizeof(real_t));\n    real_t *passed_c = (real_t *)malloc(10 * sizeof(real_t));\n    int passed_indexer;\n    int absolute_indexer;\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n    }\n    for (int x = 0; x < n/10 + 1; ++x){\n        totals[x] = 0;\n        totals_comparison[x] = 0;\n    }\n\n    #pragma acc data copyin(a[0:n], b[0:n]) copy(totals[0:n/10 + 1]) copyout(c[0:n])\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                #pragma acc atomic update capture\n                {\n                    c[x] = totals[x%(n/10 + 1)];\n                    totals[x%(n/10 + 1)] = totals[x%(n/10 + 1)] + (a[x] * b[x]);\n                }\n            }\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        totals_comparison[x%(n/10 + 1)] += a[x] * b[x];\n    }\n    for (int x = 0; x < n/10 + 1; ++x){\n        if (fabs(totals_comparison[x] - totals[x]) > PRECISION){\n            err += 1;\n            break;\n        }\n    }\n\n    for (int x = 0; x < n/10 + 1; ++x){\n        for (passed_indexer = 0, absolute_indexer = x; absolute_indexer < n; passed_indexer++, absolute_indexer+= (n/10 + 1)){\n            passed_ab[passed_indexer] = a[absolute_indexer] * b[absolute_indexer];\n            passed_c[passed_indexer] = c[absolute_indexer];\n        }\n        if (!is_possible(passed_ab, passed_c, passed_indexer - 1, 0)){\n            err++;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "atomic",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_structured_assign_x_rshift_expr.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:atomic,construct-independent,V:2.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    unsigned int *a = (unsigned int *)malloc(n * sizeof(int));\n    unsigned int *b = (unsigned int *)malloc(n * sizeof(int));\n    unsigned int *c = (unsigned int *)malloc(7 * n * sizeof(int));\n    unsigned int passed = 1<<8;\n\n    for (int x = 0; x < n; ++x){\n        a[x] = 1<<8;\n        for (int y = 0; y < 7; ++y){\n            if ((rand()/(real_t) (RAND_MAX)) > .5){\n                b[x] += 1<<y;\n            }\n        }\n    }\n\n    #pragma acc data copyin(b[0:n]) copy(a[0:n]) copyout(c[0:7*n])\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                #pragma acc loop\n                for (int y = 0; y < 7; ++y){\n                    c[x * 7 + y] = a[x];\n                    if ((b[x]>>y)%2 == 1){\n                        #pragma acc atomic update capture\n                        {\n                            c[x * 7 + y] = a[x];\n                            a[x] = a[x] >> 1;\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        for (int y = 0; y < 7; ++y){\n            if ((b[x]>>y)%2 == 1){\n                a[x] <<= 1;\n            }\n        }\n        if (a[x] != 1<<8){\n            err += 1;\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        if (!is_possible(b[x], &(c[x * 7]), 7, passed)){\n            err++;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "atomic",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_structured_bitand_equals_assign.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:atomic,construct-independent,V:2.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    int *a = (int *)malloc(n * sizeof(int));\n    int *b = (int *)malloc(n * sizeof(int));\n    int *totals = (int *)malloc((n/10 + 1) * sizeof(int));\n    int *totals_comparison = (int *)malloc((n/10 + 1) * sizeof(int));\n    int *temp_a = (int *)malloc(10 * sizeof(int));\n    int *temp_b = (int *)malloc(10 * sizeof(int));\n    int iterator;\n    int iterator2;\n    int init;\n\n    for (int x = 0; x < n; ++x){\n        for (int y = 0; y < 8; ++y){\n            if (rand()/(real_t)(RAND_MAX) < .933){ //.933 gets close to a 50/50 distribution for a collescence of 10 values\n                a[x] += 1<<y;\n            }\n        }\n    }\n    for (int x = 0; x < n/10 + 1; ++x){\n        for (int y = 0; y < 8; ++y){\n            totals[x] +=  1<<y;\n            totals_comparison[x] += 1<<y;\n        }\n    }\n    for (int x = 0; x < n; ++x){\n        b[x] = 0;\n    }\n    #pragma acc data copyin(a[0:n]) copy(totals[0:n/10 + 1]) copyout(b[0:n])\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                #pragma acc atomic update capture\n                    {\n                        totals[x/10] &= a[x];\n                        b[x] = totals[x/10];\n                    }\n            }\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        totals_comparison[x/10] &= a[x];\n    }\n    for (int x = 0; x < (n/10 + 1); ++x){\n        if (totals_comparison[x] != totals[x]){\n            err += 1;\n            break;\n        }\n    }\n    for (int x = 0; x < 8; ++x){\n        init += 1<<x;\n    }\n\n    for (int x = 0; x < n; x = x + 10){\n        int y = x;\n        for (; y < x + 10 && y < n; y++){\n            temp_a[y - x] = a[y];\n            temp_b[y - x] = b[y];\n        }\n        if (!is_possible(temp_a, temp_b, y - x, init)){\n            err += 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "atomic",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_structured_bitor_equals_assign.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:atomic,construct-independent,V:2.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    int *a = (int *)malloc(n * sizeof(int));\n    int *b = (int *)malloc(n * sizeof(int));\n    int *totals = (int *)malloc((n/10 + 1) * sizeof(int));\n    int *totals_comparison = (int *)malloc((n/10 + 1) * sizeof(int));\n    int *temp_a = (int *)malloc(10 * sizeof(int));\n    int *temp_b = (int *)malloc(10 * sizeof(int));\n    int iterator;\n    int iterator2;\n    int init;\n\n    for (int x = 0; x < n; ++x){\n        for (int y = 0; y < 8; ++y){\n            if (rand()/(real_t)(RAND_MAX) < .933){ //.933 gets close to a 50/50 distribution for a collescence of 10 values\n                a[x] += 1<<y;\n            }\n        }\n    }\n    for (int x = 0; x < n/10 + 1; ++x){\n        for (int y = 0; y < 8; ++y){\n            totals[x] +=  1<<y;\n            totals_comparison[x] += 1<<y;\n        }\n    }\n    for (int x = 0; x < n; ++x){\n        b[x] = 0;\n    }\n    #pragma acc data copyin(a[0:n]) copy(totals[0:n/10 + 1]) copyout(b[0:n])\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                #pragma acc atomic update capture\n                    {\n                        totals[x/10] |= a[x];\n                        b[x] = totals[x/10];\n                    }\n            }\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        totals_comparison[x/10] |= a[x];\n    }\n    for (int x = 0; x < (n/10 + 1); ++x){\n        if (totals_comparison[x] != totals[x]){\n            err += 1;\n            break;\n        }\n    }\n    for (int x = 0; x < 8; ++x){\n        init += 1<<x;\n    }\n    int y;\n    for (int x = 0; x < n; x = x + 10){\n        y = x;\n        for (; y < x + 10 && y < n; y++){\n            temp_a[y - x] = a[y];\n            temp_b[y - x] = b[y];\n        }\n        if (!is_possible(temp_a, temp_b, (y - x) - 1, init)){\n            err += 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "atomic",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_structured_bitxor_equals_assign.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:atomic,construct-independent,V:2.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    int *a = (int *)malloc(n * sizeof(int));\n    int *b = (int *)malloc(n * sizeof(int));\n    int *totals = (int *)malloc((n/10 + 1) * sizeof(int));\n    int *totals_comparison = (int *)malloc((n/10 + 1) * sizeof(int));\n    int *temp_a = (int *)malloc(10 * sizeof(int));\n    int *temp_b = (int *)malloc(10 * sizeof(int));\n    int iterator;\n    int iterator2;\n    int init;\n\n    for (int x = 0; x < n; ++x){\n        for (int y = 0; y < 8; ++y){\n            if (rand()/(real_t)(RAND_MAX) < .933){ //.933 gets close to a 50/50 distribution for a collescence of 10 values\n                a[x] += 1<<y;\n            }\n        }\n    }\n    for (int x = 0; x < n/10 + 1; ++x){\n        for (int y = 0; y < 8; ++y){\n            totals[x] +=  1<<y;\n            totals_comparison[x] += 1<<y;\n        }\n    }\n    for (int x = 0; x < n; ++x){\n        b[x] = 0;\n    }\n    #pragma acc data copyin(a[0:n]) copy(totals[0:n/10 + 1]) copyout(b[0:n])\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                #pragma acc atomic update capture\n                    {\n                        totals[x/10] ^= a[x];\n                        b[x] = totals[x/10];\n                    }\n            }\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        totals_comparison[x/10] ^= a[x];\n    }\n    for (int x = 0; x < (n/10 + 1); ++x){\n        if (totals_comparison[x] != totals[x]){\n            err += 1;\n            break;\n        }\n    }\n    for (int x = 0; x < 8; ++x){\n        init += 1<<x;\n    }\n    int y;\n    for (int x = 0; x < n; x = x + 10){\n        y = x;\n        for (; y < x + 10 && y < n; y++){\n            temp_a[y - x] = a[y];\n            temp_b[y - x] = b[y];\n        }\n        if (!is_possible(temp_a, temp_b, (y - x) - 1, init)){\n            err += 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "atomic",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_structured_divided_equals_assign.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:atomic,construct-independent,V:2.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t *a = (real_t *)malloc(n * sizeof(real_t));\n    real_t *b = (real_t *)malloc(n * sizeof(real_t));\n    real_t *c = (real_t *)malloc(n * sizeof(real_t));\n    real_t *totals = (real_t *)malloc((n/10 + 1) * sizeof(real_t));\n    real_t *totals_comparison = (real_t *)malloc((n/10 + 1) * sizeof(real_t));\n    real_t *temp_a = (real_t *)malloc(10 * sizeof(real_t));\n    real_t *temp_b = (real_t *)malloc(10 * sizeof(real_t));\n    real_t *temp_c = (real_t *)malloc(10 * sizeof(real_t));\n    int temp_iterator;\n    int ab_iterator;\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n        c[x] = 0;\n    }\n    for (int x = 0; x < n/10 + 1; ++x){\n        totals[x] = 1;\n        totals_comparison[x] = 1;\n    }\n\n    #pragma acc data copyin(a[0:n], b[0:n]) copy(totals[0:n/10 + 1]) copyout(c[0:n])\n    {\n      #pragma acc parallel\n      {\n          #pragma acc loop\n          for (int x = 0; x < n; ++x){\n              #pragma acc atomic update capture\n              {\n                  totals[x/10] /= (a[x] + b[x]);\n                  c[x] = totals[x/10];\n              }\n          }\n      }\n    }\n\n    for (int x = 0; x < n; ++x){\n        totals_comparison[x/10] /= a[x] + b[x];\n    }\n    for (int x = 0; x < 10; ++x){\n        if (fabs(totals_comparison[x] - totals[x]) > PRECISION){\n            err += 1;\n            break;\n        }\n    }\n\n    for (int x = 0; x < n; x = x + 10){\n        temp_iterator = 0;\n        for (ab_iterator = x; ab_iterator < n && ab_iterator < x + 10;  ab_iterator+= 1){\n            temp_a[temp_iterator] = a[ab_iterator];\n            temp_b[temp_iterator] = b[ab_iterator];\n            temp_c[temp_iterator] = c[ab_iterator];\n            temp_iterator++;\n        }\n        if (!(is_possible(temp_a, temp_b, temp_c, temp_iterator, 1))){\n            err++;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "atomic",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_structured_expr_bitand_x_assign.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:atomic,construct-independent,V:2.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    int *a = (int *)malloc(n * sizeof(int));\n    int *b = (int *)malloc(n * sizeof(int));\n    int *totals = (int *)malloc((n/10 + 1) * sizeof(int));\n    int *totals_comparison = (int *)malloc((n/10 + 1) * sizeof(int));\n    int *temp_a = (int *)malloc(10 * sizeof(int));\n    int *temp_b = (int *)malloc(10 * sizeof(int));\n    int iterator;\n    int iterator2;\n    int init;\n\n    for (int x = 0; x < n; ++x){\n        for (int y = 0; y < 8; ++y){\n            if (rand()/(real_t)(RAND_MAX) < .933){ //.933 gets close to a 50/50 distribution for a collescence of 10 values\n                a[x] += 1<<y;\n            }\n        }\n    }\n    for (int x = 0; x < n/10 + 1; ++x){\n        for (int y = 0; y < 8; ++y){\n            totals[x] +=  1<<y;\n            totals_comparison[x] += 1<<y;\n        }\n    }\n    for (int x = 0; x < n; ++x){\n        b[x] = 0;\n    }\n    #pragma acc data copyin(a[0:n]) copy(totals[0:n/10 + 1]) copyout(b[0:n])\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                #pragma acc atomic update capture\n                    {\n                        totals[x/10] = a[x] & totals[x/10];\n                        b[x] = totals[x/10];\n                    }\n            }\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        totals_comparison[x/10] &= a[x];\n    }\n    for (int x = 0; x < (n/10 + 1); ++x){\n        if (totals_comparison[x] != totals[x]){\n            err += 1;\n            break;\n        }\n    }\n    for (int x = 0; x < 8; ++x){\n        init += 1<<x;\n    }\n\n    for (int x = 0; x < n; x = x + 10){\n        int y = x;\n        for (; y < x + 10 && y < n; y++){\n            temp_a[y - x] = a[y];\n            temp_b[y - x] = b[y];\n        }\n        if (!is_possible(temp_a, temp_b, y - x, init)){\n            err += 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "atomic",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_structured_expr_bitor_x_assign.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:atomic,construct-independent,V:2.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    int *a = (int *)malloc(n * sizeof(int));\n    int *b = (int *)malloc(n * sizeof(int));\n    int *totals = (int *)malloc((n/10 + 1) * sizeof(int));\n    int *totals_comparison = (int *)malloc((n/10 + 1) * sizeof(int));\n    int *temp_a = (int *)malloc(10 * sizeof(int));\n    int *temp_b = (int *)malloc(10 * sizeof(int));\n    int iterator;\n    int iterator2;\n    int init;\n\n    for (int x = 0; x < n; ++x){\n        for (int y = 0; y < 8; ++y){\n            if (rand()/(real_t)(RAND_MAX) < .933){ //.933 gets close to a 50/50 distribution for a collescence of 10 values\n                a[x] += 1<<y;\n            }\n        }\n    }\n    for (int x = 0; x < n/10 + 1; ++x){\n        for (int y = 0; y < 8; ++y){\n            totals[x] +=  1<<y;\n            totals_comparison[x] += 1<<y;\n        }\n    }\n    for (int x = 0; x < n; ++x){\n        b[x] = 0;\n    }\n    #pragma acc data copyin(a[0:n]) copy(totals[0:n/10 + 1]) copyout(b[0:n])\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                #pragma acc atomic update capture\n                    {\n                        totals[x/10] = a[x] | totals[x/10];\n                        b[x] = totals[x/10];\n                    }\n            }\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        totals_comparison[x/10] |= a[x];\n    }\n    for (int x = 0; x < (n/10 + 1); ++x){\n        if (totals_comparison[x] != totals[x]){\n            err += 1;\n            break;\n        }\n    }\n    for (int x = 0; x < 8; ++x){\n        init += 1<<x;\n    }\n    int y;\n    for (int x = 0; x < n; x = x + 10){\n        y = x;\n        for (; y < x + 10 && y < n; y++){\n            temp_a[y - x] = a[y];\n            temp_b[y - x] = b[y];\n        }\n        if (!is_possible(temp_a, temp_b, (y - x) - 1, init)){\n            err += 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "atomic",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_structured_expr_bitxor_x_assign.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:atomic,construct-independent,V:2.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    int *a = (int *)malloc(n * sizeof(int));\n    int *b = (int *)malloc(n * sizeof(int));\n    int *totals = (int *)malloc((n/10 + 1) * sizeof(int));\n    int *totals_comparison = (int *)malloc((n/10 + 1) * sizeof(int));\n    int *temp_a = (int *)malloc(10 * sizeof(int));\n    int *temp_b = (int *)malloc(10 * sizeof(int));\n    int iterator;\n    int iterator2;\n    int init;\n    int y;\n\n    for (int x = 0; x < n; ++x){\n        for (int y = 0; y < 8; ++y){\n            if (rand()/(real_t)(RAND_MAX) < .933){ //.933 gets close to a 50/50 distribution for a collescence of 10 values\n                a[x] += 1<<y;\n            }\n        }\n    }\n    for (int x = 0; x < n/10 + 1; ++x){\n        for (int y = 0; y < 8; ++y){\n            totals[x] +=  1<<y;\n            totals_comparison[x] += 1<<y;\n        }\n    }\n    for (int x = 0; x < n; ++x){\n        b[x] = 0;\n    }\n    #pragma acc data copyin(a[0:n]) copy(totals[0:n/10 + 1]) copyout(b[0:n])\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                #pragma acc atomic update capture\n                    {\n                        totals[x/10] = a[x] ^ totals[x/10];\n                        b[x] = totals[x/10];\n                    }\n            }\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        totals_comparison[x/10] ^= a[x];\n    }\n    for (int x = 0; x < (n/10 + 1); ++x){\n        if (totals_comparison[x] != totals[x]){\n            err += 1;\n            break;\n        }\n    }\n    for (int x = 0; x < 8; ++x){\n        init += 1<<x;\n    }\n    for (int x = 0; x < n; x = x + 10){\n        y = x;\n        for (; y < x + 10 && y < n; y++){\n            temp_a[y - x] = a[y];\n            temp_b[y - x] = b[y];\n        }\n        if (!is_possible(temp_a, temp_b, (y - x) - 1, init)){\n            err += 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "atomic",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_structured_expr_multiply_x_assign.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:atomic,construct-independent,V:2.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t *a = (real_t *)malloc(n * sizeof(real_t));\n    real_t *b = (real_t *)malloc(n * sizeof(real_t));\n    real_t *c = (real_t *)malloc(n * sizeof(real_t));\n    real_t *totals = (real_t *)malloc((n/10 + 1) * sizeof(real_t));\n    real_t *totals_comparison = (real_t *)malloc((n/10 + 1) * sizeof(real_t));\n    real_t * passed_ab = (real_t *)malloc(10 * sizeof(real_t));\n    real_t * passed_c = (real_t *)malloc(10 * sizeof(real_t));\n    int passed_indexer;\n    int absolute_indexer;\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n    }\n    for (int x = 0; x < n/10 + 1; ++x){\n        totals[x] = 1;\n        totals_comparison[x] = 1;\n    }\n\n    #pragma acc data copyin(a[0:n], b[0:n]) copy(totals[0:n/10 + 1]) copyout(c[0:n])\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                #pragma acc atomic update capture\n                {\n                    totals[x%(n/10 + 1)] = (a[x] + b[x]) * totals[x%(n/10 + 1)];\n                    c[x] = totals[x%(n/10 + 1)];\n                }\n            }\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        totals_comparison[x%(n/10 + 1)] *= a[x] + b[x];\n    }\n    for (int x = 0; x < 10; ++x){\n        if (fabs(totals_comparison[x] - totals[x]) > PRECISION * totals_comparison[x]){\n            err += 1;\n            break;\n        }\n    }\n\n    for (int x = 0; x < n/10 + 1; ++x){\n        for (passed_indexer = 0, absolute_indexer = x; absolute_indexer < n; passed_indexer++, absolute_indexer += n/10 + 1){\n            passed_ab[passed_indexer] = a[absolute_indexer] + b[absolute_indexer];\n            passed_c[passed_indexer] = c[absolute_indexer];\n        }\n        if (!is_possible(passed_ab, passed_c, passed_indexer - 1, 1)){\n            err++;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "atomic",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_structured_expr_plus_x_assign.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:atomic,construct-independent,V:2.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t *a = (real_t *)malloc(n * sizeof(real_t));\n    real_t *b = (real_t *)malloc(n * sizeof(real_t));\n    real_t *c = (real_t *)malloc(n * sizeof(real_t));\n    real_t *totals = (real_t *)malloc((n/10 + 1) * sizeof(real_t));\n    real_t *totals_comparison = (real_t *)malloc((n/10 + 1) * sizeof(real_t));\n    real_t *passed_ab = (real_t *)malloc(10 * sizeof(real_t));\n    real_t *passed_c = (real_t *)malloc(10 * sizeof(real_t));\n    int passed_indexer;\n    int absolute_indexer;\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n    }\n    for (int x = 0; x < n/10 + 1; ++x){\n        totals[x] = 0;\n        totals_comparison[x] = 0;\n    }\n\n    #pragma acc data copyin(a[0:n], b[0:n]) copy(totals[0:n/10 + 1]) copyout(c[0:n])\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                #pragma acc atomic update capture\n                {\n                    totals[x%(n/10 + 1)] = (a[x] * b[x]) + totals[x%(n/10 + 1)];\n                    c[x] = totals[x%(n/10 + 1)];\n                }\n            }\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        totals_comparison[x%(n/10 + 1)] += a[x] * b[x];\n    }\n    for (int x = 0; x < n/10 + 1; ++x){\n        if (fabs(totals_comparison[x] - totals[x]) > PRECISION){\n            err += 1;\n            break;\n        }\n    }\n\n    for (int x = 0; x < n/10 + 1; ++x){\n        for (passed_indexer = 0, absolute_indexer = x; absolute_indexer < n; passed_indexer++, absolute_indexer+= (n/10 + 1)){\n            passed_ab[passed_indexer] = a[absolute_indexer] * b[absolute_indexer];\n            passed_c[passed_indexer] = c[absolute_indexer];\n        }\n        if (!is_possible(passed_ab, passed_c, passed_indexer - 1, 0)){\n            err++;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "atomic",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_structured_lshift_equals_assign.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:atomic,construct-independent,V:2.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    unsigned int *a = (unsigned int *)malloc(n * sizeof(int));\n    unsigned int *b = (unsigned int *)malloc(n * sizeof(int));\n    unsigned int *c = (unsigned int *)malloc(7 * n * sizeof(int));\n    unsigned int passed = 1;\n\n    for (int x = 0; x < n; ++x){\n        a[x] = 1;\n        for (int y = 0; y < 7; ++y){\n            if ((rand()/(real_t) (RAND_MAX)) > .5){\n                b[x] += 1<<y;\n            }\n        }\n    }\n\n    #pragma acc data copyin(b[0:n]) copy(a[0:n]) copyout(c[0:7*n])\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                #pragma acc loop\n                for (int y = 0; y < 7; ++y){\n                    c[x * 7 + y] = a[x];\n                    if ((b[x]>>y)%2 == 1){\n                        #pragma acc atomic update capture\n                        {\n                            a[x] <<= 1;\n                            c[x * 7 + y] = a[x];\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        for (int y = 0; y < 7; ++y){\n            if ((b[x]>>y)%2 == 1){\n                a[x] >>= 1;\n            }\n        }\n        if (a[x] != 1){\n            err += 1;\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        if (!is_possible(b[x], &(c[x * 7]), 7, passed)){\n            err++;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "atomic",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_structured_minus_equals_assign.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:atomic,construct-independent,V:2.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t *a = (real_t *)malloc(n * sizeof(real_t));\n    real_t *b = (real_t *)malloc(n * sizeof(real_t));\n    real_t *c = (real_t *)malloc(n * sizeof(real_t));\n    real_t *totals = (real_t *)malloc(10 * sizeof(real_t));\n    real_t *totals_host = (real_t *)malloc(10 * sizeof(real_t));\n    real_t * passed_ab = (real_t *)malloc((n/10 + 1) * sizeof(real_t));\n    real_t * passed_c = (real_t *)malloc((n/10 + 1) * sizeof(real_t));\n    int passed_indexer;\n    int absolute_indexer;\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n    }\n    for (int x = 0; x < 10; ++x){\n        totals[x] = 0;\n    }\n\n    #pragma acc data copyin(a[0:n], b[0:n]) copy(totals[0:10])\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                #pragma acc atomic update capture\n                {\n                    totals[x%10] -= (a[x] + b[x]);\n                    c[x] = totals[x%10];\n                }\n            }\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        totals_host[x%10] = totals_host[x%10] - (a[x] + b[x]);\n    }\n    for (int x = 0; x < 10; ++x){\n        if (fabs(totals_host[x] - totals[x]) > PRECISION){\n            err += 1;\n        }\n    }\n\n    for (int x = 0; x < 10; ++x){\n        for (passed_indexer = 0, absolute_indexer = x; absolute_indexer < n; passed_indexer++, absolute_indexer+= 10){\n            passed_ab[passed_indexer] = a[absolute_indexer] + b[absolute_indexer];\n            passed_c[passed_indexer] = c[absolute_indexer];\n        }\n        if (!is_possible(passed_ab, passed_c, passed_indexer - 1, 0)){\n            err++;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "atomic",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_structured_multiply_equals_assign.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:atomic,construct-independent,V:2.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t *a = (real_t *)malloc(n * sizeof(real_t));\n    real_t *b = (real_t *)malloc(n * sizeof(real_t));\n    real_t *c = (real_t *)malloc(n * sizeof(real_t));\n    real_t *totals = (real_t *)malloc((n/10 + 1) * sizeof(real_t));\n    real_t *totals_comparison = (real_t *)malloc((n/10 + 1) * sizeof(real_t));\n    real_t * passed_ab = (real_t *)malloc(10 * sizeof(real_t));\n    real_t * passed_c = (real_t *)malloc(10 * sizeof(real_t));\n    int passed_indexer;\n    int absolute_indexer;\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n    }\n    for (int x = 0; x < n/10 + 1; ++x){\n        totals[x] = 1;\n        totals_comparison[x] = 1;\n    }\n\n    #pragma acc data copyin(a[0:n], b[0:n]) copy(totals[0:n/10 + 1]) copyout(c[0:n])\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                #pragma acc atomic update capture\n                {\n                    totals[x%(n/10 + 1)] *= a[x] + b[x];\n                    c[x] = totals[x%(n/10 + 1)];\n                }\n            }\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        totals_comparison[x%(n/10 + 1)] *= a[x] + b[x];\n    }\n    for (int x = 0; x < 10; ++x){\n        if (fabs(totals_comparison[x] - totals[x]) > PRECISION * totals_comparison[x]){\n            err += 1;\n            break;\n        }\n    }\n\n    for (int x = 0; x < n/10 + 1; ++x){\n        for (passed_indexer = 0, absolute_indexer = x; absolute_indexer < n; passed_indexer++, absolute_indexer += n/10 + 1){\n            passed_ab[passed_indexer] = a[absolute_indexer] + b[absolute_indexer];\n            passed_c[passed_indexer] = c[absolute_indexer];\n        }\n        if (!is_possible(passed_ab, passed_c, passed_indexer - 1, 1)){\n            err++;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "atomic",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_structured_plus_equals_assign.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:atomic,construct-independent,V:2.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t *a = (real_t *)malloc(n * sizeof(real_t));\n    real_t *b = (real_t *)malloc(n * sizeof(real_t));\n    real_t *c = (real_t *)malloc(n * sizeof(real_t));\n    real_t *totals = (real_t *)malloc((n/10 + 1) * sizeof(real_t));\n    real_t *totals_comparison = (real_t *)malloc((n/10 + 1) * sizeof(real_t));\n    real_t *passed_ab = (real_t *)malloc(10 * sizeof(real_t));\n    real_t *passed_c = (real_t *)malloc(10 * sizeof(real_t));\n    int passed_indexer;\n    int absolute_indexer;\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n    }\n    for (int x = 0; x < n/10 + 1; ++x){\n        totals[x] = 0;\n        totals_comparison[x] = 0;\n    }\n\n    #pragma acc data copyin(a[0:n], b[0:n]) copy(totals[0:n/10 + 1]) copyout(c[0:n])\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                #pragma acc atomic update capture\n                {\n                    totals[x%(n/10 + 1)] += a[x] * b[x];\n                    c[x] = totals[x%(n/10 + 1)];\n                }\n            }\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        totals_comparison[x%(n/10 + 1)] += a[x] * b[x];\n    }\n    for (int x = 0; x < n/10 + 1; ++x){\n        if (fabs(totals_comparison[x] - totals[x]) > PRECISION){\n            err += 1;\n            break;\n        }\n    }\n\n    for (int x = 0; x < n/10 + 1; ++x){\n        for (passed_indexer = 0, absolute_indexer = x; absolute_indexer < n; passed_indexer++, absolute_indexer+= (n/10 + 1)){\n            passed_ab[passed_indexer] = a[absolute_indexer] * b[absolute_indexer];\n            passed_c[passed_indexer] = c[absolute_indexer];\n        }\n        if (!is_possible(passed_ab, passed_c, passed_indexer - 1, 0)){\n            err++;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "atomic",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_structured_postdecrement_assign.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:atomic,construct-independent,V:2.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t *a = (real_t *)malloc(n * sizeof(real_t));\n    real_t *b = (real_t *)malloc(n * sizeof(real_t));\n    int *c = (int *)malloc(n * sizeof(int));\n    int *distribution = (int *)malloc(10 * sizeof(int));\n    int *distribution_comparison = (int *)malloc(10 * sizeof(int));\n    bool found = false;\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n    }\n    for (int x = 0; x < 10; ++x){\n        distribution[x] = 0;\n        distribution_comparison[x] = 0;\n    }\n\n    #pragma acc data copyin(a[0:n], b[0:n]) copy(distribution[0:10]) copyout(c[0:n])\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                #pragma acc atomic update capture\n                {\n                    (distribution[(int) (a[x]*b[x]/10)])--;\n                    c[x] = distribution[(int) (a[x]*b[x]/10)];\n                }\n            }\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        distribution_comparison[(int) (a[x]*b[x]/10)]--;\n    }\n    for (int x = 0; x < 10; ++x){\n        if (distribution_comparison[x] != distribution[x]){\n            err += 1;\n            break;\n        }\n    }\n\n    for (int x = 0; x < 10; ++x){\n        for (int y = 0; y > -distribution_comparison[x]; --y){\n            for (int z = 0; z < n; ++z){\n                if (y - 1 == c[z] && x == (int) (a[x] * b[x] / 10)){\n                    found = true;\n                    break;\n                }\n            }\n            if (!found){\n                err++;\n            }\n            found = false;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "atomic",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_structured_postincrement_assign.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:atomic,construct-independent,V:2.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t *a = (real_t *)malloc(n * sizeof(real_t));\n    real_t *b = (real_t *)malloc(n * sizeof(real_t));\n    int *c = (int *)malloc(n * sizeof(int));\n    int *distribution = (int *)malloc(10 * sizeof(int));\n    int *distribution_comparison = (int *)malloc(10 * sizeof(int));\n    bool found = false;\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n    }\n    for (int x = 0; x < 10; ++x){\n        distribution[x] = 0;\n        distribution_comparison[x] = 0;\n    }\n\n    #pragma acc data copyin(a[0:n], b[0:n]) copy(distribution[0:10]) copyout(c[0:n])\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                #pragma acc atomic update capture\n                {\n                    distribution[(int) (a[x]*b[x]/10)]++;\n                    c[x] = distribution[(int) (a[x]*b[x]/10)];\n                }\n            }\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        distribution_comparison[(int) (a[x]*b[x]/10)]++;\n    }\n    for (int x = 0; x < 10; ++x){\n        if (distribution_comparison[x] != distribution[x]){\n            err += 1;\n            break;\n        }\n    }\n\n    for (int x = 0; x < 10; ++x){\n        for (int y = 0; y < distribution_comparison[x]; ++y){\n            for (int z = 0; z < n; ++z){\n                if (c[z] == y + 1 && (int) (a[z]*b[z]/10) == x){\n                    found = true;\n                    break;\n                }\n            }\n            if (!found){\n                err++;\n            }\n            found = false;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "atomic",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_structured_predecrement_assign.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:atomic,construct-independent,V:2.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t *a = (real_t *)malloc(n * sizeof(real_t));\n    real_t *b = (real_t *)malloc(n * sizeof(real_t));\n    int *c = (int *)malloc(n * sizeof(int));\n    int *distribution = (int *)malloc(10 * sizeof(int));\n    int *distribution_comparison = (int *)malloc(10 * sizeof(int));\n    bool found = false;\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n    }\n    for (int x = 0; x < 10; ++x){\n        distribution[x] = 0;\n        distribution_comparison[x] = 0;\n    }\n\n    #pragma acc data copyin(a[0:n], b[0:n]) copy(distribution[0:10]) copyout(c[0:n])\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                #pragma acc atomic update capture\n                {\n                    --distribution[(int) (a[x]*b[x]/10)];\n                    c[x] = distribution[(int) (a[x]*b[x]/10)];\n                }\n            }\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        distribution_comparison[(int) (a[x]*b[x]/10)]--;\n    }\n    for (int x = 0; x < 10; ++x){\n        if (distribution_comparison[x] != distribution[x]){\n            err += 1;\n            break;\n        }\n    }\n\n    for (int x = 0; x < 10; ++x){\n        for (int y = 0; y > distribution[x]; --y){\n            for (int z = 0; z < n; ++z){\n                if (c[z] == y - 1 && x == (int) (a[z] * b[z] / 10)){\n                    found = true;\n                    break;\n                }\n            }\n            if (!found){\n                err++;\n            }\n            found = false;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "atomic",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_structured_preincrement_assign.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:atomic,construct-independent,V:2.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t *a = (real_t *)malloc(n * sizeof(real_t));\n    real_t *b = (real_t *)malloc(n * sizeof(real_t));\n    int *c = (int *)malloc(n * sizeof(int));\n    int *distribution = (int *)malloc(10 * sizeof(int));\n    int *distribution_comparison = (int *)malloc(10 * sizeof(int));\n    bool found = false;\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n    }\n    for (int x = 0; x < 10; ++x){\n        distribution[x] = 0;\n        distribution_comparison[x] = 0;\n    }\n\n    #pragma acc data copyin(a[0:n], b[0:n]) copy(distribution[0:10]) copyout(c[0:n])\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                #pragma acc atomic update capture\n                {\n                    ++distribution[(int) (a[x]*b[x]/10)];\n                    c[x] = distribution[(int) (a[x]*b[x]/10)];\n                }\n            }\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        distribution_comparison[(int) (a[x]*b[x]/10)]++;\n    }\n    for (int x = 0; x < 10; ++x){\n        if (distribution_comparison[x] != distribution[x]){\n            err += 1;\n            break;\n        }\n    }\n\n    for (int x = 0; x < 10; ++x){\n        for (int y = 0; y < distribution[x]; ++y){\n            for (int z = 0; z < n; ++z){\n                if (c[z] == y + 1 && x == (int) (a[z] * b[z] / 10)){\n                    found = true;\n                    break;\n                }\n            }\n            if (!found){\n                err++;\n            }\n            found = false;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "atomic",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_structured_rshift_equals_assign.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:atomic,construct-independent,V:2.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    unsigned int *a = (unsigned int *)malloc(n * sizeof(int));\n    unsigned int *b = (unsigned int *)malloc(n * sizeof(int));\n    unsigned int *c = (unsigned int *)malloc(7 * n * sizeof(int));\n    unsigned int passed = 1<<8;\n\n    for (int x = 0; x < n; ++x){\n        a[x] = 1<<8;\n        for (int y = 0; y < 7; ++y){\n            if ((rand()/(real_t) (RAND_MAX)) > .5){\n                b[x] += 1<<y;\n            }\n        }\n    }\n\n    #pragma acc data copyin(b[0:n]) copy(a[0:n]) copyout(c[0:7*n])\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                #pragma acc loop\n                for (int y = 0; y < 7; ++y){\n                    c[x * 7 + y] = a[x];\n                    if ((b[x]>>y)%2 == 1){\n                        #pragma acc atomic update capture\n                        {\n                            a[x] >>= 1;\n                            c[x * 7 + y] = a[x];\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        for (int y = 0; y < 7; ++y){\n            if ((b[x]>>y)%2 == 1){\n                a[x] <<= 1;\n            }\n        }\n        if (a[x] != 1<<8){\n            err += 1;\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        if (!is_possible(b[x], &(c[x * 7]), 7, passed)){\n            err++;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "atomic",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_structured_x_bitand_expr_assign.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:atomic,construct-independent,V:2.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    int *a = (int *)malloc(n * sizeof(int));\n    int *b = (int *)malloc(n * sizeof(int));\n    int *totals = (int *)malloc((n/10 + 1) * sizeof(int));\n    int *totals_comparison = (int *)malloc((n/10 + 1) * sizeof(int));\n    int *temp_a = (int *)malloc(10 * sizeof(int));\n    int *temp_b = (int *)malloc(10 * sizeof(int));\n    int iterator;\n    int iterator2;\n    int init;\n\n    for (int x = 0; x < n; ++x){\n        for (int y = 0; y < 8; ++y){\n            if (rand()/(real_t)(RAND_MAX) < .933){ //.933 gets close to a 50/50 distribution for a collescence of 10 values\n                a[x] += 1<<y;\n            }\n        }\n    }\n    for (int x = 0; x < n/10 + 1; ++x){\n        for (int y = 0; y < 8; ++y){\n            totals[x] +=  1<<y;\n            totals_comparison[x] += 1<<y;\n        }\n    }\n    for (int x = 0; x < n; ++x){\n        b[x] = 0;\n    }\n    #pragma acc data copyin(a[0:n]) copy(totals[0:n/10 + 1]) copyout(b[0:n])\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                #pragma acc atomic update capture\n                    {\n                        totals[x/10] = totals[x/10] & a[x];\n                        b[x] = totals[x/10];\n                    }\n            }\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        totals_comparison[x/10] &= a[x];\n    }\n    for (int x = 0; x < (n/10 + 1); ++x){\n        if (totals_comparison[x] != totals[x]){\n            err += 1;\n            break;\n        }\n    }\n    for (int x = 0; x < 8; ++x){\n        init += 1<<x;\n    }\n\n    for (int x = 0; x < n; x = x + 10){\n        int y = x;\n        for (; y < x + 10 && y < n; y++){\n            temp_a[y - x] = a[y];\n            temp_b[y - x] = b[y];\n        }\n        if (!is_possible(temp_a, temp_b, y - x, init)){\n            err += 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "atomic",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_structured_x_bitor_expr_assign.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:atomic,construct-independent,V:2.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    int *a = (int *)malloc(n * sizeof(int));\n    int *b = (int *)malloc(n * sizeof(int));\n    int *totals = (int *)malloc((n/10 + 1) * sizeof(int));\n    int *totals_comparison = (int *)malloc((n/10 + 1) * sizeof(int));\n    int *temp_a = (int *)malloc(10 * sizeof(int));\n    int *temp_b = (int *)malloc(10 * sizeof(int));\n    int iterator;\n    int iterator2;\n    int init;\n\n    for (int x = 0; x < n; ++x){\n        for (int y = 0; y < 8; ++y){\n            if (rand()/(real_t)(RAND_MAX) < .933){ //.933 gets close to a 50/50 distribution for a collescence of 10 values\n                a[x] += 1<<y;\n            }\n        }\n    }\n    for (int x = 0; x < n/10 + 1; ++x){\n        for (int y = 0; y < 8; ++y){\n            totals[x] +=  1<<y;\n            totals_comparison[x] += 1<<y;\n        }\n    }\n    for (int x = 0; x < n; ++x){\n        b[x] = 0;\n    }\n    #pragma acc data copyin(a[0:n]) copy(totals[0:n/10 + 1]) copyout(b[0:n])\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                #pragma acc atomic update capture\n                    {\n                        totals[x/10] = totals[x/10] | a[x];\n                        b[x] = totals[x/10];\n                    }\n            }\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        totals_comparison[x/10] |= a[x];\n    }\n    for (int x = 0; x < (n/10 + 1); ++x){\n        if (totals_comparison[x] != totals[x]){\n            err += 1;\n            break;\n        }\n    }\n    for (int x = 0; x < 8; ++x){\n        init += 1<<x;\n    }\n    int y;\n    for (int x = 0; x < n; x = x + 10){\n        y = x;\n        for (; y < x + 10 && y < n; y++){\n            temp_a[y - x] = a[y];\n            temp_b[y - x] = b[y];\n        }\n        if (!is_possible(temp_a, temp_b, (y - x) - 1, init)){\n            err += 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "atomic",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_structured_x_bitxor_expr_assign.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:atomic,construct-independent,V:2.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    int *a = (int *)malloc(n * sizeof(int));\n    int *b = (int *)malloc(n * sizeof(int));\n    int *totals = (int *)malloc((n/10 + 1) * sizeof(int));\n    int *totals_comparison = (int *)malloc((n/10 + 1) * sizeof(int));\n    int *temp_a = (int *)malloc(10 * sizeof(int));\n    int *temp_b = (int *)malloc(10 * sizeof(int));\n    int iterator;\n    int iterator2;\n    int init;\n\n    for (int x = 0; x < n; ++x){\n        for (int y = 0; y < 8; ++y){\n            if (rand()/(real_t)(RAND_MAX) < .933){ //.933 gets close to a 50/50 distribution for a collescence of 10 values\n                a[x] += 1<<y;\n            }\n        }\n    }\n    for (int x = 0; x < n/10 + 1; ++x){\n        for (int y = 0; y < 8; ++y){\n            totals[x] +=  1<<y;\n            totals_comparison[x] += 1<<y;\n        }\n    }\n    for (int x = 0; x < n; ++x){\n        b[x] = 0;\n    }\n    #pragma acc data copyin(a[0:n]) copy(totals[0:n/10 + 1]) copyout(b[0:n])\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                #pragma acc atomic update capture\n                    {\n                        totals[x/10] = totals[x/10] ^ a[x];\n                        b[x] = totals[x/10];\n                    }\n            }\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        totals_comparison[x/10] ^= a[x];\n    }\n    for (int x = 0; x < (n/10 + 1); ++x){\n        if (totals_comparison[x] != totals[x]){\n            err += 1;\n            break;\n        }\n    }\n    for (int x = 0; x < 8; ++x){\n        init += 1<<x;\n    }\n    int y;\n    for (int x = 0; x < n; x = x + 10){\n        y = x;\n        for (; y < x + 10 && y < n; y++){\n            temp_a[y - x] = a[y];\n            temp_b[y - x] = b[y];\n        }\n        if (!is_possible(temp_a, temp_b, (y - x) - 1, init)){\n            err += 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "atomic",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_structured_x_divided_expr_assign.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:atomic,construct-independent,V:2.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t *a = (real_t *)malloc(n * sizeof(real_t));\n    real_t *b = (real_t *)malloc(n * sizeof(real_t));\n    real_t *c = (real_t *)malloc(n * sizeof(real_t));\n    real_t *totals = (real_t *)malloc((n/10 + 1) * sizeof(real_t));\n    real_t *totals_comparison = (real_t *)malloc((n/10 + 1) * sizeof(real_t));\n    real_t *temp_a = (real_t *)malloc(10 * sizeof(real_t));\n    real_t *temp_b = (real_t *)malloc(10 * sizeof(real_t));\n    real_t *temp_c = (real_t *)malloc(10 * sizeof(real_t));\n    int temp_iterator;\n    int ab_iterator;\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n        c[x] = 0;\n    }\n    for (int x = 0; x < n/10 + 1; ++x){\n        totals[x] = 1;\n        totals_comparison[x] = 1;\n    }\n\n    #pragma acc data copyin(a[0:n], b[0:n]) copy(totals[0:n/10 + 1]) copyout(c[0:n])\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                #pragma acc atomic update capture\n                {\n                    totals[x/10] = totals[x/10] / (a[x] + b[x]);\n                    c[x] = totals[x/10];\n                }\n            }\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        totals_comparison[x/10] /= a[x] + b[x];\n    }\n    for (int x = 0; x < 10; ++x){\n        if (fabs(totals_comparison[x] - totals[x]) > PRECISION){\n            err += 1;\n            break;\n        }\n    }\n\n    for (int x = 0; x < n; x = x + 10){\n        temp_iterator = 0;\n        for (ab_iterator = x; ab_iterator < n && ab_iterator < x + 10;  ab_iterator+= 1){\n            temp_a[temp_iterator] = a[ab_iterator];\n            temp_b[temp_iterator] = b[ab_iterator];\n            temp_c[temp_iterator] = c[ab_iterator];\n            temp_iterator++;\n        }\n        if (!(is_possible(temp_a, temp_b, temp_c, temp_iterator, 1))){\n            err++;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "atomic",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_structured_x_lshift_expr_assign.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:atomic,construct-independent,V:2.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    unsigned int *a = (unsigned int *)malloc(n * sizeof(int));\n    unsigned int *b = (unsigned int *)malloc(n * sizeof(int));\n    unsigned int *c = (unsigned int *)malloc(7 * n * sizeof(int));\n    unsigned int passed = 1;\n\n    for (int x = 0; x < n; ++x){\n        a[x] = 1;\n        for (int y = 0; y < 7; ++y){\n            if ((rand()/(real_t) (RAND_MAX)) > .5){\n                b[x] += 1<<y;\n            }\n        }\n    }\n\n    #pragma acc data copyin(b[0:n]) copy(a[0:n]) copyout(c[0:7*n])\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                #pragma acc loop\n                for (int y = 0; y < 7; ++y){\n                    c[x * 7 + y] = a[x];\n                    if ((b[x]>>y)%2 == 1){\n                        #pragma acc atomic update capture\n                        {\n                            a[x] = a[x] << 1;\n                            c[x * 7 + y] = a[x];\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        for (int y = 0; y < 7; ++y){\n            if ((b[x]>>y)%2 == 1){\n                a[x] >>= 1;\n            }\n        }\n        if (a[x] != 1){\n            err += 1;\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        if (!is_possible(b[x], &(c[x * 7]), 7, passed)){\n            err++;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "atomic",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_structured_x_minus_expr_assign.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:atomic,construct-independent,V:2.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t *a = (real_t *)malloc(n * sizeof(real_t));\n    real_t *b = (real_t *)malloc(n * sizeof(real_t));\n    real_t *c = (real_t *)malloc(n * sizeof(real_t));\n    real_t *totals = (real_t *)malloc(10 * sizeof(real_t));\n    real_t *totals_host = (real_t *)malloc(10 * sizeof(real_t));\n    real_t * passed_ab = (real_t *)malloc((n/10 + 1) * sizeof(real_t));\n    real_t * passed_c = (real_t *)malloc((n/10 + 1) * sizeof(real_t));\n    int passed_indexer;\n    int absolute_indexer;\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n    }\n    for (int x = 0; x < 10; ++x){\n        totals[x] = 0;\n    }\n\n    #pragma acc data copyin(a[0:n], b[0:n]) copy(totals[0:10])\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                #pragma acc atomic update capture\n                {\n                    totals[x%10] = totals[x%10] - (a[x] + b[x]);\n                    c[x] = totals[x%10];\n                }\n            }\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        totals_host[x%10] = totals_host[x%10] - (a[x] + b[x]);\n    }\n    for (int x = 0; x < 10; ++x){\n        if (fabs(totals_host[x] - totals[x]) > PRECISION){\n            err += 1;\n        }\n    }\n\n    for (int x = 0; x < 10; ++x){\n        for (passed_indexer = 0, absolute_indexer = x; absolute_indexer < n; passed_indexer++, absolute_indexer+= 10){\n            passed_ab[passed_indexer] = a[absolute_indexer] + b[absolute_indexer];\n            passed_c[passed_indexer] = c[absolute_indexer];\n        }\n        if (!is_possible(passed_ab, passed_c, passed_indexer - 1, 0)){\n            err++;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "atomic",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_structured_x_multiply_expr_assign.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:atomic,construct-independent,V:2.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t *a = (real_t *)malloc(n * sizeof(real_t));\n    real_t *b = (real_t *)malloc(n * sizeof(real_t));\n    real_t *c = (real_t *)malloc(n * sizeof(real_t));\n    real_t *totals = (real_t *)malloc((n/10 + 1) * sizeof(real_t));\n    real_t *totals_comparison = (real_t *)malloc((n/10 + 1) * sizeof(real_t));\n    real_t * passed_ab = (real_t *)malloc(10 * sizeof(real_t));\n    real_t * passed_c = (real_t *)malloc(10 * sizeof(real_t));\n    int passed_indexer;\n    int absolute_indexer;\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n    }\n    for (int x = 0; x < n/10 + 1; ++x){\n        totals[x] = 1;\n        totals_comparison[x] = 1;\n    }\n\n    #pragma acc data copyin(a[0:n], b[0:n]) copy(totals[0:n/10 + 1]) copyout(c[0:n])\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                #pragma acc atomic update capture\n                {\n                    totals[x%(n/10 + 1)] = totals[x%(n/10 + 1)] * (a[x] + b[x]);\n                    c[x] = totals[x%(n/10 + 1)];\n                }\n            }\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        totals_comparison[x%(n/10 + 1)] *= a[x] + b[x];\n    }\n    for (int x = 0; x < 10; ++x){\n        if (fabs(totals_comparison[x] - totals[x]) > PRECISION * totals_comparison[x]){\n            err += 1;\n            break;\n        }\n    }\n\n    for (int x = 0; x < n/10 + 1; ++x){\n        for (passed_indexer = 0, absolute_indexer = x; absolute_indexer < n; passed_indexer++, absolute_indexer += n/10 + 1){\n            passed_ab[passed_indexer] = a[absolute_indexer] + b[absolute_indexer];\n            passed_c[passed_indexer] = c[absolute_indexer];\n        }\n        if (!is_possible(passed_ab, passed_c, passed_indexer - 1, 1)){\n            err++;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "atomic",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_structured_x_plus_expr_assign.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:atomic,construct-independent,V:2.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t *a = (real_t *)malloc(n * sizeof(real_t));\n    real_t *b = (real_t *)malloc(n * sizeof(real_t));\n    real_t *c = (real_t *)malloc(n * sizeof(real_t));\n    real_t *totals = (real_t *)malloc((n/10 + 1) * sizeof(real_t));\n    real_t *totals_comparison = (real_t *)malloc((n/10 + 1) * sizeof(real_t));\n    real_t *passed_ab = (real_t *)malloc(10 * sizeof(real_t));\n    real_t *passed_c = (real_t *)malloc(10 * sizeof(real_t));\n    int passed_indexer;\n    int absolute_indexer;\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n    }\n    for (int x = 0; x < n/10 + 1; ++x){\n        totals[x] = 0;\n        totals_comparison[x] = 0;\n    }\n\n    #pragma acc data copyin(a[0:n], b[0:n]) copy(totals[0:n/10 + 1]) copyout(c[0:n])\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                #pragma acc atomic update capture\n                {\n                    totals[x%(n/10 + 1)] = totals[x%(n/10 + 1)] + (a[x] * b[x]);\n                    c[x] = totals[x%(n/10 + 1)];\n                }\n            }\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        totals_comparison[x%(n/10 + 1)] += a[x] * b[x];\n    }\n    for (int x = 0; x < n/10 + 1; ++x){\n        if (fabs(totals_comparison[x] - totals[x]) > PRECISION){\n            err += 1;\n            break;\n        }\n    }\n\n    for (int x = 0; x < n/10 + 1; ++x){\n        for (passed_indexer = 0, absolute_indexer = x; absolute_indexer < n; passed_indexer++, absolute_indexer+= (n/10 + 1)){\n            passed_ab[passed_indexer] = a[absolute_indexer] * b[absolute_indexer];\n            passed_c[passed_indexer] = c[absolute_indexer];\n        }\n        if (!is_possible(passed_ab, passed_c, passed_indexer - 1, 0)){\n            err++;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "atomic",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_structured_x_rshift_expr_assign.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:atomic,construct-independent,V:2.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    unsigned int *a = (unsigned int *)malloc(n * sizeof(int));\n    unsigned int *b = (unsigned int *)malloc(n * sizeof(int));\n    unsigned int *c = (unsigned int *)malloc(7 * n * sizeof(int));\n    unsigned int passed = 1<<8;\n\n    for (int x = 0; x < n; ++x){\n        a[x] = 1<<8;\n        for (int y = 0; y < 7; ++y){\n            if ((rand()/(real_t) (RAND_MAX)) > .5){\n                b[x] += 1<<y;\n            }\n        }\n    }\n\n    #pragma acc data copyin(b[0:n]) copy(a[0:n]) copyout(c[0:7*n])\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                #pragma acc loop\n                for (int y = 0; y < 7; ++y){\n                    c[x * 7 + y] = a[x];\n                    if ((b[x]>>y)%2 == 1){\n                        #pragma acc atomic update capture\n                        {\n                            a[x] = a[x] >> 1;\n                            c[x * 7 + y] = a[x];\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        for (int y = 0; y < 7; ++y){\n            if ((b[x]>>y)%2 == 1){\n                a[x] <<= 1;\n            }\n        }\n        if (a[x] != 1<<8){\n            err += 1;\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        if (!is_possible(b[x], &(c[x * 7]), 7, passed)){\n            err++;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "atomic",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_update_bitand_equals.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:atomic,construct-independent,V:2.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    int  *a = (int *)malloc(n * sizeof(int));\n    int *totals = (int *)malloc((n/10 + 1) * sizeof(int));\n    int *totals_comparison = (int *)malloc((n/10 + 1) * sizeof(int));\n\n    for (int x = 0; x < n; ++x){\n        for (int y = 0; y < 8; ++y){\n            if (rand()/(real_t)(RAND_MAX) < .933){ //.933 gets close to a 50/50 distribution for a collescence of 10 values\n                a[x] += 1<<y;\n            }\n        }\n    }\n    for (int x = 0; x < n/10 + 1; ++x){\n        for (int y = 0; y < 8; ++y){\n            totals[x] +=  1<<y;\n            totals_comparison[x] += 1<<y;\n        }\n\n    }\n\n    #pragma acc data copyin(a[0:n]) copy(totals[0:n/10 + 1])\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                #pragma acc atomic update\n                    totals[x%(n/10 + 1)] &= a[x];\n            }\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        totals_comparison[x%(n/10 + 1)] &= a[x];\n    }\n    for (int x = 0; x < 10; ++x){\n        if (fabs(totals_comparison[x] - totals[x]) > PRECISION){\n            err += 1;\n            break;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "atomic",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_update_bitor_equals.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:atomic,construct-independent,V:2.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    int  *a = (int *)malloc(n * sizeof(int));\n    int *totals = (int *)malloc((n/10 + 1) * sizeof(int));\n    int *totals_comparison = (int *)malloc((n/10 + 1) * sizeof(int));\n\n    for (int x = 0; x < n; ++x){\n        for (int y = 0; y < 8; ++y){\n            if (rand()/(real_t)(RAND_MAX) > .933){ //.933 gets close to a 50/50 distribution for a collescence of 10 values\n                a[x] += 1<<y;\n            }\n        }\n    }\n    for (int x = 0; x < n/10 + 1; ++x){\n        totals[x] = 0;\n\n    }\n\n    #pragma acc data copyin(a[0:n]) copy(totals[0:n/10 + 1])\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                #pragma acc atomic update\n                    totals[x%(n/10 + 1)] |= a[x];\n            }\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        totals_comparison[x%(n/10 + 1)] |= a[x];\n    }\n    for (int x = 0; x < 10; ++x){\n        if (fabs(totals_comparison[x] - totals[x]) > PRECISION){\n            err += 1;\n            break;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "atomic",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_update_bitxor_equals.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:atomic,construct-independent,V:2.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    int  *a = (int *)malloc(n * sizeof(int));\n    int *totals = (int *)malloc((n/10 + 1) * sizeof(int));\n    int *totals_comparison = (int *)malloc((n/10 + 1) * sizeof(int));\n\n    for (int x = 0; x < n; ++x){\n        for (int y = 0; y < 8; ++y){\n            if (rand()/(real_t)(RAND_MAX) > .5){\n                a[x] += 1<<y;\n            }\n        }\n    }\n    for (int x = 0; x < n/10 + 1; ++x){\n        totals[x] = 0;\n        totals_comparison[x] = 0;\n    }\n\n    #pragma acc data copyin(a[0:n]) copy(totals[0:n/10 + 1])\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                #pragma acc atomic update\n                    totals[x%(n/10 + 1)] ^= a[x];\n            }\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        totals_comparison[x%(n/10 + 1)] ^= a[x];\n    }\n    for (int x = 0; x < 10; ++x){\n        if (fabs(totals_comparison[x] - totals[x]) > PRECISION){\n            err += 1;\n            break;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "atomic",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_update_divided_equals.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:atomic,construct-independent,V:2.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t *a = (real_t *)malloc(n * sizeof(real_t));\n    real_t *b = (real_t *)malloc(n * sizeof(real_t));\n    real_t *totals = (real_t *)malloc((n/10 + 1) * sizeof(real_t));\n    real_t *totals_comparison = (real_t *)malloc((n/10 + 1) * sizeof(real_t));\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n    }\n    for (int x = 0; x < n/10 + 1; ++x){\n        totals[x] = 1;\n        totals_comparison[x] = 1;\n    }\n\n    #pragma acc data copyin(a[0:n], b[0:n]) copy(totals[0:n/10 + 1])\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                #pragma acc atomic update\n                    totals[x%(n/10 + 1)] /= (a[x] + b[x]);\n            }\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        totals_comparison[x%(n/10 + 1)] /= a[x] + b[x];\n    }\n    for (int x = 0; x < 10; ++x){\n        if (fabs(totals_comparison[x] - totals[x]) > PRECISION){\n            err += 1;\n            break;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "atomic",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_update_expr_and_x.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:construct-independent,atomic,V:2.0-2.7\n      LOGICAL FUNCTION test1()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x, y !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT, 10):: randoms\n        LOGICAL,DIMENSION(LOOPCOUNT, 10):: a !Data\n        LOGICAL,DIMENSION(LOOPCOUNT):: totals, totals_comparison\n        INTEGER :: errors = 0\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(randoms)\n        DO x = 1, LOOPCOUNT\n          DO y = 1, 10\n            IF (randoms(x, y) < .933) THEN\n              a(x, y) = .TRUE.\n            ELSE\n              a(x, y) = .FALSE.\n            END IF\n          END DO\n        END DO\n\n        totals = .FALSE.\n        totals_comparison = .FALSE.\n\n        !$acc data copyin(a(1:LOOPCOUNT,1:10)) copy(totals(1:LOOPCOUNT))\n          !$acc parallel\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              DO y = 1, 10\n                !$acc atomic update\n                  totals(x) = a(x, y) .AND. totals(x)\n              END DO\n            END DO\n          !$acc end parallel\n        !$acc end data\n\n        DO x = 1, LOOPCOUNT\n          DO y = 1, 10\n            totals_comparison(x) = totals_comparison(x) .AND. a(x, y)\n          END DO\n        END DO\n\n        DO x = 1, LOOPCOUNT\n          IF (totals_comparison(x) .NEQV. totals(x)) THEN\n            errors = errors + 1\n            WRITE(*, *) totals_comparison(x)\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "construct-independent",
                            "atomic"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_update_expr_and_x_end.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:construct-independent,atomic,V:2.0-2.7\n      LOGICAL FUNCTION test1()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x, y !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT, 10):: randoms\n        LOGICAL,DIMENSION(LOOPCOUNT, 10):: a !Data\n        LOGICAL,DIMENSION(LOOPCOUNT):: totals, totals_comparison\n        INTEGER :: errors = 0\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(randoms)\n        DO x = 1, LOOPCOUNT\n          DO y = 1, 10\n            IF (randoms(x, y) < .933) THEN\n              a(x, y) = .TRUE.\n            ELSE\n              a(x, y) = .FALSE.\n            END IF\n          END DO\n        END DO\n\n        totals = .FALSE.\n        totals_comparison = .FALSE.\n\n        !$acc data copyin(a(1:LOOPCOUNT,1:10)) copy(totals(1:LOOPCOUNT))\n          !$acc parallel\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              DO y = 1, 10\n                !$acc atomic update\n                  totals(x) = a(x, y) .AND. totals(x)\n                !$acc end atomic\n              END DO\n            END DO\n          !$acc end parallel\n        !$acc end data\n\n        DO x = 1, LOOPCOUNT\n          DO y = 1, 10\n            totals_comparison(x) = totals_comparison(x) .AND. a(x, y)\n          END DO\n        END DO\n\n        DO x = 1, LOOPCOUNT\n          IF (totals_comparison(x) .NEQV. totals(x)) THEN\n            errors = errors + 1\n            WRITE(*, *) totals_comparison(x)\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "construct-independent",
                            "atomic"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_update_expr_bitand_x.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:atomic,construct-independent,V:2.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    int  *a = (int *)malloc(n * sizeof(int));\n    int *totals = (int *)malloc((n/10 + 1) * sizeof(int));\n    int *totals_comparison = (int *)malloc((n/10 + 1) * sizeof(int));\n\n    for (int x = 0; x < n; ++x){\n        for (int y = 0; y < 8; ++y){\n            if (rand()/(real_t)(RAND_MAX) < .933){ //.933 gets close to a 50/50 distribution for a collescence of 10 values\n                a[x] += 1<<y;\n            }\n        }\n    }\n    for (int x = 0; x < n/10 + 1; ++x){\n        for (int y = 0; y < 8; ++y){\n            totals[x] +=  1<<y;\n            totals_comparison[x] += 1<<y;\n        }\n\n    }\n\n    #pragma acc data copyin(a[0:n]) copy(totals[0:n/10 + 1])\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                #pragma acc atomic update\n                    totals[x%(n/10 + 1)] = a[x] & totals[x%(n/10 + 1)];\n            }\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        totals_comparison[x%(n/10 + 1)] &= a[x];\n    }\n    for (int x = 0; x < 10; ++x){\n        if (fabs(totals_comparison[x] - totals[x]) > PRECISION){\n            err += 1;\n            break;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "atomic",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_update_expr_bitor_x.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:atomic,construct-independent,V:2.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    int  *a = (int *)malloc(n * sizeof(int));\n    int *totals = (int *)malloc((n/10 + 1) * sizeof(int));\n    int *totals_comparison = (int *)malloc((n/10 + 1) * sizeof(int));\n\n    for (int x = 0; x < n; ++x){\n        for (int y = 0; y < 8; ++y){\n            if (rand()/(real_t)(RAND_MAX) > .933){ //.933 gets close to a 50/50 distribution for a collescence of 10 values\n                a[x] += 1<<y;\n            }\n        }\n    }\n    for (int x = 0; x < n/10 + 1; ++x){\n        totals[x] = 0;\n\n    }\n\n    #pragma acc data copyin(a[0:n]) copy(totals[0:n/10 + 1])\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                #pragma acc atomic update\n                    totals[x%(n/10 + 1)] = totals[x%(n/10 + 1)] | a[x];\n            }\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        totals_comparison[x%(n/10 + 1)] |= a[x];\n    }\n    for (int x = 0; x < 10; ++x){\n        if (fabs(totals_comparison[x] - totals[x]) > PRECISION){\n            err += 1;\n            break;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "atomic",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_update_expr_bitxor_x.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:atomic,construct-independent,V:2.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    int  *a = (int *)malloc(n * sizeof(int));\n    int *totals = (int *)malloc((n/10 + 1) * sizeof(int));\n    int *totals_comparison = (int *)malloc((n/10 + 1) * sizeof(int));\n\n    for (int x = 0; x < n; ++x){\n        for (int y = 0; y < 8; ++y){\n            if (rand()/(real_t)(RAND_MAX) > .5){\n                a[x] += 1<<y;\n            }\n        }\n    }\n    for (int x = 0; x < n/10 + 1; ++x){\n        totals[x] = 0;\n        totals_comparison[x] = 0;\n    }\n\n    #pragma acc data copyin(a[0:n]) copy(totals[0:n/10 + 1])\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                #pragma acc atomic update\n                    totals[x%(n/10 + 1)] = a[x] ^ totals[x%(n/10 + 1)];\n            }\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        totals_comparison[x%(n/10 + 1)] ^= a[x];\n    }\n    for (int x = 0; x < 10; ++x){\n        if (fabs(totals_comparison[x] - totals[x]) > PRECISION){\n            err += 1;\n            break;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "atomic",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_update_expr_divided_x.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:construct-independent,atomic,V:2.0-2.7\n      LOGICAL FUNCTION test1()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x, y !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT, 10):: a !Data\n        REAL(8),DIMENSION(LOOPCOUNT):: totals\n        REAL(8),DIMENSION(10):: passed\n        INTEGER :: errors = 0\n        LOGICAL IS_POSSIBLE\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(a)\n\n        totals = 1\n\n        !$acc data copyin(a(1:LOOPCOUNT, 1:10)) copy(totals(1:LOOPCOUNT))\n          !$acc parallel\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              DO y = 1, 10\n                !$acc atomic update\n                  totals(x) = a(x, y) / totals(x)\n              END DO\n            END DO\n          !$acc end parallel\n        !$acc end data\n\n\n        DO x = 1, LOOPCOUNT\n          DO y = 1, 10\n            passed(y) = a(x, y)\n          END DO\n          IF (IS_POSSIBLE(passed, totals(x), 10, 1) .eqv. .FALSE.) THEN\n            errors = errors + 1\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "construct-independent",
                            "atomic"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_update_expr_divided_x.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:atomic,construct-independent,V:2.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t *a = (real_t *)malloc(n * sizeof(real_t));\n    real_t *b = (real_t *)malloc(n * sizeof(real_t));\n    real_t *totals = (real_t *)malloc((n/10 + 1) * sizeof(real_t));\n    real_t * passed = (real_t *)malloc(10 * sizeof(real_t));\n    int indexer;\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n    }\n    for (int x = 0; x < n/10 + 1; ++x){\n        totals[x] = 1;\n    }\n\n    #pragma acc data copyin(a[0:n], b[0:n]) copy(totals[0:n/10 + 1])\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                #pragma acc atomic update\n                    totals[x%(n/10 + 1)] = (a[x] + b[x]) / totals[x%(n/10 + 1)];\n            }\n        }\n    }\n\n\n    for (int x = 0; x < (n/10 + 1); ++x){\n        indexer = x;\n        while (indexer < n){\n            passed[indexer/(n/10 + 1)] = (a[x] + b[x]);\n            indexer += (n/10 + 1);\n        }\n        if (!(possible_result(passed, 10, 1, totals[x]))){\n            err += 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "atomic",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_update_expr_divided_x_end.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:construct-independent,atomic,V:2.0-2.7\n      LOGICAL FUNCTION test1()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x, y !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT, 10):: a !Data\n        REAL(8),DIMENSION(LOOPCOUNT):: totals\n        REAL(8),DIMENSION(10):: passed\n        INTEGER :: errors = 0\n        LOGICAL IS_POSSIBLE\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(a)\n\n        totals = 1\n\n        !$acc data copyin(a(1:LOOPCOUNT, 1:10)) copy(totals(1:LOOPCOUNT))\n          !$acc parallel\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              DO y = 1, 10\n                !$acc atomic update\n                  totals(x) = a(x, y) / totals(x)\n                !$acc end atomic\n              END DO\n            END DO\n          !$acc end parallel\n        !$acc end data\n\n\n        DO x = 1, LOOPCOUNT\n          DO y = 1, 10\n            passed(y) = a(x, y)\n          END DO\n          IF (IS_POSSIBLE(passed, totals(x), 10, 1) .eqv. .FALSE.) THEN\n            errors = errors + 1\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "construct-independent",
                            "atomic"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_update_expr_eqv_x.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:construct-independent,atomic,V:2.0-2.7\n      LOGICAL FUNCTION test1()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x, y !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT, 10):: randoms\n        LOGICAL,DIMENSION(LOOPCOUNT, 10):: a !Data\n        LOGICAL,DIMENSION(LOOPCOUNT):: totals, totals_comparison\n        INTEGER :: errors = 0\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(randoms)\n        DO x = 1, LOOPCOUNT\n          DO y = 1, 10\n            IF (randoms(x, y) > .5) THEN\n              a(x, y) = .TRUE.\n            ELSE\n              a(x, y) = .FALSE.\n            END IF\n          END DO\n        END DO\n\n        totals = .FALSE.\n        totals_comparison = .FALSE.\n\n        !$acc data copyin(a(1:LOOPCOUNT,1:10)) copy(totals(1:LOOPCOUNT))\n          !$acc parallel\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              DO y = 1, 10\n                !$acc atomic update\n                  totals(x) = a(x, y) .EQV. totals(x)\n              END DO\n            END DO\n          !$acc end parallel\n        !$acc end data\n\n        DO x = 1, LOOPCOUNT\n          DO y = 1, 10\n            totals_comparison(x) = totals_comparison(x) .EQV. a(x, y)\n          END DO\n        END DO\n\n        DO x = 1, LOOPCOUNT\n          IF (totals_comparison(x) .NEQV. totals(x)) THEN\n            errors = errors + 1\n            WRITE(*, *) totals_comparison(x)\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "construct-independent",
                            "atomic"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_update_expr_eqv_x_end.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:construct-independent,atomic,V:2.0-2.7\n      LOGICAL FUNCTION test1()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x, y !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT, 10):: randoms\n        LOGICAL,DIMENSION(LOOPCOUNT, 10):: a !Data\n        LOGICAL,DIMENSION(LOOPCOUNT):: totals, totals_comparison\n        INTEGER :: errors = 0\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(randoms)\n        DO x = 1, LOOPCOUNT\n          DO y = 1, 10\n            IF (randoms(x, y) > .5) THEN\n              a(x, y) = .TRUE.\n            ELSE\n              a(x, y) = .FALSE.\n            END IF\n          END DO\n        END DO\n\n        totals = .FALSE.\n        totals_comparison = .FALSE.\n\n        !$acc data copyin(a(1:LOOPCOUNT,1:10)) copy(totals(1:LOOPCOUNT))\n          !$acc parallel\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              DO y = 1, 10\n                !$acc atomic update\n                  totals(x) = a(x, y) .EQV. totals(x)\n                !$acc end atomic\n              END DO\n            END DO\n          !$acc end parallel\n        !$acc end data\n\n        DO x = 1, LOOPCOUNT\n          DO y = 1, 10\n            totals_comparison(x) = totals_comparison(x) .EQV. a(x, y)\n          END DO\n        END DO\n\n        DO x = 1, LOOPCOUNT\n          IF (totals_comparison(x) .NEQV. totals(x)) THEN\n            errors = errors + 1\n            WRITE(*, *) totals_comparison(x)\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "construct-independent",
                            "atomic"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_update_expr_lshift_x.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:atomic,construct-independent,V:2.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    unsigned int *a = (unsigned int *)malloc(3 * n * sizeof(int));\n    unsigned int *b = (unsigned int *)malloc(n * sizeof(int));\n    int orders[18] = {1, 2, 0, 1, 0, 2, 2, 1, 0, 2, 0, 1, 0, 1, 2, 0, 2, 1};\n    int result;\n\n    for (int x = 0; x < n; ++x){\n        for (int y = 0; y < 3; ++y){\n            a[x * 3 + y] = (int) (rand() / (unsigned int) (RAND_MAX / 4));\n        }\n        b[x] = 0;\n    }\n\n    #pragma acc data copyin(a[0:3 * n]) copy(b[0:n])\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                #pragma acc loop\n                for (int y = 0; y < 3; ++y){\n                    #pragma acc atomic update\n                        b[x] = a[x * 3 + y] << b[x];\n                }\n            }\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        for (int y = 0; y < 6; ++y){\n            result = 0;\n            for (int z = 0; z < 3; ++z){\n                result = a[x * 3 + orders[y * 3 + z]] << result;\n            }\n            if (result == b[x]){\n                break;\n            }\n        }\n        if (result != b[x]){\n            err += 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "atomic",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_update_expr_minus_x.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:construct-independent,atomic,V:2.0-2.7\n      LOGICAL FUNCTION test1()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x, y !Iterators\n        LOGICAL IS_POSSIBLE\n        REAL(8),DIMENSION(LOOPCOUNT, 10):: a !Data\n        REAL(8),DIMENSION(LOOPCOUNT):: totals\n        INTEGER :: errors = 0\n        REAL(8),DIMENSION(10):: passed\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(a)\n\n        totals = 0\n\n        !$acc data copyin(a(1:LOOPCOUNT, 1:10)) copy(totals(1:LOOPCOUNT))\n          !$acc parallel\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              DO y = 1, 10\n                !$acc atomic update\n                  totals(x) = a(x, y) - totals(x)\n              END DO\n            END DO\n          !$acc end parallel\n        !$acc end data\n\n        DO x = 1, LOOPCOUNT\n          DO y = 1, 10\n            passed(y) = a(x, y)\n          END DO\n          IF (IS_POSSIBLE(passed, totals(x), 10, 0) .eqv. .FALSE.) THEN\n            errors = errors + 1\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "construct-independent",
                            "atomic"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_update_expr_minus_x.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:atomic,construct-independent,V:2.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t *a = (real_t *)malloc(n * sizeof(real_t));\n    real_t *totals = (real_t *)malloc(((n/10) + 1) * sizeof(real_t));\n    int indexer = 0;\n    real_t * passed = (real_t *)malloc(10 * sizeof(real_t));\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n    }\n    for (int x = 0; x < (n/10) + 1; ++x){\n        totals[x] = 0;\n    }\n\n    #pragma acc data copyin(a[0:n]) copy(totals[0:(n/10) + 1])\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                #pragma acc atomic update\n                    totals[x%((int) (n/10) + 1)] = a[x] - totals[x%((int) (n/10) + 1)];\n            }\n        }\n    }\n    for (int x = 0; x < (n/10) + 1; ++x){\n        indexer = x;\n        while (indexer < n){\n            passed[indexer/((int) (n/10) + 1)] = a[indexer];\n            indexer += (n/10) + 1;\n        }\n        if (!(possible_result(passed, 10, 0, totals[x]))){\n            err += 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "atomic",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_update_expr_minus_x_end.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:construct-independent,atomic,V:2.0-2.7\n      LOGICAL FUNCTION test1()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x, y !Iterators\n        LOGICAL IS_POSSIBLE\n        REAL(8),DIMENSION(LOOPCOUNT, 10):: a !Data\n        REAL(8),DIMENSION(LOOPCOUNT):: totals\n        INTEGER :: errors = 0\n        REAL(8),DIMENSION(10):: passed\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(a)\n\n        totals = 0\n\n        !$acc data copyin(a(1:LOOPCOUNT, 1:10)) copy(totals(1:LOOPCOUNT))\n          !$acc parallel\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              DO y = 1, 10\n                !$acc atomic update\n                  totals(x) = a(x, y) - totals(x)\n                !$acc end atomic\n              END DO\n            END DO\n          !$acc end parallel\n        !$acc end data\n\n        DO x = 1, LOOPCOUNT\n          DO y = 1, 10\n            passed(y) = a(x, y)\n          END DO\n          IF (IS_POSSIBLE(passed, totals(x), 10, 0) .eqv. .FALSE.) THEN\n            errors = errors + 1\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "construct-independent",
                            "atomic"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_update_expr_multiply_x.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:atomic,construct-independent,V:2.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t *a = (real_t *)malloc(n * sizeof(real_t));\n    real_t *b = (real_t *)malloc(n * sizeof(real_t));\n    real_t *totals = (real_t *)malloc((n/10 + 1) * sizeof(real_t));\n    real_t *totals_comparison = (real_t *)malloc((n/10 + 1) * sizeof(real_t));\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n    }\n    for (int x = 0; x < n/10 + 1; ++x){\n        totals[x] = 1;\n        totals_comparison[x] = 1;\n    }\n\n    #pragma acc data copyin(a[0:n], b[0:n]) copy(totals[0:n/10 + 1])\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                #pragma acc atomic update\n                    totals[x%(n/10 + 1)] = (a[x] + b[x]) * totals[x%(n/10 + 1)];\n            }\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        totals_comparison[x%(n/10 + 1)] *= a[x] + b[x];\n    }\n    for (int x = 0; x < 10; ++x){\n        if (fabs(totals_comparison[x] - totals[x]) > PRECISION * totals_comparison[x]){\n            err += 1;\n            break;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "atomic",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_update_expr_neqv_x.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:construct-independent,atomic,V:2.0-2.7\n      LOGICAL FUNCTION test1()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x, y !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT, 10):: randoms\n        LOGICAL,DIMENSION(LOOPCOUNT, 10):: a !Data\n        LOGICAL,DIMENSION(LOOPCOUNT):: totals, totals_comparison\n        INTEGER :: errors = 0\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(randoms)\n        DO x = 1, LOOPCOUNT\n          DO y = 1, 10\n            IF (randoms(x, y) > .5) THEN\n              a(x, y) = .TRUE.\n            ELSE\n              a(x, y) = .FALSE.\n            END IF\n          END DO\n        END DO\n\n        totals = .FALSE.\n        totals_comparison = .FALSE.\n\n        !$acc data copyin(a(1:LOOPCOUNT,1:10)) copy(totals(1:LOOPCOUNT))\n          !$acc parallel\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              DO y = 1, 10\n                !$acc atomic update\n                  totals(x) = a(x, y) .NEQV. totals(x)\n              END DO\n            END DO\n          !$acc end parallel\n        !$acc end data\n\n        DO x = 1, LOOPCOUNT\n          DO y = 1, 10\n            totals_comparison(x) = totals_comparison(x) .NEQV. a(x, y)\n          END DO\n        END DO\n\n        DO x = 1, LOOPCOUNT\n          IF (totals_comparison(x) .NEQV. totals(x)) THEN\n            errors = errors + 1\n            WRITE(*, *) totals_comparison(x)\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "construct-independent",
                            "atomic"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_update_expr_neqv_x_end.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:construct-independent,atomic,V:2.0-2.7\n      LOGICAL FUNCTION test1()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x, y !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT, 10):: randoms\n        LOGICAL,DIMENSION(LOOPCOUNT, 10):: a !Data\n        LOGICAL,DIMENSION(LOOPCOUNT):: totals, totals_comparison\n        INTEGER :: errors = 0\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(randoms)\n        DO x = 1, LOOPCOUNT\n          DO y = 1, 10\n            IF (randoms(x, y) > .5) THEN\n              a(x, y) = .TRUE.\n            ELSE\n              a(x, y) = .FALSE.\n            END IF\n          END DO\n        END DO\n\n        totals = .FALSE.\n        totals_comparison = .FALSE.\n\n        !$acc data copyin(a(1:LOOPCOUNT,1:10)) copy(totals(1:LOOPCOUNT))\n          !$acc parallel\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              DO y = 1, 10\n                !$acc atomic update\n                  totals(x) = a(x, y) .NEQV. totals(x)\n                !$acc end atomic\n              END DO\n            END DO\n          !$acc end parallel\n        !$acc end data\n\n        DO x = 1, LOOPCOUNT\n          DO y = 1, 10\n            totals_comparison(x) = totals_comparison(x) .NEQV. a(x, y)\n          END DO\n        END DO\n\n        DO x = 1, LOOPCOUNT\n          IF (totals_comparison(x) .NEQV. totals(x)) THEN\n            errors = errors + 1\n            WRITE(*, *) totals_comparison(x)\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "construct-independent",
                            "atomic"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_update_expr_or_x.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:construct-independent,atomic,V:2.0-2.7\n      LOGICAL FUNCTION test1()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x, y !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT, 10):: randoms\n        LOGICAL,DIMENSION(LOOPCOUNT, 10):: a !Data\n        LOGICAL,DIMENSION(LOOPCOUNT):: totals, totals_comparison\n        INTEGER :: errors = 0\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(randoms)\n        DO x = 1, LOOPCOUNT\n          DO y = 1, 10\n            IF (randoms(x, y) > .933) THEN\n              a(x, y) = .TRUE.\n            ELSE\n              a(x, y) = .FALSE.\n            END IF\n          END DO\n        END DO\n\n        totals = .FALSE.\n        totals_comparison = .FALSE.\n\n        !$acc data copyin(a(1:LOOPCOUNT,1:10)) copy(totals(1:LOOPCOUNT))\n          !$acc parallel\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              DO y = 1, 10\n                !$acc atomic update\n                  totals(x) = a(x, y) .OR. totals(x)\n              END DO\n            END DO\n          !$acc end parallel\n        !$acc end data\n\n        DO x = 1, LOOPCOUNT\n          DO y = 1, 10\n            totals_comparison(x) = totals_comparison(x) .OR. a(x, y)\n          END DO\n        END DO\n\n        DO x = 1, LOOPCOUNT\n          IF (totals_comparison(x) .NEQV. totals(x)) THEN\n            errors = errors + 1\n            WRITE(*, *) totals_comparison(x)\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "construct-independent",
                            "atomic"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_update_expr_or_x_end.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:construct-independent,atomic,V:2.0-2.7\n      LOGICAL FUNCTION test1()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x, y !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT, 10):: randoms\n        LOGICAL,DIMENSION(LOOPCOUNT, 10):: a !Data\n        LOGICAL,DIMENSION(LOOPCOUNT):: totals, totals_comparison\n        INTEGER :: errors = 0\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(randoms)\n        DO x = 1, LOOPCOUNT\n          DO y = 1, 10\n            IF (randoms(x, y) > .933) THEN\n              a(x, y) = .TRUE.\n            ELSE\n              a(x, y) = .FALSE.\n            END IF\n          END DO\n        END DO\n\n        totals = .FALSE.\n        totals_comparison = .FALSE.\n\n        !$acc data copyin(a(1:LOOPCOUNT,1:10)) copy(totals(1:LOOPCOUNT))\n          !$acc parallel\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              DO y = 1, 10\n                !$acc atomic update\n                  totals(x) = a(x, y) .OR. totals(x)\n                !$acc end atomic\n              END DO\n            END DO\n          !$acc end parallel\n        !$acc end data\n\n        DO x = 1, LOOPCOUNT\n          DO y = 1, 10\n            totals_comparison(x) = totals_comparison(x) .OR. a(x, y)\n          END DO\n        END DO\n\n        DO x = 1, LOOPCOUNT\n          IF (totals_comparison(x) .NEQV. totals(x)) THEN\n            errors = errors + 1\n            WRITE(*, *) totals_comparison(x)\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "construct-independent",
                            "atomic"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_update_expr_plus_x.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:construct-independent,atomic,V:2.0-2.7\n      LOGICAL FUNCTION test1()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x, y !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT, 10):: a !Data\n        REAL(8),DIMENSION(LOOPCOUNT):: totals, totals_comparison\n        INTEGER :: errors = 0\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(a)\n\n        totals = 0\n        totals_comparison = 0\n\n        !$acc data copyin(a(1:LOOPCOUNT, 1:10)) copy(totals(1:LOOPCOUNT))\n          !$acc parallel\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              DO y = 1, 10\n                !$acc atomic update\n                  totals(x) = a(x, y) + totals(x)\n              END DO\n            END DO\n          !$acc end parallel\n        !$acc end data\n        DO x = 1, LOOPCOUNT\n          DO y = 1, 10\n            totals_comparison(x) = totals_comparison(x) + a(x, y)\n          END DO\n        END DO\n\n        DO x = 1, LOOPCOUNT\n          IF (totals_comparison(x) .NE. totals(x)) THEN\n            errors = errors + 1\n            WRITE(*, *) totals_comparison(x)\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "construct-independent",
                            "atomic"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_update_expr_plus_x.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:atomic,construct-independent,V:2.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t *a = (real_t *)malloc(n * sizeof(real_t));\n    real_t *b = (real_t *)malloc(n * sizeof(real_t));\n    real_t *totals = (real_t *)malloc(10 * sizeof(real_t));\n    real_t *totals_comparison = (real_t *)malloc(10 * sizeof(real_t));\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n    }\n    for (int x = 0; x < 10; ++x){\n        totals[x] = 0;\n        totals_comparison[x] = 0;\n    }\n\n    #pragma acc data copyin(a[0:n], b[0:n]) copy(totals[0:10])\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                #pragma acc loop\n                for (int y = 0; y < n; ++y){\n                    #pragma acc atomic update\n                        totals[(int) ((a[x] + b[x])/2)] = a[x] * b[x] + totals[(int) ((a[x] + b[x])/2)];\n                }\n            }\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        for (int y = 0; y < n; ++y){\n            totals_comparison[(int) ((a[x] + b[x])/2)] += a[x] * b[x];\n        }\n    }\n    for (int x = 0; x < 10; ++x){\n        if (fabs(totals_comparison[x] - totals[x]) > 10 * PRECISION){\n            err += 1;\n            break;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "atomic",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_update_expr_plus_x_end.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:construct-independent,atomic,V:2.0-2.7\n      LOGICAL FUNCTION test1()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x, y !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT, 10):: a !Data\n        REAL(8),DIMENSION(LOOPCOUNT):: totals, totals_comparison\n        INTEGER :: errors = 0\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(a)\n\n        totals = 0\n        totals_comparison = 0\n\n        !$acc data copyin(a(1:LOOPCOUNT, 1:10)) copy(totals(1:LOOPCOUNT))\n          !$acc parallel\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              DO y = 1, 10\n                !$acc atomic update\n                  totals(x) = a(x, y) + totals(x)\n                !$acc end atomic\n              END DO\n            END DO\n          !$acc end parallel\n        !$acc end data\n        DO x = 1, LOOPCOUNT\n          DO y = 1, 10\n            totals_comparison(x) = totals_comparison(x) + a(x, y)\n          END DO\n        END DO\n\n        DO x = 1, LOOPCOUNT\n          IF (totals_comparison(x) .NE. totals(x)) THEN\n            errors = errors + 1\n            WRITE(*, *) totals_comparison(x)\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "construct-independent",
                            "atomic"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_update_expr_rshift_x.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:atomic,construct-independent,V:2.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    unsigned int *a = (unsigned int *)malloc(3 * n * sizeof(int));\n    unsigned int *b = (unsigned int *)malloc(n * sizeof(int));\n    int orders[18] = {1, 2, 0, 1, 0, 2, 2, 1, 0, 2, 0, 1, 0, 1, 2, 0, 2, 1};\n    int result;\n\n    for (int x = 0; x < n; ++x){\n        for (int y = 0; y < 3; ++y){\n            a[x * 3 + y] = (int) (rand() / (unsigned int) (RAND_MAX / 4));\n        }\n        b[x] = 0;\n    }\n\n    #pragma acc data copyin(a[0:3 * n]) copy(b[0:n])\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                #pragma acc loop independent\n                for (int y = 0; y < 3; ++y){\n                    #pragma acc atomic update\n                        b[x] = a[x * 3 + y] >> b[x];\n                }\n            }\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        for (int y = 0; y < 6; ++y){\n            result = 0;\n            for (int z = 0; z < 3; ++z){\n                result = a[x * 3 + orders[y * 3 + z]] >> result;\n            }\n            if (result == b[x]){\n                break;\n            }\n        }\n        if (result != b[x]){\n            err += 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "atomic",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_update_expr_times_x.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:construct-independent,atomic,V:2.0-2.7\n      LOGICAL FUNCTION test1()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x, y !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT, 10):: a !Data\n        REAL(8),DIMENSION(LOOPCOUNT):: totals, totals_comparison\n        INTEGER :: errors = 0\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(a)\n\n        totals = 1\n        totals_comparison = 1\n\n        !$acc data copyin(a(1:LOOPCOUNT, 1:10)) copy(totals(1:LOOPCOUNT))\n          !$acc parallel\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              DO y = 1, 10\n                !$acc atomic update\n                  totals(x) = a(x, y) * totals(x)\n              END DO\n            END DO\n          !$acc end parallel\n        !$acc end data\n        DO x = 1, LOOPCOUNT\n          DO y = 1, 10\n            totals_comparison(x) = totals_comparison(x) * a(x, y)\n          END DO\n        END DO\n\n        DO x = 1, LOOPCOUNT\n          IF (totals_comparison(x) .NE. totals(x)) THEN\n            errors = errors + 1\n            WRITE(*, *) totals_comparison(x)\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "construct-independent",
                            "atomic"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_update_expr_times_x_end.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:construct-independent,atomic,V:2.0-2.7\n      LOGICAL FUNCTION test1()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x, y !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT, 10):: a !Data\n        REAL(8),DIMENSION(LOOPCOUNT):: totals, totals_comparison\n        INTEGER :: errors = 0\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(a)\n\n        totals = 1\n        totals_comparison = 1\n\n        !$acc data copyin(a(1:LOOPCOUNT, 1:10)) copy(totals(1:LOOPCOUNT))\n          !$acc parallel\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              DO y = 1, 10\n                !$acc atomic update\n                  totals(x) = a(x, y) * totals(x)\n                !$acc end atomic\n              END DO\n            END DO\n          !$acc end parallel\n        !$acc end data\n        DO x = 1, LOOPCOUNT\n          DO y = 1, 10\n            totals_comparison(x) = totals_comparison(x) * a(x, y)\n          END DO\n        END DO\n\n        DO x = 1, LOOPCOUNT\n          IF (totals_comparison(x) .NE. totals(x)) THEN\n            errors = errors + 1\n            WRITE(*, *) totals_comparison(x)\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "construct-independent",
                            "atomic"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_update_iand_expr_x.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:construct-independent,atomic,V:2.0-2.7\n      LOGICAL FUNCTION test1()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x, y !Iterators\n        INTEGER,DIMENSION(LOOPCOUNT):: a !Data\n        REAL(8),DIMENSION(LOOPCOUNT, 8):: randoms\n        INTEGER,DIMENSION(LOOPCOUNT/10 + 1):: totals, totals_comparison\n        INTEGER :: errors = 0\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(randoms)\n        a = 0\n        DO x = 1, LOOPCOUNT\n          DO y = 1, 8\n            IF (randoms(x, y) .gt. .933) THEN\n              a(x) = a(x) + ISHFT(1, y - 1)\n            END IF\n          END DO\n        END DO\n        totals = 0\n        totals_comparison = 0\n        DO x = 1, LOOPCOUNT/10 + 1\n          DO y = 0, 7\n            totals(x) = totals(x) + ISHFT(1, y)\n            totals_comparison(x) = totals_comparison(x) + ISHFT(1, y)\n          END DO\n        END DO\n\n        !$acc data copyin(a(1:LOOPCOUNT)) copy(totals(1:(LOOPCOUNT/10 + 1)))\n          !$acc parallel\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              !$acc atomic update\n                totals(MOD(x, LOOPCOUNT/10 + 1) + 1) = iand(a(x), totals(MOD(x, LOOPCOUNT/10 + 1) + 1))\n            END DO\n          !$acc end parallel\n        !$acc end data\n        DO x = 1, LOOPCOUNT\n          totals_comparison(MOD(x, LOOPCOUNT/10 + 1) + 1) = iand(totals_comparison(MOD(x, LOOPCOUNT/10 + 1) + 1), a(x))\n        END DO\n        DO x = 1, LOOPCOUNT/10 + 1\n          IF (totals_comparison(x) .NE. totals(x)) THEN\n            errors = errors + 1\n            WRITE(*, *) totals_comparison(x)\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "construct-independent",
                            "atomic"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_update_iand_expr_x_end.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:construct-independent,atomic,V:2.0-2.7\n      LOGICAL FUNCTION test1()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x, y !Iterators\n        INTEGER,DIMENSION(LOOPCOUNT):: a !Data\n        REAL(8),DIMENSION(LOOPCOUNT, 8):: randoms\n        INTEGER,DIMENSION(LOOPCOUNT/10 + 1):: totals, totals_comparison\n        INTEGER :: errors = 0\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(randoms)\n        a = 0\n        DO x = 1, LOOPCOUNT\n          DO y = 1, 8\n            IF (randoms(x, y) .gt. .933) THEN\n              a(x) = a(x) + ISHFT(1, y - 1)\n            END IF\n          END DO\n        END DO\n        totals = 0\n        totals_comparison = 0\n        DO x = 1, LOOPCOUNT/10 + 1\n          DO y = 0, 7\n            totals(x) = totals(x) + ISHFT(1, y)\n            totals_comparison(x) = totals_comparison(x) + ISHFT(1, y)\n          END DO\n        END DO\n\n        !$acc data copyin(a(1:LOOPCOUNT)) copy(totals(1:(LOOPCOUNT/10 + 1)))\n          !$acc parallel\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              !$acc atomic update\n                totals(MOD(x, LOOPCOUNT/10 + 1) + 1) = iand(a(x), totals(MOD(x, LOOPCOUNT/10 + 1) + 1))\n              !$acc end atomic\n            END DO\n          !$acc end parallel\n        !$acc end data\n        DO x = 1, LOOPCOUNT\n          totals_comparison(MOD(x, LOOPCOUNT/10 + 1) + 1) = iand(totals_comparison(MOD(x, LOOPCOUNT/10 + 1) + 1), a(x))\n        END DO\n        DO x = 1, LOOPCOUNT/10 + 1\n          IF (totals_comparison(x) .NE. totals(x)) THEN\n            errors = errors + 1\n            WRITE(*, *) totals_comparison(x)\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "construct-independent",
                            "atomic"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_update_iand_x_expr.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:construct-independent,atomic,V:2.0-2.7\n      LOGICAL FUNCTION test1()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x, y !Iterators\n        INTEGER,DIMENSION(LOOPCOUNT):: a !Data\n        REAL(8),DIMENSION(LOOPCOUNT, 8):: randoms\n        INTEGER,DIMENSION(LOOPCOUNT/10 + 1):: totals, totals_comparison\n        INTEGER :: errors = 0\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(randoms)\n        a = 0\n        DO x = 1, LOOPCOUNT\n          DO y = 1, 8\n            IF (randoms(x, y) .gt. .933) THEN\n              a(x) = a(x) + ISHFT(1, y - 1)\n            END IF\n          END DO\n        END DO\n        totals = 0\n        totals_comparison = 0\n        DO x = 1, LOOPCOUNT/10 + 1\n          DO y = 0, 7\n            totals(x) = totals(x) + ISHFT(1, y)\n            totals_comparison(x) = totals_comparison(x) + ISHFT(1, y)\n          END DO\n        END DO\n\n        !$acc data copyin(a(1:LOOPCOUNT)) copy(totals(1:(LOOPCOUNT/10 + 1)))\n          !$acc parallel\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              !$acc atomic update\n                totals(MOD(x, LOOPCOUNT/10 + 1) + 1) = iand(totals(MOD(x, LOOPCOUNT/10 + 1) + 1), a(x))\n            END DO\n          !$acc end parallel\n        !$acc end data\n        DO x = 1, LOOPCOUNT\n          totals_comparison(MOD(x, LOOPCOUNT/10 + 1) + 1) = iand(totals_comparison(MOD(x, LOOPCOUNT/10 + 1) + 1), a(x))\n        END DO\n        DO x = 1, LOOPCOUNT/10 + 1\n          IF (totals_comparison(x) .NE. totals(x)) THEN\n            errors = errors + 1\n            WRITE(*, *) totals_comparison(x)\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "construct-independent",
                            "atomic"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_update_iand_x_expr_end.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:construct-independent,atomic,V:2.0-2.7\n      LOGICAL FUNCTION test1()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x, y !Iterators\n        INTEGER,DIMENSION(LOOPCOUNT):: a !Data\n        REAL(8),DIMENSION(LOOPCOUNT, 8):: randoms\n        INTEGER,DIMENSION(LOOPCOUNT/10 + 1):: totals, totals_comparison\n        INTEGER :: errors = 0\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(randoms)\n        a = 0\n        DO x = 1, LOOPCOUNT\n          DO y = 1, 8\n            IF (randoms(x, y) .gt. .933) THEN\n              a(x) = a(x) + ISHFT(1, y - 1)\n            END IF\n          END DO\n        END DO\n        totals = 0\n        totals_comparison = 0\n        DO x = 1, LOOPCOUNT/10 + 1\n          DO y = 0, 7\n            totals(x) = totals(x) + ISHFT(1, y)\n            totals_comparison(x) = totals_comparison(x) + ISHFT(1, y)\n          END DO\n        END DO\n\n        !$acc data copyin(a(1:LOOPCOUNT)) copy(totals(1:(LOOPCOUNT/10 + 1)))\n          !$acc parallel\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              !$acc atomic update\n                totals(MOD(x, LOOPCOUNT/10 + 1) + 1) = iand(totals(MOD(x, LOOPCOUNT/10 + 1) + 1), a(x))\n              !$acc end atomic\n            END DO\n          !$acc end parallel\n        !$acc end data\n        DO x = 1, LOOPCOUNT\n          totals_comparison(MOD(x, LOOPCOUNT/10 + 1) + 1) = iand(totals_comparison(MOD(x, LOOPCOUNT/10 + 1) + 1), a(x))\n        END DO\n        DO x = 1, LOOPCOUNT/10 + 1\n          IF (totals_comparison(x) .NE. totals(x)) THEN\n            errors = errors + 1\n            WRITE(*, *) totals_comparison(x)\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "construct-independent",
                            "atomic"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_update_ior_expr_x.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:construct-independent,atomic,V:2.0-2.7\n      LOGICAL FUNCTION test1()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x, y !Iterators\n        INTEGER,DIMENSION(LOOPCOUNT):: a !Data\n        REAL(8),DIMENSION(LOOPCOUNT, 8):: randoms\n        INTEGER,DIMENSION(LOOPCOUNT/10 + 1):: totals, totals_comparison\n        INTEGER :: errors = 0\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(randoms)\n        a = 0\n        DO x = 1, LOOPCOUNT\n          DO y = 1, 8\n            IF (randoms(x, y) .lt. .933) THEN\n              a(x) = a(x) + ISHFT(1, y - 1)\n            END IF\n          END DO\n        END DO\n        totals = 0\n        totals_comparison = 0\n        DO x = 1, LOOPCOUNT/10 + 1\n          totals(x) = 0\n          totals_comparison(x) = 0\n        END DO\n\n        !$acc data copyin(a(1:LOOPCOUNT)) copy(totals(1:(LOOPCOUNT/10 + 1)))\n          !$acc parallel\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              !$acc atomic update\n                totals(MOD(x, LOOPCOUNT/10 + 1) + 1) = ior(a(x), totals(MOD(x, LOOPCOUNT/10 + 1) + 1))\n            END DO\n          !$acc end parallel\n        !$acc end data\n        DO x = 1, LOOPCOUNT\n          totals_comparison(MOD(x, LOOPCOUNT/10 + 1) + 1) = ior(totals_comparison(MOD(x, LOOPCOUNT/10 + 1) + 1), a(x))\n        END DO\n        DO x = 1, LOOPCOUNT/10 + 1\n          IF (totals_comparison(x) .NE. totals(x)) THEN\n            errors = errors + 1\n            WRITE(*, *) totals_comparison(x)\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "construct-independent",
                            "atomic"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_update_ior_expr_x_end.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:construct-independent,atomic,V:2.0-2.7\n      LOGICAL FUNCTION test1()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x, y !Iterators\n        INTEGER,DIMENSION(LOOPCOUNT):: a !Data\n        REAL(8),DIMENSION(LOOPCOUNT, 8):: randoms\n        INTEGER,DIMENSION(LOOPCOUNT/10 + 1):: totals, totals_comparison\n        INTEGER :: errors = 0\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(randoms)\n        a = 0\n        DO x = 1, LOOPCOUNT\n          DO y = 1, 8\n            IF (randoms(x, y) .lt. .933) THEN\n              a(x) = a(x) + ISHFT(1, y - 1)\n            END IF\n          END DO\n        END DO\n        totals = 0\n        totals_comparison = 0\n        DO x = 1, LOOPCOUNT/10 + 1\n          totals(x) = 0\n          totals_comparison(x) = 0\n        END DO\n\n        !$acc data copyin(a(1:LOOPCOUNT)) copy(totals(1:(LOOPCOUNT/10 + 1)))\n          !$acc parallel\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              !$acc atomic update\n                totals(MOD(x, LOOPCOUNT/10 + 1) + 1) = ior(a(x), totals(MOD(x, LOOPCOUNT/10 + 1) + 1))\n              !$acc end atomic\n            END DO\n          !$acc end parallel\n        !$acc end data\n        DO x = 1, LOOPCOUNT\n          totals_comparison(MOD(x, LOOPCOUNT/10 + 1) + 1) = ior(totals_comparison(MOD(x, LOOPCOUNT/10 + 1) + 1), a(x))\n        END DO\n        DO x = 1, LOOPCOUNT/10 + 1\n          IF (totals_comparison(x) .NE. totals(x)) THEN\n            errors = errors + 1\n            WRITE(*, *) totals_comparison(x)\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "construct-independent",
                            "atomic"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_update_ior_x_expr.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:construct-independent,atomic,V:2.0-2.7\n      LOGICAL FUNCTION test1()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x, y !Iterators\n        INTEGER,DIMENSION(LOOPCOUNT):: a !Data\n        REAL(8),DIMENSION(LOOPCOUNT, 8):: randoms\n        INTEGER,DIMENSION(LOOPCOUNT/10 + 1):: totals, totals_comparison\n        INTEGER :: errors = 0\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(randoms)\n        a = 0\n        DO x = 1, LOOPCOUNT\n          DO y = 1, 8\n            IF (randoms(x, y) .lt. .933) THEN\n              a(x) = a(x) + ISHFT(1, y - 1)\n            END IF\n          END DO\n        END DO\n        totals = 0\n        totals_comparison = 0\n        DO x = 1, LOOPCOUNT/10 + 1\n          totals(x) = 0\n          totals_comparison(x) = 0\n        END DO\n\n        !$acc data copyin(a(1:LOOPCOUNT)) copy(totals(1:(LOOPCOUNT/10 + 1)))\n          !$acc parallel\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              !$acc atomic update\n                totals(MOD(x, LOOPCOUNT/10 + 1) + 1) = ior(totals(MOD(x, LOOPCOUNT/10 + 1) + 1), a(x))\n            END DO\n          !$acc end parallel\n        !$acc end data\n        DO x = 1, LOOPCOUNT\n          totals_comparison(MOD(x, LOOPCOUNT/10 + 1) + 1) = ior(totals_comparison(MOD(x, LOOPCOUNT/10 + 1) + 1), a(x))\n        END DO\n        DO x = 1, LOOPCOUNT/10 + 1\n          IF (totals_comparison(x) .NE. totals(x)) THEN\n            errors = errors + 1\n            WRITE(*, *) totals_comparison(x)\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "construct-independent",
                            "atomic"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_update_ior_x_expr_end.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:construct-independent,atomic,V:2.0-2.7\n      LOGICAL FUNCTION test1()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x, y !Iterators\n        INTEGER,DIMENSION(LOOPCOUNT):: a !Data\n        REAL(8),DIMENSION(LOOPCOUNT, 8):: randoms\n        INTEGER,DIMENSION(LOOPCOUNT/10 + 1):: totals, totals_comparison\n        INTEGER :: errors = 0\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(randoms)\n        a = 0\n        DO x = 1, LOOPCOUNT\n          DO y = 1, 8\n            IF (randoms(x, y) .lt. .933) THEN\n              a(x) = a(x) + ISHFT(1, y - 1)\n            END IF\n          END DO\n        END DO\n        totals = 0\n        totals_comparison = 0\n        DO x = 1, LOOPCOUNT/10 + 1\n          totals(x) = 0\n          totals_comparison(x) = 0\n        END DO\n\n        !$acc data copyin(a(1:LOOPCOUNT)) copy(totals(1:(LOOPCOUNT/10 + 1)))\n          !$acc parallel\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              !$acc atomic update\n                totals(MOD(x, LOOPCOUNT/10 + 1) + 1) = ior(totals(MOD(x, LOOPCOUNT/10 + 1) + 1), a(x))\n              !$acc end atomic\n            END DO\n          !$acc end parallel\n        !$acc end data\n        DO x = 1, LOOPCOUNT\n          totals_comparison(MOD(x, LOOPCOUNT/10 + 1) + 1) = ior(totals_comparison(MOD(x, LOOPCOUNT/10 + 1) + 1), a(x))\n        END DO\n        DO x = 1, LOOPCOUNT/10 + 1\n          IF (totals_comparison(x) .NE. totals(x)) THEN\n            errors = errors + 1\n            WRITE(*, *) totals_comparison(x)\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "construct-independent",
                            "atomic"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_update_ixor_expr_x.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:construct-independent,atomic,V:2.0-2.7\n      LOGICAL FUNCTION test1()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x, y !Iterators\n        INTEGER,DIMENSION(LOOPCOUNT):: a !Data\n        REAL(8),DIMENSION(LOOPCOUNT, 8):: randoms\n        INTEGER,DIMENSION(LOOPCOUNT/10 + 1):: totals, totals_comparison\n        INTEGER :: errors = 0\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(randoms)\n        a = 0\n        DO x = 1, LOOPCOUNT\n          DO y = 1, 8\n            IF (randoms(x, y) .lt. .5) THEN\n              a(x) = a(x) + ISHFT(1, y - 1)\n            END IF\n          END DO\n        END DO\n        totals = 0\n        totals_comparison = 0\n        DO x = 1, LOOPCOUNT/10 + 1\n          totals(x) = 0\n          totals_comparison(x) = 0\n        END DO\n\n        !$acc data copyin(a(1:LOOPCOUNT)) copy(totals(1:(LOOPCOUNT/10 + 1)))\n          !$acc parallel\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              !$acc atomic update\n                totals(MOD(x, LOOPCOUNT/10 + 1) + 1) = ieor(a(x), totals(MOD(x, LOOPCOUNT/10 + 1) + 1))\n            END DO\n          !$acc end parallel\n        !$acc end data\n        DO x = 1, LOOPCOUNT\n          totals_comparison(MOD(x, LOOPCOUNT/10 + 1) + 1) = ieor(totals_comparison(MOD(x, LOOPCOUNT/10 + 1) + 1), a(x))\n        END DO\n        DO x = 1, LOOPCOUNT/10 + 1\n          IF (totals_comparison(x) .NE. totals(x)) THEN\n            errors = errors + 1\n            WRITE(*, *) totals_comparison(x)\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "construct-independent",
                            "atomic"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_update_ixor_expr_x_end.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:construct-independent,atomic,V:2.0-2.7\n      LOGICAL FUNCTION test1()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x, y !Iterators\n        INTEGER,DIMENSION(LOOPCOUNT):: a !Data\n        REAL(8),DIMENSION(LOOPCOUNT, 8):: randoms\n        INTEGER,DIMENSION(LOOPCOUNT/10 + 1):: totals, totals_comparison\n        INTEGER :: errors = 0\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(randoms)\n        a = 0\n        DO x = 1, LOOPCOUNT\n          DO y = 1, 8\n            IF (randoms(x, y) .lt. .5) THEN\n              a(x) = a(x) + ISHFT(1, y - 1)\n            END IF\n          END DO\n        END DO\n        totals = 0\n        totals_comparison = 0\n        DO x = 1, LOOPCOUNT/10 + 1\n          totals(x) = 0\n          totals_comparison(x) = 0\n        END DO\n\n        !$acc data copyin(a(1:LOOPCOUNT)) copy(totals(1:(LOOPCOUNT/10 + 1)))\n          !$acc parallel\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              !$acc atomic update\n                totals(MOD(x, LOOPCOUNT/10 + 1) + 1) = ieor(a(x), totals(MOD(x, LOOPCOUNT/10 + 1) + 1))\n              !$acc end atomic\n            END DO\n          !$acc end parallel\n        !$acc end data\n        DO x = 1, LOOPCOUNT\n          totals_comparison(MOD(x, LOOPCOUNT/10 + 1) + 1) = ieor(totals_comparison(MOD(x, LOOPCOUNT/10 + 1) + 1), a(x))\n        END DO\n        DO x = 1, LOOPCOUNT/10 + 1\n          IF (totals_comparison(x) .NE. totals(x)) THEN\n            errors = errors + 1\n            WRITE(*, *) totals_comparison(x)\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "construct-independent",
                            "atomic"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_update_ixor_x_expr.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:construct-independent,atomic,V:2.0-2.7\n      LOGICAL FUNCTION test1()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x, y !Iterators\n        INTEGER,DIMENSION(LOOPCOUNT):: a !Data\n        REAL(8),DIMENSION(LOOPCOUNT, 8):: randoms\n        INTEGER,DIMENSION(LOOPCOUNT/10 + 1):: totals, totals_comparison\n        INTEGER :: errors = 0\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(randoms)\n        a = 0\n        DO x = 1, LOOPCOUNT\n          DO y = 1, 8\n            IF (randoms(x, y) .lt. .5) THEN\n              a(x) = a(x) + ISHFT(1, y - 1)\n            END IF\n          END DO\n        END DO\n        totals = 0\n        totals_comparison = 0\n        DO x = 1, LOOPCOUNT/10 + 1\n          totals(x) = 0\n          totals_comparison(x) = 0\n        END DO\n\n        !$acc data copyin(a(1:LOOPCOUNT)) copy(totals(1:(LOOPCOUNT/10 + 1)))\n          !$acc parallel\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              !$acc atomic update\n                totals(MOD(x, LOOPCOUNT/10 + 1) + 1) = ieor(totals(MOD(x, LOOPCOUNT/10 + 1) + 1), a(x))\n            END DO\n          !$acc end parallel\n        !$acc end data\n        DO x = 1, LOOPCOUNT\n          totals_comparison(MOD(x, LOOPCOUNT/10 + 1) + 1) = ieor(totals_comparison(MOD(x, LOOPCOUNT/10 + 1) + 1), a(x))\n        END DO\n        DO x = 1, LOOPCOUNT/10 + 1\n          IF (totals_comparison(x) .NE. totals(x)) THEN\n            errors = errors + 1\n            WRITE(*, *) totals_comparison(x)\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "construct-independent",
                            "atomic"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_update_ixor_x_expr_end.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:construct-independent,atomic,V:2.0-2.7\n      LOGICAL FUNCTION test1()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x, y !Iterators\n        INTEGER,DIMENSION(LOOPCOUNT):: a !Data\n        REAL(8),DIMENSION(LOOPCOUNT, 8):: randoms\n        INTEGER,DIMENSION(LOOPCOUNT/10 + 1):: totals, totals_comparison\n        INTEGER :: errors = 0\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(randoms)\n        a = 0\n        DO x = 1, LOOPCOUNT\n          DO y = 1, 8\n            IF (randoms(x, y) .lt. .5) THEN\n              a(x) = a(x) + ISHFT(1, y - 1)\n            END IF\n          END DO\n        END DO\n        totals = 0\n        totals_comparison = 0\n        DO x = 1, LOOPCOUNT/10 + 1\n          totals(x) = 0\n          totals_comparison(x) = 0\n        END DO\n\n        !$acc data copyin(a(1:LOOPCOUNT)) copy(totals(1:(LOOPCOUNT/10 + 1)))\n          !$acc parallel\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              !$acc atomic update\n                totals(MOD(x, LOOPCOUNT/10 + 1) + 1) = ieor(totals(MOD(x, LOOPCOUNT/10 + 1) + 1), a(x))\n              !$acc end atomic\n            END DO\n          !$acc end parallel\n        !$acc end data\n        DO x = 1, LOOPCOUNT\n          totals_comparison(MOD(x, LOOPCOUNT/10 + 1) + 1) = ieor(totals_comparison(MOD(x, LOOPCOUNT/10 + 1) + 1), a(x))\n        END DO\n        DO x = 1, LOOPCOUNT/10 + 1\n          IF (totals_comparison(x) .NE. totals(x)) THEN\n            errors = errors + 1\n            WRITE(*, *) totals_comparison(x)\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "construct-independent",
                            "atomic"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_update_lshift_equals.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:atomic,construct-independent,V:2.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    unsigned int *a = (unsigned int *)malloc(n * sizeof(int));\n    unsigned int *b = (unsigned int *)malloc(n * sizeof(int));\n\n    for (int x = 0; x < n; ++x){\n        a[x] = 1;\n        for (int y = 0; y < 7; ++y){\n            if ((rand()/(unsigned int) (RAND_MAX)) > .5){\n                b[x] += 1<<y;\n            }\n        }\n    }\n\n    #pragma acc data copyin(b[0:n]) copy(a[0:n])\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                #pragma acc loop\n                for (int y = 0; y < 7; ++y){\n                    if ((b[x]>>y)%2 == 1){\n                        #pragma acc atomic update\n                            a[x] <<= 1;\n                    }\n                }\n            }\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        for (int y = 0; y < 7; ++y){\n            if ((b[x]>>y)%2 == 1){\n                a[x] >>= 1;\n            }\n        }\n        if (a[x] != 1){\n            err += 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "atomic",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_update_max_expr_list_x.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:construct-independent,atomic,V:2.0-2.7\n      LOGICAL FUNCTION test1()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x, y !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT):: a, b !Data\n        REAL(8),DIMENSION(LOOPCOUNT/10 + 1):: totals, totals_comparison\n        INTEGER :: errors = 0\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(a)\n        CALL RANDOM_NUMBER(b)\n\n        totals = 0\n        totals_comparison = 0\n\n        !$acc data copyin(a(1:LOOPCOUNT), b(1:LOOPCOUNT)) copy(totals(1:(LOOPCOUNT/10 + 1)))\n          !$acc parallel\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              !$acc atomic update\n                totals(MOD(x, LOOPCOUNT/10 + 1) + 1) = max(a(x), b(x), totals(MOD(x, LOOPCOUNT/10 + 1) + 1))\n            END DO\n          !$acc end parallel\n        !$acc end data\n        DO x = 1, LOOPCOUNT\n          totals_comparison(MOD(x, LOOPCOUNT/10 + 1) + 1) = max(totals_comparison(MOD(x, LOOPCOUNT/10 + 1) + 1), a(x), b(x))\n        END DO\n        DO x = 1, LOOPCOUNT/10 + 1\n          IF (totals_comparison(x) .NE. totals(x)) THEN\n            errors = errors + 1\n            WRITE(*, *) totals_comparison(x)\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "construct-independent",
                            "atomic"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_update_max_expr_list_x_end.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:construct-independent,atomic,V:2.0-2.7\n      LOGICAL FUNCTION test1()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x, y !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT):: a, b !Data\n        REAL(8),DIMENSION(LOOPCOUNT/10 + 1):: totals, totals_comparison\n        INTEGER :: errors = 0\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(a)\n        CALL RANDOM_NUMBER(b)\n\n        totals = 0\n        totals_comparison = 0\n\n        !$acc data copyin(a(1:LOOPCOUNT), b(1:LOOPCOUNT)) copy(totals(1:(LOOPCOUNT/10 + 1)))\n          !$acc parallel\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              !$acc atomic update\n                totals(MOD(x, LOOPCOUNT/10 + 1) + 1) = max(a(x), b(x), totals(MOD(x, LOOPCOUNT/10 + 1) + 1))\n              !$acc end atomic\n            END DO\n          !$acc end parallel\n        !$acc end data\n        DO x = 1, LOOPCOUNT\n          totals_comparison(MOD(x, LOOPCOUNT/10 + 1) + 1) = max(totals_comparison(MOD(x, LOOPCOUNT/10 + 1) + 1), a(x), b(x))\n        END DO\n        DO x = 1, LOOPCOUNT/10 + 1\n          IF (totals_comparison(x) .NE. totals(x)) THEN\n            errors = errors + 1\n            WRITE(*, *) totals_comparison(x)\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "construct-independent",
                            "atomic"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_update_max_expr_x.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:construct-independent,atomic,V:2.0-2.7\n      LOGICAL FUNCTION test1()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x, y !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT):: a !Data\n        REAL(8),DIMENSION(LOOPCOUNT/10 + 1):: totals, totals_comparison\n        INTEGER :: errors = 0\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(a)\n\n        totals = 0\n        totals_comparison = 0\n\n        !$acc data copyin(a(1:LOOPCOUNT)) copy(totals(1:(LOOPCOUNT/10 + 1)))\n          !$acc parallel\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              !$acc atomic update\n                totals(MOD(x, LOOPCOUNT/10 + 1) + 1) = max(a(x), totals(MOD(x, LOOPCOUNT/10 + 1) + 1))\n            END DO\n          !$acc end parallel\n        !$acc end data\n        DO x = 1, LOOPCOUNT\n          totals_comparison(MOD(x, LOOPCOUNT/10 + 1) + 1) = max(totals_comparison(MOD(x, LOOPCOUNT/10 + 1) + 1), a(x))\n        END DO\n        DO x = 1, LOOPCOUNT/10 + 1\n          IF (totals_comparison(x) .NE. totals(x)) THEN\n            errors = errors + 1\n            WRITE(*, *) totals_comparison(x)\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "construct-independent",
                            "atomic"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_update_max_expr_x_end.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:construct-independent,atomic,V:2.0-2.7\n      LOGICAL FUNCTION test1()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x, y !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT):: a !Data\n        REAL(8),DIMENSION(LOOPCOUNT/10 + 1):: totals, totals_comparison\n        INTEGER :: errors = 0\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(a)\n\n        totals = 0\n        totals_comparison = 0\n\n        !$acc data copyin(a(1:LOOPCOUNT)) copy(totals(1:(LOOPCOUNT/10 + 1)))\n          !$acc parallel\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              !$acc atomic update\n                totals(MOD(x, LOOPCOUNT/10 + 1) + 1) = max(a(x), totals(MOD(x, LOOPCOUNT/10 + 1) + 1))\n              !$acc end atomic\n            END DO\n          !$acc end parallel\n        !$acc end data\n        DO x = 1, LOOPCOUNT\n          totals_comparison(MOD(x, LOOPCOUNT/10 + 1) + 1) = max(totals_comparison(MOD(x, LOOPCOUNT/10 + 1) + 1), a(x))\n        END DO\n        DO x = 1, LOOPCOUNT/10 + 1\n          IF (totals_comparison(x) .NE. totals(x)) THEN\n            errors = errors + 1\n            WRITE(*, *) totals_comparison(x)\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "construct-independent",
                            "atomic"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_update_max_x_expr.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:construct-independent,atomic,V:2.0-2.7\n      LOGICAL FUNCTION test1()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x, y !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT):: a !Data\n        REAL(8),DIMENSION(LOOPCOUNT/10 + 1):: totals, totals_comparison\n        INTEGER :: errors = 0\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(a)\n\n        totals = 0\n        totals_comparison = 0\n\n        !$acc data copyin(a(1:LOOPCOUNT)) copy(totals(1:(LOOPCOUNT/10 + 1)))\n          !$acc parallel\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              !$acc atomic update\n                totals(MOD(x, LOOPCOUNT/10 + 1) + 1) = max(totals(MOD(x, LOOPCOUNT/10 + 1) + 1), a(x))\n            END DO\n          !$acc end parallel\n        !$acc end data\n        DO x = 1, LOOPCOUNT\n          totals_comparison(MOD(x, LOOPCOUNT/10 + 1) + 1) = max(totals_comparison(MOD(x, LOOPCOUNT/10 + 1) + 1), a(x))\n        END DO\n        DO x = 1, LOOPCOUNT/10 + 1\n          IF (totals_comparison(x) .NE. totals(x)) THEN\n            errors = errors + 1\n            WRITE(*, *) totals_comparison(x)\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "construct-independent",
                            "atomic"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_update_max_x_expr_end.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:construct-independent,atomic,V:2.0-2.7\n      LOGICAL FUNCTION test1()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x, y !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT):: a !Data\n        REAL(8),DIMENSION(LOOPCOUNT/10 + 1):: totals, totals_comparison\n        INTEGER :: errors = 0\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(a)\n\n        totals = 0\n        totals_comparison = 0\n\n        !$acc data copyin(a(1:LOOPCOUNT)) copy(totals(1:(LOOPCOUNT/10 + 1)))\n          !$acc parallel\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              !$acc atomic update\n                totals(MOD(x, LOOPCOUNT/10 + 1) + 1) = max(totals(MOD(x, LOOPCOUNT/10 + 1) + 1), a(x))\n              !$acc end atomic\n            END DO\n          !$acc end parallel\n        !$acc end data\n        DO x = 1, LOOPCOUNT\n          totals_comparison(MOD(x, LOOPCOUNT/10 + 1) + 1) = max(totals_comparison(MOD(x, LOOPCOUNT/10 + 1) + 1), a(x))\n        END DO\n        DO x = 1, LOOPCOUNT/10 + 1\n          IF (totals_comparison(x) .NE. totals(x)) THEN\n            errors = errors + 1\n            WRITE(*, *) totals_comparison(x)\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "construct-independent",
                            "atomic"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_update_max_x_expr_list.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:construct-independent,atomic,V:2.0-2.7\n      LOGICAL FUNCTION test1()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x, y !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT):: a, b !Data\n        REAL(8),DIMENSION(LOOPCOUNT/10 + 1):: totals, totals_comparison\n        INTEGER :: errors = 0\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(a)\n        CALL RANDOM_NUMBER(b)\n\n        totals = 0\n        totals_comparison = 0\n\n        !$acc data copyin(a(1:LOOPCOUNT), b(1:LOOPCOUNT)) copy(totals(1:(LOOPCOUNT/10 + 1)))\n          !$acc parallel\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              !$acc atomic update\n                totals(MOD(x, LOOPCOUNT/10 + 1) + 1) = max(totals(MOD(x, LOOPCOUNT/10 + 1) + 1), a(x), b(x))\n            END DO\n          !$acc end parallel\n        !$acc end data\n        DO x = 1, LOOPCOUNT\n          totals_comparison(MOD(x, LOOPCOUNT/10 + 1) + 1) = max(totals_comparison(MOD(x, LOOPCOUNT/10 + 1) + 1), a(x), b(x))\n        END DO\n        DO x = 1, LOOPCOUNT/10 + 1\n          IF (totals_comparison(x) .NE. totals(x)) THEN\n            errors = errors + 1\n            WRITE(*, *) totals_comparison(x)\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "construct-independent",
                            "atomic"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_update_max_x_expr_list_end.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:construct-independent,atomic,V:2.0-2.7\n      LOGICAL FUNCTION test1()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x, y !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT):: a, b !Data\n        REAL(8),DIMENSION(LOOPCOUNT/10 + 1):: totals, totals_comparison\n        INTEGER :: errors = 0\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(a)\n        CALL RANDOM_NUMBER(b)\n\n        totals = 0\n        totals_comparison = 0\n\n        !$acc data copyin(a(1:LOOPCOUNT), b(1:LOOPCOUNT)) copy(totals(1:(LOOPCOUNT/10 + 1)))\n          !$acc parallel\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              !$acc atomic update\n                totals(MOD(x, LOOPCOUNT/10 + 1) + 1) = max(totals(MOD(x, LOOPCOUNT/10 + 1) + 1), a(x), b(x))\n              !$acc end atomic\n            END DO\n          !$acc end parallel\n        !$acc end data\n        DO x = 1, LOOPCOUNT\n          totals_comparison(MOD(x, LOOPCOUNT/10 + 1) + 1) = max(totals_comparison(MOD(x, LOOPCOUNT/10 + 1) + 1), a(x), b(x))\n        END DO\n        DO x = 1, LOOPCOUNT/10 + 1\n          IF (totals_comparison(x) .NE. totals(x)) THEN\n            errors = errors + 1\n            WRITE(*, *) totals_comparison(x)\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "construct-independent",
                            "atomic"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_update_min_expr_list_x.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:construct-independent,atomic,V:2.0-2.7\n      LOGICAL FUNCTION test1()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x, y !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT):: a, b !Data\n        REAL(8),DIMENSION(LOOPCOUNT/10 + 1):: totals, totals_comparison\n        INTEGER :: errors = 0\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(a)\n        CALL RANDOM_NUMBER(b)\n\n        totals = 1\n        totals_comparison = 1\n\n        !$acc data copyin(a(1:LOOPCOUNT), b(1:LOOPCOUNT)) copy(totals(1:(LOOPCOUNT/10 + 1)))\n          !$acc parallel\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              !$acc atomic update\n                totals(MOD(x, LOOPCOUNT/10 + 1) + 1) = min(a(x), b(x), totals(MOD(x, LOOPCOUNT/10 + 1) + 1))\n            END DO\n          !$acc end parallel\n        !$acc end data\n        DO x = 1, LOOPCOUNT\n          totals_comparison(MOD(x, LOOPCOUNT/10 + 1) + 1) = min(totals_comparison(MOD(x, LOOPCOUNT/10 + 1) + 1), a(x), b(x))\n        END DO\n        DO x = 1, LOOPCOUNT/10 + 1\n          IF (totals_comparison(x) .NE. totals(x)) THEN\n            errors = errors + 1\n            WRITE(*, *) totals_comparison(x)\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "construct-independent",
                            "atomic"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_update_min_expr_list_x_end.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:construct-independent,atomic,V:2.0-2.7\n      LOGICAL FUNCTION test1()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x, y !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT):: a, b !Data\n        REAL(8),DIMENSION(LOOPCOUNT/10 + 1):: totals, totals_comparison\n        INTEGER :: errors = 0\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(a)\n        CALL RANDOM_NUMBER(b)\n\n        totals = 1\n        totals_comparison = 1\n\n        !$acc data copyin(a(1:LOOPCOUNT), b(1:LOOPCOUNT)) copy(totals(1:(LOOPCOUNT/10 + 1)))\n          !$acc parallel\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              !$acc atomic update\n                totals(MOD(x, LOOPCOUNT/10 + 1) + 1) = min(a(x), b(x), totals(MOD(x, LOOPCOUNT/10 + 1) + 1))\n              !$acc end atomic\n            END DO\n          !$acc end parallel\n        !$acc end data\n        DO x = 1, LOOPCOUNT\n          totals_comparison(MOD(x, LOOPCOUNT/10 + 1) + 1) = min(totals_comparison(MOD(x, LOOPCOUNT/10 + 1) + 1), a(x), b(x))\n        END DO\n        DO x = 1, LOOPCOUNT/10 + 1\n          IF (totals_comparison(x) .NE. totals(x)) THEN\n            errors = errors + 1\n            WRITE(*, *) totals_comparison(x)\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "construct-independent",
                            "atomic"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_update_min_expr_x.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:construct-independent,atomic,V:2.0-2.7\n      LOGICAL FUNCTION test1()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x, y !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT):: a !Data\n        REAL(8),DIMENSION(LOOPCOUNT/10 + 1):: totals, totals_comparison\n        INTEGER :: errors = 0\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(a)\n\n        totals = 1\n        totals_comparison = 1\n\n        !$acc data copyin(a(1:LOOPCOUNT)) copy(totals(1:(LOOPCOUNT/10 + 1)))\n          !$acc parallel\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              !$acc atomic update\n                totals(MOD(x, LOOPCOUNT/10 + 1) + 1) = min(a(x), totals(MOD(x, LOOPCOUNT/10 + 1) + 1))\n            END DO\n          !$acc end parallel\n        !$acc end data\n        DO x = 1, LOOPCOUNT\n          totals_comparison(MOD(x, LOOPCOUNT/10 + 1) + 1) = min(totals_comparison(MOD(x, LOOPCOUNT/10 + 1) + 1), a(x))\n        END DO\n        DO x = 1, LOOPCOUNT/10 + 1\n          IF (totals_comparison(x) .NE. totals(x)) THEN\n            errors = errors + 1\n            WRITE(*, *) totals_comparison(x)\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "construct-independent",
                            "atomic"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_update_min_expr_x_end.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:construct-independent,atomic,V:2.0-2.7\n      LOGICAL FUNCTION test1()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x, y !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT):: a !Data\n        REAL(8),DIMENSION(LOOPCOUNT/10 + 1):: totals, totals_comparison\n        INTEGER :: errors = 0\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(a)\n\n        totals = 1\n        totals_comparison = 1\n\n        !$acc data copyin(a(1:LOOPCOUNT)) copy(totals(1:(LOOPCOUNT/10 + 1)))\n          !$acc parallel\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              !$acc atomic update\n                totals(MOD(x, LOOPCOUNT/10 + 1) + 1) = min(a(x), totals(MOD(x, LOOPCOUNT/10 + 1) + 1))\n              !$acc end atomic\n            END DO\n          !$acc end parallel\n        !$acc end data\n        DO x = 1, LOOPCOUNT\n          totals_comparison(MOD(x, LOOPCOUNT/10 + 1) + 1) = min(totals_comparison(MOD(x, LOOPCOUNT/10 + 1) + 1), a(x))\n        END DO\n        DO x = 1, LOOPCOUNT/10 + 1\n          IF (totals_comparison(x) .NE. totals(x)) THEN\n            errors = errors + 1\n            WRITE(*, *) totals_comparison(x)\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "construct-independent",
                            "atomic"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_update_min_x_expr.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:construct-independent,atomic,V:2.0-2.7\n      LOGICAL FUNCTION test1()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x, y !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT):: a !Data\n        REAL(8),DIMENSION(LOOPCOUNT/10 + 1):: totals, totals_comparison\n        INTEGER :: errors = 0\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(a)\n\n        totals = 0\n        totals_comparison = 0\n\n        !$acc data copyin(a(1:LOOPCOUNT)) copy(totals(1:(LOOPCOUNT/10 + 1)))\n          !$acc parallel\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              !$acc atomic update\n                totals(MOD(x, LOOPCOUNT/10 + 1) + 1) = min(totals(MOD(x, LOOPCOUNT/10 + 1) + 1), a(x))\n            END DO\n          !$acc end parallel\n        !$acc end data\n        DO x = 1, LOOPCOUNT\n          totals_comparison(MOD(x, LOOPCOUNT/10 + 1) + 1) = min(totals_comparison(MOD(x, LOOPCOUNT/10 + 1) + 1), a(x))\n        END DO\n        DO x = 1, LOOPCOUNT/10 + 1\n          IF (totals_comparison(x) .NE. totals(x)) THEN\n            errors = errors + 1\n            WRITE(*, *) totals_comparison(x)\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "construct-independent",
                            "atomic"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_update_min_x_expr_end.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:construct-independent,atomic,V:2.0-2.7\n      LOGICAL FUNCTION test1()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x, y !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT):: a !Data\n        REAL(8),DIMENSION(LOOPCOUNT/10 + 1):: totals, totals_comparison\n        INTEGER :: errors = 0\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(a)\n\n        totals = 0\n        totals_comparison = 0\n\n        !$acc data copyin(a(1:LOOPCOUNT)) copy(totals(1:(LOOPCOUNT/10 + 1)))\n          !$acc parallel\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              !$acc atomic update\n                totals(MOD(x, LOOPCOUNT/10 + 1) + 1) = min(totals(MOD(x, LOOPCOUNT/10 + 1) + 1), a(x))\n              !$acc end atomic\n            END DO\n          !$acc end parallel\n        !$acc end data\n        DO x = 1, LOOPCOUNT\n          totals_comparison(MOD(x, LOOPCOUNT/10 + 1) + 1) = min(totals_comparison(MOD(x, LOOPCOUNT/10 + 1) + 1), a(x))\n        END DO\n        DO x = 1, LOOPCOUNT/10 + 1\n          IF (totals_comparison(x) .NE. totals(x)) THEN\n            errors = errors + 1\n            WRITE(*, *) totals_comparison(x)\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "construct-independent",
                            "atomic"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_update_min_x_expr_list.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:construct-independent,atomic,V:2.0-2.7\n      LOGICAL FUNCTION test1()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x, y !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT):: a, b !Data\n        REAL(8),DIMENSION(LOOPCOUNT/10 + 1):: totals, totals_comparison\n        INTEGER :: errors = 0\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(a)\n        CALL RANDOM_NUMBER(b)\n\n        totals = 1\n        totals_comparison = 1\n\n        !$acc data copyin(a(1:LOOPCOUNT), b(1:LOOPCOUNT)) copy(totals(1:(LOOPCOUNT/10 + 1)))\n          !$acc parallel\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              !$acc atomic update\n                totals(MOD(x, LOOPCOUNT/10 + 1) + 1) = min(totals(MOD(x, LOOPCOUNT/10 + 1) + 1), a(x), b(x))\n            END DO\n          !$acc end parallel\n        !$acc end data\n        DO x = 1, LOOPCOUNT\n          totals_comparison(MOD(x, LOOPCOUNT/10 + 1) + 1) = min(totals_comparison(MOD(x, LOOPCOUNT/10 + 1) + 1), a(x), b(x))\n        END DO\n        DO x = 1, LOOPCOUNT/10 + 1\n          IF (totals_comparison(x) .NE. totals(x)) THEN\n            errors = errors + 1\n            WRITE(*, *) totals_comparison(x)\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "construct-independent",
                            "atomic"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_update_min_x_expr_list_end.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:construct-independent,atomic,V:2.0-2.7\n      LOGICAL FUNCTION test1()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x, y !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT):: a, b !Data\n        REAL(8),DIMENSION(LOOPCOUNT/10 + 1):: totals, totals_comparison\n        INTEGER :: errors = 0\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(a)\n        CALL RANDOM_NUMBER(b)\n\n        totals = 1\n        totals_comparison = 1\n\n        !$acc data copyin(a(1:LOOPCOUNT), b(1:LOOPCOUNT)) copy(totals(1:(LOOPCOUNT/10 + 1)))\n          !$acc parallel\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              !$acc atomic update\n                totals(MOD(x, LOOPCOUNT/10 + 1) + 1) = min(totals(MOD(x, LOOPCOUNT/10 + 1) + 1), a(x), b(x))\n              !$acc end atomic\n            END DO\n          !$acc end parallel\n        !$acc end data\n        DO x = 1, LOOPCOUNT\n          totals_comparison(MOD(x, LOOPCOUNT/10 + 1) + 1) = min(totals_comparison(MOD(x, LOOPCOUNT/10 + 1) + 1), a(x), b(x))\n        END DO\n        DO x = 1, LOOPCOUNT/10 + 1\n          IF (totals_comparison(x) .NE. totals(x)) THEN\n            errors = errors + 1\n            WRITE(*, *) totals_comparison(x)\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "construct-independent",
                            "atomic"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_update_minus_equals.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:atomic,construct-independent,V:2.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t *a = (real_t *)malloc(n * sizeof(real_t));\n    real_t *b = (real_t *)malloc(n * sizeof(real_t));\n    real_t *totals = (real_t *)malloc(10 * sizeof(real_t));\n    real_t *totals_host = (real_t *)malloc(10 * sizeof(real_t));\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n    }\n    for (int x = 0; x < 10; ++x){\n        totals[x] = 0;\n    }\n\n    #pragma acc data copyin(a[0:n], b[0:n]) copy(totals[0:10])\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                #pragma acc atomic update\n                    totals[x%10] -= (a[x] + b[x]);\n            }\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        totals_host[x%10] = totals_host[x%10] - (a[x] + b[x]);\n    }\n    for (int x = 0; x < 10; ++x){\n        if (fabs(totals_host[x] - totals[x]) > PRECISION){\n            err += 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "atomic",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_update_multiply_equals.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:atomic,construct-independent,V:2.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t *a = (real_t *)malloc(n * sizeof(real_t));\n    real_t *b = (real_t *)malloc(n * sizeof(real_t));\n    real_t *totals = (real_t *)malloc((n/10 + 1) * sizeof(real_t));\n    real_t *totals_comparison = (real_t *)malloc((n/10 + 1) * sizeof(real_t));\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n    }\n    for (int x = 0; x < n/10 + 1; ++x){\n        totals[x] = 1;\n        totals_comparison[x] = 1;\n    }\n\n    #pragma acc data copyin(a[0:n], b[0:n]) copy(totals[0:n/10 + 1])\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                #pragma acc atomic update\n                    totals[x%(n/10 + 1)] *= a[x] + b[x];\n            }\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        totals_comparison[x%(n/10 + 1)] *= a[x] + b[x];\n    }\n    for (int x = 0; x < 10; ++x){\n        if (fabs(totals_comparison[x] - totals[x]) > PRECISION * totals_comparison[x]){\n            err += 1;\n            break;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "atomic",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_update_plus_equals.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:atomic,construct-independent,V:2.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t *a = (real_t *)malloc(n * sizeof(real_t));\n    real_t *b = (real_t *)malloc(n * sizeof(real_t));\n    real_t *totals = (real_t *)malloc((n/10 + 1) * sizeof(real_t));\n    real_t *totals_comparison = (real_t *)malloc((n/10 + 1) * sizeof(real_t));\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n    }\n    for (int x = 0; x < n/10 + 1; ++x){\n        totals[x] = 0;\n        totals_comparison[x] = 0;\n    }\n\n    #pragma acc data copyin(a[0:n], b[0:n]) copy(totals[0:n/10 + 1])\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                #pragma acc atomic update\n                    totals[x%(n/10 + 1)] += a[x] * b[x];\n            }\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        totals_comparison[x%(n/10 + 1)] += a[x] * b[x];\n    }\n    for (int x = 0; x < n/10 + 1; ++x){\n        if (fabs(totals_comparison[x] - totals[x]) > (n/10 + 1) * PRECISION){\n            err += 1;\n            break;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "atomic",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_update_postdecrement.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:atomic,construct-independent,V:2.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t *a = (real_t *)malloc(n * sizeof(real_t));\n    real_t *b = (real_t *)malloc(n * sizeof(real_t));\n    int *distribution = (int *)malloc(10 * sizeof(int));\n    int *distribution_comparison = (int *)malloc(10 * sizeof(int));\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n    }\n    for (int x = 0; x < 10; ++x){\n        distribution[x] = 0;\n        distribution_comparison[x] = 0;\n    }\n\n    #pragma acc data copyin(a[0:n], b[0:n]) copy(distribution[0:10])\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                #pragma acc atomic update\n                    distribution[(int) (a[x] * b[x] / 10)]--;\n            }\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        distribution_comparison[(int) (a[x]*b[x]/10)]--;\n    }\n    for (int x = 0; x < 10; ++x){\n        if (distribution_comparison[x] != distribution[x]){\n            err += 1;\n            break;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "atomic",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_update_postincrement.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:atomic,construct-independent,V:2.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t *a = (real_t *)malloc(n * sizeof(real_t));\n    real_t *b = (real_t *)malloc(n * sizeof(real_t));\n    int *distribution = (int *)malloc(10 * sizeof(int));\n    int *distribution_comparison = (int *)malloc(10 * sizeof(int));\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n    }\n    for (int x = 0; x < 10; ++x){\n        distribution[x] = 0;\n        distribution_comparison[x] = 0;\n    }\n\n    #pragma acc data copyin(a[0:n], b[0:n]) copy(distribution[0:10])\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                #pragma acc loop\n                for (int y = 0; y < n; ++y){\n                    #pragma acc atomic update\n                        distribution[(int) (a[x]*b[y]/10)]++;\n                }\n            }\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        for (int y = 0; y < n; ++y){\n            distribution_comparison[(int) (a[x]*b[y]/10)]++;\n        }\n    }\n    for (int x = 0; x < 10; ++x){\n        if (distribution_comparison[x] != distribution[x]){\n            err += 1;\n            break;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "atomic",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_update_predecrement.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:atomic,construct-independent,V:2.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t *a = (real_t *)malloc(n * sizeof(real_t));\n    real_t *b = (real_t *)malloc(n * sizeof(real_t));\n    int *distribution = (int *)malloc(10 * sizeof(int));\n    int *distribution_comparison = (int *)malloc(10 * sizeof(int));\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n    }\n    for (int x = 0; x < 10; ++x){\n        distribution[x] = 0;\n        distribution_comparison[x] = 0;\n    }\n\n    #pragma acc data copyin(a[0:n], b[0:n]) copy(distribution[0:10])\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                #pragma acc loop\n                for (int y = 0; y < n; ++y){\n                    #pragma acc atomic update\n                        --distribution[(int) (a[x]*b[y]/10)];\n                }\n            }\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        for (int y = 0; y < n; ++y){\n            distribution_comparison[(int) (a[x]*b[y]/10)]--;\n        }\n    }\n    for (int x = 0; x < 10; ++x){\n        if (distribution_comparison[x] != distribution[x]){\n            err += 1;\n            break;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "atomic",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_update_preincrement.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:atomic,construct-independent,V:2.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t *a = (real_t *)malloc(n * sizeof(real_t));\n    real_t *b = (real_t *)malloc(n * sizeof(real_t));\n    int *distribution = (int *)malloc(10 * sizeof(int));\n    int *distribution_comparison = (int *)malloc(10 * sizeof(int));\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n    }\n    for (int x = 0; x < 10; ++x){\n        distribution[x] = 0;\n        distribution_comparison[x] = 0;\n    }\n\n    #pragma acc data copyin(a[0:n], b[0:n]) copy(distribution[0:10])\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                #pragma acc loop\n                for (int y = 0; y < n; ++y){\n                    #pragma acc atomic update\n                        ++distribution[(int) (a[x]*b[y]/10)];\n                }\n            }\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        for (int y = 0; y < n; ++y){\n            distribution_comparison[(int) (a[x]*b[y]/10)]++;\n        }\n    }\n    for (int x = 0; x < 10; ++x){\n        if (distribution_comparison[x] != distribution[x]){\n            err += 1;\n            break;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "atomic",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_update_rshift_equals.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:atomic,construct-independent,V:2.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    unsigned int *a = (unsigned int *)malloc(n * sizeof(int));\n    unsigned int *b = (unsigned int *)malloc(n * sizeof(int));\n\n    for (int x = 0; x < n; ++x){\n        a[x] = 1<<7;\n        for (int y = 0; y < 7; ++y){\n            if ((rand()/(unsigned int) (RAND_MAX)) > .5){\n                b[x] += 1<<y;\n            }\n        }\n    }\n\n    #pragma acc data copyin(b[0:n]) copy(a[0:n])\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                #pragma acc loop\n                for (int y = 0; y < 7; ++y){\n                    if ((b[x]>>y)%2 == 1){\n                        #pragma acc atomic update\n                            a[x] >>= 1;\n                    }\n                }\n            }\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        for (int y = 0; y < 7; ++y){\n            if ((b[x]>>y)%2 == 1){\n                a[x] <<= 1;\n            }\n        }\n        if (a[x] != 1<<7){\n            err += 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "atomic",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_update_x_and_expr.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:construct-independent,atomic,V:2.0-2.7\n      LOGICAL FUNCTION test1()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x, y !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT, 10):: randoms\n        LOGICAL,DIMENSION(LOOPCOUNT, 10):: a !Data\n        LOGICAL,DIMENSION(LOOPCOUNT):: totals, totals_comparison\n        INTEGER :: errors = 0\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(randoms)\n        DO x = 1, LOOPCOUNT\n          DO y = 1, 10\n            IF (randoms(x, y) < .933) THEN\n              a(x, y) = .TRUE.\n            ELSE\n              a(x, y) = .FALSE.\n            END IF\n          END DO\n        END DO\n\n        totals = .FALSE.\n        totals_comparison = .FALSE.\n\n        !$acc data copyin(a(1:LOOPCOUNT,1:10)) copy(totals(1:LOOPCOUNT))\n          !$acc parallel\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              DO y = 1, 10\n                !$acc atomic update\n                  totals(x) = totals(x) .AND. a(x, y)\n              END DO\n            END DO\n          !$acc end parallel\n        !$acc end data\n\n        DO x = 1, LOOPCOUNT\n          DO y = 1, 10\n            totals_comparison(x) = totals_comparison(x) .AND. a(x, y)\n          END DO\n        END DO\n\n        DO x = 1, LOOPCOUNT\n          IF (totals_comparison(x) .NEQV. totals(x)) THEN\n            errors = errors + 1\n            WRITE(*, *) totals_comparison(x)\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "construct-independent",
                            "atomic"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_update_x_and_expr_end.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:construct-independent,atomic,V:2.0-2.7\n      LOGICAL FUNCTION test1()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x, y !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT, 10):: randoms\n        LOGICAL,DIMENSION(LOOPCOUNT, 10):: a !Data\n        LOGICAL,DIMENSION(LOOPCOUNT):: totals, totals_comparison\n        INTEGER :: errors = 0\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(randoms)\n        DO x = 1, LOOPCOUNT\n          DO y = 1, 10\n            IF (randoms(x, y) < .933) THEN\n              a(x, y) = .TRUE.\n            ELSE\n              a(x, y) = .FALSE.\n            END IF\n          END DO\n        END DO\n\n        totals = .FALSE.\n        totals_comparison = .FALSE.\n\n        !$acc data copyin(a(1:LOOPCOUNT,1:10)) copy(totals(1:LOOPCOUNT))\n          !$acc parallel\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              DO y = 1, 10\n                !$acc atomic update\n                  totals(x) = totals(x) .AND. a(x, y)\n                !$acc end atomic\n              END DO\n            END DO\n          !$acc end parallel\n        !$acc end data\n\n        DO x = 1, LOOPCOUNT\n          DO y = 1, 10\n            totals_comparison(x) = totals_comparison(x) .AND. a(x, y)\n          END DO\n        END DO\n\n        DO x = 1, LOOPCOUNT\n          IF (totals_comparison(x) .NEQV. totals(x)) THEN\n            errors = errors + 1\n            WRITE(*, *) totals_comparison(x)\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "construct-independent",
                            "atomic"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_update_x_bitand_expr.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:atomic,construct-independent,V:2.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    int  *a = (int *)malloc(n * sizeof(int));\n    int *totals = (int *)malloc((n/10 + 1) * sizeof(int));\n    int *totals_comparison = (int *)malloc((n/10 + 1) * sizeof(int));\n\n    for (int x = 0; x < n; ++x){\n        for (int y = 0; y < 8; ++y){\n            if (rand()/(real_t)(RAND_MAX) < .933){ //.933 gets close to a 50/50 distribution for a collescence of 10 values\n                a[x] += 1<<y;\n            }\n        }\n    }\n    for (int x = 0; x < n/10 + 1; ++x){\n        for (int y = 0; y < 8; ++y){\n            totals[x] +=  1<<y;\n            totals_comparison[x] += 1<<y;\n        }\n    }\n\n    #pragma acc data copyin(a[0:n]) copy(totals[0:n/10 + 1])\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                #pragma acc atomic update\n                    totals[x%(n/10 + 1)] = totals[x%(n/10 + 1)] & a[x];\n            }\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        totals_comparison[x%(n/10 + 1)] &= a[x];\n    }\n    for (int x = 0; x < 10; ++x){\n        if (fabs(totals_comparison[x] - totals[x]) > PRECISION){\n            err += 1;\n            break;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "atomic",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_update_x_bitor_expr.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:atomic,construct-independent,V:2.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    int  *a = (int *)malloc(n * sizeof(int));\n    int *totals = (int *)malloc((n/10 + 1) * sizeof(int));\n    int *totals_comparison = (int *)malloc((n/10 + 1) * sizeof(int));\n\n    for (int x = 0; x < n; ++x){\n        for (int y = 0; y < 8; ++y){\n            if (rand()/(real_t)(RAND_MAX) > .933){ //.933 gets close to a 50/50 distribution for a collescence of 10 values\n                a[x] += 1<<y;\n            }\n        }\n    }\n    for (int x = 0; x < n/10 + 1; ++x){\n        totals[x] = 0;\n\n    }\n\n    #pragma acc data copyin(a[0:n]) copy(totals[0:n/10 + 1])\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                #pragma acc atomic update\n                    totals[x%(n/10 + 1)] = totals[x%(n/10 + 1)] | a[x];\n            }\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        totals_comparison[x%(n/10 + 1)] |= a[x];\n    }\n    for (int x = 0; x < 10; ++x){\n        if (fabs(totals_comparison[x] - totals[x]) > PRECISION){\n            err += 1;\n            break;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "atomic",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_update_x_bitxor_expr.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:atomic,construct-independent,V:2.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    int  *a = (int *)malloc(n * sizeof(int));\n    int *totals = (int *)malloc((n/10 + 1) * sizeof(int));\n    int *totals_comparison = (int *)malloc((n/10 + 1) * sizeof(int));\n\n    for (int x = 0; x < n; ++x){\n        for (int y = 0; y < 8; ++y){\n            if (rand()/(real_t)(RAND_MAX) > .5){\n                a[x] += 1<<y;\n            }\n        }\n    }\n    for (int x = 0; x < n/10 + 1; ++x){\n        totals[x] = 0;\n        totals_comparison[x] = 0;\n    }\n\n    #pragma acc data copyin(a[0:n]) copy(totals[0:n/10 + 1])\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                #pragma acc atomic update\n                    totals[x%(n/10 + 1)] =  totals[x%(n/10 + 1)] ^ a[x];\n            }\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        totals_comparison[x%(n/10 + 1)] ^= a[x];\n    }\n    for (int x = 0; x < n/10 + 1; ++x){\n        if (fabs(totals_comparison[x] - totals[x]) > PRECISION){\n            err += 1;\n            break;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "atomic",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_update_x_divided_expr.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:construct-independent,atomic,V:2.0-2.7\n      LOGICAL FUNCTION test1()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x, y !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT, 10):: a !Data\n        REAL(8),DIMENSION(LOOPCOUNT):: totals, totals_comparison\n        INTEGER :: errors = 0\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(a)\n\n        totals = 1\n        totals_comparison = 1\n\n        !$acc data copyin(a(1:LOOPCOUNT, 1:10)) copy(totals(1:LOOPCOUNT))\n          !$acc parallel\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              DO y = 1, 10\n                !$acc atomic update\n                  totals(x) = totals(x) / a(x, y)\n              END DO\n            END DO\n          !$acc end parallel\n        !$acc end data\n        DO x = 1, LOOPCOUNT\n          DO y = 1, 10\n            totals_comparison(x) = totals_comparison(x) / a(x, y)\n          END DO\n        END DO\n\n        DO x = 1, LOOPCOUNT\n          IF (totals_comparison(x) .NE. totals(x)) THEN\n            errors = errors + 1\n            WRITE(*, *) totals_comparison(x)\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "construct-independent",
                            "atomic"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_update_x_divided_expr.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:atomic,construct-independent,V:2.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t *a = (real_t *)malloc(n * sizeof(real_t));\n    real_t *b = (real_t *)malloc(n * sizeof(real_t));\n    real_t *totals = (real_t *)malloc((n/10 + 1) * sizeof(real_t));\n    real_t *totals_comparison = (real_t *)malloc((n/10 + 1) * sizeof(real_t));\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n    }\n    for (int x = 0; x < n/10 + 1; ++x){\n        totals[x] = 1;\n        totals_comparison[x] = 1;\n    }\n\n    #pragma acc data copyin(a[0:n], b[0:n]) copy(totals[0:n/10 + 1])\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                #pragma acc atomic update\n                    totals[x%(n/10 + 1)] = totals[x%(n/10 + 1)] / (a[x] + b[x]);\n            }\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        totals_comparison[x%(n/10 + 1)] /= a[x] + b[x];\n    }\n    for (int x = 0; x < 10; ++x){\n        if (fabs(totals_comparison[x] - totals[x]) > PRECISION){\n            err += 1;\n            break;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "atomic",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_update_x_divided_expr_end.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:construct-independent,atomic,V:2.0-2.7\n      LOGICAL FUNCTION test1()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x, y !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT, 10):: a !Data\n        REAL(8),DIMENSION(LOOPCOUNT):: totals, totals_comparison\n        INTEGER :: errors = 0\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(a)\n\n        totals = 1\n        totals_comparison = 1\n\n        !$acc data copyin(a(1:LOOPCOUNT, 1:10)) copy(totals(1:LOOPCOUNT))\n          !$acc parallel\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              DO y = 1, 10\n                !$acc atomic update\n                  totals(x) = totals(x) / a(x, y)\n                !$acc end atomic\n              END DO\n            END DO\n          !$acc end parallel\n        !$acc end data\n        DO x = 1, LOOPCOUNT\n          DO y = 1, 10\n            totals_comparison(x) = totals_comparison(x) / a(x, y)\n          END DO\n        END DO\n\n        DO x = 1, LOOPCOUNT\n          IF (totals_comparison(x) .NE. totals(x)) THEN\n            errors = errors + 1\n            WRITE(*, *) totals_comparison(x)\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "construct-independent",
                            "atomic"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_update_x_eqv_expr.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:construct-independent,atomic,V:2.0-2.7\n      LOGICAL FUNCTION test1()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x, y !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT, 10):: randoms\n        LOGICAL,DIMENSION(LOOPCOUNT, 10):: a !Data\n        LOGICAL,DIMENSION(LOOPCOUNT):: totals, totals_comparison\n        INTEGER :: errors = 0\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(randoms)\n        DO x = 1, LOOPCOUNT\n          DO y = 1, 10\n            IF (randoms(x, y) > .5) THEN\n              a(x, y) = .TRUE.\n            ELSE\n              a(x, y) = .FALSE.\n            END IF\n          END DO\n        END DO\n\n        totals = .FALSE.\n        totals_comparison = .FALSE.\n\n        !$acc data copyin(a(1:LOOPCOUNT,1:10)) copy(totals(1:LOOPCOUNT))\n          !$acc parallel\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              DO y = 1, 10\n                !$acc atomic update\n                  totals(x) = totals(x) .EQV. a(x, y)\n              END DO\n            END DO\n          !$acc end parallel\n        !$acc end data\n\n        DO x = 1, LOOPCOUNT\n          DO y = 1, 10\n            totals_comparison(x) = totals_comparison(x) .EQV. a(x, y)\n          END DO\n        END DO\n\n        DO x = 1, LOOPCOUNT\n          IF (totals_comparison(x) .NEQV. totals(x)) THEN\n            errors = errors + 1\n            WRITE(*, *) totals_comparison(x)\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "construct-independent",
                            "atomic"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_update_x_eqv_expr_end.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:construct-independent,atomic,V:2.0-2.7\n      LOGICAL FUNCTION test1()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x, y !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT, 10):: randoms\n        LOGICAL,DIMENSION(LOOPCOUNT, 10):: a !Data\n        LOGICAL,DIMENSION(LOOPCOUNT):: totals, totals_comparison\n        INTEGER :: errors = 0\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(randoms)\n        DO x = 1, LOOPCOUNT\n          DO y = 1, 10\n            IF (randoms(x, y) > .5) THEN\n              a(x, y) = .TRUE.\n            ELSE\n              a(x, y) = .FALSE.\n            END IF\n          END DO\n        END DO\n\n        totals = .FALSE.\n        totals_comparison = .FALSE.\n\n        !$acc data copyin(a(1:LOOPCOUNT,1:10)) copy(totals(1:LOOPCOUNT))\n          !$acc parallel\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              DO y = 1, 10\n                !$acc atomic update\n                  totals(x) = totals(x) .EQV. a(x, y)\n                !$acc end atomic\n              END DO\n            END DO\n          !$acc end parallel\n        !$acc end data\n\n        DO x = 1, LOOPCOUNT\n          DO y = 1, 10\n            totals_comparison(x) = totals_comparison(x) .EQV. a(x, y)\n          END DO\n        END DO\n\n        DO x = 1, LOOPCOUNT\n          IF (totals_comparison(x) .NEQV. totals(x)) THEN\n            errors = errors + 1\n            WRITE(*, *) totals_comparison(x)\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "construct-independent",
                            "atomic"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_update_x_lshift_expr.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:atomic,construct-independent,V:2.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    unsigned int *a = (unsigned int *)malloc(n * sizeof(int));\n    unsigned int *b = (unsigned int *)malloc(n * sizeof(int));\n\n    for (int x = 0; x < n; ++x){\n        a[x] = 1;\n        for (int y = 0; y < 7; ++y){\n            if ((rand()/(unsigned int) (RAND_MAX)) > .5){\n                b[x] += 1<<y;\n            }\n        }\n    }\n\n    #pragma acc data copyin(b[0:n]) copy(a[0:n])\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                #pragma acc loop\n                for (int y = 0; y < 7; ++y){\n                    if ((b[x]>>y)%2 == 1){\n                        #pragma acc atomic update\n                            a[x] = a[x] << 1;\n                    }\n                }\n            }\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        for (int y = 0; y < 7; ++y){\n            if ((b[x]>>y)%2 == 1){\n                a[x] >>= 1;\n            }\n        }\n        if (a[x] != 1){\n            err += 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "atomic",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_update_x_minus_expr.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:construct-independent,atomic,V:2.0-2.7\n      LOGICAL FUNCTION test1()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x, y !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT, 10):: a !Data\n        REAL(8),DIMENSION(LOOPCOUNT):: totals, totals_comparison\n        INTEGER :: errors = 0\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(a)\n\n        totals = 0\n        totals_comparison = 0\n\n        !$acc data copyin(a(1:LOOPCOUNT, 1:10)) copy(totals(1:LOOPCOUNT))\n          !$acc parallel\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              DO y = 1, 10\n                !$acc atomic update\n                  totals(x) = totals(x) - a(x, y)\n              END DO\n            END DO\n          !$acc end parallel\n        !$acc end data\n        DO x = 1, LOOPCOUNT\n          DO y = 1, 10\n            totals_comparison(x) = totals_comparison(x) - a(x, y)\n          END DO\n        END DO\n\n        DO x = 1, LOOPCOUNT\n          IF (totals_comparison(x) .NE. totals(x)) THEN\n            errors = errors + 1\n            WRITE(*, *) totals_comparison(x)\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "construct-independent",
                            "atomic"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_update_x_minus_expr.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:atomic,construct-independent,V:2.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t *a = (real_t *)malloc(n * sizeof(real_t));\n    real_t *b = (real_t *)malloc(n * sizeof(real_t));\n    real_t *totals = (real_t *)malloc(10 * sizeof(real_t));\n    real_t *totals_host = (real_t *)malloc(10 * sizeof(real_t));\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n    }\n    for (int x = 0; x < 10; ++x){\n        totals[x] = 0;\n    }\n\n    #pragma acc data copyin(a[0:n], b[0:n]) copy(totals[0:10])\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                #pragma acc atomic update\n                    totals[x%10] = totals[x%10] - (a[x] + b[x]);\n            }\n        }\n    }\n\n\n    for (int x = 0; x < n; ++x){\n        totals_host[x%10] = totals_host[x%10] - (a[x] + b[x]);\n    }\n    for (int x = 0; x < 10; ++x){\n        if (fabs(totals_host[x] - totals[x]) > PRECISION){\n            err += 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "atomic",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_update_x_minus_expr_end.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:construct-independent,atomic,V:2.0-2.7\n      LOGICAL FUNCTION test1()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x, y !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT, 10):: a !Data\n        REAL(8),DIMENSION(LOOPCOUNT):: totals, totals_comparison\n        INTEGER :: errors = 0\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(a)\n\n        totals = 0\n        totals_comparison = 0\n\n        !$acc data copyin(a(1:LOOPCOUNT, 1:10)) copy(totals(1:LOOPCOUNT))\n          !$acc parallel\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              DO y = 1, 10\n                !$acc atomic update\n                  totals(x) = totals(x) - a(x, y)\n                !$acc end atomic\n              END DO\n            END DO\n          !$acc end parallel\n        !$acc end data\n        DO x = 1, LOOPCOUNT\n          DO y = 1, 10\n            totals_comparison(x) = totals_comparison(x) - a(x, y)\n          END DO\n        END DO\n\n        DO x = 1, LOOPCOUNT\n          IF (totals_comparison(x) .NE. totals(x)) THEN\n            errors = errors + 1\n            WRITE(*, *) totals_comparison(x)\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "construct-independent",
                            "atomic"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_update_x_multiply_expr.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:atomic,construct-independent,V:2.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t *a = (real_t *)malloc(n * sizeof(real_t));\n    real_t *b = (real_t *)malloc(n * sizeof(real_t));\n    real_t *totals = (real_t *)malloc((n/10 + 1) * sizeof(real_t));\n    real_t *totals_comparison = (real_t *)malloc((n/10 + 1) * sizeof(real_t));\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n    }\n    for (int x = 0; x < n/10 + 1; ++x){\n        totals[x] = 1;\n        totals_comparison[x] = 1;\n    }\n\n    #pragma acc data copyin(a[0:n], b[0:n]) copy(totals[0:n/10 + 1])\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                #pragma acc atomic update\n                    totals[x%(n/10 + 1)] = totals[x%(n/10 + 1)] * (a[x] + b[x]);\n            }\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        totals_comparison[x%(n/10 + 1)] *= a[x] + b[x];\n    }\n    for (int x = 0; x < 10; ++x){\n        if (fabs(totals_comparison[x] - totals[x]) > PRECISION * totals_comparison[x]){\n            err += 1;\n            break;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "atomic",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_update_x_neqv_expr.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:construct-independent,atomic,V:2.0-2.7\n      LOGICAL FUNCTION test1()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x, y !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT, 10):: randoms\n        LOGICAL,DIMENSION(LOOPCOUNT, 10):: a !Data\n        LOGICAL,DIMENSION(LOOPCOUNT):: totals, totals_comparison\n        INTEGER :: errors = 0\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(randoms)\n        DO x = 1, LOOPCOUNT\n          DO y = 1, 10\n            IF (randoms(x, y) > .5) THEN\n              a(x, y) = .TRUE.\n            ELSE\n              a(x, y) = .FALSE.\n            END IF\n          END DO\n        END DO\n\n        totals = .FALSE.\n        totals_comparison = .FALSE.\n\n        !$acc data copyin(a(1:LOOPCOUNT,1:10)) copy(totals(1:LOOPCOUNT))\n          !$acc parallel\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              DO y = 1, 10\n                !$acc atomic update\n                  totals(x) = totals(x) .NEQV. a(x, y)\n              END DO\n            END DO\n          !$acc end parallel\n        !$acc end data\n\n        DO x = 1, LOOPCOUNT\n          DO y = 1, 10\n            totals_comparison(x) = totals_comparison(x) .NEQV. a(x, y)\n          END DO\n        END DO\n\n        DO x = 1, LOOPCOUNT\n          IF (totals_comparison(x) .NEQV. totals(x)) THEN\n            errors = errors + 1\n            WRITE(*, *) totals_comparison(x)\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "construct-independent",
                            "atomic"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_update_x_neqv_expr_end.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:construct-independent,atomic,V:2.0-2.7\n      LOGICAL FUNCTION test1()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x, y !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT, 10):: randoms\n        LOGICAL,DIMENSION(LOOPCOUNT, 10):: a !Data\n        LOGICAL,DIMENSION(LOOPCOUNT):: totals, totals_comparison\n        INTEGER :: errors = 0\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(randoms)\n        DO x = 1, LOOPCOUNT\n          DO y = 1, 10\n            IF (randoms(x, y) > .5) THEN\n              a(x, y) = .TRUE.\n            ELSE\n              a(x, y) = .FALSE.\n            END IF\n          END DO\n        END DO\n\n        totals = .FALSE.\n        totals_comparison = .FALSE.\n\n        !$acc data copyin(a(1:LOOPCOUNT,1:10)) copy(totals(1:LOOPCOUNT))\n          !$acc parallel\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              DO y = 1, 10\n                !$acc atomic update\n                  totals(x) = totals(x) .NEQV. a(x, y)\n                !$acc end atomic\n              END DO\n            END DO\n          !$acc end parallel\n        !$acc end data\n\n        DO x = 1, LOOPCOUNT\n          DO y = 1, 10\n            totals_comparison(x) = totals_comparison(x) .NEQV. a(x, y)\n          END DO\n        END DO\n\n        DO x = 1, LOOPCOUNT\n          IF (totals_comparison(x) .NEQV. totals(x)) THEN\n            errors = errors + 1\n            WRITE(*, *) totals_comparison(x)\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "construct-independent",
                            "atomic"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_update_x_or_expr.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:construct-independent,atomic,V:2.0-2.7\n      LOGICAL FUNCTION test1()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x, y !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT, 10):: randoms\n        LOGICAL,DIMENSION(LOOPCOUNT, 10):: a !Data\n        LOGICAL,DIMENSION(LOOPCOUNT):: totals, totals_comparison\n        INTEGER :: errors = 0\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(randoms)\n        DO x = 1, LOOPCOUNT\n          DO y = 1, 10\n            IF (randoms(x, y) > .933) THEN\n              a(x, y) = .TRUE.\n            ELSE\n              a(x, y) = .FALSE.\n            END IF\n          END DO\n        END DO\n\n        totals = .FALSE.\n        totals_comparison = .FALSE.\n\n        !$acc data copyin(a(1:LOOPCOUNT,1:10)) copy(totals(1:LOOPCOUNT))\n          !$acc parallel\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              DO y = 1, 10\n                !$acc atomic update\n                  totals(x) = totals(x) .OR. a(x, y)\n              END DO\n            END DO\n          !$acc end parallel\n        !$acc end data\n\n        DO x = 1, LOOPCOUNT\n          DO y = 1, 10\n            totals_comparison(x) = totals_comparison(x) .OR. a(x, y)\n          END DO\n        END DO\n\n        DO x = 1, LOOPCOUNT\n          IF (totals_comparison(x) .NEQV. totals(x)) THEN\n            errors = errors + 1\n            WRITE(*, *) totals_comparison(x)\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "construct-independent",
                            "atomic"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_update_x_or_expr_end.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:construct-independent,atomic,V:2.0-2.7\n      LOGICAL FUNCTION test1()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x, y !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT, 10):: randoms\n        LOGICAL,DIMENSION(LOOPCOUNT, 10):: a !Data\n        LOGICAL,DIMENSION(LOOPCOUNT):: totals, totals_comparison\n        INTEGER :: errors = 0\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(randoms)\n        DO x = 1, LOOPCOUNT\n          DO y = 1, 10\n            IF (randoms(x, y) > .933) THEN\n              a(x, y) = .TRUE.\n            ELSE\n              a(x, y) = .FALSE.\n            END IF\n          END DO\n        END DO\n\n        totals = .FALSE.\n        totals_comparison = .FALSE.\n\n        !$acc data copyin(a(1:LOOPCOUNT,1:10)) copy(totals(1:LOOPCOUNT))\n          !$acc parallel\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              DO y = 1, 10\n                !$acc atomic update\n                  totals(x) = totals(x) .OR. a(x, y)\n                !$acc end atomic\n              END DO\n            END DO\n          !$acc end parallel\n        !$acc end data\n\n        DO x = 1, LOOPCOUNT\n          DO y = 1, 10\n            totals_comparison(x) = totals_comparison(x) .OR. a(x, y)\n          END DO\n        END DO\n\n        DO x = 1, LOOPCOUNT\n          IF (totals_comparison(x) .NEQV. totals(x)) THEN\n            errors = errors + 1\n            WRITE(*, *) totals_comparison(x)\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "construct-independent",
                            "atomic"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_update_x_plus_expr.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:construct-independent,atomic,V:2.0-2.7\n      LOGICAL FUNCTION test1()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x, y !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT, 10):: a !Data\n        REAL(8),DIMENSION(LOOPCOUNT):: totals, totals_comparison\n        INTEGER :: errors = 0\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(a)\n\n        totals = 0\n        totals_comparison = 0\n\n        !$acc data copyin(a(1:LOOPCOUNT, 1:10)) copy(totals(1:LOOPCOUNT))\n          !$acc parallel\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              DO y = 1, 10\n                !$acc atomic update\n                  totals(x) = totals(x) + a(x, y)\n              END DO\n            END DO\n          !$acc end parallel\n        !$acc end data\n        DO x = 1, LOOPCOUNT\n          DO y = 1, 10\n            totals_comparison(x) = totals_comparison(x) + a(x, y)\n          END DO\n        END DO\n\n        DO x = 1, LOOPCOUNT\n          IF (totals_comparison(x) .NE. totals(x)) THEN\n            errors = errors + 1\n            WRITE(*, *) totals_comparison(x)\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "construct-independent",
                            "atomic"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_update_x_plus_expr.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:atomic,construct-independent,V:2.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t *a = (real_t *)malloc(n * sizeof(real_t));\n    real_t *b = (real_t *)malloc(n * sizeof(real_t));\n    real_t *totals = (real_t *)malloc(10 * sizeof(real_t));\n    real_t *totals_comparison = (real_t *)malloc(10 * sizeof(real_t));\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n    }\n    for (int x = 0; x < 10; ++x){\n        totals[x] = 0;\n        totals_comparison[x] = 0;\n    }\n\n    #pragma acc data copyin(a[0:n], b[0:n]) copy(totals[0:10])\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                #pragma acc loop\n                for (int y = 0; y < n; ++y){\n                    #pragma acc atomic update\n                        totals[(int) ((a[x] + b[x])/2)] = totals[(int) ((a[x] + b[x])/2)] + a[x] * b[x];\n                }\n            }\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        for (int y = 0; y < n; ++y){\n            totals_comparison[(int) ((a[x] + b[x])/2)] += a[x] * b[x];\n        }\n    }\n    for (int x = 0; x < 10; ++x){\n        if (fabs(totals_comparison[x] - totals[x]) > PRECISION){\n            err += 1;\n            break;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "atomic",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_update_x_plus_expr_end.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:construct-independent,atomic,V:2.0-2.7\n      LOGICAL FUNCTION test1()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x, y !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT, 10):: a !Data\n        REAL(8),DIMENSION(LOOPCOUNT):: totals, totals_comparison\n        INTEGER :: errors = 0\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(a)\n\n        totals = 0\n        totals_comparison = 0\n\n        !$acc data copyin(a(1:LOOPCOUNT, 1:10)) copy(totals(1:LOOPCOUNT))\n          !$acc parallel\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              DO y = 1, 10\n                !$acc atomic update\n                  totals(x) = totals(x) + a(x, y)\n                !$acc end atomic\n              END DO\n            END DO\n          !$acc end parallel\n        !$acc end data\n        DO x = 1, LOOPCOUNT\n          DO y = 1, 10\n            totals_comparison(x) = totals_comparison(x) + a(x, y)\n          END DO\n        END DO\n\n        DO x = 1, LOOPCOUNT\n          IF (totals_comparison(x) .NE. totals(x)) THEN\n            errors = errors + 1\n            WRITE(*, *) totals_comparison(x)\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "construct-independent",
                            "atomic"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_update_x_rshift_expr.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:atomic,construct-independent,V:2.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    unsigned int *a = (unsigned int *)malloc(n * sizeof(int));\n    unsigned int *b = (unsigned int *)malloc(n * sizeof(int));\n\n    for (int x = 0; x < n; ++x){\n        a[x] = 1<<7;\n        for (int y = 0; y < 7; ++y){\n            if ((rand()/(unsigned int) (RAND_MAX)) > .5){\n                b[x] += 1<<y;\n            }\n        }\n    }\n\n    #pragma acc data copyin(b[0:n]) copy(a[0:n])\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                #pragma acc loop\n                for (int y = 0; y < 7; ++y){\n                    if ((b[x]>>y)%2 == 1){\n                        #pragma acc atomic update\n                            a[x] = a[x] >> 1;\n                    }\n                }\n            }\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        for (int y = 0; y < 7; ++y){\n            if ((b[x]>>y)%2 == 1){\n                a[x] <<= 1;\n            }\n        }\n        if (a[x] != 1<<7){\n            err += 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "atomic",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_update_x_times_expr.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:construct-independent,atomic,V:2.0-2.7\n      LOGICAL FUNCTION test1()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x, y !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT, 10):: a !Data\n        REAL(8),DIMENSION(LOOPCOUNT):: totals, totals_comparison\n        INTEGER :: errors = 0\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(a)\n\n        totals = 1\n        totals_comparison = 1\n\n        !$acc data copyin(a(1:LOOPCOUNT, 1:10)) copy(totals(1:LOOPCOUNT))\n          !$acc parallel\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              DO y = 1, 10\n                !$acc atomic update\n                  totals(x) = totals(x) * a(x, y)\n              END DO\n            END DO\n          !$acc end parallel\n        !$acc end data\n        DO x = 1, LOOPCOUNT\n          DO y = 1, 10\n            totals_comparison(x) = totals_comparison(x) * a(x, y)\n          END DO\n        END DO\n\n        DO x = 1, LOOPCOUNT\n          IF (totals_comparison(x) .NE. totals(x)) THEN\n            errors = errors + 1\n            WRITE(*, *) totals_comparison(x)\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "construct-independent",
                            "atomic"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_update_x_times_expr_end.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:construct-independent,atomic,V:2.0-2.7\n      LOGICAL FUNCTION test1()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x, y !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT, 10):: a !Data\n        REAL(8),DIMENSION(LOOPCOUNT):: totals, totals_comparison\n        INTEGER :: errors = 0\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(a)\n\n        totals = 1\n        totals_comparison = 1\n\n        !$acc data copyin(a(1:LOOPCOUNT, 1:10)) copy(totals(1:LOOPCOUNT))\n          !$acc parallel\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              DO y = 1, 10\n                !$acc atomic update\n                  totals(x) = totals(x) * a(x, y)\n                !$acc end atomic\n              END DO\n            END DO\n          !$acc end parallel\n        !$acc end data\n        DO x = 1, LOOPCOUNT\n          DO y = 1, 10\n            totals_comparison(x) = totals_comparison(x) * a(x, y)\n          END DO\n        END DO\n\n        DO x = 1, LOOPCOUNT\n          IF (totals_comparison(x) .NE. totals(x)) THEN\n            errors = errors + 1\n            WRITE(*, *) totals_comparison(x)\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "construct-independent",
                            "atomic"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_x_and_expr.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:construct-independent,atomic,V:2.0-2.7\n      LOGICAL FUNCTION test1()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x, y !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT, 10):: randoms\n        LOGICAL,DIMENSION(LOOPCOUNT, 10):: a !Data\n        LOGICAL,DIMENSION(LOOPCOUNT):: totals, totals_comparison\n        INTEGER :: errors = 0\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(randoms)\n        DO x = 1, LOOPCOUNT\n          DO y = 1, 10\n            IF (randoms(x, y) < .933) THEN\n              a(x, y) = .TRUE.\n            ELSE\n              a(x, y) = .FALSE.\n            END IF\n          END DO\n        END DO\n\n        totals = .FALSE.\n        totals_comparison = .FALSE.\n\n        !$acc data copyin(a(1:LOOPCOUNT,1:10)) copy(totals(1:LOOPCOUNT))\n          !$acc parallel\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              DO y = 1, 10\n                !$acc atomic\n                  totals(x) = totals(x) .AND. a(x, y)\n              END DO\n            END DO\n          !$acc end parallel\n        !$acc end data\n\n        DO x = 1, LOOPCOUNT\n          DO y = 1, 10\n            totals_comparison(x) = totals_comparison(x) .AND. a(x, y)\n          END DO\n        END DO\n\n        DO x = 1, LOOPCOUNT\n          IF (totals_comparison(x) .NEQV. totals(x)) THEN\n            errors = errors + 1\n            WRITE(*, *) totals_comparison(x)\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "construct-independent",
                            "atomic"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_x_and_expr_end.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:construct-independent,atomic,V:2.0-2.7\n      LOGICAL FUNCTION test1()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x, y !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT, 10):: randoms\n        LOGICAL,DIMENSION(LOOPCOUNT, 10):: a !Data\n        LOGICAL,DIMENSION(LOOPCOUNT):: totals, totals_comparison\n        INTEGER :: errors = 0\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(randoms)\n        DO x = 1, LOOPCOUNT\n          DO y = 1, 10\n            IF (randoms(x, y) < .933) THEN\n              a(x, y) = .TRUE.\n            ELSE\n              a(x, y) = .FALSE.\n            END IF\n          END DO\n        END DO\n\n        totals = .FALSE.\n        totals_comparison = .FALSE.\n\n        !$acc data copyin(a(1:LOOPCOUNT,1:10)) copy(totals(1:LOOPCOUNT))\n          !$acc parallel\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              DO y = 1, 10\n                !$acc atomic\n                  totals(x) = totals(x) .AND. a(x, y)\n                !$acc end atomic\n              END DO\n            END DO\n          !$acc end parallel\n        !$acc end data\n\n        DO x = 1, LOOPCOUNT\n          DO y = 1, 10\n            totals_comparison(x) = totals_comparison(x) .AND. a(x, y)\n          END DO\n        END DO\n\n        DO x = 1, LOOPCOUNT\n          IF (totals_comparison(x) .NEQV. totals(x)) THEN\n            errors = errors + 1\n            WRITE(*, *) totals_comparison(x)\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "construct-independent",
                            "atomic"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_x_bitand_expr.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:atomic,construct-independent,V:2.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    int  *a = (int *)malloc(n * sizeof(int));\n    int *totals = (int *)malloc((n/10 + 1) * sizeof(int));\n    int *totals_comparison = (int *)malloc((n/10 + 1) * sizeof(int));\n\n    for (int x = 0; x < n; ++x){\n        for (int y = 0; y < 8; ++y){\n            if (rand()/(real_t)(RAND_MAX) < .933){ //.933 gets close to a 50/50 distribution for a collescence of 10 values\n                a[x] += 1<<y;\n            }\n        }\n    }\n    for (int x = 0; x < n/10 + 1; ++x){\n        for (int y = 0; y < 8; ++y){\n            totals[x] +=  1<<y;\n            totals_comparison[x] += 1<<y;\n        }\n    }\n\n    #pragma acc data copyin(a[0:n]) copy(totals[0:n/10 + 1])\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                #pragma acc atomic\n                    totals[x%(n/10 + 1)] = totals[x%(n/10 + 1)] & a[x];\n            }\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        totals_comparison[x%(n/10 + 1)] &= a[x];\n    }\n    for (int x = 0; x < 10; ++x){\n        if (fabs(totals_comparison[x] - totals[x]) > PRECISION){\n            err += 1;\n            break;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "atomic",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_x_bitor_expr.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:atomic,construct-independent,V:2.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    int  *a = (int *)malloc(n * sizeof(int));\n    int *totals = (int *)malloc((n/10 + 1) * sizeof(int));\n    int *totals_comparison = (int *)malloc((n/10 + 1) * sizeof(int));\n\n    for (int x = 0; x < n; ++x){\n        for (int y = 0; y < 8; ++y){\n            if (rand()/(real_t)(RAND_MAX) > .933){ //.933 gets close to a 50/50 distribution for a collescence of 10 values\n                a[x] += 1<<y;\n            }\n        }\n    }\n    for (int x = 0; x < n/10 + 1; ++x){\n        totals[x] = 0;\n\n    }\n\n    #pragma acc data copyin(a[0:n]) copy(totals[0:n/10 + 1])\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                #pragma acc atomic\n                    totals[x%(n/10 + 1)] = totals[x%(n/10 + 1)] | a[x];\n            }\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        totals_comparison[x%(n/10 + 1)] |= a[x];\n    }\n    for (int x = 0; x < 10; ++x){\n        if (fabs(totals_comparison[x] - totals[x]) > PRECISION){\n            err += 1;\n            break;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "atomic",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_x_bitxor_expr.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:atomic,construct-independent,V:2.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    int  *a = (int *)malloc(n * sizeof(int));\n    int *totals = (int *)malloc((n/10 + 1) * sizeof(int));\n    int *totals_comparison = (int *)malloc((n/10 + 1) * sizeof(int));\n\n    for (int x = 0; x < n; ++x){\n        for (int y = 0; y < 8; ++y){\n            if (rand()/(real_t)(RAND_MAX) > .5){\n                a[x] += 1<<y;\n            }\n        }\n    }\n    for (int x = 0; x < n/10 + 1; ++x){\n        totals[x] = 0;\n        totals_comparison[x] = 0;\n    }\n\n    #pragma acc data copyin(a[0:n]) copy(totals[0:n/10 + 1])\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                #pragma acc atomic\n                    totals[x%(n/10 + 1)] =  totals[x%(n/10 + 1)] ^ a[x];\n            }\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        totals_comparison[x%(n/10 + 1)] ^= a[x];\n    }\n    for (int x = 0; x < n/10 + 1; ++x){\n        if (fabs(totals_comparison[x] - totals[x]) > PRECISION){\n            err += 1;\n            break;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "atomic",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_x_divided_expr.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:construct-independent,atomic,V:2.0-2.7\n      LOGICAL FUNCTION test1()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x, y !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT, 10):: a !Data\n        REAL(8),DIMENSION(LOOPCOUNT):: totals, totals_comparison\n        INTEGER :: errors = 0\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(a)\n\n        totals = 1\n        totals_comparison = 1\n\n        !$acc data copyin(a(1:LOOPCOUNT, 1:10)) copy(totals(1:LOOPCOUNT))\n          !$acc parallel\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              DO y = 1, 10\n                !$acc atomic\n                  totals(x) = totals(x) / a(x, y)\n              END DO\n            END DO\n          !$acc end parallel\n        !$acc end data\n        DO x = 1, LOOPCOUNT\n          DO y = 1, 10\n            totals_comparison(x) = totals_comparison(x) / a(x, y)\n          END DO\n        END DO\n\n        DO x = 1, LOOPCOUNT\n          IF (totals_comparison(x) .NE. totals(x)) THEN\n            errors = errors + 1\n            WRITE(*, *) totals_comparison(x)\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "construct-independent",
                            "atomic"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_x_divided_expr.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:atomic,construct-independent,V:2.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t *a = (real_t *)malloc(n * sizeof(real_t));\n    real_t *b = (real_t *)malloc(n * sizeof(real_t));\n    real_t *totals = (real_t *)malloc((n/10 + 1) * sizeof(real_t));\n    real_t *totals_comparison = (real_t *)malloc((n/10 + 1) * sizeof(real_t));\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n    }\n    for (int x = 0; x < n/10 + 1; ++x){\n        totals[x] = 1;\n        totals_comparison[x] = 1;\n    }\n\n    #pragma acc data copyin(a[0:n], b[0:n]) copy(totals[0:n/10 + 1])\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                #pragma acc atomic\n                    totals[x%(n/10 + 1)] = totals[x%(n/10 + 1)] / (a[x] + b[x]);\n            }\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        totals_comparison[x%(n/10 + 1)] /= a[x] + b[x];\n    }\n    for (int x = 0; x < 10; ++x){\n        if (fabs(totals_comparison[x] - totals[x]) > PRECISION){\n            err += 1;\n            break;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "atomic",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_x_divided_expr_end.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:construct-independent,atomic,V:2.0-2.7\n      LOGICAL FUNCTION test1()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x, y !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT, 10):: a !Data\n        REAL(8),DIMENSION(LOOPCOUNT):: totals, totals_comparison\n        INTEGER :: errors = 0\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(a)\n\n        totals = 1\n        totals_comparison = 1\n\n        !$acc data copyin(a(1:LOOPCOUNT, 1:10)) copy(totals(1:LOOPCOUNT))\n          !$acc parallel\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              DO y = 1, 10\n                !$acc atomic\n                  totals(x) = totals(x) / a(x, y)\n                !$acc end atomic\n              END DO\n            END DO\n          !$acc end parallel\n        !$acc end data\n        DO x = 1, LOOPCOUNT\n          DO y = 1, 10\n            totals_comparison(x) = totals_comparison(x) / a(x, y)\n          END DO\n        END DO\n\n        DO x = 1, LOOPCOUNT\n          IF (totals_comparison(x) .NE. totals(x)) THEN\n            errors = errors + 1\n            WRITE(*, *) totals_comparison(x)\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "construct-independent",
                            "atomic"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_x_eqv_expr.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:construct-independent,atomic,V:2.0-2.7\n      LOGICAL FUNCTION test1()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x, y !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT, 10):: randoms\n        LOGICAL,DIMENSION(LOOPCOUNT, 10):: a !Data\n        LOGICAL,DIMENSION(LOOPCOUNT):: totals, totals_comparison\n        INTEGER :: errors = 0\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(randoms)\n        DO x = 1, LOOPCOUNT\n          DO y = 1, 10\n            IF (randoms(x, y) > .5) THEN\n              a(x, y) = .TRUE.\n            ELSE\n              a(x, y) = .FALSE.\n            END IF\n          END DO\n        END DO\n\n        totals = .FALSE.\n        totals_comparison = .FALSE.\n\n        !$acc data copyin(a(1:LOOPCOUNT,1:10)) copy(totals(1:LOOPCOUNT))\n          !$acc parallel\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              DO y = 1, 10\n                !$acc atomic\n                  totals(x) = totals(x) .EQV. a(x, y)\n              END DO\n            END DO\n          !$acc end parallel\n        !$acc end data\n\n        DO x = 1, LOOPCOUNT\n          DO y = 1, 10\n            totals_comparison(x) = totals_comparison(x) .EQV. a(x, y)\n          END DO\n        END DO\n\n        DO x = 1, LOOPCOUNT\n          IF (totals_comparison(x) .NEQV. totals(x)) THEN\n            errors = errors + 1\n            WRITE(*, *) totals_comparison(x)\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "construct-independent",
                            "atomic"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_x_eqv_expr_end.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:construct-independent,atomic,V:2.0-2.7\n      LOGICAL FUNCTION test1()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x, y !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT, 10):: randoms\n        LOGICAL,DIMENSION(LOOPCOUNT, 10):: a !Data\n        LOGICAL,DIMENSION(LOOPCOUNT):: totals, totals_comparison\n        INTEGER :: errors = 0\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(randoms)\n        DO x = 1, LOOPCOUNT\n          DO y = 1, 10\n            IF (randoms(x, y) > .5) THEN\n              a(x, y) = .TRUE.\n            ELSE\n              a(x, y) = .FALSE.\n            END IF\n          END DO\n        END DO\n\n        totals = .FALSE.\n        totals_comparison = .FALSE.\n\n        !$acc data copyin(a(1:LOOPCOUNT,1:10)) copy(totals(1:LOOPCOUNT))\n          !$acc parallel\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              DO y = 1, 10\n                !$acc atomic\n                  totals(x) = totals(x) .EQV. a(x, y)\n                !$acc end atomic\n              END DO\n            END DO\n          !$acc end parallel\n        !$acc end data\n\n        DO x = 1, LOOPCOUNT\n          DO y = 1, 10\n            totals_comparison(x) = totals_comparison(x) .EQV. a(x, y)\n          END DO\n        END DO\n\n        DO x = 1, LOOPCOUNT\n          IF (totals_comparison(x) .NEQV. totals(x)) THEN\n            errors = errors + 1\n            WRITE(*, *) totals_comparison(x)\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "construct-independent",
                            "atomic"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_x_lshift_expr.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:atomic,construct-independent,V:2.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    unsigned int *a = (unsigned int *)malloc(n * sizeof(int));\n    unsigned int *b = (unsigned int *)malloc(n * sizeof(int));\n\n    for (int x = 0; x < n; ++x){\n        a[x] = 1;\n        for (int y = 0; y < 7; ++y){\n            if ((rand()/(unsigned int) (RAND_MAX)) > .5){\n                b[x] += 1<<y;\n            }\n        }\n    }\n\n    #pragma acc data copyin(b[0:n]) copy(a[0:n])\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                #pragma acc loop\n                for (int y = 0; y < 7; ++y){\n                    if ((b[x]>>y)%2 == 1){\n                        #pragma acc atomic\n                            a[x] = a[x] << 1;\n                    }\n                }\n            }\n        }\n    }\n    for (int x = 0; x < n; ++x){\n        for (int y = 0; y < 7; ++y){\n            if ((b[x]>>y)%2 == 1){\n                a[x] >>= 1;\n            }\n        }\n        if (a[x] != 1){\n            err += 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "atomic",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_x_minus_expr.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:construct-independent,atomic,V:2.0-2.7\n      LOGICAL FUNCTION test1()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x, y !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT, 10):: a !Data\n        REAL(8),DIMENSION(LOOPCOUNT):: totals, totals_comparison\n        INTEGER :: errors = 0\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(a)\n\n        totals = 0\n        totals_comparison = 0\n\n        !$acc data copyin(a(1:LOOPCOUNT, 1:10)) copy(totals(1:LOOPCOUNT))\n          !$acc parallel\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              DO y = 1, 10\n                !$acc atomic\n                  totals(x) = totals(x) - a(x, y)\n              END DO\n            END DO\n          !$acc end parallel\n        !$acc end data\n        DO x = 1, LOOPCOUNT\n          DO y = 1, 10\n            totals_comparison(x) = totals_comparison(x) - a(x, y)\n          END DO\n        END DO\n\n        DO x = 1, LOOPCOUNT\n          IF (totals_comparison(x) .NE. totals(x)) THEN\n            errors = errors + 1\n            WRITE(*, *) totals_comparison(x)\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "construct-independent",
                            "atomic"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_x_minus_expr.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:atomic,construct-independent,V:2.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t *a = (real_t *)malloc(n * sizeof(real_t));\n    real_t *b = (real_t *)malloc(n * sizeof(real_t));\n    real_t *totals = (real_t *)malloc(10 * sizeof(real_t));\n    real_t *totals_host = (real_t *)malloc(10 * sizeof(real_t));\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n    }\n    for (int x = 0; x < 10; ++x){\n        totals[x] = 0;\n    }\n\n    #pragma acc data copyin(a[0:n], b[0:n]) copy(totals[0:10])\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                #pragma acc atomic\n                    totals[x%10] = totals[x%10] - (a[x] + b[x]);\n            }\n        }\n    }\n\n\n    for (int x = 0; x < n; ++x){\n        totals_host[x%10] = totals_host[x%10] - (a[x] + b[x]);\n    }\n    for (int x = 0; x < 10; ++x){\n        if (fabs(totals_host[x] - totals[x]) > PRECISION){\n            err += 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "atomic",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_x_minus_expr_end.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:construct-independent,atomic,V:2.0-2.7\n      LOGICAL FUNCTION test1()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x, y !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT, 10):: a !Data\n        REAL(8),DIMENSION(LOOPCOUNT):: totals, totals_comparison\n        INTEGER :: errors = 0\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(a)\n\n        totals = 0\n        totals_comparison = 0\n\n        !$acc data copyin(a(1:LOOPCOUNT, 1:10)) copy(totals(1:LOOPCOUNT))\n          !$acc parallel\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              DO y = 1, 10\n                !$acc atomic\n                  totals(x) = totals(x) - a(x, y)\n                !$acc end atomic\n              END DO\n            END DO\n          !$acc end parallel\n        !$acc end data\n        DO x = 1, LOOPCOUNT\n          DO y = 1, 10\n            totals_comparison(x) = totals_comparison(x) - a(x, y)\n          END DO\n        END DO\n\n        DO x = 1, LOOPCOUNT\n          IF (totals_comparison(x) .NE. totals(x)) THEN\n            errors = errors + 1\n            WRITE(*, *) totals_comparison(x)\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "construct-independent",
                            "atomic"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_x_multiply_expr.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:atomic,construct-independent,V:2.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t *a = (real_t *)malloc(n * sizeof(real_t));\n    real_t *b = (real_t *)malloc(n * sizeof(real_t));\n    real_t *totals = (real_t *)malloc((n/10 + 1) * sizeof(real_t));\n    real_t *totals_comparison = (real_t *)malloc((n/10 + 1) * sizeof(real_t));\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n    }\n    for (int x = 0; x < n/10 + 1; ++x){\n        totals[x] = 1;\n        totals_comparison[x] = 1;\n    }\n\n    #pragma acc data copyin(a[0:n], b[0:n]) copy(totals[0:n/10 + 1])\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                #pragma acc atomic\n                    totals[x%(n/10 + 1)] = totals[x%(n/10 + 1)] * (a[x] + b[x]);\n            }\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        totals_comparison[x%(n/10 + 1)] *= a[x] + b[x];\n    }\n    for (int x = 0; x < 10; ++x){\n        if (fabs(totals_comparison[x] - totals[x]) > PRECISION * totals_comparison[x]){\n            err += 1;\n            break;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "atomic",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_x_neqv_expr.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:construct-independent,atomic,V:2.0-2.7\n      LOGICAL FUNCTION test1()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x, y !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT, 10):: randoms\n        LOGICAL,DIMENSION(LOOPCOUNT, 10):: a !Data\n        LOGICAL,DIMENSION(LOOPCOUNT):: totals, totals_comparison\n        INTEGER :: errors = 0\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(randoms)\n        DO x = 1, LOOPCOUNT\n          DO y = 1, 10\n            IF (randoms(x, y) > .5) THEN\n              a(x, y) = .TRUE.\n            ELSE\n              a(x, y) = .FALSE.\n            END IF\n          END DO\n        END DO\n\n        totals = .FALSE.\n        totals_comparison = .FALSE.\n\n        !$acc data copyin(a(1:LOOPCOUNT,1:10)) copy(totals(1:LOOPCOUNT))\n          !$acc parallel\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              DO y = 1, 10\n                !$acc atomic\n                  totals(x) = totals(x) .NEQV. a(x, y)\n              END DO\n            END DO\n          !$acc end parallel\n        !$acc end data\n\n        DO x = 1, LOOPCOUNT\n          DO y = 1, 10\n            totals_comparison(x) = totals_comparison(x) .NEQV. a(x, y)\n          END DO\n        END DO\n\n        DO x = 1, LOOPCOUNT\n          IF (totals_comparison(x) .NEQV. totals(x)) THEN\n            errors = errors + 1\n            WRITE(*, *) totals_comparison(x)\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "construct-independent",
                            "atomic"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_x_neqv_expr_end.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:construct-independent,atomic,V:2.0-2.7\n      LOGICAL FUNCTION test1()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x, y !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT, 10):: randoms\n        LOGICAL,DIMENSION(LOOPCOUNT, 10):: a !Data\n        LOGICAL,DIMENSION(LOOPCOUNT):: totals, totals_comparison\n        INTEGER :: errors = 0\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(randoms)\n        DO x = 1, LOOPCOUNT\n          DO y = 1, 10\n            IF (randoms(x, y) > .5) THEN\n              a(x, y) = .TRUE.\n            ELSE\n              a(x, y) = .FALSE.\n            END IF\n          END DO\n        END DO\n\n        totals = .FALSE.\n        totals_comparison = .FALSE.\n\n        !$acc data copyin(a(1:LOOPCOUNT,1:10)) copy(totals(1:LOOPCOUNT))\n          !$acc parallel\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              DO y = 1, 10\n                !$acc atomic\n                  totals(x) = totals(x) .NEQV. a(x, y)\n                !$acc end atomic\n              END DO\n            END DO\n          !$acc end parallel\n        !$acc end data\n\n        DO x = 1, LOOPCOUNT\n          DO y = 1, 10\n            totals_comparison(x) = totals_comparison(x) .NEQV. a(x, y)\n          END DO\n        END DO\n\n        DO x = 1, LOOPCOUNT\n          IF (totals_comparison(x) .NEQV. totals(x)) THEN\n            errors = errors + 1\n            WRITE(*, *) totals_comparison(x)\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "construct-independent",
                            "atomic"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_x_or_expr.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:construct-independent,atomic,V:2.0-2.7\n      LOGICAL FUNCTION test1()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x, y !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT, 10):: randoms\n        LOGICAL,DIMENSION(LOOPCOUNT, 10):: a !Data\n        LOGICAL,DIMENSION(LOOPCOUNT):: totals, totals_comparison\n        INTEGER :: errors = 0\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(randoms)\n        DO x = 1, LOOPCOUNT\n          DO y = 1, 10\n            IF (randoms(x, y) > .933) THEN\n              a(x, y) = .TRUE.\n            ELSE\n              a(x, y) = .FALSE.\n            END IF\n          END DO\n        END DO\n\n        totals = .FALSE.\n        totals_comparison = .FALSE.\n\n        !$acc data copyin(a(1:LOOPCOUNT,1:10)) copy(totals(1:LOOPCOUNT))\n          !$acc parallel\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              DO y = 1, 10\n                !$acc atomic\n                  totals(x) = totals(x) .OR. a(x, y)\n              END DO\n            END DO\n          !$acc end parallel\n        !$acc end data\n\n        DO x = 1, LOOPCOUNT\n          DO y = 1, 10\n            totals_comparison(x) = totals_comparison(x) .OR. a(x, y)\n          END DO\n        END DO\n\n        DO x = 1, LOOPCOUNT\n          IF (totals_comparison(x) .NEQV. totals(x)) THEN\n            errors = errors + 1\n            WRITE(*, *) totals_comparison(x)\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "construct-independent",
                            "atomic"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_x_or_expr_end.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:construct-independent,atomic,V:2.0-2.7\n      LOGICAL FUNCTION test1()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x, y !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT, 10):: randoms\n        LOGICAL,DIMENSION(LOOPCOUNT, 10):: a !Data\n        LOGICAL,DIMENSION(LOOPCOUNT):: totals, totals_comparison\n        INTEGER :: errors = 0\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(randoms)\n        DO x = 1, LOOPCOUNT\n          DO y = 1, 10\n            IF (randoms(x, y) > .933) THEN\n              a(x, y) = .TRUE.\n            ELSE\n              a(x, y) = .FALSE.\n            END IF\n          END DO\n        END DO\n\n        totals = .FALSE.\n        totals_comparison = .FALSE.\n\n        !$acc data copyin(a(1:LOOPCOUNT,1:10)) copy(totals(1:LOOPCOUNT))\n          !$acc parallel\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              DO y = 1, 10\n                !$acc atomic\n                  totals(x) = totals(x) .OR. a(x, y)\n                !$acc end atomic\n              END DO\n            END DO\n          !$acc end parallel\n        !$acc end data\n\n        DO x = 1, LOOPCOUNT\n          DO y = 1, 10\n            totals_comparison(x) = totals_comparison(x) .OR. a(x, y)\n          END DO\n        END DO\n\n        DO x = 1, LOOPCOUNT\n          IF (totals_comparison(x) .NEQV. totals(x)) THEN\n            errors = errors + 1\n            WRITE(*, *) totals_comparison(x)\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "construct-independent",
                            "atomic"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_x_plus_expr.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:construct-independent,atomic,V:2.0-2.7\n      LOGICAL FUNCTION test1()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x, y !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT, 10):: a !Data\n        REAL(8),DIMENSION(LOOPCOUNT):: totals, totals_comparison\n        INTEGER :: errors = 0\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(a)\n\n        totals = 0\n        totals_comparison = 0\n\n        !$acc data copyin(a(1:LOOPCOUNT, 1:10)) copy(totals(1:LOOPCOUNT))\n          !$acc parallel\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              DO y = 1, 10\n                !$acc atomic\n                  totals(x) = totals(x) + a(x, y)\n              END DO\n            END DO\n          !$acc end parallel\n        !$acc end data\n        DO x = 1, LOOPCOUNT\n          DO y = 1, 10\n            totals_comparison(x) = totals_comparison(x) + a(x, y)\n          END DO\n        END DO\n\n        DO x = 1, LOOPCOUNT\n          IF (totals_comparison(x) .NE. totals(x)) THEN\n            errors = errors + 1\n            WRITE(*, *) totals_comparison(x)\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "construct-independent",
                            "atomic"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_x_plus_expr.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:atomic,construct-independent,V:2.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t *a = (real_t *)malloc(n * sizeof(real_t));\n    real_t *b = (real_t *)malloc(n * sizeof(real_t));\n    real_t *totals = (real_t *)malloc(10 * sizeof(real_t));\n    real_t *totals_comparison = (real_t *)malloc(10 * sizeof(real_t));\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n    }\n    for (int x = 0; x < 10; ++x){\n        totals[x] = 0;\n        totals_comparison[x] = 0;\n    }\n\n    #pragma acc data copyin(a[0:n], b[0:n]) copy(totals[0:10])\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                #pragma acc loop\n                for (int y = 0; y < n; ++y){\n                    #pragma acc atomic\n                        totals[(int) ((a[x] + b[x])/2)] = totals[(int) ((a[x] + b[x])/2)] + a[x] * b[x];\n                }\n            }\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        for (int y = 0; y < n; ++y){\n            totals_comparison[(int) ((a[x] + b[x])/2)] += a[x] * b[x];\n        }\n    }\n    for (int x = 0; x < 10; ++x){\n        if (fabs(totals_comparison[x] - totals[x]) > PRECISION){\n            err += 1;\n            break;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "atomic",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_x_plus_expr_end.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:construct-independent,atomic,V:2.0-2.7\n      LOGICAL FUNCTION test1()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x, y !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT, 10):: a !Data\n        REAL(8),DIMENSION(LOOPCOUNT):: totals, totals_comparison\n        INTEGER :: errors = 0\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(a)\n\n        totals = 0\n        totals_comparison = 0\n\n        !$acc data copyin(a(1:LOOPCOUNT, 1:10)) copy(totals(1:LOOPCOUNT))\n          !$acc parallel\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              DO y = 1, 10\n                !$acc atomic\n                  totals(x) = totals(x) + a(x, y)\n                !$acc end atomic\n              END DO\n            END DO\n          !$acc end parallel\n        !$acc end data\n        DO x = 1, LOOPCOUNT\n          DO y = 1, 10\n            totals_comparison(x) = totals_comparison(x) + a(x, y)\n          END DO\n        END DO\n\n        DO x = 1, LOOPCOUNT\n          IF (totals_comparison(x) .NE. totals(x)) THEN\n            errors = errors + 1\n            WRITE(*, *) totals_comparison(x)\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "construct-independent",
                            "atomic"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_x_rshift_expr.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:atomic,construct-independent,V:2.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    unsigned int *a = (unsigned int *)malloc(n * sizeof(int));\n    unsigned int *b = (unsigned int *)malloc(n * sizeof(int));\n\n    for (int x = 0; x < n; ++x){\n        a[x] = 1<<7;\n        for (int y = 0; y < 7; ++y){\n            if ((rand()/(unsigned int) (RAND_MAX)) > .5){\n                b[x] += 1<<y;\n            }\n        }\n    }\n\n    #pragma acc data copyin(b[0:n]) copy(a[0:n])\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                #pragma acc loop\n                for (int y = 0; y < 7; ++y){\n                    if ((b[x]>>y)%2 == 1){\n                        #pragma acc atomic\n                            a[x] = a[x] >> 1;\n                    }\n                }\n            }\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        for (int y = 0; y < 7; ++y){\n            if ((b[x]>>y)%2 == 1){\n                a[x] <<= 1;\n            }\n        }\n        if (a[x] != 1<<7){\n            err += 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "atomic",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_x_times_expr.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:construct-independent,atomic,V:2.0-2.7\n      LOGICAL FUNCTION test1()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x, y !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT, 10):: a !Data\n        REAL(8),DIMENSION(LOOPCOUNT):: totals, totals_comparison\n        INTEGER :: errors = 0\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(a)\n\n        totals = 1\n        totals_comparison = 1\n\n        !$acc data copyin(a(1:LOOPCOUNT, 1:10)) copy(totals(1:LOOPCOUNT))\n          !$acc parallel\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              DO y = 1, 10\n                !$acc atomic\n                  totals(x) = totals(x) * a(x, y)\n              END DO\n            END DO\n          !$acc end parallel\n        !$acc end data\n        DO x = 1, LOOPCOUNT\n          DO y = 1, 10\n            totals_comparison(x) = totals_comparison(x) * a(x, y)\n          END DO\n        END DO\n\n        DO x = 1, LOOPCOUNT\n          IF (totals_comparison(x) .NE. totals(x)) THEN\n            errors = errors + 1\n            WRITE(*, *) totals_comparison(x)\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "construct-independent",
                            "atomic"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "atomic_x_times_expr_end.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:construct-independent,atomic,V:2.0-2.7\n      LOGICAL FUNCTION test1()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x, y !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT, 10):: a !Data\n        REAL(8),DIMENSION(LOOPCOUNT):: totals, totals_comparison\n        INTEGER :: errors = 0\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(a)\n\n        totals = 1\n        totals_comparison = 1\n\n        !$acc data copyin(a(1:LOOPCOUNT, 1:10)) copy(totals(1:LOOPCOUNT))\n          !$acc parallel\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              DO y = 1, 10\n                !$acc atomic\n                  totals(x) = totals(x) * a(x, y)\n                !$acc end atomic\n              END DO\n            END DO\n          !$acc end parallel\n        !$acc end data\n        DO x = 1, LOOPCOUNT\n          DO y = 1, 10\n            totals_comparison(x) = totals_comparison(x) * a(x, y)\n          END DO\n        END DO\n\n        DO x = 1, LOOPCOUNT\n          IF (totals_comparison(x) .NE. totals(x)) THEN\n            errors = errors + 1\n            WRITE(*, *) totals_comparison(x)\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "construct-independent",
                            "atomic"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "data_copy_no_lower_bound.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:data,data_region,construct-independent,V:1.0-2.7\n      LOGICAL FUNCTION test1()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT):: a, b, c !Data\n        INTEGER :: errors = 0\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(a)\n        CALL RANDOM_NUMBER(b)\n        c = 0\n\n        !$acc data copyin(a(1:LOOPCOUNT), b(1:LOOPCOUNT)) copy(c(:LOOPCOUNT))\n          !$acc parallel\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              c(x) = c(x) + a(x) + b(x)\n            END DO\n          !$acc end parallel\n        !$acc end data\n        DO x = 1, LOOPCOUNT\n          IF (abs(c(x) - (a(x) + b(x))) .gt. PRECISION) THEN\n            errors = errors + 1\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "data",
                            "data_region",
                            "construct-independent"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "data_copy_no_lower_bound.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:data,data-region,construct-independent,V:1.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n    real_t * c = (real_t *)malloc(n * sizeof(real_t));\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n        c[x] = 0.0;\n    }\n\n    #pragma acc data copyin(a[0:n], b[0:n]) copy(c[:n])\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                c[x] += a[x] + b[x];\n            }\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        if (fabs(c[x] - (a[x] + b[x])) > PRECISION){\n            err += 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "data",
                            "data-region",
                            "construct-independent"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "data_copyin_no_lower_bound.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:data,data_region,construct-independent,V:1.0-2.7\n      LOGICAL FUNCTION test1()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT):: a, b, c !Data\n        INTEGER :: errors = 0\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(a)\n        CALL RANDOM_NUMBER(b)\n        c = 0\n\n        !$acc data copyin(a(:LOOPCOUNT), b(:LOOPCOUNT)) copyout(c(1:LOOPCOUNT))\n          !$acc parallel\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              c(x) = a(x) + b(x)\n            END DO\n          !$acc end parallel\n        !$acc end data\n\n        DO x = 1, LOOPCOUNT\n          IF (abs(c(x) - (a(x) + b(x))) .gt. PRECISION) THEN\n            errors = errors + 1\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "data",
                            "data_region",
                            "construct-independent"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "data_copyin_no_lower_bound.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:data,data-region,construct-independent,V:1.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n    real_t * c = (real_t *)malloc(n * sizeof(real_t));\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n        c[x] = 0.0;\n    }\n\n    #pragma acc data copyin(a[:n], b[:n]) copyout(c[0:n])\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                c[x] = a[x] + b[x];\n            }\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        if (fabs(c[x] - (a[x] + b[x])) > PRECISION){\n            err += 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "data",
                            "data-region",
                            "construct-independent"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "data_copyout_no_lower_bound.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:data,data_region,construct-independent,V:1.0-2.7\n      LOGICAL FUNCTION test1()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT):: a, b, c !Data\n        INTEGER :: errors = 0\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(a)\n        CALL RANDOM_NUMBER(b)\n        c = 0\n\n        !$acc data copyin(a(1:LOOPCOUNT), b(1:LOOPCOUNT)) copyout(c(:LOOPCOUNT))\n          !$acc parallel\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              c(x) = a(x) + b(x)\n            END DO\n          !$acc end parallel\n        !$acc end data\n        DO x = 1, LOOPCOUNT\n          IF (abs(c(x) - (a(x) + b(x))) .gt. PRECISION) THEN\n            errors = errors + 1\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "data",
                            "data_region",
                            "construct-independent"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "data_copyout_no_lower_bound.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:data,data-region,construct-independent,V:1.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n    real_t * c = (real_t *)malloc(n * sizeof(real_t));\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n        c[x] = 0.0;\n    }\n\n    #pragma acc data copyin(a[0:n], b[0:n]) copyout(c[:n])\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                c[x] = a[x] + b[x];\n            }\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        if (fabs(c[x] - (a[x] + b[x])) > PRECISION){\n            err += 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "data",
                            "data-region",
                            "construct-independent"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "data_copyout_reference_counts.F90": {
                "num tests": 3,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:data,data_region,devonly,construct-independent,V:2.0-2.7\n      LOGICAL FUNCTION test1()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT):: a, b, c !Data\n        INTEGER :: errors = 0\n        INTEGER,DIMENSION(1)::devtest\n\n        devtest(1) = 1\n        !$acc enter data copyin(devtest(1:1))\n        !$acc parallel present(devtest(1:1))\n          devtest(1) = 0\n        !$acc end parallel\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        IF (devtest(1) .eq. 1) THEN\n          CALL RANDOM_NUMBER(a)\n          CALL RANDOM_NUMBER(b)\n          c = 0\n          !$acc data copyin(c(1:LOOPCOUNT))\n            !$acc data copyin(a(1:LOOPCOUNT), b(1:LOOPCOUNT)) copyout(c(1:LOOPCOUNT))\n              !$acc parallel\n                !$acc loop\n                DO x = 1, LOOPCOUNT\n                  c(x) = c(x) + a(x) + b(x)\n                END DO\n              !$acc end parallel\n            !$acc end data\n          !$acc end data\n\n          DO x = 1, LOOPCOUNT\n            IF (abs(c(x)) .gt. PRECISION) THEN\n              errors = errors + 1\n              EXIT\n            END IF\n          END DO\n        END IF\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "data",
                            "data_region",
                            "devonly",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "2": {
                        "content": "#ifndef T2\n!T2:data,data_region,devonly,construct-independent,V:2.0-2.7\n      LOGICAL FUNCTION test2()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT):: a, b, c !Data\n        INTEGER :: errors = 0\n        INTEGER,DIMENSION(1)::devtest\n\n        devtest(1) = 1\n        !$acc enter data copyin(devtest(1:1))\n        !$acc parallel present(devtest(1:1))\n          devtest(1) = 0\n        !$acc end parallel\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(a)\n        CALL RANDOM_NUMBER(b)\n        c = 0\n\n        !$acc enter data copyin(c(1:LOOPCOUNT))\n        !$acc data copyin(a(1:LOOPCOUNT), b(1:LOOPCOUNT)) copyout(c(1:LOOPCOUNT))\n          !$acc parallel\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              c(x) = c(x) + a(x) + b(x)\n            END DO\n          !$acc end parallel\n        !$acc end data\n        IF (devtest(1) .eq. 1) THEN\n          DO x = 1, LOOPCOUNT\n            IF (abs(c(x)) .gt. PRECISION) THEN\n              errors = errors + 2\n              EXIT\n            END IF\n          END DO\n        END IF\n        !$acc exit data copyout(c(1:LOOPCOUNT))\n        DO x = 1, LOOPCOUNT\n          IF (abs(c(x) - (a(x) + b(x))) .gt. PRECISION) THEN\n            errors = errors + 4\n            EXIT\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test2 = .FALSE.\n        ELSE\n          test2 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T2\n        LOGICAL :: test2\n#endif\n#ifndef T2\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test2()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 1\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "data",
                            "data_region",
                            "devonly",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "3": {
                        "content": "#ifndef T3\n!T3:data,data_region,devonly,construct-independent,V:2.0-2.7\n      LOGICAL FUNCTION test3()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT):: a, b, c !Data\n        INTEGER :: errors = 0\n        INTEGER,DIMENSION(1)::devtest\n\n        devtest(1) = 1\n        !$acc enter data copyin(devtest(1:1))\n        !$acc parallel present(devtest(1:1))\n          devtest(1) = 0\n        !$acc end parallel\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(a)\n        CALL RANDOM_NUMBER(b)\n        c = 0\n\n        !$acc enter data copyin(c(1:LOOPCOUNT))\n        !$acc data copyin(a(1:LOOPCOUNT), b(1:LOOPCOUNT)) copyout(c(1:LOOPCOUNT))\n          !$acc parallel\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              c(x) = c(x) + a(x) + b(x)\n            END DO\n          !$acc end parallel\n          !$acc exit data delete(c(1:LOOPCOUNT))\n        !$acc end data\n\n        DO x = 1, LOOPCOUNT\n          IF (abs(c(x) - (a(x) + b(x))) .gt. PRECISION) THEN\n            errors = errors + 8\n            EXIT\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test3 = .FALSE.\n        ELSE\n          test3 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T3\n        LOGICAL :: test3\n#endif\n#ifndef T3\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test3()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 2\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "data",
                            "data_region",
                            "devonly",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "data_copyout_reference_counts.c": {
                "num tests": 3,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:data,data-region,reference-counting,devonly,construct-independent,V:2.5-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n    real_t * c = (real_t *)malloc(n * sizeof(real_t));\n    int * devtest = (int *)malloc(sizeof(int));\n    devtest[0] = 1;\n    #pragma acc enter data copyin(devtest[0:1])\n    #pragma acc parallel present(devtest[0:1])\n    {\n      devtest[0] = 0;\n    }\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n        c[x] = 0.0;\n    }\n\n\n    if (devtest[0] == 1) {\n        #pragma acc data copyin(c[0:n])\n        {\n            #pragma acc data copyin(a[0:n], b[0:n]) copyout(c[0:n])\n            {\n                #pragma acc parallel\n                {\n                    #pragma acc loop\n                    for (int x = 0; x < n; ++x){\n                        c[x] += a[x] + b[x];\n                    }\n                }\n            }\n            for (int x = 0; x < n; ++x){\n                if (fabs(c[x]) > PRECISION){\n                    err += 1;\n                    break;\n                }\n            }\n        }\n        for (int x = 0; x < n; ++x){\n            if (fabs(c[x]) > PRECISION){\n                err += 1;\n                break;\n            }\n        }\n\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "data",
                            "data-region",
                            "reference-counting",
                            "devonly",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "2": {
                        "content": "#ifndef T2\n//T2:data,data-region,reference-counting,construct-independent,V:2.5-2.7\nint test2(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n    real_t * c = (real_t *)malloc(n * sizeof(real_t));\n    int * devtest = (int *)malloc(sizeof(int));\n    devtest[0] = 1;\n    #pragma acc enter data copyin(devtest[0:1])\n    #pragma acc parallel present(devtest[0:1])\n    {\n      devtest[0] = 0;\n    }\n\n    for (int x = 0; x < n; ++x){\n      a[x] = rand() / (real_t)(RAND_MAX / 10);\n      b[x] = rand() / (real_t)(RAND_MAX / 10);\n      c[x] = 0.0;\n    }\n\n    #pragma acc enter data copyin(c[0:n])\n    #pragma acc data copyin(a[0:n], b[0:n]) copyout(c[0:n])\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                c[x] += a[x] + b[x];\n            }\n        }\n    }\n    if (devtest[0] == 1){\n        for (int x = 0; x < n; ++x){\n            if (fabs(c[x]) > PRECISION){\n                err += 1;\n                break;\n            }\n        }\n    }\n    #pragma acc exit data copyout(c[0:n])\n    for (int x = 0; x < n; ++x){\n        if (fabs(c[x] - (a[x] + b[x])) > PRECISION){\n            err += 1;\n            break;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T2\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test2();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 1);\n    }\n#endif\n",
                        "tags": [
                            "data",
                            "data-region",
                            "reference-counting",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "3": {
                        "content": "#ifndef T3\n//T3:data,data-region,construct-independent,V:2.5-2.7\nint test3(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n    real_t * c = (real_t *)malloc(n * sizeof(real_t));\n    int * devtest = (int *)malloc(sizeof(int));\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n        c[x] = 0.0;\n    }\n\n    #pragma acc enter data copyin(c[0:n])\n    #pragma acc data copyin(a[0:n], b[0:n]) copyout(c[0:n])\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                c[x] += a[x] + b[x];\n            }\n        }\n        #pragma acc exit data delete(c[0:n])\n    }\n    for (int x = 0; x < n; ++x){\n        if (fabs(c[x] - (a[x] + b[x])) > PRECISION){\n            err += 1;\n            break;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T3\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test3();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 2);\n    }\n#endif\n",
                        "tags": [
                            "data",
                            "data-region",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "data_create.F90": {
                "num tests": 3,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:data,data_region,construct-independent,V:1.0-2.7\n      LOGICAL FUNCTION test1()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT):: a, b, c !Data\n        INTEGER :: errors = 0\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(a)\n        b = 0\n        c = 0 \n\n        !$acc data create(b(1:LOOPCOUNT))\n          !$acc data copyin(a(1:LOOPCOUNT))\n            !$acc parallel\n              !$acc loop\n              DO x = 1, LOOPCOUNT\n                b(x) = a(x)\n              END DO\n            !$acc end parallel\n          !$acc end data\n          !$acc data copyout(c(1:LOOPCOUNT))\n            !$acc parallel\n              !$acc loop\n              DO x = 1, LOOPCOUNT\n                c(x) = b(x)\n              END DO\n            !$acc end parallel\n          !$acc end data\n        !$acc end data\n\n        DO x = 1, LOOPCOUNT\n          IF (abs(a(x) - c(x)) .gt. PRECISION) THEN\n            errors = errors + 1\n            EXIT\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "data",
                            "data_region",
                            "construct-independent"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "2": {
                        "content": "#ifndef T2\n!T2:data,data_region,construct-independent,V:1.0-2.7\n      LOGICAL FUNCTION test2()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT):: a, b, c !Data\n        INTEGER :: errors = 0\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(a)\n        b = 0\n        c = 0\n \n        !$acc data present_or_create(b(1:LOOPCOUNT))\n          !$acc data copyin(a(1:LOOPCOUNT))\n            !$acc parallel\n              !$acc loop\n              DO x = 1, LOOPCOUNT\n                b(x) = a(x)\n              END DO\n            !$acc end parallel\n          !$acc end data\n          !$acc data copyout(c(1:LOOPCOUNT))\n            !$acc parallel\n              !$acc loop\n              DO x = 1, LOOPCOUNT\n                c(x) = b(x)\n              END DO\n            !$acc end parallel\n          !$acc end data\n        !$acc end data\n \n        DO x = 1, LOOPCOUNT\n          IF (abs(a(x) - c(x)) .gt. PRECISION) THEN\n            errors = errors + 2\n            EXIT\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test2 = .FALSE.\n        ELSE\n          test2 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T2\n        LOGICAL :: test2\n#endif\n#ifndef T2\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test2()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 1\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "data",
                            "data_region",
                            "construct-independent"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "3": {
                        "content": "#ifndef T3\n!T3:data,data_region,construct-independent,V:1.0-2.7\n      LOGICAL FUNCTION test3()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT):: a, b, c !Data\n        INTEGER :: errors = 0\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(a)\n        b = 0\n        c = 0\n \n        !$acc data pcreate(b(1:LOOPCOUNT))\n          !$acc data copyin(a(1:LOOPCOUNT))\n            !$acc parallel\n              !$acc loop\n              DO x = 1, LOOPCOUNT\n                b(x) = a(x)\n              END DO\n            !$acc end parallel\n          !$acc end data\n          !$acc data copyout(c(1:LOOPCOUNT))\n            !$acc parallel\n              !$acc loop\n              DO x = 1, LOOPCOUNT\n                c(x) = b(x)\n              END DO\n            !$acc end parallel\n          !$acc end data\n        !$acc end data\n     \n        DO x = 1, LOOPCOUNT\n          IF (abs(a(x) - c(x)) .gt. PRECISION) THEN\n            errors = errors + 4\n            EXIT\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test3 = .FALSE.\n        ELSE\n          test3 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T3\n        LOGICAL :: test3\n#endif\n#ifndef T3\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test3()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 2\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "data",
                            "data_region",
                            "construct-independent"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "data_create.c": {
                "num tests": 3,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:data,data-region,construct-independent,V:1.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n    real_t * c = (real_t *)malloc(n * sizeof(real_t));\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = 0.0;\n        c[x] = 0.0;\n    }\n\n    #pragma acc data create(b[0:n])\n    {\n        #pragma acc data copyin(a[0:n])\n        {\n            #pragma acc parallel\n            {\n                #pragma acc loop\n                for (int x = 0; x < n; ++x){\n                    b[x] = a[x];\n                }\n            }\n        }\n        #pragma acc data copyout(c[0:n])\n        {\n            #pragma acc parallel\n            {\n                #pragma acc loop\n                for (int x = 0; x < n; ++x){\n                    c[x] = b[x];\n                }\n            }\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        if (fabs(c[x] - a[x]) > PRECISION) {\n            err += 1;\n            break;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "data",
                            "data-region",
                            "construct-independent"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "2": {
                        "content": "#ifndef T2\n//T2:data,data-region,construct-independent,compatibility-features,V:1.0-2.7\nint test2(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n    real_t * c = (real_t *)malloc(n * sizeof(real_t));\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = 0.0;\n        c[x] = 0.0;\n    }\n\n    #pragma acc data present_or_create(b[0:n])\n    {\n        #pragma acc data copyin(a[0:n])\n        {\n            #pragma acc parallel\n            {\n                #pragma acc loop\n                for (int x = 0; x < n; ++x){\n                    b[x] = a[x];\n                }\n            }\n        }\n        #pragma acc data copyout(c[0:n])\n        {\n            #pragma acc parallel\n            {\n                #pragma acc loop\n                for (int x = 0; x < n; ++x){\n                    c[x] = a[x];\n                }\n            }\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        if (fabs(c[x] - a[x]) > PRECISION) {\n            err += 2;\n            break;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T2\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test2();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 1);\n    }\n#endif\n",
                        "tags": [
                            "data",
                            "data-region",
                            "construct-independent",
                            "compatibility-features"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "3": {
                        "content": "#ifndef T3\n//T3:data,data-region,construct-independent,compatibility-features,V:1.0-2.7\nint test3(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n    real_t * c = (real_t *)malloc(n * sizeof(real_t));\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = 0.0;\n        c[x] = 0.0;\n    }\n\n    #pragma acc data pcreate(b[0:n])\n    {\n        #pragma acc data copyin(a[0:n])\n        {\n            #pragma acc parallel\n            {\n                #pragma acc loop\n                for (int x = 0; x < n; ++x){\n                    b[x] = a[x];\n                }\n            }\n        }\n        #pragma acc data copyout(c[0:n])\n        {\n            #pragma acc parallel\n            {\n                #pragma acc loop\n                for (int x = 0; x < n; ++x){\n                    c[x] = b[x];\n                }\n            }\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        if (fabs(c[x] - a[x]) > PRECISION){\n            err += 4;\n            break;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T3\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test3();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 2);\n    }\n#endif\n",
                        "tags": [
                            "data",
                            "data-region",
                            "construct-independent",
                            "compatibility-features"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "data_create_no_lower_bound.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:data,data_region,construct-independent,V:1.0-2.7\n      LOGICAL FUNCTION test1()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT):: a, b, c, d, e !Data\n        INTEGER :: errors = 0\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(a)\n        CALL RANDOM_NUMBER(b)\n        c = 0\n        CALL RANDOM_NUMBER(d)\n        e = 0\n\n        !$acc data copyin(a(1:LOOPCOUNT), b(1:LOOPCOUNT), d(1:LOOPCOUNT)) create(c(:LOOPCOUNT)) copyout(e(1:LOOPCOUNT))\n          !$acc parallel\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              c(x) = a(x) + b(x)\n            END DO\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              e(x) = c(x) + d(x)\n            END DO\n          !$acc end parallel\n        !$acc end data\n        DO x = 1, LOOPCOUNT\n          IF (abs(e(x) - (a(x) + b(x) + d(x))) .gt. PRECISION) THEN\n            errors = errors + 1\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "data",
                            "data_region",
                            "construct-independent"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "data_create_no_lower_bound.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:data,data-region,construct-independent,V:1.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n    real_t * c = (real_t *)malloc(n * sizeof(real_t));\n    real_t * d = (real_t *)malloc(n * sizeof(real_t));\n    real_t * e = (real_t *)malloc(n * sizeof(real_t));\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n        c[x] = 0.0;\n        d[x] = rand() / (real_t)(RAND_MAX / 10);\n        e[x] = 0.0;\n    }\n\n    #pragma acc data copyin(a[0:n], b[0:n], d[0:n]) create(c[:n]) copyout(e[0:n])\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                c[x] = a[x] + b[x];\n            }\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                e[x] = c[x] + d[x];\n            }\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        if (fabs(e[x] - (a[x] + b[x] + d[x])) > PRECISION){\n            err += 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "data",
                            "data-region",
                            "construct-independent"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "data_present_no_lower_bound.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:data,data_region,construct-independent,present,V:2.0-2.7\n      LOGICAL FUNCTION test1()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT):: a, b, c !Data\n        INTEGER :: errors = 0\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(a)\n        CALL RANDOM_NUMBER(b)\n        c = 0\n \n        !$acc enter data copyin(c(1:LOOPCOUNT))\n        !$acc data copyin(a(1:LOOPCOUNT), b(1:LOOPCOUNT)) present(c(:LOOPCOUNT))\n          !$acc parallel\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              c(x) = a(x) + b(x)\n            END DO\n          !$acc end parallel\n        !$acc end data\n        !$acc exit data copyout(c(1:LOOPCOUNT))\n        DO x = 1, LOOPCOUNT\n          IF (abs(c(x) - (a(x) + b(x))) .gt. PRECISION) THEN\n            errors = errors + 1\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "data",
                            "data_region",
                            "construct-independent",
                            "present"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "data_present_no_lower_bound.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:data,data-region,construct-independent,V:1.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n    real_t * c = (real_t *)malloc(n * sizeof(real_t));\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n        c[x] = 0.0;\n    }\n\n    #pragma acc enter data copyin(c[0:n])\n    #pragma acc data copyin(a[0:n], b[0:n]) present(c[:n])\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                c[x] += a[x] + b[x];\n            }\n        }\n    }\n    #pragma acc exit data copyout(c[0:n])\n\n    for (int x = 0; x < n; ++x){\n        if (fabs(c[x] - (a[x] + b[x])) > PRECISION){\n            err += 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "data",
                            "data-region",
                            "construct-independent"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "data_with_changing_subscript.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:data,data_region,construct-independent,V:1.0-2.7\n      LOGICAL FUNCTION test1()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x, indexer !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT):: a, b, c !Data\n        INTEGER :: errors = 0\n\n        indexer = LOOPCOUNT\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(a)\n        CALL RANDOM_NUMBER(b)\n        c = 0\n\n        !$acc data copyin(a(1:indexer), b(1:indexer)) copyout(c(1:indexer))\n          !$acc parallel\n            !$acc loop\n            DO x = 1, indexer\n              c(x) = a(x) + b(x)\n            END DO\n            indexer = 1\n          !$acc end parallel\n        !$acc end data\n        DO x = 1, LOOPCOUNT\n          IF (abs(c(x) - (a(x) + b(x))) .gt. PRECISION) THEN\n            errors = errors + 1\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "data",
                            "data_region",
                            "construct-independent"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "data_with_changing_subscript.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:data,data-region,construct-independent,V:2.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    int length = n;\n    real_t * a = (real_t *)malloc(n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n    real_t * c = (real_t *)malloc(n * sizeof(real_t));\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n        c[x] = 0.0;\n    }\n\n    #pragma acc data copyin(a[0:length], b[0:length]) copyout(c[0:length])\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < length; ++x){\n                c[x] = a[x] + b[x];\n            }\n        }\n        length = 1;\n    }\n\n    for (int x = 0; x < n; ++x){\n        if (fabs(c[x] - (a[x] + b[x])) > PRECISION){\n            err += 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "data",
                            "data-region",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "data_with_derived_type.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:data,data_region,construct-independent,V:1.0-2.7\n      LOGICAL FUNCTION test1()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        TYPE multi_item\n          REAL(8) :: a\n          REAL(8) :: b\n          REAL(8) :: c\n        END TYPE multi_item\n        INTEGER :: x !Iterators\n        TYPE (multi_item),DIMENSION(LOOPCOUNT):: a !Data\n        INTEGER :: errors = 0\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        DO x = 1, LOOPCOUNT\n          CALL RANDOM_NUMBER(a(x)%a)\n          CALL RANDOM_NUMBER(a(x)%b)\n          a(x)%c = 0.0\n        END DO\n\n        !$acc data copy(a(1:LOOPCOUNT))\n          !$acc parallel\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              a(x)%c = a(x)%a + a(x)%b\n            END DO\n          !$acc end parallel\n        !$acc end data\n        DO x = 1, LOOPCOUNT\n          IF (abs(a(x)%c - (a(x)%a + a(x)%b)) .gt. PRECISION) THEN\n            errors = errors + 1\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "data",
                            "data_region",
                            "construct-independent"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "data_with_structs.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:data,data-region,construct-independent,V:1.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    multi_item * a = (multi_item *)malloc(n * sizeof(multi_item));\n\n    for (int x = 0; x < n; ++x){\n        a[x].a = rand() / (real_t)(RAND_MAX / 10);\n        a[x].b = rand() / (real_t)(RAND_MAX / 10);\n        a[x].c = rand() / (real_t)(RAND_MAX / 10);\n    }\n\n    #pragma acc data copy(a[0:n])\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                a[x].c = a[x].a + a[x].b;\n            }\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        if (fabs(a[x].c - (a[x].a + a[x].b)) > PRECISION){\n            err += 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "data",
                            "data-region",
                            "construct-independent"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "declare_copyin.F90": {
                "num tests": 4,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:construct-independent,declare,V:2.0-2.7\n      LOGICAL FUNCTION test1()\n  USE OPENACC\n  USE DECLARE_COPYIN_MOD\n  IMPLICIT NONE\n  INCLUDE \"acc_testsuite.Fh\"\n  INTEGER :: errors = 0\n  INTEGER :: mult = 2\n  INTEGER :: x\n  REAL(8),DIMENSION(LOOPCOUNT) :: a, b\n\n  SEEDDIM(1) = 1\n# ifdef SEED\n  SEEDDIM(1) = SEED\n# endif\n  CALL RANDOM_SEED(PUT=SEEDDIM)\n\n  CALL RANDOM_NUMBER(a)\n  b = 0\n\n  !$acc data copyin(a(1:LOOPCOUNT)) copyout(b(1:LOOPCOUNT)) present(fixed_size_array)\n    !$acc parallel\n      !$acc loop\n      DO x = 1, LOOPCOUNT\n        b(x) = a(x) + fixed_size_array(MOD(x, 10))\n      END DO\n    !$acc end parallel\n  !$acc end data\n\n  DO x = 1, LOOPCOUNT\n    IF (abs(b(x) - (a(x) + fixed_size_array(MOD(x, 10)))) .gt. PRECISION) THEN\n      errors = errors + 1\n    END IF\n  END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "construct-independent",
                            "declare"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "2": {
                        "content": "#ifndef T2\n!T2:construct-independent,declare,V:1.0-2.7\n      LOGICAL FUNCTION test2()\n  USE OPENACC\n  USE DECLARE_COPYIN_MOD\n  IMPLICIT NONE\n  INCLUDE \"acc_testsuite.Fh\"\n  INTEGER :: errors = 0\n  INTEGER :: mult = 2\n  REAL(8),DIMENSION(LOOPCOUNT) :: a, b\n\n  SEEDDIM(1) = 1\n# ifdef SEED\n  SEEDDIM(1) = SEED\n# endif\n  CALL RANDOM_SEED(PUT=SEEDDIM)\n\n  CALL RANDOM_NUMBER(a)\n  b = 0\n\n  !$acc data copyin(a(1:LOOPCOUNT)) copyout(b(1:LOOPCOUNT)) present(scalar)\n    !$acc parallel\n      !$acc loop\n      DO x = 1, LOOPCOUNT\n        b(x) = a(x) + scalar\n      END DO\n    !$acc end parallel\n  !$acc end data\n\n  DO x = 1, LOOPCOUNT\n    IF (abs(b(x) - (a(x) + scalar)) .gt. PRECISION) THEN\n      errors = errors + 1\n    END IF\n  END DO\n\n        IF (errors .eq. 0) THEN\n          test2 = .FALSE.\n        ELSE\n          test2 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T2\n        LOGICAL :: test2\n#endif\n#ifndef T2\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test2()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 1\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "construct-independent",
                            "declare"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "3": {
                        "content": "#ifndef T3\n!T3:construct-independent,declare,V:1.0-2.7\n      LOGICAL FUNCTION test3()\n  USE OPENACC\n  USE DECLARE_COPYIN_MOD\n  IMPLICIT NONE\n  INCLUDE \"acc_testsuite.Fh\"\n  INTEGER :: errors = 0\n  INTEGER :: mult = 2\n  REAL(8),DIMENSION(LOOPCOUNT) :: a, b\n\n  SEEDDIM(1) = 1\n# ifdef SEED\n  SEEDDIM(1) = SEED\n# endif\n  CALL RANDOM_SEED(PUT=SEEDDIM)\n\n  CALL RANDOM_NUMBER(a)\n  b = a\n\n  !$acc data copy(a(1:LOOPCOUNT))\n    !$acc parallel\n      !$acc loop\n      DO x = 1, 1\n        CALL externMultiplyData(a, LOOPCOUNT)\n      END DO\n    !$acc end parallel\n  !$acc end data\n\n  DO x = 1, LOOPCOUNT\n    IF (abs(a(x) - (b(x) * 2)) .gt. PRECISION) THEN\n      errors = errors + 1\n    END IF\n  END DO\n\n        IF (errors .eq. 0) THEN\n          test3 = .FALSE.\n        ELSE\n          test3 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T3\n        LOGICAL :: test3\n#endif\n#ifndef T3\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test3()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 2\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "construct-independent",
                            "declare"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "4": {
                        "content": "#ifndef T4\n!T4:construct-independent,declare,V:1.0-2.7\n      LOGICAL FUNCTION test4()\n  USE OPENACC\n  USE DECLARE_COPYIN_MOD\n  IMPLICIT NONE\n  INCLUDE \"acc_testsuite.Fh\"\n  INTEGER :: errors = 0\n  INTEGER :: mult = 2\n  REAL(8),DIMENSION(LOOPCOUNT) :: a, b\n\n  SEEDDIM(1) = 1\n# ifdef SEED\n  SEEDDIM(1) = SEED\n# endif\n  CALL RANDOM_SEED(PUT=SEEDDIM)\n\n  CALL RANDOM_NUMBER(a)\n  b = a\n\n  !$acc data copy(a(1:LOOPCOUNT))\n    !$acc parallel\n      !$acc loop\n      DO x = 1, 1\n        CALL multiplyData(a)\n      END DO\n    !$acc end parallel\n  !$acc end data\n\n  DO x = 1, LOOPCOUNT\n    IF (abs(a(x) - (b(x) * 2)) .gt. PRECISION) THEN\n      errors = errors + 1\n    END IF\n  END DO\n\n        IF (errors .eq. 0) THEN\n          test4 = .FALSE.\n        ELSE\n          test4 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T4\n        LOGICAL :: test4\n#endif\n#ifndef T4\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test4()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 3\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "construct-independent",
                            "declare"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "declare_copyin.c": {
                "num tests": 5,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:declare,construct-independent,V:1.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n    int mult = 2;\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = 0;\n    }\n    #pragma acc data copyin(a[0:n]) copyout(b[0:n]) present(fixed_size_array)\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                b[x] = a[x] + fixed_size_array[x%10];\n            }\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        if (fabs(b[x] - (a[x] + fixed_size_array[x%10])) > PRECISION){\n            err += 1;\n            break;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "declare",
                            "construct-independent"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "2": {
                        "content": "#ifndef T2\n//T2:declare,construct-independent,V:1.0-2.7\nint test2(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n    int mult = 2;\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = 0;\n    }\n\n    #pragma acc data copyin(a[0:n]) copyout(b[0:n]) present(scalar)\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                b[x] = a[x] + scalar;\n            }\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        if (fabs(b[x] - (a[x] + scalar)) > PRECISION){\n            err += 1;\n            break;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T2\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test2();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 1);\n    }\n#endif\n",
                        "tags": [
                            "declare",
                            "construct-independent"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "3": {
                        "content": "#ifndef T3\n//T3:declare,construct-independent,V:2.0-2.7\nint test3(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n    int mult = 2;\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = a[x];\n    }\n\n    #pragma acc data copy(a[0:n])\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < 1; ++x){\n                extern_multiplyData_copyin(a, n);\n            }\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        if (fabs(a[x] - (b[x] * 2)) > PRECISION){\n            err += 1;\n            break;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T3\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test3();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 2);\n    }\n#endif\n",
                        "tags": [
                            "declare",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "4": {
                        "content": "#ifndef T4\n//T4:declare,construct-independent,V:2.0-2.7\nint test4(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n    int mult = 2;\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = a[x];\n    }\n\n    #pragma acc data copy(a[0:n])\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < 1; ++x){\n                multiplyData(a);\n            }\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        if (fabs(a[x] - (b[x] * 2)) > PRECISION){\n            err += 1;\n            break;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T4\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test4();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 3);\n    }\n#endif\n",
                        "tags": [
                            "declare",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "5": {
                        "content": "#ifndef T5\n//T5:declare,construct-independent,attach,V:2.6-2.7\nint test5(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n    int mult = 2;\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = a[x];\n    }\n\n    datapointer = a;\n    #pragma acc enter data copyin(a[0:n]) attach(datapointer)\n    #pragma acc data present(datapointer[0:n])\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                datapointer[x] = datapointer[x] * 2;\n            }\n        }\n    }\n    #pragma acc exit data copyout(a[0:n])\n\n    for (int x = 0; x < n; ++x){\n        if (fabs(a[x] - (b[x] * 2)) > PRECISION){\n            err += 1;\n            break;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T5\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test5();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 4);\n    }\n#endif\n",
                        "tags": [
                            "declare",
                            "construct-independent",
                            "attach"
                        ],
                        "versions": [
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "declare_copyin_mod.F90": {
                "num tests": 0,
                "tests": {}
            },
            "declare_create.F90": {
                "num tests": 4,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:construct-independent,declare,update,V:2.0-2.7\n      LOGICAL FUNCTION test1()\n  USE OPENACC\n  IMPLICIT NONE\n  INCLUDE \"acc_testsuite.Fh\"\n  INTEGER :: errors = 0\n  INTEGER :: mult = 2\n  REAL(8),DIMENSION(LOOPCOUNT) :: a, b\n\n  SEEDDIM(1) = 1\n# ifdef SEED\n  SEEDDIM(1) = SEED\n# endif\n  CALL RANDOM_SEED(PUT=SEEDDIM)\n\n  CALL RANDOM_NUMBER(a)\n  b = 0\n  !$acc update device(n)\n  !$acc data copyin(a(1:LOOPCOUNT)) copyout(b(1:LOOPCOUNT)) present(fixed_size_array)\n    !$acc parallel\n      !$acc loop\n      DO x = 1, 10\n        fixed_size_array(x) = x * x\n      END DO\n    !$acc end parallel\n    !$acc parallel\n      !$acc loop\n      DO x = 1, LOOPCOUNT\n        b(x) = a(x) + fixed_size_array(MOD(x, 10))\n      END DO\n    !$acc end parallel\n  !$acc end data\n\n  DO x = 1, LOOPCOUNT\n    IF (abs(b(x) - (a(x) + (MOD(x, 10) * MOD(x, 10)))) .gt. PRECISION) THEN\n      errors = errors + 1\n    END IF\n  END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "construct-independent",
                            "declare",
                            "update"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "2": {
                        "content": "#ifndef T2\n!T2:construct-independent,declare,update,V:2.0-2.7\n      LOGICAL FUNCTION test2()\n  USE OPENACC\n  IMPLICIT NONE\n  INCLUDE \"acc_testsuite.Fh\"\n  INTEGER :: errors = 0\n  INTEGER :: mult = 2\n  REAL(8),DIMENSION(LOOPCOUNT) :: a, b\n\n  SEEDDIM(1) = 1\n# ifdef SEED\n  SEEDDIM(1) = SEED\n# endif\n  CALL RANDOM_SEED(PUT=SEEDDIM)\n\n  CALL RANDOM_NUMBER(a)\n  b = 0\n  scalar = 10\n  !$acc update device(scalar)\n  !$acc data copyin(a(1:LOOPCOUNT)) copyout(b(1:LOOPCOUNT)) present(scalar)\n    !$acc parallel\n      !$acc loop\n      DO x = 1, LOOPCOUNT\n        b(x) = a(x) + scalar\n      END DO\n    !$acc end parallel\n  !$acc end data\n\n  DO x = 1, LOOPCOUNT\n    IF (abs(b(x) - (a(x) + scalar)) .gt. PRECISION) THEN\n      errors = errors + 1\n    END IF\n  END DO\n\n        IF (errors .eq. 0) THEN\n          test2 = .FALSE.\n        ELSE\n          test2 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T2\n        LOGICAL :: test2\n#endif\n#ifndef T2\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test2()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 1\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "construct-independent",
                            "declare",
                            "update"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "3": {
                        "content": "#ifndef T3\n!T3:construct-independent,declare,V:2.0-2.7\n      LOGICAL FUNCTION test3()\n  USE OPENACC\n  IMPLICIT NONE\n  INCLUDE \"acc_testsuite.Fh\"\n  INTEGER :: errors = 0\n  INTEGER :: mult = 2\n  REAL(8),DIMENSION(LOOPCOUNT) :: a, b\n\n  SEEDDIM(1) = 1\n# ifdef SEED\n  SEEDDIM(1) = SEED\n# endif\n  CALL RANDOM_SEED(PUT=SEEDDIM)\n\n  CALL RANDOM_NUMBER(a)\n  b = a\n  !$acc update\n  !$acc data copy(a(1:LOOPCOUNT))\n    !$acc parallel\n      !$acc loop\n      DO x = 1, 1\n        CALL externMultiplyData(a, LOOPCOUNT)\n      END DO\n    !$acc end parallel\n  !$acc end data\n\n  DO x = 1, LOOPCOUNT\n    IF (abs(a(x) - (b(x) * 2)) .gt. PRECISION) THEN\n      errors = errors + 1\n    END IF\n  END DO\n\n        IF (errors .eq. 0) THEN\n          test3 = .FALSE.\n        ELSE\n          test3 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T3\n        LOGICAL :: test3\n#endif\n#ifndef T3\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test3()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 2\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "construct-independent",
                            "declare"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "4": {
                        "content": "#ifndef T4\n!T4:construct-independent,declare,V:2.0-2.7\n      LOGICAL FUNCTION test4()\n  USE OPENACC\n  IMPLICIT NONE\n  INCLUDE \"acc_testsuite.Fh\"\n  INTEGER :: errors = 0\n  INTEGER :: mult = 2\n  REAL(8),DIMENSION(LOOPCOUNT) :: a, b\n\n  SEEDDIM(1) = 1\n# ifdef SEED\n  SEEDDIM(1) = SEED\n# endif\n  CALL RANDOM_SEED(PUT=SEEDDIM)\n\n  CALL RANDOM_NUMBER(a)\n  b = a\n\n  !$acc data copy(a(1:LOOPCOUNT))\n    !$acc parallel\n      !$acc loop\n      DO x = 1, 1\n        CALL multiplyData(a)\n      END DO\n    !$acc end parallel\n  !$acc end data\n\n  DO x = 1, LOOPCOUNT\n    IF (abs(a(x) - (b(x) * 2)) .gt. PRECISION) THEN\n      errors = errors + 1\n    END IF\n  END DO\n\n        IF (errors .eq. 0) THEN\n          test4 = .FALSE.\n        ELSE\n          test4 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T4\n        LOGICAL :: test4\n#endif\n#ifndef T4\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test4()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 3\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "construct-independent",
                            "declare"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "declare_create.c": {
                "num tests": 5,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:declare,construct-independent,V:1.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n    int mult = 2;\n    #pragma acc update device(n)\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = 0;\n    }\n\n    #pragma acc data copyin(a[0:n]) copyout(b[0:n]) present(fixed_size_array)\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < 10; ++x){\n                fixed_size_array[x] = x*x;\n            }\n        }\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                b[x] = a[x] + fixed_size_array[x%10];\n            }\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        if (fabs(b[x] - (a[x] + (x%10) * (x%10))) > PRECISION){\n            err += 1;\n            break;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "declare",
                            "construct-independent"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "2": {
                        "content": "#ifndef T2\n//T2:declare,construct-independent,V:1.0-2.7\nint test2(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n    int mult = 2;\n    #pragma acc update device(n)\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = 0;\n    }\n\n    scalar = 10;\n    #pragma acc update device(scalar)\n    #pragma acc data copyin(a[0:n]) copyout(b[0:n])\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                b[x] = a[x] + scalar;\n            }\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        if (fabs(b[x] - (a[x] + 10)) > PRECISION){\n            err += 1;\n            break;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T2\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test2();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 1);\n    }\n#endif\n",
                        "tags": [
                            "declare",
                            "construct-independent"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "3": {
                        "content": "#ifndef T3\n//T3:declare,construct-independent,V:1.0-2.7\nint test3(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n    int mult = 2;\n    #pragma acc update device(n)\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = a[x];\n    }\n\n    #pragma acc update device(mult_create)\n    #pragma acc data copy(a[0:n])\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < 1; ++x){\n                extern_multiplyData_create(a, n);\n            }\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        if (fabs(a[x] - (b[x] * 2)) > PRECISION){\n            err += 1;\n            break;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T3\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test3();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 2);\n    }\n#endif\n",
                        "tags": [
                            "declare",
                            "construct-independent"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "4": {
                        "content": "#ifndef T4\n//T4:declare,construct-independent,V:2.0-2.7\nint test4(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n    int mult = 2;\n    #pragma acc update device(n)\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = a[x];\n    }\n    #pragma acc data copy(a[0:n])\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < 1; ++x){\n                multiplyData(a);\n            }\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        if (fabs(a[x] - (b[x] * 2)) > PRECISION){\n            err += 1;\n            break;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T4\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test4();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 3);\n    }\n#endif\n",
                        "tags": [
                            "declare",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "5": {
                        "content": "#ifndef T5\n//T5:declare,construct-independent,V:2.6-2.7\nint test5(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n    int mult = 2;\n    #pragma acc update device(n)\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = a[x];\n    }\n    datapointer = a;\n\n    #pragma acc data copyin(a[0:n]) attach(datapointer)\n    {\n        #pragma acc parallel present(datapointer[0:n])\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                datapointer[x] = datapointer[x] * 2;\n            }\n        }\n    }\n\n    #pragma acc exit data copyout(a[0:n])\n    for (int x = 0; x < n; ++x){\n        if (fabs(a[x] - (b[x] * 2)) > PRECISION){\n            err += 1;\n            break;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T5\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test5();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 4);\n    }\n#endif\n",
                        "tags": [
                            "declare",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "declare_device_resident.c": {
                "num tests": 3,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:declare,construct-independent,V:1.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n    int mult = 2;\n\n    #pragma acc parallel\n    {\n      mult_device_resident = 2;\n      scalar = 10;\n      for (int x = 0; x < 10; ++x){\n        fixed_size_array[x] = x*x;\n      }\n    }\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = 0;\n    }\n\n    #pragma acc data copyin(a[0:n]) copyout(b[0:n]) present(fixed_size_array)\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < 10; ++x){\n                fixed_size_array[x] = x*x;\n            }\n        }\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                b[x] = a[x] + fixed_size_array[x%10];\n            }\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        if (fabs(b[x] - (a[x] + (x%10) * (x%10))) > PRECISION){\n            err += 1;\n            break;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "declare",
                            "construct-independent"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "2": {
                        "content": "#ifndef T2\n//T2:declare,construct-independent,V:1.0-2.7\nint test2(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n    int mult = 2;\n\n    #pragma acc parallel\n    {\n      mult_device_resident = 2;\n      scalar = 10;\n      for (int x = 0; x < 10; ++x){\n        fixed_size_array[x] = x*x;\n      }\n    }\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = 0;\n    }\n\n    #pragma acc data copyin(a[0:n]) copyout(b[0:n])\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                b[x] = a[x] + scalar;\n            }\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        if (fabs(b[x] - (a[x] + 10)) > PRECISION){\n            err += 1;\n            break;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T2\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test2();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 1);\n    }\n#endif\n",
                        "tags": [
                            "declare",
                            "construct-independent"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "3": {
                        "content": "#ifndef T3\n//T3:declare,construct-independent,V:2.0-2.7\nint test3(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n    int mult = 2;\n\n    #pragma acc parallel\n    {\n      mult_device_resident = 2;\n      scalar = 10;\n      for (int x = 0; x < 10; ++x){\n        fixed_size_array[x] = x*x;\n      }\n    }\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = a[x];\n    }\n\n    #pragma acc data copy(a[0:n])\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < 1; ++x){\n                extern_multiplyData_device_resident(a, n);\n            }\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        if (fabs(a[x] - (b[x] * 2)) > PRECISION){\n            err += 1;\n            break;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T3\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test3();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 2);\n    }\n#endif\n",
                        "tags": [
                            "declare",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "declare_function_scope_copy.F90": {
                "num tests": 4,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:devonly,construct-independent,declare,V:2.0-2.7\n      LOGICAL FUNCTION test1()\n  USE OPENACC\n  IMPLICIT NONE\n  INCLUDE \"acc_testsuite.Fh\"\n  INTEGER :: errors = 0\n  INTEGER :: mult = 2\n  REAL(8),DIMENSION(LOOPCOUNT, LOOPCOUNT) :: a, b, c\n  INTEGER,DIMENSION(1) :: devtest\n  INTEGER :: x, y\n\n  devtest(1) = 1\n  !$acc enter data copyin(devtest(1:1))\n  !$acc parallel present(devtest(1:1))\n    devtest(1) = 0\n  !$acc end parallel\n\n  SEEDDIM(1) = 1\n# ifdef SEED\n  SEEDDIM(1) = SEED\n# endif\n  CALL RANDOM_SEED(PUT=SEEDDIM)\n\n  CALL RANDOM_NUMBER(a)\n  CALL RANDOM_NUMBER(b)\n  c = 1\n  !$acc data copyin(a(1:LOOPCOUNT, 1:LOOPCOUNT), b(1:LOOPCOUNT, 1:LOOPCOUNT))\n    DO x = 1, LOOPCOUNT\n      CALL copyin_copyout_test(a(:,x), b(:,x), c(:,x), LOOPCOUNT)\n    END DO\n  !$acc end data\n  DO x = 1, LOOPCOUNT\n    DO y = 1, LOOPCOUNT\n      IF (abs(c(x, y) - (1 + a(x, y) + b(x, y))) .gt. PRECISION) THEN\n        errors = errors + 1\n      END IF\n    END DO\n  END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "devonly",
                            "construct-independent",
                            "declare"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "2": {
                        "content": "#ifndef T2\n!T2:devonly,construct-independent,declare,V:2.0-2.7\n      LOGICAL FUNCTION test2()\n  USE OPENACC\n  IMPLICIT NONE\n  INCLUDE \"acc_testsuite.Fh\"\n  INTEGER :: errors = 0\n  INTEGER :: mult = 2\n  REAL(8),DIMENSION(LOOPCOUNT, LOOPCOUNT) :: a, b, c\n  INTEGER,DIMENSION(1) :: devtest\n  INTEGER :: x, y\n\n  devtest(1) = 1\n  !$acc enter data copyin(devtest(1:1))\n  !$acc parallel present(devtest(1:1))\n    devtest(1) = 0\n  !$acc end parallel\n\n  SEEDDIM(1) = 1\n# ifdef SEED\n  SEEDDIM(1) = SEED\n# endif\n  CALL RANDOM_SEED(PUT=SEEDDIM)\n\n  CALL RANDOM_NUMBER(a)\n  CALL RANDOM_NUMBER(b)\n  c = 2\n\n  !$acc data copyin(a(1:LOOPCOUNT, 1:LOOPCOUNT), b(1:LOOPCOUNT, 1:LOOPCOUNT))\n    DO x = 1, LOOPCOUNT\n      !$acc data copy(c(1:LOOPCOUNT, x:x))\n        CALL copyin_copyout_test(a(:,x), b(:,x), c(:,x), LOOPCOUNT)\n      !$acc end data\n    END DO\n  !$acc end data\n\n  DO x = 1, LOOPCOUNT\n    DO y = 1, LOOPCOUNT\n      IF (abs(c(x, y) - (2 + a(x, y) + b(x, y))) .gt. PRECISION) THEN\n        errors = errors + 1\n      END IF\n    END DO\n  END DO\n\n        IF (errors .eq. 0) THEN\n          test2 = .FALSE.\n        ELSE\n          test2 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T2\n        LOGICAL :: test2\n#endif\n#ifndef T2\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test2()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 1\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "devonly",
                            "construct-independent",
                            "declare"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "3": {
                        "content": "#ifndef T3\n!T3:devonly,construct-independent,declare,V:2.0-2.7\n      LOGICAL FUNCTION test3()\n  USE OPENACC\n  IMPLICIT NONE\n  INCLUDE \"acc_testsuite.Fh\"\n  INTEGER :: errors = 0\n  INTEGER :: mult = 2\n  REAL(8),DIMENSION(LOOPCOUNT, LOOPCOUNT) :: a, b, c\n  INTEGER,DIMENSION(1) :: devtest\n  INTEGER :: x, y\n\n  devtest(1) = 1\n  !$acc enter data copyin(devtest(1:1))\n  !$acc parallel present(devtest(1:1))\n    devtest(1) = 0\n  !$acc end parallel\n\n  SEEDDIM(1) = 1\n# ifdef SEED\n  SEEDDIM(1) = SEED\n# endif\n  CALL RANDOM_SEED(PUT=SEEDDIM)\n\n  IF (devtest(1) .eq. 1) THEN\n    CALL RANDOM_NUMBER(a)\n    CALL RANDOM_NUMBER(b)\n    c = 3\n\n    !$acc data copyin(a(1:LOOPCOUNT, 1:LOOPCOUNT), b(1:LOOPCOUNT, 1:LOOPCOUNT))\n      DO x = 1, LOOPCOUNT\n        !$acc data copyin(c(1:LOOPCOUNT, x:x))\n          CALL copyin_copyout_test(a(:,x), b(:,x), c(:,x), LOOPCOUNT)\n          DO y = 1, LOOPCOUNT\n            IF (abs(c(y, x) - 3) .gt. PRECISION) THEN\n              errors = errors + 1\n            END IF\n          END DO\n        !$acc end data\n        DO y = 1, LOOPCOUNT\n          IF (abs(c(y, x) - 3) .gt. PRECISION) THEN\n            errors = errors + 1\n          END IF\n        END DO\n      END DO\n    !$acc end data\n  END IF\n\n        IF (errors .eq. 0) THEN\n          test3 = .FALSE.\n        ELSE\n          test3 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T3\n        LOGICAL :: test3\n#endif\n#ifndef T3\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test3()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 2\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "devonly",
                            "construct-independent",
                            "declare"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "4": {
                        "content": "#ifndef T4\n!T4:devonly,construct-independent,declare,V:2.0-2.7\n      LOGICAL FUNCTION test4()\n  USE OPENACC\n  IMPLICIT NONE\n  INCLUDE \"acc_testsuite.Fh\"\n  INTEGER :: errors = 0\n  INTEGER :: mult = 2\n  REAL(8),DIMENSION(LOOPCOUNT, LOOPCOUNT) :: a, b, c\n  INTEGER,DIMENSION(1) :: devtest\n  INTEGER :: x, y\n\n  devtest(1) = 1\n  !$acc enter data copyin(devtest(1:1))\n  !$acc parallel present(devtest(1:1))\n    devtest(1) = 0\n  !$acc end parallel\n\n  SEEDDIM(1) = 1\n# ifdef SEED\n  SEEDDIM(1) = SEED\n# endif\n  CALL RANDOM_SEED(PUT=SEEDDIM)\n\n  IF (devtest(1) .eq. 1) THEN\n    CALL RANDOM_NUMBER(a)\n    CALL RANDOM_NUMBER(b)\n    c = 4\n\n    !$acc data copyin(a(1:LOOPCOUNT, 1:LOOPCOUNT), b(1:LOOPCOUNT, 1:LOOPCOUNT))\n      DO x = 1, LOOPCOUNT\n        !$acc data copy(c(1:LOOPCOUNT, x:x))\n          CALL copyin_copyout_test(a(:,x), b(:,x), c(:,x), LOOPCOUNT)\n          DO y = 1, LOOPCOUNT\n            IF (abs(c(y, x) - 4) .gt. PRECISION) THEN\n              errors = errors + 1\n            END IF\n          END DO\n        !$acc end data\n        DO y = 1, LOOPCOUNT\n          IF (abs(c(y, x) - (4 + a(y, x) + b(y, x))) .gt. PRECISION) THEN\n            errors = errors + 1\n          END IF\n        END DO\n      END DO\n    !$acc end data\n  END IF\n\n        IF (errors .eq. 0) THEN\n          test4 = .FALSE.\n        ELSE\n          test4 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T4\n        LOGICAL :: test4\n#endif\n#ifndef T4\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test4()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 3\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "devonly",
                            "construct-independent",
                            "declare"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "declare_function_scope_copy.c": {
                "num tests": 4,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:declare,construct-independent,V:1.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t ** a = (real_t **)malloc(n * sizeof(real_t));\n    real_t ** b = (real_t **)malloc(n * sizeof(real_t));\n    real_t ** c = (real_t **)malloc(n * sizeof(real_t));\n\n    for (int x = 0; x < n; ++x){\n        a[x] = (real_t *)malloc(n * sizeof(real_t));\n        b[x] = (real_t *)malloc(n * sizeof(real_t));\n        c[x] = (real_t *)malloc(n * sizeof(real_t));\n        for (int y = 0; y < n; ++y){\n            a[x][y] = rand() / (real_t)(RAND_MAX / 10);\n            b[x][y] = rand() / (real_t)(RAND_MAX / 10);\n            c[x][y] = 1;\n        }\n    }\n    #pragma acc data copyin(a[0:n][0:n], b[0:n][0:n])\n    {\n        for (int x = 0; x < n; ++x){\n            copyin_copyout_test(a[x], b[x], c[x]);\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        for (int y = 0; y < n; ++y){\n            if (fabs(c[x][y] - (1 + a[x][y] + b[x][y])) > PRECISION){\n                err += 1;\n            }\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "declare",
                            "construct-independent"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "2": {
                        "content": "#ifndef T2\n//T2:declare,construct-independent,reference-counting,V:2.5-2.7\nint test2(){\n    int err = 0;\n    srand(SEED);\n    real_t ** a = (real_t **)malloc(n * sizeof(real_t));\n    real_t ** b = (real_t **)malloc(n * sizeof(real_t));\n    real_t ** c = (real_t **)malloc(n * sizeof(real_t));\n\n    for (int x = 0; x < n; ++x){\n        for (int y = 0; y < n; ++y){\n            a[x][y] = rand() / (real_t)(RAND_MAX / 10);\n            b[x][y] = rand() / (real_t)(RAND_MAX / 10);\n            c[x][y] = 2;\n        }\n    }\n\n    #pragma acc data copyin(a[0:n][0:n], b[0:n][0:n])\n    {\n        for (int x = 0; x < n; ++x){\n            #pragma acc data copy(c[x:1][0:n])\n            {\n                copyin_copyout_test(a[x], b[x], c[x]);\n            }\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        for (int y = 0; y < n; ++y){\n            if (fabs(c[x][y] - (2 + a[x][y] + b[x][y])) > PRECISION){\n                err += 1;\n            }\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T2\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test2();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 1);\n    }\n#endif\n",
                        "tags": [
                            "declare",
                            "construct-independent",
                            "reference-counting"
                        ],
                        "versions": [
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "3": {
                        "content": "#ifndef T3\n//T3:declare,construct-independent,devonly,reference-counting,V:2.5-2.7\nint test3(){\n    int err = 0;\n    srand(SEED);\n    real_t ** a = (real_t **)malloc(n * sizeof(real_t));\n    real_t ** b = (real_t **)malloc(n * sizeof(real_t));\n    real_t ** c = (real_t **)malloc(n * sizeof(real_t));\n    int *devtest = (int *)malloc(sizeof(int));\n\n    devtest[0] = 1;\n    #pragma acc enter data copyin(devtest[0:1])\n    #pragma acc parallel present(devtest[0:1])\n    {\n        devtest[0] = 0;\n    }\n\n    if (devtest[0] == 1){\n        for (int x = 0; x < n; ++x){\n            for (int y = 0; y < n; ++y){\n                a[x][y] = rand() / (real_t)(RAND_MAX / 10);\n                b[x][y] = rand() / (real_t)(RAND_MAX / 10);\n                c[x][y] = 3;\n            }\n        }\n\n        #pragma acc data copyin(a[0:n][0:n], b[0:n][0:n])\n        {\n            for (int x = 0; x < n; ++x){\n                #pragma acc data copyin(c[x:1][0:n])\n                {\n                    copyin_copyout_test(a[x], b[x], c[x]);\n                    for (int y = 0; y < n; ++y){\n                        if (fabs(c[x][y] - 3) > PRECISION){\n                            err += 1;\n                        }\n                    }\n                }\n                for (int y = 0; y < n; ++y){\n                    if (fabs(c[x][y] - 3) > PRECISION){\n                        err += 1;\n                    }\n                }\n            }\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T3\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test3();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 2);\n    }\n#endif\n",
                        "tags": [
                            "declare",
                            "construct-independent",
                            "devonly",
                            "reference-counting"
                        ],
                        "versions": [
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "4": {
                        "content": "#ifndef T4\n//T4:declare,construct-independent,devonly,reference-counting,V:2.5-2.7\nint test4(){\n    int err = 0;\n    srand(SEED);\n    real_t ** a = (real_t **)malloc(n * sizeof(real_t));\n    real_t ** b = (real_t **)malloc(n * sizeof(real_t));\n    real_t ** c = (real_t **)malloc(n * sizeof(real_t));\n    int *devtest = (int *)malloc(sizeof(int));\n\n    devtest[0] = 1;\n    #pragma acc enter data copyin(devtest[0:1])\n    #pragma acc parallel present(devtest[0:1])\n    {\n        devtest[0] = 0;\n    }\n\n    if (devtest[1] == 1){\n        for (int x = 0; x < n; ++x){\n            for (int y = 0; y < n; ++y){\n                a[x][y] = rand() / (real_t)(RAND_MAX / 10);\n                b[x][y] = rand() / (real_t)(RAND_MAX / 10);\n                c[x][y] = 4;\n            }\n        }\n\n        #pragma acc data copyin(a[0:n][0:n], b[0:n][0:n])\n        {\n            for (int x = 0; x < n; ++x){\n                #pragma acc data copy(c[x:1][0:n])\n                {\n                    copyin_copyout_test(a[x], b[x], c[x]);\n                    for (int y = 0; y < n; ++y){\n                        if (fabs(c[x][y] - 4) > PRECISION){\n                            err += 1;\n                        }\n                    }\n                }\n                for (int y = 0; y < n; ++y){\n                    if (fabs(c[x][y] - (4 + a[x][y] + b[x][y])) > PRECISION){\n                        err += 1;\n                    }\n                }\n            }\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T4\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test4();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 3);\n    }\n#endif\n",
                        "tags": [
                            "declare",
                            "construct-independent",
                            "devonly",
                            "reference-counting"
                        ],
                        "versions": [
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "declare_function_scope_copyin.F90": {
                "num tests": 3,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:devonly,construct-independent,declare,V:2.0-2.7\n      LOGICAL FUNCTION test1()\n  USE OPENACC\n  IMPLICIT NONE\n  INCLUDE \"acc_testsuite.Fh\"\n  INTEGER :: errors = 0\n  INTEGER :: mult = 2\n  REAL(8),DIMENSION(LOOPCOUNT, LOOPCOUNT) :: a, b, c, a_host, b_host\n  INTEGER,DIMENSION(1) :: devtest\n  INTEGER :: x, y\n\n  devtest(1) = 1\n  !$acc enter data copyin(devtest(1:1))\n  !$acc parallel present(devtest(1:1))\n    devtest(1) = 0\n  !$acc end parallel\n\n  SEEDDIM(1) = 1\n# ifdef SEED\n  SEEDDIM(1) = SEED\n# endif\n  CALL RANDOM_SEED(PUT=SEEDDIM)\n\n  CALL RANDOM_NUMBER(a)\n  CALL RANDOM_NUMBER(b)\n  c = 1\n\n  !$acc data copy(c(1:LOOPCOUNT, 1:LOOPCOUNT))\n    DO x = 1, LOOPCOUNT\n      CALL function_test(a(:,x), b(:,x), c(:,x), LOOPCOUNT)\n    END DO\n  !$acc end data\n\n  DO x = 1, LOOPCOUNT\n    DO y = 1, LOOPCOUNT\n      IF (abs(c(x, y) - (1 + a(x, y) + b(x, y))) .gt. PRECISION) THEN\n        errors = errors + 1\n        PRINT*, \"1\"\n      END IF\n    END DO\n  END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "devonly",
                            "construct-independent",
                            "declare"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "2": {
                        "content": "#ifndef T2\n!T2:devonly,construct-independent,declare,V:2.0-2.7\n      LOGICAL FUNCTION test2()\n  USE OPENACC\n  IMPLICIT NONE\n  INCLUDE \"acc_testsuite.Fh\"\n  INTEGER :: errors = 0\n  INTEGER :: mult = 2\n  REAL(8),DIMENSION(LOOPCOUNT, LOOPCOUNT) :: a, b, c, a_host, b_host\n  INTEGER,DIMENSION(1) :: devtest\n  INTEGER :: x, y\n\n  devtest(1) = 1\n  !$acc enter data copyin(devtest(1:1))\n  !$acc parallel present(devtest(1:1))\n    devtest(1) = 0\n  !$acc end parallel\n\n  SEEDDIM(1) = 1\n# ifdef SEED\n  SEEDDIM(1) = SEED\n# endif\n  CALL RANDOM_SEED(PUT=SEEDDIM)\n\n  IF (devtest(1) .eq. 1) THEN\n    CALL RANDOM_NUMBER(a)\n    CALL RANDOM_NUMBER(b)\n    c = 0\n    a_host = a\n    b_host = b\n\n    !$acc data copy(a(1:LOOPCOUNT, 1:LOOPCOUNT), b(1:LOOPCOUNT, 1:LOOPCOUNT), c(1:LOOPCOUNT, 1:LOOPCOUNT))\n      DO x = 1, LOOPCOUNT\n        CALL function_test_dev_only(a(:,x), b(:,x), c(:,x), LOOPCOUNT)\n      END DO\n    !$acc end data\n\n    DO x = 1, LOOPCOUNT\n      DO y = 1, LOOPCOUNT\n        IF (abs(a(x, y) + 1) .gt. PRECISION) THEN\n          errors = errors + 1\n          PRINT*, \"2\"\n        END IF\n        IF (abs(b(x, y) + 1) .gt. PRECISION) THEN\n          errors = errors + 1\n          PRINT*, \"3\"\n        END IF\n        IF (abs(c(x, y) - (a_host(x, y) + b_host(x, y))) .gt. PRECISION) THEN\n          errors = errors + 1\n          PRINT*, \"4\"\n        END IF\n      END DO\n    END DO\n  END IF\n\n        IF (errors .eq. 0) THEN\n          test2 = .FALSE.\n        ELSE\n          test2 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T2\n        LOGICAL :: test2\n#endif\n#ifndef T2\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test2()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 1\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "devonly",
                            "construct-independent",
                            "declare"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "3": {
                        "content": "#ifndef T3\n!T3:devonly,construct-independent,declare,V:2.0-2.7\n      LOGICAL FUNCTION test3()\n  USE OPENACC\n  IMPLICIT NONE\n  INCLUDE \"acc_testsuite.Fh\"\n  INTEGER :: errors = 0\n  INTEGER :: mult = 2\n  REAL(8),DIMENSION(LOOPCOUNT, LOOPCOUNT) :: a, b, c, a_host, b_host\n  INTEGER,DIMENSION(1) :: devtest\n  INTEGER :: x, y\n\n  devtest(1) = 1\n  !$acc enter data copyin(devtest(1:1))\n  !$acc parallel present(devtest(1:1))\n    devtest(1) = 0\n  !$acc end parallel\n\n  SEEDDIM(1) = 1\n# ifdef SEED\n  SEEDDIM(1) = SEED\n# endif\n  CALL RANDOM_SEED(PUT=SEEDDIM)\n\n  IF (devtest(1) .eq. 1) THEN\n    CALL RANDOM_NUMBER(a)\n    CALL RANDOM_NUMBER(b)\n    c = 1\n    a_host = a\n    b_host = b\n\n    !$acc data copy(c(1:LOOPCOUNT, 1:LOOPCOUNt))\n      DO x = 1, LOOPCOUNT\n        CALL function_test_dev_only(a(:,x), b(:,x), c(:,x), LOOPCOUNT)\n      END DO\n    !$acc end data\n\n    DO x = 1, LOOPCOUNT\n      DO y = 1, LOOPCOUNT\n        IF (abs(a(x, y) - a_host(x, y)) .gt. PRECISION) THEN\n          errors = errors + 1\n          PRINT*, \"5\"\n        END IF\n        IF (abs(b(x, y) - b_host(x, y)) .gt. PRECISION) THEN\n          errors = errors + 1\n          PRINT*, \"6\"\n        END IF\n        IF (abs(c(x, y) - (1 + a(x, y) + b(x, y))) .gt. PRECISION) THEN\n          errors = errors + 1\n          PRINT*, \"7\"\n        END IF\n      END DO\n    END DO\n  END IF\n\n        IF (errors .eq. 0) THEN\n          test3 = .FALSE.\n        ELSE\n          test3 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T3\n        LOGICAL :: test3\n#endif\n#ifndef T3\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test3()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 2\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "devonly",
                            "construct-independent",
                            "declare"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "declare_function_scope_copyin.c": {
                "num tests": 3,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:declare,construct-independent,V:1.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t ** a = (real_t **)malloc(n * sizeof(real_t));\n    real_t ** b = (real_t **)malloc(n * sizeof(real_t));\n    real_t ** c = (real_t **)malloc(n * sizeof(real_t));\n\n    for (int x = 0; x < n; ++x){\n        a[x] = (real_t *)malloc(n * sizeof(real_t));\n        b[x] = (real_t *)malloc(n * sizeof(real_t));\n        c[x] = (real_t *)malloc(n * sizeof(real_t));\n        for (int y = 0; y < n; ++y){\n            a[x][y] = rand() / (real_t)(RAND_MAX / 10);\n            b[x][y] = rand() / (real_t)(RAND_MAX / 10);\n            c[x][y] = 1;\n        }\n    }\n\n    #pragma acc data copy(c[0:n][0:n])\n    {\n        for (int x = 0; x < n; ++x){\n            function_test(a[x], b[x], c[x]);\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        for (int y = 0; y < n; ++y){\n            if (fabs(c[x][y] - (1 + a[x][y] + b[x][y])) > PRECISION){\n                err += 1;\n            }\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "declare",
                            "construct-independent"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "2": {
                        "content": "#ifndef T2\n//T2:declare,construct-independent,devonly,reference-counting,V:2.5-2.7\nint test2(){\n    int err = 0;\n    srand(SEED);\n    real_t ** a = (real_t **)malloc(n * sizeof(real_t));\n    real_t ** b = (real_t **)malloc(n * sizeof(real_t));\n    real_t ** c = (real_t **)malloc(n * sizeof(real_t));\n    int * devtest = (int *)malloc(sizeof(int));\n    real_t ** a_host = (real_t **)malloc(n * sizeof(real_t *));\n    real_t ** b_host = (real_t **)malloc(n * sizeof(real_t *));\n\n    devtest[0] = 1;\n    #pragma acc enter data copyin(devtest[0:1])\n    #pragma acc parallel present(devtest[0:1])\n    {\n        devtest[0] = 0;\n    }\n\n    if (devtest[0] == 1){\n        for (int x = 0; x < n; ++x){\n            a_host[x] = (real_t *)malloc(n * sizeof(real_t));\n            b_host[x] = (real_t *)malloc(n * sizeof(real_t));\n            for (int y = 0; y < n; ++y){\n                a[x][y] = rand() / (real_t)(RAND_MAX / 10);\n                a_host[x][y] = a[x][y];\n                b[x][y] = rand() / (real_t)(RAND_MAX / 10);\n                b_host[x][y] = b[x][y];\n                c[x][y] = 0;\n            }\n        }\n\n        #pragma acc data copy(a[0:n][0:n], b[0:n][0:n], c[0:n][0:n])\n        {\n            for (int x = 0; x < n; ++x){\n                function_test_dev_only(a[x], b[x], c[x]);\n            }\n        }\n\n        for (int x = 0; x < n; ++x){\n            for (int y = 0; y < n; ++y){\n                if (fabs(a[x][y] + 1) > PRECISION){\n                    err += 1;\n                }\n                if (fabs(b[x][y] + 1) > PRECISION){\n                    err += 1;\n                }\n                if (fabs(c[x][y] - (a_host[x][y] + b_host[x][y])) > PRECISION){\n                    err += 1;\n                }\n            }\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T2\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test2();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 1);\n    }\n#endif\n",
                        "tags": [
                            "declare",
                            "construct-independent",
                            "devonly",
                            "reference-counting"
                        ],
                        "versions": [
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "3": {
                        "content": "#ifndef T3\n//T3:declare,construct-independent,devonly,V:2.0-2.7\nint test3(){\n    int err = 0;\n    srand(SEED);\n    real_t ** a = (real_t **)malloc(n * sizeof(real_t));\n    real_t ** b = (real_t **)malloc(n * sizeof(real_t));\n    real_t ** c = (real_t **)malloc(n * sizeof(real_t));\n    int * devtest = (int *)malloc(sizeof(int));\n    real_t ** a_host = (real_t **)malloc(n * sizeof(real_t *));\n    real_t ** b_host = (real_t **)malloc(n * sizeof(real_t *));\n\n    devtest[0] = 1;\n    #pragma acc enter data copyin(devtest[0:1])\n    #pragma acc parallel present(devtest[0:1])\n    {\n        devtest[0] = 0;\n    }\n\n    if (devtest[0] == 1){\n        for (int x = 0; x < n; ++x){\n            for (int y = 0; y < n; ++y){\n                a[x][y] = rand() / (real_t)(RAND_MAX / 10);\n                a_host[x][y] = a[x][y];\n                b[x][y] = rand() / (real_t)(RAND_MAX / 10);\n                b_host[x][y] = b[x][y];\n                c[x][y] = 1;\n            }\n        }\n\n        #pragma acc data copy(c[0:n][0:n])\n        {\n            for (int x = 0; x < n; ++x){\n                function_test_dev_only(a[x], b[x], c[x]);\n            }\n        }\n\n        for (int x = 0; x < n; ++x){\n            for (int y = 0; y < n; ++y){\n                if (fabs(a[x][y] - a_host[x][y]) > PRECISION){\n                    err += 1;\n                }\n                if (fabs(b[x][y] - b_host[x][y]) > PRECISION){\n                    err += 1;\n                }\n                if (fabs(c[x][y] - (1 + a[x][y] + b[x][y])) > PRECISION){\n                    err += 1;\n                }\n            }\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T3\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test3();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 2);\n    }\n#endif\n",
                        "tags": [
                            "declare",
                            "construct-independent",
                            "devonly"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "declare_function_scope_copyout.F90": {
                "num tests": 3,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:devonly,construct-independent,declare,V:2.0-2.7\n      LOGICAL FUNCTION test1()\n  USE OPENACC\n  IMPLICIT NONE\n  INCLUDE \"acc_testsuite.Fh\"\n  INTEGER :: errors = 0\n  INTEGER :: mult = 2\n  REAL(8),DIMENSION(LOOPCOUNT, LOOPCOUNT) :: a, b, c\n  INTEGER,DIMENSION(1) :: devtest\n  INTEGER :: x, y\n\n  devtest(1) = 1\n  !$acc enter data copyin(devtest(1:1))\n  !$acc parallel present(devtest(1:1))\n    devtest(1) = 0\n  !$acc end parallel\n\n  SEEDDIM(1) = 1\n# ifdef SEED\n  SEEDDIM(1) = SEED\n# endif\n  CALL RANDOM_SEED(PUT=SEEDDIM)\n\n  CALL RANDOM_NUMBER(a)\n  CALL RANDOM_NUMBER(b)\n  c = 1\n\n  !$acc data copyin(a(1:LOOPCOUNT, 1:LOOPCOUNT), b(1:LOOPCOUNT, 1:LOOPCOUNT))\n    DO x = 1, LOOPCOUNT\n      CALL copyout_test(a(:,x), b(:,x), c(:,x), LOOPCOUNT)\n    END DO\n  !$acc end data\n\n  DO x = 1, LOOPCOUNT\n    DO y = 1, LOOPCOUNT\n      IF (abs(c(x, y) - (a(x, y) + b(x, y))) .gt. PRECISION) THEN\n        errors = errors + 1\n      END IF\n    END DO\n  END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "devonly",
                            "construct-independent",
                            "declare"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "2": {
                        "content": "#ifndef T2\n!T2:devonly,construct-independent,declare,V:2.0-2.7\n      LOGICAL FUNCTION test2()\n  USE OPENACC\n  IMPLICIT NONE\n  INCLUDE \"acc_testsuite.Fh\"\n  INTEGER :: errors = 0\n  INTEGER :: mult = 2\n  REAL(8),DIMENSION(LOOPCOUNT, LOOPCOUNT) :: a, b, c\n  INTEGER,DIMENSION(1) :: devtest\n  INTEGER :: x, y\n\n  devtest(1) = 1\n  !$acc enter data copyin(devtest(1:1))\n  !$acc parallel present(devtest(1:1))\n    devtest(1) = 0\n  !$acc end parallel\n\n  SEEDDIM(1) = 1\n# ifdef SEED\n  SEEDDIM(1) = SEED\n# endif\n  CALL RANDOM_SEED(PUT=SEEDDIM)\n\n  CALL RANDOM_NUMBER(a)\n  CALL RANDOM_NUMBER(b)\n  c = 2\n\n  !$acc data copyin(a(1:LOOPCOUNT, 1:LOOPCOUNT), b(1:LOOPCOUNT, 1:LOOPCOUNT))\n    DO x = 1, LOOPCOUNT\n      !$acc data copy(c(1:LOOPCOUNT, x:x))\n        CALL copyout_test(a(:,x), b(:,x), c(:,x), LOOPCOUNT)\n      !$acc end data\n    END DO\n  !$acc end data\n\n  DO x = 1, LOOPCOUNT\n    DO y = 1, LOOPCOUNT\n      IF (abs(c(x, y) - (a(x, y) + b(x, y))) .gt. PRECISION) THEN\n        errors = errors + 1\n      END IF\n    END DO\n  END DO\n\n        IF (errors .eq. 0) THEN\n          test2 = .FALSE.\n        ELSE\n          test2 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T2\n        LOGICAL :: test2\n#endif\n#ifndef T2\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test2()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 1\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "devonly",
                            "construct-independent",
                            "declare"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "3": {
                        "content": "#ifndef T3\n!T3:devonly,construct-independent,declare,V:2.0-2.7\n      LOGICAL FUNCTION test3()\n  USE OPENACC\n  IMPLICIT NONE\n  INCLUDE \"acc_testsuite.Fh\"\n  INTEGER :: errors = 0\n  INTEGER :: mult = 2\n  REAL(8),DIMENSION(LOOPCOUNT, LOOPCOUNT) :: a, b, c\n  INTEGER,DIMENSION(1) :: devtest\n  INTEGER :: x, y\n\n  devtest(1) = 1\n  !$acc enter data copyin(devtest(1:1))\n  !$acc parallel present(devtest(1:1))\n    devtest(1) = 0\n  !$acc end parallel\n\n  SEEDDIM(1) = 1\n# ifdef SEED\n  SEEDDIM(1) = SEED\n# endif\n  CALL RANDOM_SEED(PUT=SEEDDIM)\n\n  IF (devtest(1) .eq. 1) THEN\n    CALL RANDOM_NUMBER(a)\n    CALL RANDOM_NUMBER(b)\n    c = 3\n\n    !$acc data copyin(a(1:LOOPCOUNT, 1:LOOPCOUNT), b(1:LOOPCOUNT, 1:LOOPCOUNT))\n      DO x = 1, LOOPCOUNT\n        !$acc data copyin(c(1:LOOPCOUNT, x:x))\n          CALL copyout_test(a(:,x), b(:,x), c(:,x), LOOPCOUNT)\n        !$acc end data\n        DO y = 1, LOOPCOUNT\n          IF (abs(c(y, x) - 3) .gt. PRECISION) THEN\n            errors = errors + 1\n          END IF\n        END DO\n      END DO\n    !$acc end data\n  END IF\n\n        IF (errors .eq. 0) THEN\n          test3 = .FALSE.\n        ELSE\n          test3 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T3\n        LOGICAL :: test3\n#endif\n#ifndef T3\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test3()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 2\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "devonly",
                            "construct-independent",
                            "declare"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "declare_function_scope_copyout.c": {
                "num tests": 4,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:declare,construct-independent,V:1.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t ** a = (real_t **)malloc(n * sizeof(real_t));\n    real_t ** b = (real_t **)malloc(n * sizeof(real_t));\n    real_t ** c = (real_t **)malloc(n * sizeof(real_t));\n\n    for (int x = 0; x < n; ++x){\n        a[x] = (real_t *)malloc(n * sizeof(real_t));\n        b[x] = (real_t *)malloc(n * sizeof(real_t));\n        c[x] = (real_t *)malloc(n * sizeof(real_t));\n        for (int y = 0; y < n; ++y){\n            a[x][y] = rand() / (real_t)(RAND_MAX / 10);\n            b[x][y] = rand() / (real_t)(RAND_MAX / 10);\n            c[x][y] = 1;\n        }\n    }\n    #pragma acc data copyin(a[0:n][0:n], b[0:n][0:n])\n    {\n        for (int x = 0; x < n; ++x){\n            copyout_test(a[x], b[x], c[x]);\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        for (int y = 0; y < n; ++y){\n            if (fabs(c[x][y] - (a[x][y] + b[x][y])) > PRECISION){\n                err += 1;\n            }\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "declare",
                            "construct-independent"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "2": {
                        "content": "#ifndef T2\n//T2:declare,construct-independent,reference-counting,V:2.5-2.7\nint test2(){\n    int err = 0;\n    srand(SEED);\n    real_t ** a = (real_t **)malloc(n * sizeof(real_t));\n    real_t ** b = (real_t **)malloc(n * sizeof(real_t));\n    real_t ** c = (real_t **)malloc(n * sizeof(real_t));\n\n    for (int x = 0; x < n; ++x){\n        for (int y = 0; y < n; ++y){\n            a[x][y] = rand() / (real_t)(RAND_MAX / 10);\n            b[x][y] = rand() / (real_t)(RAND_MAX / 10);\n            c[x][y] = 2;\n        }\n    }\n\n    #pragma acc data copyin(a[0:n][0:n], b[0:n][0:n])\n    {\n        for (int x = 0; x < n; ++x){\n            #pragma acc data copy(c[x:1][0:n])\n            {\n                copyout_test(a[x], b[x], c[x]);\n            }\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        for (int y = 0; y < n; ++y){\n            if (fabs(c[x][y] - (a[x][y] + b[x][y])) > PRECISION){\n                err += 1;\n            }\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T2\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test2();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 1);\n    }\n#endif\n",
                        "tags": [
                            "declare",
                            "construct-independent",
                            "reference-counting"
                        ],
                        "versions": [
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "3": {
                        "content": "#ifndef T3\n//T3:declare,construct-independent,devonly,reference-counting,V:2.5-2.7\nint test3(){\n    int err = 0;\n    srand(SEED);\n    real_t ** a = (real_t **)malloc(n * sizeof(real_t));\n    real_t ** b = (real_t **)malloc(n * sizeof(real_t));\n    real_t ** c = (real_t **)malloc(n * sizeof(real_t));\n    int *devtest = (int *)malloc(sizeof(int));\n\n    devtest[0] = 1;\n    #pragma acc enter data copyin(devtest[0:1])\n    #pragma acc parallel present(devtest[0:1])\n    {\n        devtest[0] = 0;\n    }\n\n    if (devtest[0] == 1){\n        for (int x = 0; x < n; ++x){\n            for (int y = 0; y < n; ++y){\n                a[x][y] = rand() / (real_t)(RAND_MAX / 10);\n                b[x][y] = rand() / (real_t)(RAND_MAX / 10);\n                c[x][y] = 3;\n            }\n        }\n\n        #pragma acc data copyin(a[0:n][0:n], b[0:n][0:n])\n        {\n            for (int x = 0; x < n; ++x){\n                #pragma acc data copyin(c[x:1][0:n])\n                {\n                    copyout_test(a[x], b[x], c[x]);\n                    for (int y = 0; y < n; ++y){\n                        if (fabs(c[x][y] - 3) > PRECISION){\n                            err += 1;\n                        }\n                    }\n                }\n                for (int y = 0; y < n; ++y){\n                    if (fabs(c[x][y] - 3) > PRECISION){\n                        err += 1;\n                    }\n                }\n            }\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T3\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test3();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 2);\n    }\n#endif\n",
                        "tags": [
                            "declare",
                            "construct-independent",
                            "devonly",
                            "reference-counting"
                        ],
                        "versions": [
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "4": {
                        "content": "#ifndef T4\n//T4:declare,construct-independent,devonly,reference-counting,V:2.5-2.7\nint test4(){\n    int err = 0;\n    srand(SEED);\n    real_t ** a = (real_t **)malloc(n * sizeof(real_t));\n    real_t ** b = (real_t **)malloc(n * sizeof(real_t));\n    real_t ** c = (real_t **)malloc(n * sizeof(real_t));\n    int *devtest = (int *)malloc(sizeof(int));\n\n    devtest[0] = 1;\n    #pragma acc enter data copyin(devtest[0:1])\n    #pragma acc parallel present(devtest[0:1])\n    {\n        devtest[0] = 0;\n    }\n\n    if (devtest[0] == 1){\n        for (int x = 0; x < n; ++x){\n            for (int y = 0; y < n; ++y){\n                a[x][y] = rand() / (real_t)(RAND_MAX / 10);\n                b[x][y] = rand() / (real_t)(RAND_MAX / 10);\n                c[x][y] = 4;\n            }\n        }\n\n        #pragma acc data copyin(a[0:n][0:n], b[0:n][0:n])\n        {\n            for (int x = 0; x < n; ++x){\n                #pragma acc data copy(c[x:1][0:n])\n                {\n                    copyout_test(a[x], b[x], c[x]);\n                    for (int y = 0; y < n; ++y){\n                        if (fabs(c[x][y] - 4) > PRECISION){\n                            err += 1;\n                        }\n                    }\n                }\n                for (int y = 0; y < n; ++y){\n                    if (fabs(c[x][y] - (a[x][y] + b[x][y])) > PRECISION){\n                        err += 1;\n                    }\n                }\n            }\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T4\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test4();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 3);\n    }\n#endif\n",
                        "tags": [
                            "declare",
                            "construct-independent",
                            "devonly",
                            "reference-counting"
                        ],
                        "versions": [
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "declare_function_scope_create.F90": {
                "num tests": 3,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:devonly,construct-independent,declare,V:2.0-2.7\n      LOGICAL FUNCTION test1()\n  USE OPENACC\n  IMPLICIT NONE\n  INCLUDE \"acc_testsuite.Fh\"\n  INTEGER :: errors = 0\n  INTEGER :: mult = 2\n  REAL(8),DIMENSION(LOOPCOUNT, LOOPCOUNT) :: a, b, c, d\n  INTEGER,DIMENSION(1) :: devtest\n  INTEGER :: x, y\n\n  devtest(1) = 1\n  !$acc enter data copyin(devtest(1:1))\n  !$acc parallel present(devtest(1:1))\n    devtest(1) = 0\n  !$acc end parallel\n\n  SEEDDIM(1) = 1\n# ifdef SEED\n  SEEDDIM(1) = SEED\n# endif\n  CALL RANDOM_SEED(PUT=SEEDDIM)\n\n  CALL RANDOM_NUMBER(a)\n  CALL RANDOM_NUMBER(b)\n  c = 1\n  d = 0\n\n  !$acc data copyin(a(1:LOOPCOUNT, 1:LOOPCOUNT), b(1:LOOPCOUNT, 1:LOOPCOUNT)) copyout(d(1:LOOPCOUNT, 1:LOOPCOUNT))\n    DO x = 1, LOOPCOUNT\n      CALL create_test(a(x), b(x), c(x), d(x), LOOPCOUNT)\n    END DO\n  !$acc end data\n\n  DO x = 1, LOOPCOUNT\n    DO y = 1, LOOPCOUNT\n      IF (abs(d(x, y) - (a(x, y) * (a(x, y) + b(x, y)))) .gt. PRECISION) THEN\n        errors = errors + 1\n      END IF\n    END DO\n  END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "devonly",
                            "construct-independent",
                            "declare"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "2": {
                        "content": "#ifndef T2\n!T2:devonly,construct-independent,declare,V:2.0-2.7\n      LOGICAL FUNCTION test2()\n  USE OPENACC\n  IMPLICIT NONE\n  INCLUDE \"acc_testsuite.Fh\"\n  INTEGER :: errors = 0\n  INTEGER :: mult = 2\n  REAL(8),DIMENSION(LOOPCOUNT, LOOPCOUNT) :: a, b, c, d\n  INTEGER,DIMENSION(1) :: devtest\n  INTEGER :: x, y\n\n  devtest(1) = 1\n  !$acc enter data copyin(devtest(1:1))\n  !$acc parallel present(devtest(1:1))\n    devtest(1) = 0\n  !$acc end parallel\n\n  SEEDDIM(1) = 1\n# ifdef SEED\n  SEEDDIM(1) = SEED\n# endif\n  CALL RANDOM_SEED(PUT=SEEDDIM)\n\n  CALL RANDOM_NUMBER(a)\n  CALL RANDOM_NUMBER(b)\n  c = 2\n  d = 0\n\n  !$acc data copyin(a(1:LOOPCOUNT, 1:LOOPCOUNT), b(1:LOOPCOUNT, 1:LOOPCOUNT)) copy(c(1:LOOPCOUNT, 1:LOOPCOUNT)) copyout(d(1:LOOPCOUNT, 1:LOOPCOUNT))\n    DO x = 1, LOOPCOUNT\n      CALL create_as_present(a(x), b(x), c(x), d(x), LOOPCOUNT)\n    END DO\n  !$acc end data\n\n  DO x = 1, LOOPCOUNT\n    DO y = 1, LOOPCOUNT\n      IF (abs(c(x, y) - (2 + a(x, y) + b(x, y))) .gt. PRECISION) THEN\n        errors = errors + 1\n      END IF\n      IF (abs(d(x, y) - (a(x, y) * c(x, y))) .gt. PRECISION * 2) THEN\n        errors = errors + 1\n      END IF\n    END DO\n  END DO\n\n        IF (errors .eq. 0) THEN\n          test2 = .FALSE.\n        ELSE\n          test2 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T2\n        LOGICAL :: test2\n#endif\n#ifndef T2\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test2()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 1\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "devonly",
                            "construct-independent",
                            "declare"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "3": {
                        "content": "#ifndef T3\n!T3:devonly,construct-independent,declare,V:2.0-2.7\n      LOGICAL FUNCTION test3()\n  USE OPENACC\n  IMPLICIT NONE\n  INCLUDE \"acc_testsuite.Fh\"\n  INTEGER :: errors = 0\n  INTEGER :: mult = 2\n  REAL(8),DIMENSION(LOOPCOUNT, LOOPCOUNT) :: a, b, c, d\n  INTEGER,DIMENSION(1) :: devtest\n  INTEGER :: x, y\n\n  devtest(1) = 1\n  !$acc enter data copyin(devtest(1:1))\n  !$acc parallel present(devtest(1:1))\n    devtest(1) = 0\n  !$acc end parallel\n\n  SEEDDIM(1) = 1\n# ifdef SEED\n  SEEDDIM(1) = SEED\n# endif\n  CALL RANDOM_SEED(PUT=SEEDDIM)\n\n  IF (devtest(1) .eq. 1) THEN\n    CALL RANDOM_NUMBER(a)\n    CALL RANDOM_NUMBER(b)\n    c = 3\n\n    !$acc data copyin(a(1:LOOPCOUNT, 1:LOOPCOUNT), b(1:LOOPCOUNT, 1:LOOPCOUNT))\n      DO x = 1, LOOPCOUNT\n        !$acc data copyin(c(x:x, 1:LOOPCOUNT)) copyout(d(x:x, 1:LOOPCOUNT))\n          CALL create_as_present(a(x), b(x), c(x), d(x), LOOPCOUNT)\n        !$acc end data\n        DO y = 1, LOOPCOUNT\n          IF (abs(c(x, y) - 3) .gt. PRECISION) THEN\n            errors = errors + 1\n          END IF\n          IF (abs(d(x, y) - (a(x, y) * (3 + a(x, y) + b(x, y)))) .gt. PRECISION * 2) THEN\n            errors = errors + 1\n          END IF\n        END DO\n      END DO\n    !$acc end data\n  END IF\n\n        IF (errors .eq. 0) THEN\n          test3 = .FALSE.\n        ELSE\n          test3 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T3\n        LOGICAL :: test3\n#endif\n#ifndef T3\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test3()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 2\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "devonly",
                            "construct-independent",
                            "declare"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "declare_function_scope_create.c": {
                "num tests": 3,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:declare,construct-independent,V:2.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t ** a = (real_t **)malloc(n * sizeof(real_t));\n    real_t ** b = (real_t **)malloc(n * sizeof(real_t));\n    real_t ** c = (real_t **)malloc(n * sizeof(real_t));\n    real_t ** d = (real_t **)malloc(n * sizeof(real_t));\n\n    for (int x = 0; x < n; ++x){\n        a[x] = (real_t *)malloc(n * sizeof(real_t));\n        b[x] = (real_t *)malloc(n * sizeof(real_t));\n        c[x] = (real_t *)malloc(n * sizeof(real_t));\n        d[x] = (real_t *)malloc(n * sizeof(real_t));\n        for (int y = 0; y < n; ++y){\n            a[x][y] = rand() / (real_t)(RAND_MAX / 10);\n            b[x][y] = rand() / (real_t)(RAND_MAX / 10);\n            c[x][y] = 1;\n            d[x][y] = 0;\n        }\n    }\n    #pragma acc data copyin(a[0:n][0:n], b[0:n][0:n]) copyout(d[0:n][0:n])\n    {\n        for (int x = 0; x < n; ++x){\n            create_test(a[x], b[x], c[x], d[x]);\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        for (int y = 0; y < n; ++y){\n            if (fabs(d[x][y] - (a[x][y] * (a[x][y] + b[x][y]))) > PRECISION){\n                err += 1;\n            }\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "declare",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "2": {
                        "content": "#ifndef T2\n//T2:declare,construct-independent,V:2.0-2.7\nint test2(){\n    int err = 0;\n    srand(SEED);\n    real_t ** a = (real_t **)malloc(n * sizeof(real_t));\n    real_t ** b = (real_t **)malloc(n * sizeof(real_t));\n    real_t ** c = (real_t **)malloc(n * sizeof(real_t));\n    real_t ** d = (real_t **)malloc(n * sizeof(real_t));\n\n    for (int x = 0; x < n; ++x){\n        for (int y = 0; y < n; ++y){\n            a[x][y] = rand() / (real_t)(RAND_MAX / 10);\n            b[x][y] = rand() / (real_t)(RAND_MAX / 10);\n            c[x][y] = 2;\n            d[x][y] = 0;\n        }\n    }\n\n    #pragma acc data copyin(a[0:n][0:n], b[0:n][0:n]) copy(c[0:n][0:n]) copyout(d[0:n][0:n])\n    {\n        for (int x = 0; x < n; ++x){\n            create_as_present(a[x], b[x], c[x], d[x]);\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        for (int y = 0; y < n; ++y){\n            if (fabs(c[x][y] - (2 + a[x][y] + b[x][y])) > PRECISION){\n                err += 1;\n            }\n            if (fabs(d[x][y] - (a[x][y] * c[x][y])) > PRECISION * 2){\n                err += 1;\n            }\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T2\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test2();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 1);\n    }\n#endif\n",
                        "tags": [
                            "declare",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "3": {
                        "content": "#ifndef T3\n//T3:declare,construct-independent,devonly,V:2.0-2.7\nint test3(){\n    int err = 0;\n    srand(SEED);\n    real_t ** a = (real_t **)malloc(n * sizeof(real_t));\n    real_t ** b = (real_t **)malloc(n * sizeof(real_t));\n    real_t ** c = (real_t **)malloc(n * sizeof(real_t));\n    real_t ** d = (real_t **)malloc(n * sizeof(real_t));\n    int *devtest = (int *)malloc(sizeof(int));\n\n    devtest[0] = 1;\n    #pragma acc enter data copyin(devtest[0:1])\n    #pragma acc parallel present(devtest[0:1])\n    {\n        devtest[0] = 0;\n    }\n\n    if (devtest[0] == 1){\n        for (int x = 0; x < n; ++x){\n            for (int y = 0; y < n; ++y){\n                a[x][y] = rand() / (real_t)(RAND_MAX / 10);\n                b[x][y] = rand() / (real_t)(RAND_MAX / 10);\n                c[x][y] = 3;\n            }\n        }\n\n        #pragma acc data copyin(a[0:n][0:n], b[0:n][0:n])\n        {\n            for (int x = 0; x < n; ++x){\n                #pragma acc data copyin(c[x:1][0:n]) copyout(d[x:1][0:n])\n                {\n                    create_as_present(a[x], b[x], c[x], d[x]);\n                }\n                for (int y = 0; y < n; ++y){\n                    if (fabs(c[x][y] - 3) > PRECISION){\n                        err += 1;\n                    }\n                }\n                for (int y = 0; y < n; ++y){\n                    if (fabs(d[x][y] - (a[x][y] * (3 + a[x][y] + b[x][y]))) > PRECISION * 2){\n                        err += 1;\n                    }\n                }\n            }\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T3\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test3();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 2);\n    }\n#endif\n",
                        "tags": [
                            "declare",
                            "construct-independent",
                            "devonly"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "declare_function_scope_deviceptr.c": {
                "num tests": 2,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:declare,runtime,construct-independent,V:2.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t ** a = (real_t **)malloc(n * sizeof(real_t *));\n    real_t ** b = (real_t **)malloc(n * sizeof(real_t *));\n    real_t ** c = (real_t **)malloc(n * sizeof(real_t *));\n    real_t ** d = (real_t **)malloc(n * sizeof(real_t *));\n    real_t ** devpointer_c = (real_t **)malloc(n * sizeof(real_t *));\n    int *devtest = (int *)malloc(sizeof(int));\n\n    for (int x = 0; x < n; ++x){\n        a[x] = (real_t *)malloc(n * sizeof(real_t));\n        b[x] = (real_t *)malloc(n * sizeof(real_t));\n        c[x] = (real_t *)malloc(n * sizeof(real_t));\n        d[x] = (real_t *)malloc(n * sizeof(real_t));\n        for (int y = 0; y < n; ++y){\n            a[x][y] = rand() / (real_t)(RAND_MAX / 10);\n            b[x][y] = rand() / (real_t)(RAND_MAX / 10);\n            c[x][y] = 1;\n            d[x][y] = 0;\n        }\n    }\n\n    #pragma acc data copyin(a[0:n][0:n], b[0:n][0:n]) copy(c[0:n][0:n]) copyout(d[0:n][0:n])\n    {\n        for (int x = 0; x < n; ++x){\n            devpointer_c[x] = acc_deviceptr(c[x]);\n            declare_deviceptr(a[x], b[x], devpointer_c[x], d[x]);\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        for (int y = 0; y < n; ++y){\n            if (fabs(c[x][y] - (1 + a[x][y] + b[x][y])) > PRECISION){\n                err += 1;\n            }\n            if (fabs(d[x][y] - (a[x][y] * c[x][y])) > PRECISION * 2){\n                err += 1;\n            }\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "declare",
                            "runtime",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "2": {
                        "content": "#ifndef T2\n//T2:declare,runtime,construct-independent,devonly,V:2.0-2.7\nint test2(){\n    int err = 0;\n    srand(SEED);\n    real_t ** a = (real_t **)malloc(n * sizeof(real_t *));\n    real_t ** b = (real_t **)malloc(n * sizeof(real_t *));\n    real_t ** c = (real_t **)malloc(n * sizeof(real_t *));\n    real_t ** d = (real_t **)malloc(n * sizeof(real_t *));\n    real_t ** devpointer_c = (real_t **)malloc(n * sizeof(real_t *));\n    int *devtest = (int *)malloc(sizeof(int));\n\n    devtest[0] = 1;\n    #pragma acc enter data copyin(devtest[0:1])\n    #pragma acc parallel present(devtest[0:1])\n    {\n        devtest[0] = 0;\n    }\n\n    if (devtest[0] == 1){\n        for (int x = 0; x < n; ++x){\n            for (int y = 0; y < n; ++y){\n                a[x][y] = rand() / (real_t)(RAND_MAX / 10);\n                b[x][y] = rand() / (real_t)(RAND_MAX / 10);\n                c[x][y] = 3;\n            }\n        }\n\n        #pragma acc data copyin(a[0:n][0:n], b[0:n][0:n])\n        {\n            for (int x = 0; x < n; ++x){\n                #pragma acc data copyout(d[x:1][0:n])\n                {\n                    devpointer_c[x] = acc_copyin(c[x], n * sizeof(real_t));\n                    declare_deviceptr(a[x], b[x], devpointer_c[x], d[x]);\n                }\n                for (int y = 0; y < n; ++y){\n                    if (fabs(c[x][y] - 3) > PRECISION){\n                        err += 1;\n                    }\n                }\n                for (int y = 0; y < n; ++y){\n                    if (fabs(d[x][y] - (a[x][y] * (3 + a[x][y] + b[x][y]))) > PRECISION * 10){\n                        err += 1;\n                    }\n                }\n            }\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T2\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test2();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 1);\n    }\n#endif\n",
                        "tags": [
                            "declare",
                            "runtime",
                            "construct-independent",
                            "devonly"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "declare_function_scope_present.F90": {
                "num tests": 2,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:devonly,construct-independent,declare,V:2.0-2.7\n      LOGICAL FUNCTION test1()\n  USE OPENACC\n  IMPLICIT NONE\n  INCLUDE \"acc_testsuite.Fh\"\n  INTEGER :: errors = 0\n  INTEGER :: mult = 2\n  REAL(8),DIMENSION(LOOPCOUNT, LOOPCOUNT) :: a, b, c, d\n  INTEGER,DIMENSION(1) :: devtest\n  INTEGER :: x, y\n\n  devtest(1) = 1\n  !$acc enter data copyin(devtest(1:1))\n  !$acc parallel present(devtest(1:1))\n    devtest(1) = 0\n  !$acc end parallel\n\n  SEEDDIM(1) = 1\n# ifdef SEED\n  SEEDDIM(1) = SEED\n# endif\n  CALL RANDOM_SEED(PUT=SEEDDIM)\n\n  CALL RANDOM_NUMBER(a)\n  CALL RANDOM_NUMBER(b)\n  c = 1\n  d = 0\n\n  !$acc data copyin(a(1:LOOPCOUNT, 1:LOOPCOUNT), b(1:LOOPCOUNT, 1:LOOPCOUNT)) copyout(d(1:LOOPCOUNT, 1:LOOPCOUNT))\n    DO x = 1, LOOPCOUNT\n      !$acc data copy(c(x:x, 1:LOOPCOUNT))\n        CALL present(a(x), b(x), c(x), d(x), LOOPCOUNT)\n      !$acc end data\n    END DO\n  !$acc end data\n\n  DO x = 1, LOOPCOUNT\n    DO y = 1, LOOPCOUNT\n      IF (abs(c(x, y) - (1 + a(x, y) + b(x, y))) .gt. PRECISION) THEN\n        errors = errors + 1\n      END IF\n      IF (abs(d(x, y) - (a(x, y) * c(x, y))) .gt. PRECISION * 2) THEN\n        errors = errors + 1\n      END IF\n    END DO\n  END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "devonly",
                            "construct-independent",
                            "declare"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "2": {
                        "content": "#ifndef T2\n!T2:devonly,construct-independent,declare,V:2.0-2.7\n      LOGICAL FUNCTION test2()\n  USE OPENACC\n  IMPLICIT NONE\n  INCLUDE \"acc_testsuite.Fh\"\n  INTEGER :: errors = 0\n  INTEGER :: mult = 2\n  REAL(8),DIMENSION(LOOPCOUNT, LOOPCOUNT) :: a, b, c, d\n  INTEGER,DIMENSION(1) :: devtest\n  INTEGER :: x, y\n\n  devtest(1) = 1\n  !$acc enter data copyin(devtest(1:1))\n  !$acc parallel present(devtest(1:1))\n    devtest(1) = 0\n  !$acc end parallel\n\n  SEEDDIM(1) = 1\n# ifdef SEED\n  SEEDDIM(1) = SEED\n# endif\n  CALL RANDOM_SEED(PUT=SEEDDIM)\n\n  IF (devtest(1) .eq. 1) THEN\n    CALL RANDOM_NUMBER(a)\n    CALL RANDOM_NUMBER(b)\n    c = 3\n\n    !$acc data copyin(a(1:LOOPCOUNT, 1:LOOPCOUNT), b(1:LOOPCOUNT, 1:LOOPCOUNT))\n      DO x = 1, LOOPCOUNT\n        !$acc data copyin(c(x:x, 1:LOOPCOUNT)) copyout(d(x:x, 1:LOOPCOUNT))\n          CALL present(a(x), b(x), c(x), d(x), LOOPCOUNT)\n        !$acc end data\n        DO y = 1, LOOPCOUNT\n          IF (abs(c(x, y) - 3) .gt. PRECISION) THEN\n            errors = errors + 1\n          END IF\n          IF (abs(d(x, y) - (a(x, y) * (3 + a(x, y) + b(x, y)))) .gt. PRECISION * 2) THEN\n            errors = errors + 1\n          END IF\n        END DO\n      END DO\n    !$acc end data\n  END IF\n\n        IF (errors .eq. 0) THEN\n          test2 = .FALSE.\n        ELSE\n          test2 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T2\n        LOGICAL :: test2\n#endif\n#ifndef T2\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test2()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 1\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "devonly",
                            "construct-independent",
                            "declare"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "declare_function_scope_present.c": {
                "num tests": 2,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:declare,present,construct-independent,V:2.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t ** a = (real_t **)malloc(n * sizeof(real_t));\n    real_t ** b = (real_t **)malloc(n * sizeof(real_t));\n    real_t ** c = (real_t **)malloc(n * sizeof(real_t));\n    real_t ** d = (real_t **)malloc(n * sizeof(real_t));\n\n    for (int x = 0; x < n; ++x){\n        a[x] = (real_t *)malloc(n * sizeof(real_t));\n        b[x] = (real_t *)malloc(n * sizeof(real_t));\n        c[x] = (real_t *)malloc(n * sizeof(real_t));\n        d[x] = (real_t *)malloc(n * sizeof(real_t));\n        for (int y = 0; y < n; ++y){\n            a[x][y] = rand() / (real_t)(RAND_MAX / 10);\n            b[x][y] = rand() / (real_t)(RAND_MAX / 10);\n            c[x][y] = 1;\n            d[x][y] = 0;\n        }\n    }\n\n    #pragma acc data copyin(a[0:n][0:n], b[0:n][0:n]) copyout(d[0:n][0:n])\n    {\n        for (int x = 0; x < n; ++x){\n            #pragma acc data copy(c[x:1][0:n])\n            {\n                present(a[x], b[x], c[x], d[x]);\n            }\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        for (int y = 0; y < n; ++y){\n            if (fabs(c[x][y] - (1 + a[x][y] + b[x][y])) > PRECISION){\n                err += 1;\n            }\n            if (fabs(d[x][y] - (a[x][y] * c[x][y])) > PRECISION * 2){\n                err += 1;\n            }\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "declare",
                            "present",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "2": {
                        "content": "#ifndef T2\n//T2:declare,present,devonly,construct-independent,V:2.0-2.7\nint test2(){\n    int err = 0;\n    srand(SEED);\n    real_t ** a = (real_t **)malloc(n * sizeof(real_t));\n    real_t ** b = (real_t **)malloc(n * sizeof(real_t));\n    real_t ** c = (real_t **)malloc(n * sizeof(real_t));\n    real_t ** d = (real_t **)malloc(n * sizeof(real_t));\n    int *devtest = (int *)malloc(sizeof(int));\n\n    devtest[0] = 1;\n    #pragma acc enter data copyin(devtest[0:1])\n    #pragma acc parallel present(devtest[0:1])\n    {\n        devtest[0] = 0;\n    }\n\n    if (devtest[0] == 1){\n        for (int x = 0; x < n; ++x){\n            for (int y = 0; y < n; ++y){\n                a[x][y] = rand() / (real_t)(RAND_MAX / 10);\n                b[x][y] = rand() / (real_t)(RAND_MAX / 10);\n                c[x][y] = 3;\n            }\n        }\n\n        #pragma acc data copyin(a[0:n][0:n], b[0:n][0:n])\n        {\n            for (int x = 0; x < n; ++x){\n                #pragma acc data copyin(c[x:1][0:n]) copyout(d[x:1][0:n])\n                {\n                    present(a[x], b[x], c[x], d[x]);\n                }\n                for (int y = 0; y < n; ++y){\n                    if (fabs(c[x][y] - 3) > PRECISION){\n                        err += 1;\n                    }\n                }\n                for (int y = 0; y < n; ++y){\n                    if (fabs(d[x][y] - (a[x][y] * (3 + a[x][y] + b[x][y]))) > PRECISION * 2){\n                        err += 1;\n                    }\n                }\n            }\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T2\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test2();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 1);\n    }\n#endif\n",
                        "tags": [
                            "declare",
                            "present",
                            "devonly",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "enter_data_copyin_no_lower_bound.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:data,executable-data,construct-independent,V:2.0-2.7\n      LOGICAL FUNCTION test1()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT):: a, b, c !Data\n        INTEGER :: errors = 0\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(a)\n        CALL RANDOM_NUMBER(b)\n        c = 0\n\n        !$acc enter data copyin(a(:LOOPCOUNT), b(:LOOPCOUNT))\n        !$acc data copyout(c(1:LOOPCOUNT)) present(a(1:LOOPCOUNT), b(1:LOOPCOUNT))\n          !$acc parallel\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              c(x) = a(x) + b(x)\n            END DO\n          !$acc end parallel\n        !$acc end data\n        !$acc exit data delete(a(1:LOOPCOUNT), b(1:LOOPCOUNT))\n\n        DO x = 1, LOOPCOUNT\n          IF (abs(c(x) - (a(x) + b(x))) .gt. PRECISION) THEN\n            errors = errors + 1\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "data",
                            "executable-data",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "enter_data_copyin_no_lower_bound.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:data,executable-data,syntactic,V:2.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n    real_t * c = (real_t *)malloc(n * sizeof(real_t));\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n        c[x] = 0.0;\n    }\n\n    #pragma acc enter data copyin(a[:n], b[:n]) create(c[0:n])\n    #pragma acc parallel present(a[0:n], b[0:n], c[0:n])\n    {\n        #pragma acc loop\n        for (int x = 0; x < n; ++x){\n            c[x] = a[x] + b[x];\n        }\n    }\n    #pragma acc exit data copyout(c[0:n]) delete(a[0:n], b[0:n])\n\n    for (int x = 0; x < n; ++x){\n        if (fabs(c[x] - (a[x] + b[x])) > PRECISION) {\n            err += 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "data",
                            "executable-data",
                            "syntactic"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "enter_data_create.F90": {
                "num tests": 3,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:data,executable-data,construct-independent,V:2.0-2.7\n      LOGICAL FUNCTION test1()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT):: a, b, c !Data\n        INTEGER :: errors = 0\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(a)\n        b = 0\n        c = 0\n\n        !$acc enter data create(b(1:LOOPCOUNT))\n        !$acc data copyin(a(1:LOOPCOUNT))\n          !$acc parallel present(b(1:LOOPCOUNT))\n            !$acc loop \n            DO x = 1, LOOPCOUNT\n              b(x) = a(x)\n            END DO\n          !$acc end parallel\n        !$acc end data\n        !$acc data copyout(c(1:LOOPCOUNT))\n          !$acc parallel present(b(1:LOOPCOUNT))\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              c(x) = b(x)\n            END DO\n          !$acc end parallel\n        !$acc end data\n        !$acc exit data delete(b(1:LOOPCOUNT))\n\n        DO x = 1, LOOPCOUNT\n          IF (abs(a(x) - c(x)) .gt. PRECISION) THEN\n            errors = errors + 1\n            EXIT\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "data",
                            "executable-data",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "2": {
                        "content": "#ifndef T2\n!T2:data,executable-data,construct-independent,V:2.0-2.7\n      LOGICAL FUNCTION test2()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT):: a, b, c !Data\n        INTEGER :: errors = 0\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(a)\n        b = 0\n        c = 0\n        !$acc enter data present_or_create(b(1:LOOPCOUNT))\n        !$acc data copyin(a(1:LOOPCOUNT))\n          !$acc parallel present(b(1:LOOPCOUNT))\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              b(x) = a(x)\n            END DO\n          !$acc end parallel\n        !$acc end data\n        !$acc data copyout(c(1:LOOPCOUNT))\n          !$acc parallel present(b(1:LOOPCOUNT))\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              c(x) = b(x)\n            END DO\n          !$acc end parallel\n        !$acc end data\n        !$acc exit data delete(b(1:LOOPCOUNT))\n\n        DO x = 1, LOOPCOUNT\n          IF (abs(a(x) - c(x)) .gt. PRECISION) THEN\n            errors = errors + 2\n            EXIT\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test2 = .FALSE.\n        ELSE\n          test2 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T2\n        LOGICAL :: test2\n#endif\n#ifndef T2\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test2()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 1\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "data",
                            "executable-data",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "3": {
                        "content": "#ifndef T3\n!T3:data,executable-data,construct-independent,V:2.0-2.7\n      LOGICAL FUNCTION test3()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT):: a, b, c !Data\n        INTEGER :: errors = 0\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(a)\n        b = 0\n        c = 0\n \n        !$acc enter data pcreate(b(1:LOOPCOUNT))\n        !$acc data copyin(a(1:LOOPCOUNT))\n          !$acc parallel present(b(1:LOOPCOUNT))\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              b(x) = a(x)\n            END DO\n          !$acc end parallel\n        !$acc end data\n        !$acc data copyout(c(1:LOOPCOUNT))\n          !$acc parallel present(b(1:LOOPCOUNT))\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              c(x) = b(x)\n            END DO\n          !$acc end parallel\n        !$acc end data\n        !$acc exit data delete(b(1:LOOPCOUNT))\n\n        DO x = 1, LOOPCOUNT\n          IF (abs(a(x) - c(x)) .gt. PRECISION) THEN\n            errors = errors + 4\n            EXIT\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test3 = .FALSE.\n        ELSE\n          test3 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T3\n        LOGICAL :: test3\n#endif\n#ifndef T3\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test3()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 2\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "data",
                            "executable-data",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "enter_data_create.c": {
                "num tests": 3,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:data,executable-data,construct-independent,V:2.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n    real_t * c = (real_t *)malloc(n * sizeof(real_t));\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = 0.0;\n        c[x] = 0.0;\n    }\n\n    #pragma acc enter data create(b[0:n])\n    #pragma acc data copyin(a[0:n])\n    {\n        #pragma acc parallel present(b[0:n])\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                b[x] = a[x];\n            }\n        }\n    }\n    #pragma acc data copyout(c[0:n])\n    {\n        #pragma acc parallel present(b[0:n])\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                c[x] = b[x];\n            }\n        }\n    }\n    #pragma acc exit data delete(b[0:n])\n\n    for (int x = 0; x < n; ++x){\n        if (fabs(c[x] - a[x]) > PRECISION) {\n            err += 1;\n            break;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "data",
                            "executable-data",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "2": {
                        "content": "#ifndef T2\n//T2:data,executable-data,construct-independent,compatibility-features,V:2.0-2.7\nint test2(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n    real_t * c = (real_t *)malloc(n * sizeof(real_t));\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = 0.0;\n        c[x] = 0.0;\n    }\n\n    #pragma acc enter data present_or_create(b[0:n])\n    #pragma acc data copyin(a[0:n])\n    {\n        #pragma acc parallel present(b[0:n])\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                b[x] = a[x];\n            }\n        }\n    }\n    #pragma acc data copyout(c[0:n])\n    {\n        #pragma acc parallel present(b[0:n])\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                c[x] = b[x];\n            }\n        }\n    }\n    #pragma acc exit data delete(b[0:n])\n    for (int x = 0; x < n; ++x){\n        if (fabs(c[x] - a[x]) > PRECISION) {\n            err += 2;\n            break;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T2\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test2();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 1);\n    }\n#endif\n",
                        "tags": [
                            "data",
                            "executable-data",
                            "construct-independent",
                            "compatibility-features"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "3": {
                        "content": "#ifndef T3\n//T3:data,executable-data,construct-independent,compatibility-features,V:2.0-2.7\nint test3(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n    real_t * c = (real_t *)malloc(n * sizeof(real_t));\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = 0.0;\n        c[x] = 0.0;\n    }\n\n    #pragma acc enter data pcreate(b[0:n])\n    #pragma acc data copyin(a[0:n])\n    {\n        #pragma acc parallel present(b[0:n])\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                b[x] = a[x];\n            }\n        }\n    }\n    #pragma acc data copyout(c[0:n])\n    {\n        #pragma acc parallel present(b[0:n])\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                c[x] = b[x];\n            }\n        }\n    }\n    #pragma acc exit data delete(b[0:n])\n    for (int x = 0; x < n; ++x){\n        if (fabs(c[x] - a[x]) > PRECISION){\n            err += 4;\n            break;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T3\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test3();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 2);\n    }\n#endif\n",
                        "tags": [
                            "data",
                            "executable-data",
                            "construct-independent",
                            "compatibility-features"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "enter_data_create_no_lower_bound.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:data,executable-data,construct-independent,V:2.0-2.7\n      LOGICAL FUNCTION test1()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT):: a, b, c, d, e !Data\n        INTEGER :: errors = 0\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(a)\n        CALL RANDOM_NUMBER(b)\n        c = 0\n        CALL RANDOM_NUMBER(d)\n        e = 0\n\n        !$acc enter data create(c(:LOOPCOUNT))\n        !$acc data copyin(a(1:LOOPCOUNT), b(1:LOOPCOUNT), d(1:LOOPCOUNT)) copyout(e(1:LOOPCOUNT)) present(c(1:LOOPCOUNT))\n          !$acc parallel\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              c(x) = a(x) + b(x)\n            END DO\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              e(x) = c(x) + d(x)\n            END DO\n          !$acc end parallel\n        !$acc end data\n        DO x = 1, LOOPCOUNT\n          IF (abs(e(x) - (a(x) + b(x) + d(x))) .gt. PRECISION) THEN\n            errors = errors + 1\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "data",
                            "executable-data",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "enter_data_create_no_lower_bound.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:data,executable-data,syntactic,construct-independent,V:2.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n    real_t * c = (real_t *)malloc(n * sizeof(real_t));\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n        c[x] = 0.0;\n    }\n\n    #pragma acc enter data copyin(a[0:n], b[0:n]) create(c[:n])\n    #pragma acc parallel present(a[0:n], b[0:n], c[0:n])\n    {\n        #pragma acc loop\n        for (int x = 0; x < n; ++x){\n            c[x] = a[x] + b[x];\n        }\n    }\n    #pragma acc exit data delete(a[0:n], b[0:n]) copyout(c[0:n])\n\n    for (int x = 0; x < n; ++x){\n        if (fabs(c[x] - (a[x] + b[x])) > PRECISION){\n            err += 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "data",
                            "executable-data",
                            "syntactic",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "enter_data_if.F90": {
                "num tests": 5,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:data,executable-data,devonly,construct-independent,if,V:2.0-2.7\n      LOGICAL FUNCTION test1()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT):: a, a_copy, b, b_copy, c !Data\n        INTEGER :: errors = 0\n        INTEGER,DIMENSION(1):: devtest\n        LOGICAL :: dev = .TRUE.\n        LOGICAL :: cpu = .FALSE.\n        devtest(1) = 1\n\n        !$acc enter data copyin(devtest(1:1))\n        !$acc parallel\n          devtest(1) = 0\n        !$acc end parallel\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(a)\n        CALL RANDOM_NUMBER(b)\n        c = 0\n\n        !$acc enter data copyin(a(1:LOOPCOUNT), b(1:LOOPCOUNT)) if(dev)\n        !$acc data create(a(1:LOOPCOUNT), b(1:LOOPCOUNT)) copyout(c(1:LOOPCOUNT))\n          !$acc parallel\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              c(x) = a(x) + b(x)\n            END DO\n          !$acc end parallel\n        !$acc end data\n        !$acc exit data delete(a(1:LOOPCOUNT), b(1:LOOPCOUNT)) if(dev)\n        DO x = 1, LOOPCOUNT\n          IF (abs(c(x) - (a(x) + b(x))) .gt. PRECISION) THEN\n            errors = errors + 1\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "data",
                            "executable-data",
                            "devonly",
                            "construct-independent",
                            "if"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "2": {
                        "content": "#ifndef T2\n!T2:data,executable-data,devonly,construct-independent,if,V:2.0-2.7\n      LOGICAL FUNCTION test2()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT):: a, a_copy, b, b_copy, c !Data\n        INTEGER :: errors = 0\n        INTEGER,DIMENSION(1):: devtest\n        LOGICAL :: dev = .TRUE.\n        LOGICAL :: cpu = .FALSE.\n        devtest(1) = 1\n\n        !$acc enter data copyin(devtest(1:1))\n        !$acc parallel\n          devtest(1) = 0\n        !$acc end parallel\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(a)\n        CALL RANDOM_NUMBER(b)\n        c = 0\n\n        !$acc enter data create(a(1:LOOPCOUNT), b(1:LOOPCOUNT)) if(cpu)\n        !$acc data copyin(a(1:LOOPCOUNT), b(1:LOOPCOUNT)) copyout(c(1:LOOPCOUNT))\n          !$acc parallel\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              c(x) = a(x) + b(x)\n            END DO\n          !$acc end parallel\n        !$acc end data\n        !$acc exit data copyout(a(1:LOOPCOUNT), b(1:LOOPCOUNT)) if(cpu)\n\n        DO x = 1, LOOPCOUNT\n          IF (abs(c(x) - (a(x) + b(x))) .gt. PRECISION) THEN\n            errors = errors + 1\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test2 = .FALSE.\n        ELSE\n          test2 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T2\n        LOGICAL :: test2\n#endif\n#ifndef T2\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test2()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 1\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "data",
                            "executable-data",
                            "devonly",
                            "construct-independent",
                            "if"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "3": {
                        "content": "#ifndef T3\n!T3:data,executable-data,devonly,construct-independent,if,V:2.0-2.7\n      LOGICAL FUNCTION test3()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT):: a, a_copy, b, b_copy, c !Data\n        INTEGER :: errors = 0\n        INTEGER,DIMENSION(1):: devtest\n        LOGICAL :: dev = .TRUE.\n        LOGICAL :: cpu = .FALSE.\n        devtest(1) = 1\n\n        !$acc enter data copyin(devtest(1:1))\n        !$acc parallel\n          devtest(1) = 0\n        !$acc end parallel\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        IF (devtest(1) .eq. 1) THEN\n          CALL RANDOM_NUMBER(a)\n          a_copy = a\n          CALL RANDOM_NUMBER(b)\n          b_copy = b\n          c = 0\n\n          !$acc enter data copyin(a(1:LOOPCOUNT), b(1:LOOPCOUNT)) if(dev)\n\n          a = 0\n          b = 0\n\n          !$acc data copyin(a(1:LOOPCOUNT), b(1:LOOPCOUNT)) copyout(c(1:LOOPCOUNT))\n            !$acc parallel\n              !$acc loop\n              DO x = 1, LOOPCOUNT\n                c(x) = a(x) + b(x)\n              END DO\n            !$acc end parallel\n          !$acc end data\n          !$acc exit data delete(a(1:LOOPCOUNT), b(1:LOOPCOUNT)) if(dev)\n\n          DO x = 1, LOOPCOUNT\n            IF (abs(c(x) - (a_copy(x) + b_copy(x))) .gt. PRECISION) THEN\n              errors = errors + 1\n            END IF\n          END DO\n        END IF\n\n        IF (errors .eq. 0) THEN\n          test3 = .FALSE.\n        ELSE\n          test3 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T3\n        LOGICAL :: test3\n#endif\n#ifndef T3\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test3()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 2\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "data",
                            "executable-data",
                            "devonly",
                            "construct-independent",
                            "if"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "4": {
                        "content": "#ifndef T4\n!T4:data,executable-data,devonly,construct-independent,if,V:2.0-2.7\n      LOGICAL FUNCTION test4()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT):: a, a_copy, b, b_copy, c !Data\n        INTEGER :: errors = 0\n        INTEGER,DIMENSION(1):: devtest\n        LOGICAL :: dev = .TRUE.\n        LOGICAL :: cpu = .FALSE.\n        devtest(1) = 1\n\n        !$acc enter data copyin(devtest(1:1))\n        !$acc parallel\n          devtest(1) = 0\n        !$acc end parallel\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        IF (devtest(1) .eq. 1) THEN\n          CALL RANDOM_NUMBER(a)\n          CALL RANDOM_NUMBER(b)\n          c = 0\n\n          !$acc enter data copyin(a(1:LOOPCOUNT), b(1:LOOPCOUNT)) if(cpu)\n          CALL RANDOM_NUMBER(a)\n          a_copy = a\n          CALL RANDOM_NUMBER(b)\n          b_copy = b\n\n          !$acc data copyin(a(1:LOOPCOUNT), b(1:LOOPCOUNT)) copyout(c(1:LOOPCOUNT))\n            !$acc parallel\n              !$acc loop\n              DO x = 1, LOOPCOUNT\n                c(x) = a(x) + b(x)\n              END DO\n            !$acc end parallel\n          !$acc end data\n          !$acc exit data copyout(a(1:LOOPCOUNT), b(1:LOOPCOUNT)) if(cpu)\n\n          DO x = 1, LOOPCOUNT\n            IF (abs(c(x) - (a_copy(x) + b_copy(x))) .gt. PRECISION) THEN\n              errors = errors + 1\n            END IF\n          END DO\n        END IF\n\n        IF (errors .eq. 0) THEN\n          test4 = .FALSE.\n        ELSE\n          test4 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T4\n        LOGICAL :: test4\n#endif\n#ifndef T4\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test4()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 3\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "data",
                            "executable-data",
                            "devonly",
                            "construct-independent",
                            "if"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "5": {
                        "content": "#ifndef T5\n!T5:data,executable-data,devonly,construct-independent,if,V:2.0-2.7\n      LOGICAL FUNCTION test5()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT):: a, a_copy, b, b_copy, c !Data\n        INTEGER :: errors = 0\n        INTEGER,DIMENSION(1):: devtest\n        LOGICAL :: dev = .TRUE.\n        LOGICAL :: cpu = .FALSE.\n        devtest(1) = 1\n\n        !$acc enter data copyin(devtest(1:1))\n        !$acc parallel\n          devtest(1) = 0\n        !$acc end parallel\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        IF (devtest(1) .eq. 1) THEN\n          CALL RANDOM_NUMBER(a)\n          CALL RANDOM_NUMBER(b)\n          c = 0\n\n          !$acc enter data create(a(1:LOOPCOUNT), b(1:LOOPCOUNT)) if(cpu)\n          !$acc data copyin(a(1:LOOPCOUNT), b(1:LOOPCOUNT)) copyout(c(1:LOOPCOUNT))\n            !$acc parallel\n              !$acc loop\n              DO x = 1, LOOPCOUNT\n                c(x) = a(x) + b(x)\n              END DO\n            !$acc end parallel\n          !$acc end data\n\n          DO x = 1, LOOPCOUNT\n            IF (abs(c(x) - (a(x) + b(x))) .gt. PRECISION) THEN\n              errors = errors + 1\n            END IF\n          END DO\n        END IF\n\n        IF (errors .eq. 0) THEN\n          test5 = .FALSE.\n        ELSE\n          test5 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T5\n        LOGICAL :: test5\n#endif\n#ifndef T5\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test5()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 4\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "data",
                            "executable-data",
                            "devonly",
                            "construct-independent",
                            "if"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "enter_exit_data_if.c": {
                "num tests": 5,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:data,executable-data,construct-independent,if,reference-counting,V:2.5-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n    real_t * c = (real_t *)malloc(n * sizeof(real_t));\n    int dev = 1;\n    int host = 0;\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n        c[x] = 0.0;\n    }\n\n    #pragma acc enter data copyin(a[0:n], b[0:n]) if(dev)\n    #pragma acc data create(a[0:n], b[0:n]) copyout(c[0:n])\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                c[x] = a[x] + b[x];\n            }\n        }\n    }\n    #pragma acc exit data delete(a[0:n], b[0:n]) if(dev)\n\n    for (int x = 0; x < n; ++x){\n        if (fabs(c[x] - (a[x] + b[x])) > PRECISION){\n            err += 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "data",
                            "executable-data",
                            "construct-independent",
                            "if",
                            "reference-counting"
                        ],
                        "versions": [
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "2": {
                        "content": "#ifndef T2\n//T2:data,executable-data,construct-independent,if,V:2.0-2.7\nint test2(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n    real_t * c = (real_t *)malloc(n * sizeof(real_t));\n    int dev = 1;\n    int host = 0;\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n        c[x] = 0;\n    }\n\n    #pragma acc enter data create(a[0:n], b[0:n]) if(host)\n    #pragma acc data copyin(a[0:n], b[0:n]) copyout(c[0:n])\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                c[x] = a[x] + b[x];\n            }\n        }\n    }\n    #pragma acc exit data delete(a[0:n], b[0:n]) if(host)\n\n    for (int x = 0; x < n; ++x){\n        if (fabs(c[x] - (a[x] + b[x])) > PRECISION){\n            err += 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T2\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test2();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 1);\n    }\n#endif\n",
                        "tags": [
                            "data",
                            "executable-data",
                            "construct-independent",
                            "if"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "3": {
                        "content": "#ifndef T3\n//T3:data,executable-data,construct-independent,devonly,if,reference-counting,V:2.5-2.7\nint test3(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(n * sizeof(real_t));\n    real_t * a_copy = (real_t *)malloc(n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n    real_t * b_copy = (real_t *)malloc(n * sizeof(real_t));\n    real_t * c = (real_t *)malloc(n * sizeof(real_t));\n    int dev = 1;\n    int host = 0;\n    int * devtest = (int *)malloc(sizeof(int));\n\n    devtest[0] = 1;\n    #pragma acc enter data copyin(devtest[0:1])\n    #pragma acc parallel\n    {\n        devtest[0] = 0;\n    }\n\n    if (devtest[0] == 1){\n        for (int x = 0; x < n; ++x){\n            a[x] = rand() / (real_t)(RAND_MAX / 10);\n            a_copy[x] = a[x];\n            b[x] = rand() / (real_t)(RAND_MAX / 10);\n            b_copy[x] = b[x];\n            c[x] = 0.0;\n        }\n\n        #pragma acc enter data copyin(a[0:n], b[0:n]) if(dev)\n        for (int x = 0; x < n; ++x){\n            a[x] = 0;\n            b[x] = 0;\n        }\n        #pragma acc data create(a[0:n], b[0:n]) copyout(c[0:n])\n        {\n            #pragma acc parallel\n            {\n                #pragma acc loop\n                for (int x = 0; x < n; ++x){\n                    c[x] = a[x] + b[x];\n                }\n            }\n        }\n        #pragma acc exit data copyout(a[0:n], b[0:n]) if(dev)\n\n        for (int x = 0; x < n; ++x){\n            if (fabs(c[x] - (a_copy[x] + b_copy[x])) > PRECISION){\n                err += 1;\n            }\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T3\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test3();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 2);\n    }\n#endif\n",
                        "tags": [
                            "data",
                            "executable-data",
                            "construct-independent",
                            "devonly",
                            "if",
                            "reference-counting"
                        ],
                        "versions": [
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "4": {
                        "content": "#ifndef T4\n//T4:data,executable-data,if,construct-independent,devonly,V:2.0-2.7\nint test4(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(n * sizeof(real_t));\n    real_t * a_copy = (real_t *)malloc(n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n    real_t * b_copy = (real_t *)malloc(n * sizeof(real_t));\n    real_t * c = (real_t *)malloc(n * sizeof(real_t));\n    int dev = 1;\n    int host = 0;\n    int * devtest = (int *)malloc(sizeof(int));\n\n    devtest[0] = 1;\n    #pragma acc enter data copyin(devtest[0:1])\n    #pragma acc parallel\n    {\n        devtest[0] = 0;\n    }\n\n    if (devtest[0] == 1){\n        for (int x = 0; x < n; ++x){\n            a[x] = rand() / (real_t)(RAND_MAX / 10);\n            b[x] = rand() / (real_t)(RAND_MAX / 10);\n            c[x] = 0.0;\n        }\n\n        #pragma acc enter data copyin(a[0:n], b[0:n]) if(host)\n        for (int x = 0; x < n; ++x){\n            a[x] = rand() / (real_t)(RAND_MAX / 10);\n            a_copy[x] = a[x];\n            b[x] = rand() / (real_t)(RAND_MAX / 10);\n            b_copy[x] = b[x];\n        }\n        #pragma acc data copyin(a[0:n], b[0:n]) copyout(c[0:n])\n        {\n            #pragma acc parallel\n            {\n                #pragma acc loop\n                for (int x = 0; x < n; ++x){\n                    c[x] = a[x] + b[x];\n                }\n            }\n        }\n        #pragma acc exit data copyout(a[0:n], b[0:n]) if(host)\n\n        for (int x = 0; x < n; ++x){\n            if (fabs(c[x] - (a_copy[x] + b_copy[x])) > PRECISION){\n                err += 1;\n            }\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T4\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test4();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 3);\n    }\n#endif\n",
                        "tags": [
                            "data",
                            "executable-data",
                            "if",
                            "construct-independent",
                            "devonly"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "5": {
                        "content": "#ifndef T5\n//T5:data,executable-data,if,construct-independent,devonly,V:2.0-2.7\nint test5(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(n * sizeof(real_t));\n    real_t * a_copy = (real_t *)malloc(n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n    real_t * b_copy = (real_t *)malloc(n * sizeof(real_t));\n    real_t * c = (real_t *)malloc(n * sizeof(real_t));\n    int dev = 1;\n    int host = 0;\n    int * devtest = (int *)malloc(sizeof(int));\n\n    devtest[0] = 1;\n    #pragma acc enter data copyin(devtest[0:1])\n    #pragma acc parallel\n    {\n        devtest[0] = 0;\n    }\n\n    if (devtest[0] == 1){\n        for (int x = 0; x < n; ++x){\n            a[x] = rand() / (real_t)(RAND_MAX / 10);\n            b[x] = rand() / (real_t)(RAND_MAX / 10);\n            c[x] = 0.0;\n        }\n\n        #pragma acc enter data create(a[0:n], b[0:n]) if(host)\n        #pragma acc data copyin(a[0:n], b[0:n]) copyout(c[0:n])\n        {\n            #pragma acc parallel\n            {\n                #pragma acc loop\n                for (int x = 0; x < n; ++x){\n                    c[x] = a[x] + b[x];\n                }\n            }\n        }\n        #pragma acc exit data copyout(a[0:n], b[0:n]) if(host)\n\n        for (int x = 0; x < n; ++x){\n            if (fabs(c[x] - (a[x] + b[x])) > PRECISION){\n                err += 1;\n            }\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T5\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test5();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 4);\n    }\n#endif\n",
                        "tags": [
                            "data",
                            "executable-data",
                            "if",
                            "construct-independent",
                            "devonly"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "exit_data.F90": {
                "num tests": 2,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:data,executable-data,devonly,construct-independent,V:2.0-2.7\n      LOGICAL FUNCTION test1()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT):: a, a_copy !Data\n        INTEGER :: errors = 0\n        INTEGER,DIMENSION(1):: devtest\n        devtest(1) = 1\n        !$acc enter data copyin(devtest(1:1))\n        !$acc parallel\n          devtest(1) = 0\n        !$acc end parallel\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(a)\n        a_copy = a\n\n        IF (devtest(1) .eq. 1) THEN\n          !$acc enter data copyin(a(1:LOOPCOUNT))\n          !$acc parallel present(a(1:LOOPCOUNT))\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              a(x) = a(x) + 1\n            END DO\n          !$acc end parallel\n          !$acc exit data delete(a(1:LOOPCOUNT))\n\n          DO x = 1, LOOPCOUNT\n            IF (abs(a(x) - a_copy(x)) .gt. PRECISION) THEN\n              errors = errors + 1\n            END IF\n          END DO\n        END IF\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "data",
                            "executable-data",
                            "devonly",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "2": {
                        "content": "#ifndef T2\n!T2:data,executable-data,devonly,construct-independent,V:2.0-2.7\n      LOGICAL FUNCTION test2()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT):: a, a_copy !Data\n        INTEGER :: errors = 0\n        INTEGER,DIMENSION(1):: devtest\n        devtest(1) = 1\n        !$acc enter data copyin(devtest(1:1))\n        !$acc parallel\n          devtest(1) = 0\n        !$acc end parallel\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(a)\n        a_copy = a\n        !$acc enter data copyin(a(1:LOOPCOUNT))\n        !$acc parallel present(a(1:LOOPCOUNT))\n          !$acc loop\n          DO x = 1, LOOPCOUNT\n            a(x) = a(x) + 1\n          END DO\n        !$acc end parallel\n        !$acc exit data copyout(a(1:LOOPCOUNT))\n\n        DO x = 1, LOOPCOUNT\n          IF (abs(a(x) - (a_copy(x) + 1)) .gt. PRECISION) THEN\n            errors = errors + 1\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test2 = .FALSE.\n        ELSE\n          test2 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T2\n        LOGICAL :: test2\n#endif\n#ifndef T2\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test2()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 1\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "data",
                            "executable-data",
                            "devonly",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "exit_data.c": {
                "num tests": 2,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:data,executable-data,devonly,construct-independent,V:2.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(n * sizeof(real_t));\n    real_t * a_copy = (real_t *)malloc(n * sizeof(real_t));\n    int * devtest = (int *)malloc(sizeof(int));\n\n    devtest[0] = 1;\n    #pragma acc enter data copyin(devtest[0:1])\n    #pragma acc parallel present(devtest[0:1])\n    {\n        devtest[0] = 0;\n    }\n\n    if (devtest[0] == 1){\n        for (int x = 0; x < n; ++x){\n            a[x] = rand() / (real_t)(RAND_MAX / 10);\n            a_copy[x] = a[x];\n        }\n\n        #pragma acc enter data copyin(a[0:n])\n        #pragma acc parallel present(a[0:n])\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                a[x] = a[x] + 1;\n            }\n        }\n        #pragma acc exit data delete(a[0:n])\n\n        for (int x = 0; x < n; ++x){\n            if (fabs(a[x] - a_copy[x]) > PRECISION){\n                err += 1;\n            }\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "data",
                            "executable-data",
                            "devonly",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "2": {
                        "content": "#ifndef T2\n//T2:data,executable-data,V:2.0-2.7\nint test2(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(n * sizeof(real_t));\n    real_t * a_copy = (real_t *)malloc(n * sizeof(real_t));\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        a_copy[x] = a[x];\n    }\n\n    #pragma acc enter data copyin(a[0:n])\n    #pragma acc parallel present(a[0:n])\n    {\n        #pragma acc loop\n        for (int x = 0; x < n; ++x){\n            a[x] = a[x] + 1;\n        }\n    }\n    #pragma acc exit data copyout(a[0:n])\n\n    for (int x = 0; x < n; ++x){\n        if (fabs(a[x] - (a_copy[x] + 1)) > PRECISION){\n            err += 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T2\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test2();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 1);\n    }\n#endif\n",
                        "tags": [
                            "data",
                            "executable-data"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "exit_data_copyout_no_lower_bound.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:data,executable-data,construct-independent,V:2.0-2.7\n      LOGICAL FUNCTION test1()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT):: a, b, c !Data\n        INTEGER :: errors = 0\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(a)\n        CALL RANDOM_NUMBER(b)\n        c = 0\n        !$acc enter data create(c(1:LOOPCOUNT))\n        !$acc data copyin(a(1:LOOPCOUNT), b(1:LOOPCOUNT)) present(c(1:LOOPCOUNT))\n          !$acc parallel\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              c(x) = a(x) + b(x)\n            END DO\n          !$acc end parallel\n        !$acc end data\n        !$acc exit data copyout(c(:LOOPCOUNT))\n        DO x = 1, LOOPCOUNT\n          IF (abs(c(x) - (a(x) + b(x))) .gt. PRECISION) THEN\n            errors = errors + 1\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "data",
                            "executable-data",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "exit_data_copyout_no_lower_bound.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:data,executable-data,syntactic,construct-independent,V:2.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n    real_t * c = (real_t *)malloc(n * sizeof(real_t));\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n        c[x] = 0.0;\n    }\n\n    #pragma acc enter data copyin(a[0:n], b[0:n]) create(c[0:n])\n    #pragma acc parallel present(a[0:n], b[0:n], c[0:n])\n    {\n        #pragma acc loop\n        for (int x = 0; x < n; ++x){\n            c[x] = a[x] + b[x];\n        }\n    }\n    #pragma acc exit data delete(a[0:n], b[0:n]) copyout(c[:n])\n\n    for (int x = 0; x < n; ++x){\n        if (fabs(c[x] - (a[x] + b[x])) > PRECISION) {\n            err += 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "data",
                            "executable-data",
                            "syntactic",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "exit_data_copyout_reference_counts.F90": {
                "num tests": 3,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:data,executable-data,devonly,construct-independent,V:2.0-2.7\n      LOGICAL FUNCTION test1()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT):: a, b, c !Data\n        INTEGER :: errors = 0\n        INTEGER,DIMENSION(1):: devtest\n\n        devtest(1) = 1\n        !$acc enter data copyin(devtest(1:1))\n        !$acc parallel present(devtest(1:1))\n          devtest(1) = 0\n        !$acc end parallel\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(a)\n        CALL RANDOM_NUMBER(b)\n        c = 0\n\n        IF (devtest(1) .eq. 1) THEN\n          !$acc enter data copyin(a(1:LOOPCOUNT), b(1:LOOPCOUNT), c(1:LOOPCOUNT))\n          !$acc data copyin(c(1:LOOPCOUNT))\n            !$acc parallel\n              !$acc loop\n              DO x = 1, LOOPCOUNT\n                c(x) = c(x) + a(x) + b(x)\n              END DO\n            !$acc end parallel\n            !$acc exit data delete(a(1:LOOPCOUNT), b(1:LOOPCOUNT)) copyout(c(1:LOOPCOUNT))\n          !$acc end data\n\n          DO x = 1, LOOPCOUNT\n            IF (abs(c(x)) .gt. PRECISION) THEN\n              errors = errors + 1\n              EXIT\n            END IF\n          END DO \n        END IF\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "data",
                            "executable-data",
                            "devonly",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "2": {
                        "content": "#ifndef T2\n!T2:data,executable-data,devonly,construct-independent,V:2.0-2.7\n      LOGICAL FUNCTION test2()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT):: a, b, c !Data\n        INTEGER :: errors = 0\n        INTEGER,DIMENSION(1):: devtest\n\n        devtest(1) = 1\n        !$acc enter data copyin(devtest(1:1))\n        !$acc parallel present(devtest(1:1))\n          devtest(1) = 0\n        !$acc end parallel\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(a)\n        CALL RANDOM_NUMBER(b)\n        c = 0\n        !$acc enter data copyin(a(1:LOOPCOUNT), b(1:LOOPCOUNT), c(1:LOOPCOUNT))\n        !$acc data copyin(c(1:LOOPCOUNT))\n          !$acc parallel\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              c(x) = c(x) + a(x) + b(x)\n            END DO\n          !$acc end parallel\n        !$acc end data\n        !$acc exit data copyout(c(1:LOOPCOUNT)) delete(a(1:LOOPCOUNT), b(1:LOOPCOUNT))\n\n        DO x = 1, LOOPCOUNT\n          IF (abs(c(x) - (a(x) + b(x))) .gt. PRECISION) THEN\n            errors = errors + 2\n            EXIT\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test2 = .FALSE.\n        ELSE\n          test2 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T2\n        LOGICAL :: test2\n#endif\n#ifndef T2\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test2()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 1\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "data",
                            "executable-data",
                            "devonly",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "3": {
                        "content": "#ifndef T3\n!T3:data,executable-data,devonly,construct-independent,V:2.0-2.7\n      LOGICAL FUNCTION test3()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT):: a, b, c !Data\n        INTEGER :: errors = 0\n        INTEGER,DIMENSION(1):: devtest\n\n        devtest(1) = 1\n        !$acc enter data copyin(devtest(1:1))\n        !$acc parallel present(devtest(1:1))\n          devtest(1) = 0\n        !$acc end parallel\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(a)\n        CALL RANDOM_NUMBER(b)\n        c = 0\n\n        !$acc enter data copyin(a(1:LOOPCOUNT), b(1:LOOPCOUNT), c(1:LOOPCOUNT))\n        !$acc enter data copyin(c(1:LOOPCOUNT))\n        !$acc parallel\n          !$acc loop\n          DO x = 1, LOOPCOUNT\n            c(x) = c(x) + a(x) + b(x)\n          END DO\n        !$acc end parallel\n        !$acc exit data delete(c(1:LOOPCOUNT))\n        !$acc exit data delete(a(1:LOOPCOUNT), b(1:LOOPCOUNT)) copyout(c(1:LOOPCOUNT))\n\n        DO x = 1, LOOPCOUNT\n          IF (abs(c(x) - (a(x) + b(x))) .gt. PRECISION) THEN\n            errors = errors + 4\n            EXIT\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test3 = .FALSE.\n        ELSE\n          test3 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T3\n        LOGICAL :: test3\n#endif\n#ifndef T3\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test3()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 2\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "data",
                            "executable-data",
                            "devonly",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "exit_data_copyout_reference_counts.c": {
                "num tests": 3,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:data,executable-data,devonly,construct-independent,reference-counting,V:2.5-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n    real_t * c = (real_t *)malloc(n * sizeof(real_t));\n    int * devtest = (int *)malloc(sizeof(int));\n\n    devtest[0] = 1;\n    #pragma acc enter data copyin(devtest[0:1])\n    #pragma acc parallel present(devtest[0:1])\n    {\n        devtest[0] = 0;\n    }\n\n    if (devtest[0] == 1){\n        for (int x = 0; x < n; ++x){\n          a[x] = rand() / (real_t)(RAND_MAX / 10);\n          b[x] = rand() / (real_t)(RAND_MAX / 10);\n          c[x] = 0.0;\n        }\n\n        #pragma acc enter data copyin(a[0:n], b[0:n], c[0:n])\n        #pragma acc data copyin(c[0:n])\n        {\n            #pragma acc parallel\n            {\n                #pragma acc loop\n                for (int x = 0; x < n; ++x){\n                    c[x] += a[x] + b[x];\n                }\n            }\n            #pragma acc exit data copyout(c[0:n]) delete(a[0:n], b[0:n])\n        }\n        for (int x = 0; x < n; ++x){\n            if (fabs(c[x]) > PRECISION){\n                err += 1;\n            }\n        }\n\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "data",
                            "executable-data",
                            "devonly",
                            "construct-independent",
                            "reference-counting"
                        ],
                        "versions": [
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "2": {
                        "content": "#ifndef T2\n//T2:data,executable-data,reference-counting,construct-independent,V:2.5-2.7\nint test2(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n    real_t * c = (real_t *)malloc(n * sizeof(real_t));\n\n    for (int x = 0; x < n; ++x){\n      a[x] = rand() / (real_t)(RAND_MAX / 10);\n      b[x] = rand() / (real_t)(RAND_MAX / 10);\n      c[x] = 0.0;\n    }\n\n    #pragma acc enter data copyin(a[0:n], b[0:n], c[0:n])\n    #pragma acc data copyin(c[0:n])\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                c[x] += a[x] + b[x];\n            }\n        }\n    }\n    #pragma acc exit data copyout(c[0:n]) delete(a[0:n], b[0:n])\n\n    for (int x = 0; x < n; ++x){\n        if (fabs(c[x] - (a[x] + b[x])) > PRECISION){\n            err += 2;\n            break;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T2\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test2();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 1);\n    }\n#endif\n",
                        "tags": [
                            "data",
                            "executable-data",
                            "reference-counting",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "3": {
                        "content": "#ifndef T3\n//T3:data,executable-data,reference-counting,construct-independent,V:2.5-2.7\nint test3(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n    real_t * c = (real_t *)malloc(n * sizeof(real_t));\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n        c[x] = 0.0;\n    }\n\n    #pragma acc enter data copyin(a[0:n], b[0:n], c[0:n])\n    #pragma acc enter data create(c[0:n])\n    #pragma acc parallel\n    {\n        #pragma acc loop\n        for (int x = 0; x < n; ++x){\n            c[x] += a[x] + b[x];\n        }\n    }\n    #pragma acc exit data delete(c[0:n])\n    #pragma acc exit data delete(a[0:n], b[0:n]) copyout(c[0:n])\n\n    for (int x = 0; x < n; ++x){\n        if (fabs(c[x] - (a[x] + b[x])) > PRECISION){\n            err += 4;\n            break;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T3\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test3();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 2);\n    }\n#endif\n",
                        "tags": [
                            "data",
                            "executable-data",
                            "reference-counting",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "exit_data_delete_no_lower_bound.F90": {
                "num tests": 2,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:data,executable-data,construct-independent,V:2.0-2.7\n      LOGICAL FUNCTION test1()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT):: a, b, c !Data\n        INTEGER :: errors = 0\n        LOGICAL,DIMENSION(1):: has_device\n\n        has_device(1) = .TRUE.\n        !$acc enter data copyin(has_device(1:1))\n        !$acc parallel present(has_device(1:1))\n          has_device(1) = .FALSE.\n        !$acc end parallel\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(a)\n        CALL RANDOM_NUMBER(b)\n        c = 0\n\n        !$acc enter data copyin(a(1:LOOPCOUNT), b(1:LOOPCOUNT))\n        !$acc data copyout(c(1:LOOPCOUNT)) present(a(1:LOOPCOUNT), b(1:LOOPCOUNT))\n          !$acc parallel\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              c(x) = a(x) + b(x)\n            END DO\n          !$acc end parallel\n        !$acc end data\n        !$acc exit data delete(a(:LOOPCOUNT), b(:LOOPCOUNT))\n        DO x = 1, LOOPCOUNT\n          IF (abs(c(x) - (a(x) + b(x))) .gt. PRECISION) THEN\n            errors = errors + 1\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "data",
                            "executable-data",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "2": {
                        "content": "#ifndef T2\n!T2:data,executable-data,construct-independent,V:2.0-2.7\n      LOGICAL FUNCTION test2()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT):: a, b, c !Data\n        INTEGER :: errors = 0\n        LOGICAL,DIMENSION(1):: has_device\n\n        has_device(1) = .TRUE.\n        !$acc enter data copyin(has_device(1:1))\n        !$acc parallel present(has_device(1:1))\n          has_device(1) = .FALSE.\n        !$acc end parallel\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        IF (has_device(1) .eqv. .TRUE.) THEN\n          CALL RANDOM_NUMBER(a)\n          CALL RANDOM_NUMBER(b)\n          c = 0\n          \n          !$acc enter data copyin(c(1:LOOPCOUNT))\n          !$acc data copyin(a(1:LOOPCOUNT), b(1:LOOPCOUNT)) present(c(1:LOOPCOUNT))\n            !$acc parallel\n              !$acc loop\n              DO x = 1, LOOPCOUNT\n                c(x) = a(x) + b(x)\n              END DO\n            !$acc end parallel\n          !$acc end data\n          !$acc exit data delete(c(:LOOPCOUNT))\n\n          DO x = 1, LOOPCOUNT\n            IF (abs(c(x)) .gt. PRECISION) THEN\n              errors = errors + 1\n            END IF\n          END DO\n        END IF\n\n        IF (errors .eq. 0) THEN\n          test2 = .FALSE.\n        ELSE\n          test2 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T2\n        LOGICAL :: test2\n#endif\n#ifndef T2\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test2()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 1\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "data",
                            "executable-data",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "exit_data_delete_no_lower_bound.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:data,executable-data,construct-independent,syntactic,V:2.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n    real_t * c = (real_t *)malloc(n * sizeof(real_t));\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n        c[x] = 0.0;\n    }\n\n    #pragma acc enter data copyin(a[0:n], b[0:n]) create(c[0:n])\n    #pragma acc parallel present(a[0:n], b[0:n], c[0:n])\n    {\n        #pragma acc loop\n        for (int x = 0; x < n; ++x){\n            c[x] = a[x] + b[x];\n        }\n    }\n    #pragma acc exit data delete(a[:n], b[:n]) copyout(c[0:n])\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "data",
                            "executable-data",
                            "construct-independent",
                            "syntactic"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "exit_data_finalize.F90": {
                "num tests": 2,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:data,executable-data,devonly,construct-independent,V:2.0-2.7\n      LOGICAL FUNCTION test1()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT):: a, b, c !Data\n        INTEGER :: errors = 0\n        INTEGER,DIMENSION(1) :: devtest\n\n        devtest(1) = 1\n        !$acc enter data copyin(devtest(1:1))\n        !$acc parallel present(devtest(1:1))\n          devtest(1) = 0\n        !$acc end parallel\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(a)\n        CALL RANDOM_NUMBER(b)\n        c = 0\n\n        !$acc enter data copyin(a(1:LOOPCOUNT), b(1:LOOPCOUNT), c(1:LOOPCOUNT))\n        !$acc enter data create(a(1:LOOPCOUNT), b(1:LOOPCOUNT), c(1:LOOPCOUNT))\n        !$acc parallel present(a(1:LOOPCOUNT), b(1:LOOPCOUNT), c(1:LOOPCOUNT))\n          !$acc loop\n          DO x = 1, LOOPCOUNT\n            c(x) = a(x) + b(x)\n          END DO\n        !$acc end parallel\n        !$acc exit data copyout(a(1:LOOPCOUNT), b(1:LOOPCOUNT), c(1:LOOPCOUNT))\n        IF (devtest(1) .eq. 1) THEN\n          DO x = 1, LOOPCOUNT\n            IF (abs(c(x)) .gt. PRECISION) THEN\n              errors = errors + 1\n            END IF\n          END DO\n        END IF\n        !$acc exit data copyout(a(1:LOOPCOUNT), b(1:LOOPCOUNT), c(1:LOOPCOUNT))\n        DO x = 1, LOOPCOUNT\n          IF (abs(c(x) - (a(x) + b(x))) .gt. PRECISION) THEN\n            errors = errors + 1\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "data",
                            "executable-data",
                            "devonly",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "2": {
                        "content": "#ifndef T2\n!T2:data,executable-data,devonly,construct-independent,V:2.5-2.7\n      LOGICAL FUNCTION test2()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT):: a, b, c !Data\n        INTEGER :: errors = 0\n        INTEGER,DIMENSION(1) :: devtest\n\n        devtest(1) = 1\n        !$acc enter data copyin(devtest(1:1))\n        !$acc parallel present(devtest(1:1))\n          devtest(1) = 0\n        !$acc end parallel\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(a)\n        CALL RANDOM_NUMBER(b)\n        c = 0\n        !$acc enter data copyin(a(1:LOOPCOUNT), b(1:LOOPCOUNT), c(1:LOOPCOUNT))\n        !$acc enter data create(a(1:LOOPCOUNT), b(1:LOOPCOUNT), c(1:LOOPCOUNT))\n        !$acc parallel present(a(1:LOOPCOUNT), b(1:LOOPCOUNT), c(1:LOOPCOUNT))\n          !$acc loop\n          DO x = 1, LOOPCOUNT\n            c(x) = a(x) + b(x)\n          END DO\n        !$acc end parallel\n        !$acc exit data copyout(c(1:LOOPCOUNT)) delete(a(1:LOOPCOUNT), b(1:LOOPCOUNT)) finalize\n        DO x = 1, LOOPCOUNT\n          IF (abs(c(x) - (a(x) + b(x))) .gt. PRECISION) THEN\n            errors = errors + 1\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test2 = .FALSE.\n        ELSE\n          test2 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T2\n        LOGICAL :: test2\n#endif\n#ifndef T2\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test2()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 1\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "data",
                            "executable-data",
                            "devonly",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "exit_data_finalize.c": {
                "num tests": 2,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:data,executable-data,reference-counting,construct-independent,V:2.5-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n    real_t * c = (real_t *)malloc(n * sizeof(real_t));\n    int * devtest = (int *)malloc(sizeof(int));\n\n    devtest[0] = 1;\n    #pragma acc enter data copyin(devtest[0:1])\n    #pragma acc parallel\n    {\n        devtest[0] = 0;\n    }\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n        c[x] = 0;\n    }\n\n    #pragma acc enter data copyin(a[0:n], b[0:n], c[0:n])\n    #pragma acc enter data create(a[0:n], b[0:n], c[0:n])\n    #pragma acc parallel present(a[0:n], b[0:n], c[0:n])\n    {\n        #pragma acc loop\n        for (int x = 0; x < n; ++x){\n            c[x] = a[x] + b[x];\n        }\n    }\n    #pragma acc exit data copyout(a[0:n], b[0:n], c[0:n])\n    if (devtest[0] == 1){\n        for (int x = 0; x < n; ++x){\n            if (fabs(c[x]) > PRECISION) {\n                err += 1;\n            }\n        }\n    }\n    #pragma acc exit data copyout(c[0:n]) delete(a[0:n], b[0:n])\n    for (int x = 0; x < n; ++x){\n        if (fabs(c[x] - (a[x] + b[x])) > PRECISION){\n            err += 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "data",
                            "executable-data",
                            "reference-counting",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "2": {
                        "content": "#ifndef T2\n//T2:data,executable-data,reference-counting,construct-independent,V:2.5-2.7\nint test2(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n    real_t * c = (real_t *)malloc(n * sizeof(real_t));\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n        c[x] = 0.0;\n    }\n\n    #pragma acc enter data copyin(a[0:n], b[0:n], c[0:n])\n    #pragma acc enter data copyin(a[0:n], b[0:n], c[0:n])\n    #pragma acc parallel present(a[0:n], b[0:n], c[0:n])\n    {\n        #pragma acc loop\n        for (int x = 0; x < n; ++x){\n            c[x] = a[x] + b[x];\n        }\n    }\n    #pragma acc exit data delete(a[0:n], b[0:n]) copyout(c[0:n]) finalize\n    for (int x = 0; x < n; ++x){\n        if (fabs(c[x] - (a[x] + b[x])) > PRECISION) {\n            err += 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T2\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test2();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 1);\n    }\n#endif\n",
                        "tags": [
                            "data",
                            "executable-data",
                            "reference-counting",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "host_data.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:data,data-region,host-data,construct-independent,V:2.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(n * sizeof(real_t));\n    int * high = (int *)malloc(n * sizeof(int));\n    int high_current_index = 0;\n    size_t * a_points = (size_t *)malloc(n * sizeof(void *));\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        if (a[x] > 5) {\n            high[high_current_index] = x;\n            high_current_index += 1;\n        }\n    }\n\n    #pragma acc enter data copyin(a[0:n])\n\n    #pragma acc host_data use_device(a)\n    {\n        int x = 0;\n        for (x = 0; x < high_current_index; ++x){\n            a_points[x] = (size_t) a + (high[x]*sizeof(real_t*));\n        }\n        for (; x < n; ++x){\n            a_points[x] = 0;\n        }\n    }\n    #pragma acc enter data copyin(a_points[0:n])\n    #pragma acc parallel present(a[0:n], a_points[0:n])\n    {\n        #pragma acc loop\n        for (int x = 0; x < n; ++x){\n            if (a_points[x] != 0){\n                *((real_t *) a_points[x]) -= 5;\n            }\n        }\n    }\n    #pragma acc exit data delete(a_points[0:n]) copyout(a[0:n])\n    for (int x = 0; x < n; ++x){\n        if (a[x] < 0 || a[x] > 5) {\n            err += 1;\n            break;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "data",
                            "data-region",
                            "host-data",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "id": 1,
            "init.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:construct-independent,init,nonvalidating,V:2.5-2.7\n      LOGICAL FUNCTION test1()\n        USE OPENACC\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: errors = 0\n\n        !$acc init\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "construct-independent",
                            "init",
                            "nonvalidating"
                        ],
                        "versions": [
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "init.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:init,V:2.5-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n\n    #pragma acc init\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "init"
                        ],
                        "versions": [
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "init_device_num.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:runtime,construct-independent,internal-control-values,init,nonvalidating,V:2.5-2.7\n      LOGICAL FUNCTION test1()\n        USE OPENACC\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: device_num\n        INTEGER :: device_type\n        INTEGER :: errors = 0\n\n        device_num = acc_get_device_num(acc_get_device_type())\n        !$acc init device_num(device_num)\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "runtime",
                            "construct-independent",
                            "internal-control-values",
                            "init",
                            "nonvalidating"
                        ],
                        "versions": [
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "init_device_num.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:init,runtime,V:2.5-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    int device_num = acc_get_device_num(acc_get_device_type());\n\n    #pragma acc init device_num(device_num)\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "init",
                            "runtime"
                        ],
                        "versions": [
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "init_device_type.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:runtime,construct-independent,internal-control-values,init,nonvalidating,V:2.5-2.7\n      LOGICAL FUNCTION test1()\n        USE OPENACC\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: device_type\n        INTEGER :: errors = 0\n\n        device_type = acc_get_device_type()\n        !$acc init device_type(device_type)\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "runtime",
                            "construct-independent",
                            "internal-control-values",
                            "init",
                            "nonvalidating"
                        ],
                        "versions": [
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "init_device_type.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:init,runtime,V:2.5-2.7\nint test1(){\n    int err = 0;\n    int device_type = acc_get_device_type();\n    srand(SEED);\n\n    #pragma acc init device_type(device_type)\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "init",
                            "runtime"
                        ],
                        "versions": [
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "init_device_type_num.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:runtime,construct-independent,internal-control-values,init,nonvalidating,V:2.5-2.7\n      LOGICAL FUNCTION test1()\n        USE OPENACC\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: device_num\n        INTEGER :: device_type\n        INTEGER :: errors = 0\n\n        device_type = acc_get_device_type()\n        device_num = acc_get_device_num(device_type)\n        !$acc init device_type(device_num) device_num(device_num)\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "runtime",
                            "construct-independent",
                            "internal-control-values",
                            "init",
                            "nonvalidating"
                        ],
                        "versions": [
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "init_device_type_num.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:init,runtime,V:2.5-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    int device_type = acc_get_device_type();\n    int device_num = acc_get_device_num(device_type);\n\n    #pragma acc init device_type(device_type) device_num(device_num)\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "init",
                            "runtime"
                        ],
                        "versions": [
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "kernels_async.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:async,kernels,update,V:2.0-2.7\n      LOGICAL FUNCTION test1()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT):: a, b, c, d, e, f, g !Data\n        INTEGER :: errors = 0\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(a)\n        CALL RANDOM_NUMBER(b)\n        c = 0\n        CALL RANDOM_NUMBER(d)\n        CALL RANDOM_NUMBER(e)\n        f = 0\n        g = 0\n        !$acc enter data create(g(1:LOOPCOUNT), c(1:LOOPCOUNT), f(1:LOOPCOUNT))\n        !$acc data copyin(a(1:LOOPCOUNT), b(1:LOOPCOUNT), d(1:LOOPCOUNT), e(1:LOOPCOUNT))\n          !$acc kernels async(1)\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              c(x) = a(x) + b(x)\n            END DO\n          !$acc end kernels\n          !$acc kernels async(2)\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              f(x) = d(x) + e(x)\n            END DO\n          !$acc end kernels\n          !$acc kernels wait(1, 2) async(3)\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              g(x) = c(x) + f(x)\n            END DO\n          !$acc end kernels\n        !$acc end data\n        !$acc wait(1, 2)\n        !$acc update host(c(1:LOOPCOUNT), f(1:LOOPCOUNT))\n        !$acc exit data copyout(g(1:LOOPCOUNT)) async(3)\n        DO x = 1, LOOPCOUNT\n          IF (abs(c(x) - (a(x) + b(x))) .gt. PRECISION) THEN\n            errors = errors + 1\n            WRITE(*, *) x, \" a: \", c(x), \" = \", a(x), \" + \", b(x)\n          END IF\n          IF (abs(f(x) - (d(x) + e(x))) .gt. PRECISION) THEN\n            errors = errors + 1\n            WRITE(*, *) x, \" b: \", f(x), \" = \", d(x), \" + \", e(x)\n          END IF\n        END DO\n        !$acc wait(3)\n        DO x = 1, LOOPCOUNT\n          IF (abs(g(x) - (c(x) + f(x))) .gt. PRECISION) THEN\n            errors = errors + 1\n            WRITE(*, *) x, \" c: \", g(x), \" = \", c(x), \" + \", f(x)\n          END IF\n        END DO\n        !$acc exit data delete(c(1:LOOPCOUNT), f(1:LOOPCOUNT))\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "async",
                            "kernels",
                            "update"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "kernels_async.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:kernels,async,wait,V:2.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t * restrict a = (real_t *)malloc(n * sizeof(real_t));\n    real_t * restrict b = (real_t *)malloc(n * sizeof(real_t));\n    real_t * restrict c = (real_t *)malloc(n * sizeof(real_t));\n    real_t * restrict d = (real_t *)malloc(n * sizeof(real_t));\n    real_t * restrict e = (real_t *)malloc(n * sizeof(real_t));\n    real_t * restrict f = (real_t *)malloc(n * sizeof(real_t));\n    real_t * restrict g = (real_t *)malloc(n * sizeof(real_t));\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n      \tb[x] = rand() / (real_t)(RAND_MAX / 10);\n      \tc[x] = 0.0;\n      \td[x] = rand() / (real_t)(RAND_MAX / 10);\n      \te[x] = rand() / (real_t)(RAND_MAX / 10);\n      \tf[x] = 0.0;\n      \tg[x] = 0.0;\n    }\n    #pragma acc enter data create(g[0:n], c[0:n], f[0:n])\n    #pragma acc data copyin(a[0:n], b[0:n], d[0:n], e[0:n])\n    {\n        #pragma acc kernels async(1)\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                c[x] = a[x] + b[x];\n            }\n        }\n        #pragma acc kernels async(2)\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                f[x] = d[x] + e[x];\n            }\n        }\n        #pragma acc kernels wait(1, 2) async(3)\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                g[x] = c[x] + f[x];\n            }\n        }\n    }\n    #pragma acc wait(1, 2)\n    #pragma acc update host(c[0:n], f[0:n])\n    #pragma acc exit data copyout(g[0:n]) async(3)\n    for (int x = 0; x < n; ++x){\n        if (fabs(c[x] - (a[x] + b[x])) > PRECISION){\n            err += 1;\n      \t}\n        if (fabs(f[x] - (d[x] + e[x])) > PRECISION){\n            err += 1;\n        }\n    }\n    #pragma acc wait(3)\n    for (int x = 0; x < n; ++x){\n        if (fabs(g[x] - (c[x] + f[x])) > PRECISION){\n            err += 1;\n        }\n    }\n    #pragma acc exit data delete(c[0:n], f[0:n])\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "kernels",
                            "async",
                            "wait"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "kernels_copy.F90": {
                "num tests": 3,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:devonly,kernels,V:2.0-2.7\n      LOGICAL FUNCTION test1()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT):: a, b, c !Data\n        INTEGER :: errors = 0\n        INTEGER,DIMENSION(1):: devtest\n        devtest(1) = 1\n\n        !$acc enter data copyin(devtest(1:1))\n        !$acc kernels present(devtest)\n          devtest(1) = 0\n        !$acc end kernels\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(a)\n        CALL RANDOM_NUMBER(b)\n        c = 1\n\n        !$acc data copyin(a(1:LOOPCOUNT), b(1:LOOPCOUNT))\n          !$acc kernels copy(c(1:LOOPCOUNT))\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              c(x) = c(x) + a(x) + b(x)\n            END DO\n          !$acc end kernels\n        !$acc end data\n\n        DO x = 1, LOOPCOUNT\n          IF (abs(c(x) - (a(x) + b(x) + 1)) .gt. PRECISION) THEN\n            errors = errors + 1\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "devonly",
                            "kernels"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "2": {
                        "content": "#ifndef T2\n!T2:devonly,kernels,V:2.0-2.7\n      LOGICAL FUNCTION test2()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT):: a, b, c !Data\n        INTEGER :: errors = 0\n        INTEGER,DIMENSION(1):: devtest\n        devtest(1) = 1\n\n        !$acc enter data copyin(devtest(1:1))\n        !$acc kernels present(devtest)\n          devtest(1) = 0\n        !$acc end kernels\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        IF (devtest(1) .eq. 1) THEN\n          CALL RANDOM_NUMBER(a)\n          CALL RANDOM_NUMBER(b)\n          c = 1\n\n          !$acc data copyin(a(1:LOOPCOUNT), b(1:LOOPCOUNT), c(1:LOOPCOUNT))\n            !$acc kernels copy(c(1:LOOPCOUNT))\n              !$acc loop\n              DO x = 1, LOOPCOUNT\n                c(x) = c(x) + a(x) + b(x)\n              END DO\n            !$acc end kernels\n          !$acc end data\n\n          DO x = 1, LOOPCOUNT\n            IF (abs(c(x) - 1) .gt. PRECISION) THEN\n              IF ((a(x) + b(x)) .gt. PRECISION) THEN\n                errors = errors + 1\n              END IF\n            END IF\n          END DO\n        END IF\n\n        IF (errors .eq. 0) THEN\n          test2 = .FALSE.\n        ELSE\n          test2 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T2\n        LOGICAL :: test2\n#endif\n#ifndef T2\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test2()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 1\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "devonly",
                            "kernels"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "3": {
                        "content": "#ifndef T3\n!T3:devonly,kernels,V:2.0-2.7\n      LOGICAL FUNCTION test3()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT):: a, b, c !Data\n        INTEGER :: errors = 0\n        INTEGER,DIMENSION(1):: devtest\n        devtest(1) = 1\n\n        !$acc enter data copyin(devtest(1:1))\n        !$acc kernels present(devtest)\n          devtest(1) = 0\n        !$acc end kernels\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        IF (devtest(1) .eq. 1) THEN\n          CALL RANDOM_NUMBER(a)\n          CALL RANDOM_NUMBER(b)\n          c = 1\n\n          !$acc data copyin(a(1:LOOPCOUNT), b(1:LOOPCOUNT)) copy(c(1:LOOPCOUNT))\n            DO x = 1, LOOPCOUNT\n              c(x) = 0\n            END DO\n            !$acc kernels copy(c(1:LOOPCOUNT))\n              !$acc loop\n              DO x = 1, LOOPCOUNT\n                c(x) = c(x) + a(x) + b(x)\n              END DO\n            !$acc end kernels\n            DO x = 1, LOOPCOUNT\n              IF (abs(c(x)) .gt. PRECISION) THEN\n                errors = errors + 1\n              END IF\n            END DO\n          !$acc end data\n\n          DO x = 1, LOOPCOUNT\n            IF (abs(c(x) - (1 + a(x) + b(x))) .gt. PRECISION) THEN\n              errors = errors + 1\n            END IF\n          END DO\n        END IF\n\n        IF (errors .eq. 0) THEN\n          test3 = .FALSE.\n        ELSE\n          test3 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T3\n        LOGICAL :: test3\n#endif\n#ifndef T3\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test3()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 2\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "devonly",
                            "kernels"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "kernels_copy.c": {
                "num tests": 3,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:kernels,data,data-region,V:1.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n    real_t * c = (real_t *)malloc(n * sizeof(real_t));\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n        c[x] = 1;\n    }\n    #pragma acc data copyin(a[0:n], b[0:n])\n    {\n        #pragma acc kernels copy(c[0:n])\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                c[x] += a[x] + b[x];\n            }\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        if (fabs(c[x] - (1 + a[x] + b[x])) > PRECISION) {\n            err += 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "kernels",
                            "data",
                            "data-region"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "2": {
                        "content": "#ifndef T2\n//T2:kernels,data,data-region,devonly,reference-counting,V:2.5-2.7\nint test2(){\n    int err = 0;\n    srand(SEED);\n    int * devtest = (int *)malloc(sizeof(int));\n    real_t * a = (real_t *)malloc(n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n    real_t * c = (real_t *)malloc(n * sizeof(real_t));\n    devtest[0] = 1;\n    #pragma acc enter data copyin(devtest[0:1])\n    #pragma acc kernels present(devtest[0:1])\n    {\n      devtest[0] = 0;\n    }\n\n    if (devtest[0] == 1){\n        for (int x = 0; x < n; ++x){\n          a[x] = rand() / (real_t)(RAND_MAX / 10);\n          b[x] = rand() / (real_t)(RAND_MAX / 10);\n          c[x] = 1;\n        }\n        #pragma acc data copyin(a[0:n], b[0:n], c[0:n])\n        {\n            #pragma acc kernels copy(c[0:n])\n            {\n                #pragma acc loop\n                for (int x = 0; x < n; ++x){\n                    c[x] += a[x] + b[x];\n                }\n            }\n        }\n\n        for (int x = 0; x < n; ++x){\n            if (fabs(c[x] - 1) > PRECISION && (a[x] + b[x]) > PRECISION) {\n                err += 1;\n            }\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T2\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test2();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 1);\n    }\n#endif\n",
                        "tags": [
                            "kernels",
                            "data",
                            "data-region",
                            "devonly",
                            "reference-counting"
                        ],
                        "versions": [
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "3": {
                        "content": "#ifndef T3\n//T3:kernels,data,data-region,devonly,reference-counting,V:2.5-2.7\nint test3(){\n    int err = 0;\n    srand(SEED);\n    int * devtest = (int *)malloc(sizeof(int));\n    real_t * a = (real_t *)malloc(n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n    real_t * c = (real_t *)malloc(n * sizeof(real_t));\n    devtest[0] = 1;\n    #pragma acc enter data copyin(devtest[0:1])\n    #pragma acc kernels present(devtest[0:1])\n    {\n      devtest[0] = 0;\n    }\n\n    if (devtest[0] == 1){\n        for (int x = 0; x < n; ++ x){\n            a[x] = rand() / (real_t)(RAND_MAX / 10);\n            b[x] = rand() / (real_t)(RAND_MAX / 10);\n            c[x] = 1;\n        }\n\n        #pragma acc data copyin(a[0:n], b[0:n]) copy(c[0:n])\n        {\n            for (int x = 0; x < n; ++x){\n                c[x] = 0;\n            }\n            #pragma acc kernels copy(c[0:n])\n            {\n                #pragma acc loop\n                for (int x = 0; x < n; ++x){\n                    c[x] += a[x] + b[x];\n                }\n            }\n            for (int x = 0; x < n; ++x){\n                if (fabs(c[x]) > PRECISION) {\n                    err += 1;\n                }\n            }\n        }\n\n        for (int x = 0; x < n; ++x){\n            if (fabs(c[x] - (a[x] + b[x] + 1)) > PRECISION){\n                err += 1;\n            }\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T3\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test3();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 2);\n    }\n#endif\n",
                        "tags": [
                            "kernels",
                            "data",
                            "data-region",
                            "devonly",
                            "reference-counting"
                        ],
                        "versions": [
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "kernels_copyin.F90": {
                "num tests": 3,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:devonly,kernels,V:2.0-2.7\n      LOGICAL FUNCTION test1()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT):: a, b !Data\n        INTEGER :: errors = 0\n        INTEGER,DIMENSION(1):: devtest\n        devtest(1) = 1\n\n        !$acc enter data copyin(devtest(1:1))\n        !$acc kernels\n          devtest(1) = 0\n        !$acc end kernels\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(a)\n        b = 0\n\n        !$acc data copy(b(1:LOOPCOUNT))\n          !$acc kernels copyin(a(1:LOOPCOUNT))\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              b(x) = b(x) + a(x)\n            END DO\n          !$acc end kernels\n        !$acc end data\n\n        DO x = 1, LOOPCOUNT\n          IF (abs(a(x) - b(x)) .gt. PRECISION) THEN\n            errors = errors + 1\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "devonly",
                            "kernels"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "2": {
                        "content": "#ifndef T2\n!T2:devonly,kernels,V:2.0-2.7\n      LOGICAL FUNCTION test2()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT):: a, b !Data\n        INTEGER :: errors = 0\n        INTEGER,DIMENSION(1):: devtest\n        devtest(1) = 1\n\n        !$acc enter data copyin(devtest(1:1))\n        !$acc kernels\n          devtest(1) = 0\n        !$acc end kernels\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        IF (devtest(1) .eq. 1) THEN\n          CALL RANDOM_NUMBER(a)\n          b = 0\n          !$acc data copy(a(1:LOOPCOUNT), b(1:LOOPCOUNT))\n            DO x = 1, LOOPCOUNT\n              a(x) = -1\n            END DO\n            !$acc kernels copyin(a(1:LOOPCOUNT))\n              !$acc loop\n              DO x = 1, LOOPCOUNT\n                b(x) = a(x)\n              END DO\n            !$acc end kernels\n            DO x = 1, LOOPCOUNT\n              IF (abs(a(x) + 1) .gt. PRECISION) THEN\n                errors = errors + 1\n              END IF\n            END DO\n          !$acc end data\n          DO x = 1, LOOPCOUNT\n            IF (abs(a(x) - b(x)) .gt. PRECISION) THEN\n              errors = errors + 1\n            END IF\n          END DO\n        END IF\n\n        IF (errors .eq. 0) THEN\n          test2 = .FALSE.\n        ELSE\n          test2 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T2\n        LOGICAL :: test2\n#endif\n#ifndef T2\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test2()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 1\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "devonly",
                            "kernels"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "3": {
                        "content": "#ifndef T3\n!T3:devonly,kernels,V:2.0-2.7\n      LOGICAL FUNCTION test3()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT):: a, b !Data\n        INTEGER :: errors = 0\n        INTEGER,DIMENSION(1):: devtest\n        devtest(1) = 1\n\n        !$acc enter data copyin(devtest(1:1))\n        !$acc kernels\n          devtest(1) = 0\n        !$acc end kernels\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        IF (devtest(1) .eq. 1) THEN\n          CALL RANDOM_NUMBER(a)\n          b = 0\n\n          !$acc kernels copyin(a(1:LOOPCOUNT), b(1:LOOPCOUNT))\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              b(x) = a(x)\n            END DO\n          !$acc end kernels\n\n          DO x = 1, LOOPCOUNT\n            IF (abs(b(x)) .gt. PRECISION) THEN\n              errors = errors + 1\n            END IF\n          END DO\n        END IF\n\n        IF (errors .eq. 0) THEN\n          test3 = .FALSE.\n        ELSE\n          test3 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T3\n        LOGICAL :: test3\n#endif\n#ifndef T3\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test3()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 2\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "devonly",
                            "kernels"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "kernels_copyin.c": {
                "num tests": 3,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:kernels,data,data-region,V:1.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = 0.0;\n    }\n\n\n    #pragma acc data copy(b[0:n])\n    {\n        #pragma acc kernels copyin(a[0:n])\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                b[x] += a[x];\n            }\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        if (fabs(b[x] - a[x]) > PRECISION){\n            err += 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "kernels",
                            "data",
                            "data-region"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "2": {
                        "content": "#ifndef T2\n//T2:kernels,data,data-region,devonly,reference-counting,V:2.5-2.7\nint test2(){\n    int err = 0;\n    srand(SEED);\n    int * devtest = (int *)malloc(sizeof(int));\n    real_t * a = (real_t *)malloc(n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n    devtest[0] = 1;\n    #pragma acc enter data copyin(devtest[0:1])\n    #pragma acc kernels present(devtest[0:1])\n    {\n      devtest[0] = 0;\n    }\n\n    if (devtest[0] == 1){\n        for (int x = 0; x < n; ++x){\n            a[x] = rand() / (real_t)(RAND_MAX / 10);\n            b[x] = 0.0;\n        }\n\n        #pragma acc data copy(a[0:n], b[0:n])\n        {\n            for (int x = 0; x < n; ++x){\n                a[x] = -1;\n            }\n            #pragma acc kernels copyin(a[0:n])\n            {\n                #pragma acc loop\n                for (int x = 0; x < n; ++x){\n                    b[x] = a[x];\n                }\n            }\n        }\n\n        for (int x = 0; x < n; ++x){\n            if (fabs(b[x] - a[x]) > PRECISION){\n                err += 1;\n            }\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T2\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test2();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 1);\n    }\n#endif\n",
                        "tags": [
                            "kernels",
                            "data",
                            "data-region",
                            "devonly",
                            "reference-counting"
                        ],
                        "versions": [
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "3": {
                        "content": "#ifndef T3\n//T3:kernels,data,data-region,devonly,V:1.0-2.7\nint test3(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n\n    if (devtest[0] == 1){\n        for (int x = 0; x < n; ++x){\n            a[x] = rand() / (real_t)(RAND_MAX / 10);\n            b[x] = 0;\n        }\n        #pragma acc kernels copyin(a[0:n], b[0:n])\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                b[x] = a[x];\n            }\n        }\n\n        for (int x = 0; x < n; ++x){\n            if (fabs(b[x]) > PRECISION){\n                err += 1;\n            }\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T3\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test3();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 2);\n    }\n#endif\n",
                        "tags": [
                            "kernels",
                            "data",
                            "data-region",
                            "devonly"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "kernels_copyout.F90": {
                "num tests": 2,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:devonly,kernels,V:2.0-2.7\n      LOGICAL FUNCTION test1()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT):: a, b !Data\n        INTEGER :: errors = 0\n        INTEGER,DIMENSION(1):: devtest\n        devtest(1) = 1\n\n        !$acc enter data copyin(devtest(1:1))\n        !$acc kernels present(devtest(1:1))\n          devtest(1) = 0\n        !$acc end kernels\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(a)\n        b = 0\n\n        !$acc data copyin(a(1:LOOPCOUNT))\n          !$acc kernels copyout(b(1:LOOPCOUNT))\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              b(x) = a(x)\n            END DO\n          !$acc end kernels\n        !$acc end data\n\n        DO x = 1, LOOPCOUNT\n          IF (abs(a(x) - b(x)) .gt. PRECISION) THEN\n            errors = errors + 1\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "devonly",
                            "kernels"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "2": {
                        "content": "#ifndef T2\n!T2:devonly,kernels,V:2.0-2.7\n      LOGICAL FUNCTION test2()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT):: a, b !Data\n        INTEGER :: errors = 0\n        INTEGER,DIMENSION(1):: devtest\n        devtest(1) = 1\n\n        !$acc enter data copyin(devtest(1:1))\n        !$acc kernels present(devtest(1:1))\n          devtest(1) = 0\n        !$acc end kernels\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        IF (devtest(1) .eq. 1) THEN\n          CALL RANDOM_NUMBER(a)\n          b = 0\n          \n          !$acc data copyin(a(1:LOOPCOUNT), b(1:LOOPCOUNT))\n            !$acc kernels copyout(b(1:LOOPCOUNT))\n              !$acc loop\n              DO x = 1, LOOPCOUNT\n                b(x) = a(x)\n              END DO\n            !$acc end kernels\n          !$acc end data\n          \n          DO x = 1, LOOPCOUNT\n            IF (abs(b(x)) .gt. PRECISION) THEN\n              errors = errors + 1\n            END IF\n          END DO\n        END IF\n\n        IF (errors .eq. 0) THEN\n          test2 = .FALSE.\n        ELSE\n          test2 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T2\n        LOGICAL :: test2\n#endif\n#ifndef T2\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test2()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 1\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "devonly",
                            "kernels"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "kernels_copyout.c": {
                "num tests": 2,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:kernels,data,data-region,V:1.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = 0;\n    }\n\n    #pragma acc data copyin(a[0:n])\n    {\n        #pragma acc kernels copyout(b[0:n])\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                b[x] = a[x];\n            }\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        if (fabs(b[x] - a[x]) > PRECISION){\n            err += 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "kernels",
                            "data",
                            "data-region"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "2": {
                        "content": "#ifndef T2\n//T2:kernels,data,data-region,devonly,reference-counting,V:2.5-2.7\nint test2(){\n    int err = 0;\n    srand(SEED);\n    int * devtest = (int *)malloc(sizeof(int));\n    real_t * a = (real_t *)malloc(n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n    devtest[0] = 1;\n    #pragma acc enter data copyin(devtest[0:1])\n    #pragma acc kernels present(devtest[0:1])\n    {\n      devtest[0] = 0;\n    }\n\n    if (devtest[0] == 1){\n        for (int x = 0; x < n; ++x){\n            a[x] = rand() / (real_t)(RAND_MAX / 10);\n            b[x] = 0;\n        }\n\n        #pragma acc data copyin(a[0:n], b[0:n])\n        {\n            #pragma acc kernels copyout(b[0:n])\n            {\n                #pragma acc loop\n                for (int x = 0; x < n; ++x){\n                    b[x] = a[x];\n                }\n            }\n        }\n\n        for (int x = 0; x < n; ++x){\n            if (fabs(b[x]) > PRECISION){\n                err += 1;\n            }\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T2\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test2();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 1);\n    }\n#endif\n",
                        "tags": [
                            "kernels",
                            "data",
                            "data-region",
                            "devonly",
                            "reference-counting"
                        ],
                        "versions": [
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "kernels_create.F90": {
                "num tests": 3,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:devonly,kernels,V:2.0-2.7\n      LOGICAL FUNCTION test1()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT):: a, b, c !Data\n        INTEGER :: errors = 0\n        INTEGER,DIMENSION(1):: devtest\n        devtest(1) = 1\n\n        !$acc enter data copyin(devtest(1:1))\n        !$acc kernels present(devtest(1:1))\n          devtest(1) = 0\n        !$acc end kernels\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        IF (devtest(1) .eq. 1) THEN\n          CALL RANDOM_NUMBER(a)\n          b = 0\n          c = 0\n          !$acc data copyin(a(1:LOOPCOUNT))\n            !$acc kernels create(b(1:LOOPCOUNT))\n              !$acc loop\n              DO x = 1, LOOPCOUNT\n                b(x) = a(x)\n              END DO\n            !$acc end kernels\n          !$acc end data\n          DO x = 1, LOOPCOUNT\n            IF (abs(b(x)) .gt. PRECISION) THEN\n              errors = errors + 1\n            END IF\n          END DO\n        END IF\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "devonly",
                            "kernels"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "2": {
                        "content": "#ifndef T2\n!T2:devonly,kernels,V:2.0-2.7\n      LOGICAL FUNCTION test2()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT):: a, b, c !Data\n        INTEGER :: errors = 0\n        INTEGER,DIMENSION(1):: devtest\n        devtest(1) = 1\n\n        !$acc enter data copyin(devtest(1:1))\n        !$acc kernels present(devtest(1:1))\n          devtest(1) = 0\n        !$acc end kernels\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(a)\n        b = 0\n        !$acc data copyin(a(1:LOOPCOUNT)) copyout(b(1:LOOPCOUNT))\n          !$acc kernels create(b(1:LOOPCOUNT))\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              b(x) = a(x)\n            END DO\n          !$acc end kernels\n        !$acc end data\n        DO x = 1, LOOPCOUNT\n          IF (abs(b(x) - a(x)) .gt. PRECISION) THEN\n            errors = errors + 1\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test2 = .FALSE.\n        ELSE\n          test2 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T2\n        LOGICAL :: test2\n#endif\n#ifndef T2\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test2()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 1\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "devonly",
                            "kernels"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "3": {
                        "content": "#ifndef T3\n!T3:devonly,kernels,V:2.0-2.7\n      LOGICAL FUNCTION test3()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT):: a, b, c !Data\n        INTEGER :: errors = 0\n        INTEGER,DIMENSION(1):: devtest\n        devtest(1) = 1\n\n        !$acc enter data copyin(devtest(1:1))\n        !$acc kernels present(devtest(1:1))\n          devtest(1) = 0\n        !$acc end kernels\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(a)\n        b = 0\n\n        !$acc data copyin(a(1:LOOPCOUNT)) copyout(c(1:LOOPCOUNT))\n          !$acc kernels create(b(1:LOOPCOUNT))\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              b(x) = a(x)\n            END DO\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              c(x) = b(x)\n            END DO\n          !$acc end kernels\n        !$acc end data\n\n        DO x = 1, LOOPCOUNT\n          IF (abs(c(x) - a(x)) .gt. PRECISION) THEN\n            errors = errors + 1\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test3 = .FALSE.\n        ELSE\n          test3 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T3\n        LOGICAL :: test3\n#endif\n#ifndef T3\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test3()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 2\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "devonly",
                            "kernels"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "kernels_create.c": {
                "num tests": 3,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:kernels,data,data-region,devonly,V:1.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    int * devtest = (int *)malloc(sizeof(int));\n    real_t * a = (real_t *)malloc(n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n    devtest[0] = 1;\n    #pragma acc enter data copyin(devtest[0:1])\n    #pragma acc parallel present(devtest[0:1])\n    {\n      devtest[0] = 0;\n    }\n\n    if (devtest[0] == 1){\n        for (int x = 0; x < n; ++x){\n          a[x] = rand() / (real_t)(RAND_MAX / 10);\n          b[x] = 0.0;\n        }\n\n        #pragma acc data copyin(a[0:n])\n        {\n            #pragma acc kernels create(b[0:n])\n            {\n                #pragma acc loop\n                for (int x = 0; x < n; ++x){\n                    b[x] = a[x];\n                }\n            }\n        }\n\n        for (int x = 0; x < n; ++x){\n            if (fabs(b[x]) > PRECISION){\n                err += 1;\n            }\n        }\n\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "kernels",
                            "data",
                            "data-region",
                            "devonly"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "2": {
                        "content": "#ifndef T2\n//T2:kernels,data,data-region,reference-counting,V:2.5-2.7\nint test2(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n\n    for (int x = 0; x < n; ++x){\n      a[x] = rand() / (real_t)(RAND_MAX / 10);\n      b[x] = 0.0;\n    }\n\n    #pragma acc data copyin(a[0:n]) copyout(b[0:n])\n    {\n        #pragma acc kernels create(b[0:n])\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                b[x] = a[x];\n            }\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        if (fabs(a[x] - b[x]) > PRECISION){\n            err += 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T2\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test2();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 1);\n    }\n#endif\n",
                        "tags": [
                            "kernels",
                            "data",
                            "data-region",
                            "reference-counting"
                        ],
                        "versions": [
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "3": {
                        "content": "#ifndef T3\n//T3:kernels,data,data-region,V:1.0-2.7\nint test3(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n    real_t * c = (real_t *)malloc(n * sizeof(real_t));\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = 0.0;\n    }\n\n    #pragma acc data copyin(a[0:n]) copyout(c[0:n])\n    {\n        #pragma acc kernels create(b[0:n])\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                b[x] = a[x];\n            }\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                c[x] = b[x];\n            }\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        if (fabs(c[x] - a[x]) > PRECISION){\n            err += 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T3\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test3();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 2);\n    }\n#endif\n",
                        "tags": [
                            "kernels",
                            "data",
                            "data-region"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "kernels_default_copy.F90": {
                "num tests": 2,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:devonly,kernels,V:2.0-2.7\n      LOGICAL FUNCTION test1()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT):: a, b, c !Data\n        INTEGER :: errors = 0\n        LOGICAL,DIMENSION(1):: devtest\n        devtest(1) = .TRUE.\n\n        !$acc enter data copyin(devtest(1:1))\n        !$acc kernels\n          devtest(1) = .FALSE.\n        !$acc end kernels\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(a)\n        CALL RANDOM_NUMBER(b)\n        c = 0\n\n        !$acc data copyin(a(1:LOOPCOUNT), b(1:LOOPCOUNT))\n          !$acc kernels\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              c(x) = c(x) + a(x) + b(x)\n            END DO\n          !$acc end kernels\n        !$acc end data\n        DO x = 1, LOOPCOUNT\n          IF (abs(c(x) - (a(x) + b(x))) .gt. PRECISION) THEN\n            errors = errors + 1\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "devonly",
                            "kernels"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "2": {
                        "content": "#ifndef T2\n!T2:devonly,kernels,V:2.0-2.7\n      LOGICAL FUNCTION test2()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT):: a, b, c !Data\n        INTEGER :: errors = 0\n        LOGICAL,DIMENSION(1):: devtest\n        devtest(1) = .TRUE.\n\n        !$acc enter data copyin(devtest(1:1))\n        !$acc kernels\n          devtest(1) = .FALSE.\n        !$acc end kernels\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        IF (devtest(1)) THEN\n          CALL RANDOM_NUMBER(a)\n          CALL RANDOM_NUMBER(b)\n          c = 1\n\n          !$acc enter data copyin(c(1:LOOPCOUNT))\n          c = 0\n          !$acc data copyin(a(1:LOOPCOUNT), b(1:LOOPCOUNT))\n            !$acc kernels\n              !$acc loop\n              DO x = 1, LOOPCOUNT\n                c(x) = c(x) + a(x) + b(x)\n              END DO\n            !$acc end kernels\n          !$acc end data\n          DO x = 1, LOOPCOUNT\n            IF (abs(c(x)) .gt. PRECISION) THEN\n              errors = errors + 1\n            END IF\n          END DO\n          !$acc exit data copyout(c(1:LOOPCOUNT))\n          DO x = 1, LOOPCOUNT\n            IF (abs(c(x) - (a(x) + b(x) + 1)) .gt. PRECISION) THEN\n              errors = errors + 1\n            END IF\n          END DO\n        END IF\n\n        IF (errors .eq. 0) THEN\n          test2 = .FALSE.\n        ELSE\n          test2 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T2\n        LOGICAL :: test2\n#endif\n#ifndef T2\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test2()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 1\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "devonly",
                            "kernels"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "kernels_default_copy.c": {
                "num tests": 2,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:kernels,data-region,default-mapping,V:1.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n    real_t c[n];\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n        c[x] = 0.0;\n    }\n\n    #pragma acc data copyin(a[0:n], b[0:n])\n    {\n        #pragma acc kernels\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                c[x] += a[x] + b[x];\n            }\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        if (fabs(c[x] - (a[x] + b[x])) > PRECISION){\n            err += 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "kernels",
                            "data-region",
                            "default-mapping"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "2": {
                        "content": "#ifndef T2\n//T2:kernels,data-region,default-mapping,reference-counting,devonly,V:2.5-2.7\nint test2(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n    real_t c[n];\n    int * devtest = (int *)malloc(sizeof(real_t));\n\n    devtest[0] = 1;\n    #pragma acc enter data copyin(devtest[0:1])\n    #pragma acc kernels present(devtest[0:1])\n    {\n        devtest[0] = 0;\n    }\n\n    if (devtest[0] == 1){\n        for (int x = 0; x < n; ++x){\n            a[x] = rand() / (real_t)(RAND_MAX / 10);\n            b[x] = rand() / (real_t)(RAND_MAX / 10);\n            c[x] = 1;\n        }\n\n        #pragma acc enter data copyin(c[0:n])\n        for (int x = 0; x < n; ++x){\n            c[x] = 0.0;\n        }\n        #pragma acc data copyin(a[0:n], b[0:n])\n        {\n            #pragma acc kernels\n            {\n                #pragma acc loop\n                for (int x = 0; x < n; ++x){\n                    c[x] += a[x] + b[x];\n                }\n            }\n        }\n\n        for (int x = 0; x < n; ++x){\n            if (fabs(c[x]) > PRECISION){\n                err += 1;\n            }\n        }\n\n        #pragma acc exit data copyout(c[0:n])\n\n        for (int x = 0; x < n; ++x){\n            if (fabs(c[x] - (a[x] + b[x] + 1)) > PRECISION){\n                err += 1;\n            }\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T2\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test2();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 1);\n    }\n#endif\n",
                        "tags": [
                            "kernels",
                            "data-region",
                            "default-mapping",
                            "reference-counting",
                            "devonly"
                        ],
                        "versions": [
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "kernels_default_present.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:kernels,default,V:2.5-2.7\n      LOGICAL FUNCTION test1()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT):: a, b !Data\n        INTEGER :: errors = 0\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(a)\n        b = 0\n\n        !$acc enter data copyin(a(1:LOOPCOUNT)) create(b(1:LOOPCOUNT))\n        !$acc kernels default(present)\n          !$acc loop\n          DO x = 1, LOOPCOUNT\n            b(x) = a(x)\n          END DO\n        !$acc end kernels\n        !$acc exit data delete(a(1:LOOPCOUNT)) copyout(b(1:LOOPCOUNT)) \n        DO x = 1, LOOPCOUNT\n          IF (abs(a(x) - b(x)) .gt. PRECISION) THEN\n            errors = errors + 1\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "kernels",
                            "default"
                        ],
                        "versions": [
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "kernels_default_present.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:kernels,data,data-region,default,V:2.5-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = 0;\n    }\n\n    #pragma acc enter data copyin(a[0:n]), create(b[0:n])\n    #pragma acc kernels default(present)\n    {\n        #pragma acc loop\n        for (int x = 0; x < n; ++x){\n            b[x] = a[x];\n        }\n    }\n    #pragma acc exit data delete(a[0:n]), copyout(b[0:n])\n\n    for (int x = 0; x < n; ++x){\n        if (fabs(a[x] - b[x]) > PRECISION){\n            err += 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "kernels",
                            "data",
                            "data-region",
                            "default"
                        ],
                        "versions": [
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "kernels_if.F90": {
                "num tests": 4,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:devonly,kernels,if,V:2.0-2.7\n      LOGICAL FUNCTION test1()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT):: a, b !Data\n        INTEGER :: errors = 0\n        LOGICAL,DIMENSION(1):: devtest\n        LOGICAL:: data_on_device = .FALSE.\n        devtest(1) = .TRUE.\n\n        !$acc enter data copyin(devtest(1:1))\n        !$acc kernels present(devtest(1:1))\n          devtest(1) = .FALSE.\n        !$acc end kernels\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(a)\n        b = 0\n\n        !$acc kernels if(data_on_device) present(a(1:LOOPCOUNT), b(1:LOOPCOUNT))\n          !$acc loop\n          DO x = 1, LOOPCOUNT\n            b(x) = a(x)\n          END DO\n        !$acc end kernels\n\n        DO x = 1, LOOPCOUNT\n          IF (abs(a(x) - b(x)) .gt. PRECISION) THEN\n            errors = errors + 1\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "devonly",
                            "kernels",
                            "if"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "2": {
                        "content": "#ifndef T2\n!T2:devonly,kernels,if,V:2.0-2.7\n      LOGICAL FUNCTION test2()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT):: a, b !Data\n        INTEGER :: errors = 0\n        LOGICAL,DIMENSION(1):: devtest\n        LOGICAL:: data_on_device = .FALSE.\n        devtest(1) = .TRUE.\n\n        !$acc enter data copyin(devtest(1:1))\n        !$acc kernels present(devtest(1:1))\n          devtest(1) = .FALSE.\n        !$acc end kernels\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(a)\n        b = 0\n\n        data_on_device = .TRUE.\n        !$acc enter data copyin(a(1:LOOPCOUNT)) create(b(1:LOOPCOUNT))\n        !$acc kernels if(data_on_device) present(a(1:LOOPCOUNT), b(1:LOOPCOUNT))\n          !$acc loop\n          DO x = 1, LOOPCOUNT\n            b(x) = a(x)\n          END DO\n        !$acc end kernels\n        !$acc exit data copyout(b(1:LOOPCOUNT)) delete(a(1:LOOPCOUNT))\n\n        DO x = 1, LOOPCOUNT\n          IF (abs(b(x) - a(x)) .gt. PRECISION) THEN\n            errors = errors + 1\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test2 = .FALSE.\n        ELSE\n          test2 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T2\n        LOGICAL :: test2\n#endif\n#ifndef T2\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test2()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 1\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "devonly",
                            "kernels",
                            "if"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "3": {
                        "content": "#ifndef T3\n!T3:devonly,kernels,if,V:2.0-2.7\n      LOGICAL FUNCTION test3()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT):: a, b !Data\n        INTEGER :: errors = 0\n        LOGICAL,DIMENSION(1):: devtest\n        LOGICAL:: data_on_device = .FALSE.\n        devtest(1) = .TRUE.\n\n        !$acc enter data copyin(devtest(1:1))\n        !$acc kernels present(devtest(1:1))\n          devtest(1) = .FALSE.\n        !$acc end kernels\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        IF (devtest(1) .eqv. .TRUE.) THEN\n          CALL RANDOM_NUMBER(a)\n          b = 0\n\n          !$acc enter data copyin(a(1:LOOPCOUNT)) create(b(1:LOOPCOUNT))\n          DO x = 1, LOOPCOUNT\n            a(x) = -1\n          END DO\n\n          !$acc kernels if(data_on_device) present(a(1:LOOPCOUNT), b(1:LOOPCOUNT))\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              b(x) = a(x)\n            END DO\n          !$acc end kernels\n\n          DO x = 1, LOOPCOUNT\n            IF (abs(a(x) + 1) .gt. PRECISION) THEN\n              errors = errors + 1\n            END IF\n            IF (abs(b(x)) .gt. PRECISION) THEN\n              errors = errors + 1\n            END IF\n          END DO\n\n          !$acc exit data copyout(a(1:LOOPCOUNT), b(1:LOOPCOUNT))\n          data_on_device = .FALSE.\n\n          DO x = 1, LOOPCOUNT\n            IF (abs(a(x) - b(x)) .gt. PRECISION) THEN\n              errors = errors + 1\n            END IF\n          END DO\n        END IF\n\n        IF (errors .eq. 0) THEN\n          test3 = .FALSE.\n        ELSE\n          test3 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T3\n        LOGICAL :: test3\n#endif\n#ifndef T3\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test3()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 2\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "devonly",
                            "kernels",
                            "if"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "4": {
                        "content": "#ifndef T4\n!T4:devonly,kernels,if,V:2.0-2.7\n      LOGICAL FUNCTION test4()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT):: a, b !Data\n        INTEGER :: errors = 0\n        LOGICAL,DIMENSION(1):: devtest\n        LOGICAL:: data_on_device = .FALSE.\n        devtest(1) = .TRUE.\n\n        !$acc enter data copyin(devtest(1:1))\n        !$acc kernels present(devtest(1:1))\n          devtest(1) = .FALSE.\n        !$acc end kernels\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        IF (devtest(1) .eq. 1) THEN\n          CALL RANDOM_NUMBER(a)\n          b = 0\n\n          !$acc enter data copyin(a(1:LOOPCOUNT), b(1:LOOPCOUNT))\n          !$acc kernels if(data_on_device) present(a(1:LOOPCOUNT), b(1:LOOPCOUNT))\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              b(x) = a(x)\n            END DO\n          !$acc end kernels\n\n          DO x = 1, LOOPCOUNT\n            IF (abs(a(x) - b(x)) .gt. PRECISION) THEN\n              errors = errors + 1\n            END IF\n          END DO\n\n          !$acc exit data copyout(a(1:LOOPCOUNT), b(1:LOOPCOUNT))\n\n          DO x = 1, LOOPCOUNT\n            IF (abs(b(x)) .gt. PRECISION) THEN\n              IF (abs(b(x) - a(x)) .gt. PRECISION) THEN\n                errors = errors + 1\n              END IF\n            END IF\n          END DO\n        END IF\n\n        IF (errors .eq. 0) THEN\n          test4 = .FALSE.\n        ELSE\n          test4 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T4\n        LOGICAL :: test4\n#endif\n#ifndef T4\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test4()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 3\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "devonly",
                            "kernels",
                            "if"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "kernels_if.c": {
                "num tests": 4,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:kernels,if,V:1.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    int data_on_device = 0;\n    real_t * a = (real_t *)malloc(n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = 0;\n    }\n\n    #pragma acc kernels if(data_on_device) present(a[0:n], b[0:n])\n    {\n        #pragma acc loop\n        for (int x = 0; x < n; ++x){\n            b[x] = a[x];\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        if (fabs(b[x] - a[x]) > PRECISION){\n            err += 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "kernels",
                            "if"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "2": {
                        "content": "#ifndef T2\n//T2:kernels,if,V:2.0-2.7\nint test2(){\n    int err = 0;\n    srand(SEED);\n    int * devtest = (int *)malloc(sizeof(int));\n    real_t * a = (real_t *)malloc(n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = 0;\n    }\n\n    #pragma acc enter data copyin(a[0:n]) create(b[0:n])\n    data_on_device = 1;\n\n    #pragma acc kernels if(data_on_device) present(a[0:n], b[0:n])\n    {\n        #pragma acc loop\n        for (int x = 0; x < n; ++x){\n            b[x] = a[x];\n        }\n    }\n    #pragma acc exit data copyout(b[0:n]) delete(a[0:n])\n\n    for (int x = 0; x < n; ++x){\n        if (fabs(b[x] - a[x]) > PRECISION){\n            err += 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T2\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test2();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 1);\n    }\n#endif\n",
                        "tags": [
                            "kernels",
                            "if"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "3": {
                        "content": "#ifndef T3\n//T3:kernels,if,devonly,V:2.0-2.7\nint test3(){\n    int err = 0;\n    srand(SEED);\n    int data_on_device = 0;\n    int * devtest = (int *)malloc(sizeof(int));\n    real_t * a = (real_t *)malloc(n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n    devtest[0] = 1;\n    #pragma acc enter data copyin(devtest[0:1])\n    #pragma acc parallel present(devtest[0:1])\n    {\n      devtest[0] = 0;\n    }\n\n    if (devtest[0] == 1){\n        for (int x = 0; x < n; ++x){\n            a[x] = rand() / (real_t)(RAND_MAX / 10);\n            b[x] = 0;\n        }\n\n        #pragma acc enter data copyin(a[0:n]) create(b[0:n])\n        for (int x = 0; x < n; ++x){\n            a[x] = -1;\n        }\n\n        #pragma acc kernels if(data_on_device) present(a[0:n], b[0:n])\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                b[x] = a[x];\n            }\n        }\n        for (int x = 0; x < n; ++x){\n            if (fabs(a[x] + 1) > PRECISION){\n                err += 1;\n            }\n            if (fabs(b[x]) > PRECISION){\n                err += 1;\n            }\n        }\n        #pragma acc exit data copyout(a[0:n], b[0:n])\n        data_on_device = 0;\n        for (int x = 0; x < n; ++x){\n            if (fabs(a[x] - b[x]) > PRECISION){\n                err += 1;\n            }\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T3\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test3();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 2);\n    }\n#endif\n",
                        "tags": [
                            "kernels",
                            "if",
                            "devonly"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "4": {
                        "content": "#ifndef T4\n//T4:kernels,if,devonly,V:2.0-2.7\nint test4(){\n    int err = 0;\n    srand(SEED);\n    int data_on_device = 0;\n    int * devtest = (int *)malloc(sizeof(int));\n    real_t * a = (real_t *)malloc(n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n    devtest[0] = 1;\n    #pragma acc enter data copyin(devtest[0:1])\n    #pragma acc parallel present(devtest[0:1])\n    {\n      devtest[0] = 0;\n    }\n\n    if (devtest[0] == 1){\n        for (int x = 0; x < n; ++x){\n            a[x] = rand() / (real_t)(RAND_MAX / 10);\n            b[x] = 0;\n        }\n\n        #pragma acc enter data copyin(a[0:n], b[0:n])\n        #pragma acc kernels if(data_on_device) present(a[0:n], b[0:n])\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                b[x] = a[x];\n            }\n        }\n        for (int x = 0; x < n; ++x){\n            if (fabs(a[x] - b[x]) > PRECISION) {\n                err += 1;\n            }\n        }\n        #pragma acc exit data copyout(a[0:n], b[0:n])\n        for (int x = 0; x < n; ++x){\n            if (fabs(b[x]) > PRECISION && b[x] != a[x]){\n                err += 1;\n            }\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T4\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test4();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 3);\n    }\n#endif\n",
                        "tags": [
                            "kernels",
                            "if",
                            "devonly"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "kernels_loop.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:kernels,loop,V:1.0-2.7\n      LOGICAL FUNCTION test1()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x, _0, _1, _2, _3, _4, _5, _6, _7, _8, _9 !Iterators\n        REAL(8),DIMENSION(1024):: a, b !Data\n        INTEGER :: errors = 0\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(a)\n        b = 0\n\n        !$acc data copyin(a(1:1024)) copyout(b(1:1024))\n          !$acc kernels\n            !$acc loop\n            DO _0 = 0, 1\n              !$acc loop\n              DO _1 = 0, 1\n                !$acc loop\n                DO _2 = 0, 1\n                  !$acc loop\n                  DO _3 = 0, 1\n                    !$acc loop\n                    DO _4 = 0, 1\n                      !$acc loop\n                      DO _5 = 0, 1\n                        !$acc loop\n                        DO _6 = 0, 1\n                          !$acc loop\n                          DO _7 = 0, 1\n                            !$acc loop\n                            DO _8 = 0, 1\n                              !$acc loop\n                              DO _9 = 1, 2\n                                b(_0*512+_1*256+_2*128+_3*64+_4*32+_5*16+_6*8+_7*4+_8*2+_9)=a(_0*512+_1*256+_2*128+_3*64+_4*32+_5*16+_6*8+_7*4+_8*2+_9)\n                              END DO\n                            END DO\n                          END DO\n                        END DO\n                      END DO\n                    END DO\n                  END DO\n                END DO\n              END DO\n            END DO\n          !$acc end kernels\n        !$acc end data\n\n        DO x = 1, 1024\n          IF (abs(a(x) - b(x)) .gt. PRECISION) THEN\n            errors = errors + 1\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "kernels",
                            "loop"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "kernels_loop.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:kernels,loop,combined-constructs,V:1.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n\n    real_t * a = (real_t *)malloc(1024 * sizeof(real_t));\n    real_t * b = (real_t *)malloc(1024 * sizeof(real_t));\n\n    for (int x = 0; x < 1024; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = 0.0;\n    }\n\n    #pragma acc kernels loop copy(a[0:1024]) copyout(b[0:1024])\n    for (int _0 = 0; _0 < 2; ++_0){\n        #pragma acc loop\n        for (int _1 = 0; _1 < 2; ++_1){\n            #pragma acc loop\n            for (int _2 = 0; _2 < 2; ++_2){\n                #pragma acc loop\n                for (int _3 = 0; _3 < 2; ++_3){\n                    #pragma acc loop\n                    for (int _4 = 0; _4 < 2; ++_4){\n                        #pragma acc loop\n                        for (int _5 = 0; _5 < 2; ++_5){\n                            #pragma acc loop\n                            for (int _6 = 0; _6 < 2; ++_6){\n                                #pragma acc loop\n                                for (int _7 = 0; _7 < 2; ++_7){\n                                    #pragma acc loop\n                                    for (int _8 = 0; _8 < 2; ++_8){\n                                        #pragma acc loop\n                                        for (int _9 = 0; _9 < 2; ++_9){\n                                            b[_0 * 512 + _1 * 256 + _2 * 128 + _3 * 64 + _4 * 32 + _5 * 16 + _6 * 8 + _7 * 4 + _8 * 2 + _9] = a[_0 * 512 + _1 * 256 + _2 * 128 + _3 * 64 + _4 * 32 + _5 * 16 + _6 * 8 + _7 * 4 + _8 * 2 + _9];\n                                        }\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    for (int x = 0; x < 1024; ++x){\n        if (fabs(a[x] - b[x]) > PRECISION){\n            err += 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "kernels",
                            "loop",
                            "combined-constructs"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "kernels_loop_independent.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:kernels,combined-constructs,loop,V:1.0-2.7\n      LOGICAL FUNCTION test1()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT):: a, b !Data\n        INTEGER :: errors = 0\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(a)\n        b = 0\n\n        !$acc data copyin(a(1:LOOPCOUNT)) copy(b(1:LOOPCOUNT))\n          !$acc kernels loop independent\n          DO x = 1, LOOPCOUNT\n            b(x) = b(x) + a(x)\n          END DO\n        !$acc end data\n\n        DO x = 1, LOOPCOUNT\n          IF (abs(a(x) - b(x)) .gt. PRECISION) THEN\n            errors = errors + 1\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "kernels",
                            "combined-constructs",
                            "loop"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "kernels_loop_independent.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:kernels,loop,combined-constructs,V:1.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n    }\n\n    #pragma acc data copyin(a[0:n]) copyout(b[0:n])\n    {\n        #pragma acc kernels loop independent\n        for (int x = 0; x < n; ++x){\n            b[x] = a[x];\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        if (fabs(a[x] - b[x]) > PRECISION){\n            err += 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "kernels",
                            "loop",
                            "combined-constructs"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "kernels_loop_reduction_add_general.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:kernels,reduction,combined-constructs,loop,V:1.0-2.7\n      LOGICAL FUNCTION test1()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT):: a, b !Data\n        REAL(8) :: total\n        INTEGER :: errors = 0\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(a)\n        CALL RANDOM_NUMBER(b)\n        total = 0\n        !$acc data copyin(a(1:LOOPCOUNT), b(1:LOOPCOUNT)) copy(total)\n          !$acc parallel loop reduction(+:total)\n          DO x = 1, LOOPCOUNT\n            total = total + a(x) + b(x)\n          END DO\n        !$acc end data\n        DO x = 1, LOOPCOUNT\n          total = total - (a(x) + b(x))\n        END DO\n        IF (abs(total) .gt. LOOPCOUNT * PRECISION) THEN\n          WRITE(*, *) total\n          errors = 1\n        END IF\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "kernels",
                            "reduction",
                            "combined-constructs",
                            "loop"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "kernels_loop_reduction_add_general.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:kernels,loop,reduction,combined-constructs,V:1.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n    }\n\n    real_t total = 10; //Should be innitialized to 0 anyway.\n    #pragma acc data copyin(a[0:n], b[0:n])\n    {\n        #pragma acc kernels loop reduction(+:total)\n        for (int x = 0; x < n; ++x){\n            total += a[x] + b[x];\n        }\n    }\n    for (int x = 0; x < n; ++x){\n        total -= a[x] + b[x];\n    }\n    if (fabs(total - 10) > PRECISION * (2 * n - 1)){\n        err = 1;\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "kernels",
                            "loop",
                            "reduction",
                            "combined-constructs"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "kernels_loop_reduction_add_loop.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:kernels,private,reduction,combined-constructs,loop,V:1.0-2.7\n      LOGICAL FUNCTION test1()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x, y !Iterators\n        REAL(8),DIMENSION(10*LOOPCOUNT):: a, b, c, d !Data\n        REAL(8) :: avg\n        INTEGER :: errors = 0\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(a)\n        CALL RANDOM_NUMBER(b)\n        avg = 0\n        !$acc data copyin(a(1:10*LOOPCOUNT), b(1:10*LOOPCOUNT)) create(c(1:10*LOOPCOUNT)) copyout(d(1:10*LOOPCOUNT))\n          !$acc kernels loop gang private(avg)\n          DO x = 0, 9\n            avg = 0\n            !$acc loop worker reduction(+:avg)\n            DO y = 1, LOOPCOUNT\n              avg = avg + a(x * LOOPCOUNT + y) + b(x * LOOPCOUNT + y)\n              c(x * LOOPCOUNT + y) = a(x * LOOPCOUNT + y) + b(x * LOOPCOUNT + y)\n            END DO\n            avg = avg / LOOPCOUNT\n            !$acc loop worker\n            DO y = 1, LOOPCOUNT\n              d(x * LOOPCOUNT + y) = c(x * LOOPCOUNT + y) / avg\n            END DO\n          END DO\n        !$acc end data\n        DO x = 0, 9\n          avg = 0\n          DO y = 1, LOOPCOUNT\n            avg = avg + a(x * LOOPCOUNT + y) + b(x * LOOPCOUNT + y)\n          END DO\n          avg = avg / LOOPCOUNT\n          DO y = 1, LOOPCOUNT\n            IF (abs(d(x * LOOPCOUNT + y) - ((a(x * LOOPCOUNT + y) + b(x * LOOPCOUNT + y)) / avg)) .gt. PRECISION) THEN\n              errors = errors + 1\n            END IF\n          END DO\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "kernels",
                            "private",
                            "reduction",
                            "combined-constructs",
                            "loop"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "kernels_loop_reduction_add_loop.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:kernels,loop,combined-constructs,reduction,V:1.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(10 * n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(10 * n * sizeof(real_t));\n    real_t * c = (real_t *)malloc(10 * n * sizeof(real_t));\n    real_t * d = (real_t *)malloc(10 * n * sizeof(real_t));\n    real_t avg = 0.0;\n\n    for (int x = 0; x < 10 * n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n    }\n\n    #pragma acc data copyin(a[0:10*n], b[0:10*n]) create(c[0:10*n]) copyout(d[0:10*n])\n    {\n        #pragma acc kernels loop gang private(avg)\n        for (int x = 0; x < 10; ++x){\n            avg = 0;\n            #pragma acc loop worker reduction(+:avg)\n            for (int y = 0; y < n; ++y){\n                avg += c[x * n + y] = a[x * n + y] + b[x * n + y];\n            }\n            avg = avg / n;\n            #pragma acc loop worker\n            for (int y = 0; y < n; ++y){\n                d[x * n + y] = c[x * n + y] - avg;\n            }\n        }\n    }\n\n    real_t rolling_total = 0;\n\n    for (int x = 0; x < 10; ++x){\n        rolling_total = 0;\n        for (int y = 0; y < n; ++y){\n            rolling_total += a[x * n + y] + b[x * n + y];\n        }\n        rolling_total = rolling_total / n;\n        for (int y = 0; y < n; ++y){\n            if (fabs(d[x * n + y] - ((a[x * n + y] + b[x * n + y]) - rolling_total)) > PRECISION){\n                err += 1;\n            }\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "kernels",
                            "loop",
                            "combined-constructs",
                            "reduction"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "kernels_loop_reduction_add_vector_loop.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:kernels,private,reduction,combined-constructs,loop,V:1.0-2.7\n      LOGICAL FUNCTION test1()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x, y !Iterators\n        REAL(8),DIMENSION(10*LOOPCOUNT):: a, b !Data\n        REAL(8),DIMENSION(10) :: c\n        REAL(8) :: temp\n        INTEGER :: errors = 0\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(a)\n        CALL RANDOM_NUMBER(b)\n\n        !$acc data copyin(a(1:10*LOOPCOUNT), b(1:10*LOOPCOUNT)) copyout(c(1:10))\n          !$acc kernels loop private(temp)\n          DO x = 0, 9\n            temp = 0.0\n            !$acc loop vector reduction(+:temp)\n            DO y = 1, LOOPCOUNT\n              temp = temp + a(x * LOOPCOUNT + y) + b(x * LOOPCOUNT + y)\n            END DO\n            c(x + 1) = temp\n          END DO\n        !$acc end data\n\n        DO x = 0, 9\n          temp = 0\n          DO y = 1, LOOPCOUNT\n            temp = temp + a(x * LOOPCOUNT + y) + b(x * LOOPCOUNT + y)\n          END DO\n          IF (abs(temp - c(x + 1)) .gt. PRECISION) THEN\n            errors = errors + 1\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "kernels",
                            "private",
                            "reduction",
                            "combined-constructs",
                            "loop"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "kernels_loop_reduction_add_vector_loop.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:kernels,loop,reduction,combined-constructs,V:1.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(10 * n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(10 * n * sizeof(real_t));\n    real_t * c = (real_t *)malloc(10 * sizeof(real_t));\n    real_t temp = 0.0;\n\n    for(int x = 0; x < 10 * n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n    }\n    #pragma acc data copyin(a[0:10*n], b[0:10*n]) copyout(c[0:10])\n    {\n        #pragma acc kernels loop private(temp)\n        for (int x = 0; x < 10; ++x){\n            temp = 0.0;\n            #pragma acc loop vector reduction(+:temp)\n            for (int y = 0; y < n; ++y){\n                temp += a[(x * n) + y] + b[(x * n) + y];\n            }\n            c[x] = temp;\n        }\n    }\n    for (int x = 0; x < 10; ++x){\n        for (int y = 0; y < n; ++y){\n            c[x] -= a[(x * n) + y] + b[(x * n) + y];\n        }\n        if (fabs(c[x]) > PRECISION * (2 * n - 1)){\n            err = 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "kernels",
                            "loop",
                            "reduction",
                            "combined-constructs"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "kernels_loop_reduction_and_general.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:kernels,reduction,combined-constructs,loop,V:1.0-2.7\n      LOGICAL FUNCTION test1()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT):: randoms\n        LOGICAL,DIMENSION(LOOPCOUNT):: a !Data\n        LOGICAL :: results = .TRUE.\n        LOGICAL :: host_results = .TRUE.\n        REAL(8) :: false_margin\n        INTEGER :: errors = 0\n        false_margin = exp(log(.5) / LOOPCOUNT)\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(randoms)\n        DO x = 1, LOOPCOUNT\n          IF (randoms(x) .lt. false_margin) THEN\n            a(x) = .TRUE.\n          ELSE\n            a(x) = .FALSE.\n          END IF\n        END DO\n\n        !$acc data copyin(a(1:LOOPCOUNT))\n          !$acc kernels loop reduction(.and.:results)\n          DO x = 1, LOOPCOUNT\n            results = results .and. a(x)\n          END DO\n        !$acc end data\n\n        DO x = 1, LOOPCOUNT\n          host_results = host_results .and. a(x)\n        END DO\n        IF (host_results .neqv. results) THEN\n          errors = 1\n        END IF\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "kernels",
                            "reduction",
                            "combined-constructs",
                            "loop"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "kernels_loop_reduction_and_general.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:kernels,loop,reduction,combined-constructs,V:1.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n\n    char * a = (char *)malloc(n * sizeof(char));\n    real_t false_margin = pow(exp(1), log(.5)/n);\n    char result = 1;\n\n    for (int x = 0; x < n; ++x){\n        if(rand() / (real_t)(RAND_MAX) < false_margin){\n            a[x] = 1;\n        }\n        else{\n            a[x] = 0;\n        }\n    }\n\n\n    #pragma acc data copyin(a[0:n])\n    {\n        #pragma acc kernels loop reduction(&&:result)\n        for (int x = 0; x < n; ++x){\n            result = result && a[x];\n        }\n    }\n\n    char found = 0;\n    for (int x = 0; x < n; ++x){\n        if (a[x] == 0){\n            found = 1;\n            break;\n        }\n    }\n    if (found == result){\n        err = 1;\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "kernels",
                            "loop",
                            "reduction",
                            "combined-constructs"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "kernels_loop_reduction_and_loop.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:kernels,reduction,combined-constructs,loop,V:1.0-2.7\n      LOGICAL FUNCTION test1()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x, y !Iterators\n        LOGICAL,DIMENSION(10*LOOPCOUNT):: a, a_copy !Data\n        LOGICAL,DIMENSION(10) :: results, has_false\n        LOGICAL :: host_results = .TRUE.\n        LOGICAL :: temp = .TRUE.\n        REAL(8),DIMENSION(10*LOOPCOUNT):: randoms\n        REAL(8) :: false_margin = exp(log(.5) / LOOPCOUNT)\n        INTEGER :: errors = 0\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(randoms)\n        DO x = 1, 10\n          results(x) = .TRUE.\n          has_false(x) = .FALSE.\n        END DO\n        DO x = 1, 10*LOOPCOUNT\n          IF (randoms(x) .lt. false_margin) THEN\n            a(x) = .TRUE.\n            a_copy(x) = .TRUE.\n          ELSE\n            a(x) = .FALSE.\n            a_copy(x) = .FALSE.\n            has_false(x / LOOPCOUNT) = .TRUE.\n          END IF\n        END DO\n\n        !$acc data copy(a(1:10*LOOPCOUNT), results(1:10))\n          !$acc kernels loop gang\n          DO x = 0, 9\n            temp = .TRUE.\n            !$acc loop worker reduction(.AND.:temp)\n            DO y = 1, LOOPCOUNT\n              temp = temp .AND. a(x * LOOPCOUNT + y)\n            END DO\n            results(x + 1) = temp\n            !$acc loop worker\n            DO y = 1, LOOPCOUNT\n              IF (temp .eqv. .TRUE.) THEN\n                IF (a(x * LOOPCOUNT + y) .eqv. .TRUE.) THEN\n                  a(x * LOOPCOUNT + y) = .FALSE.\n                ELSE\n                  a(x * LOOPCOUNT + y) = .TRUE.\n                END IF\n              END IF\n            END DO\n          END DO\n        !$acc end data\n        DO x = 0, 9\n          temp = .TRUE.\n          DO y = 1, LOOPCOUNT\n            temp = temp .AND. a_copy(x * LOOPCOUNT + y)\n          END DO\n          IF (temp .neqv. results(x + 1)) THEN\n            errors = errors + 1\n          END IF\n          DO y = 1, LOOPCOUNT\n            IF (temp .eqv. .TRUE.) THEN\n              IF (a(x * LOOPCOUNT + y) .eqv. a_copy(x * LOOPCOUNT + y)) THEN\n                errors = errors + 1\n              END IF\n            ELSE\n              IF (a(x * LOOPCOUNT + y) .neqv. a_copy(x * LOOPCOUNT + y)) THEN\n                errors = errors + 1\n              END IF\n            END IF\n          END DO\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "kernels",
                            "reduction",
                            "combined-constructs",
                            "loop"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "kernels_loop_reduction_and_loop.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:kernels,loop,reduction,combined-constructs,V:1.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    char * a = (char *)malloc(10 * n * sizeof(char));\n    char * a_copy = (char *)malloc(10 * n * sizeof(char));\n    char * has_false = (char *)malloc(10 * sizeof(char));\n    real_t false_margin = pow(exp(1), log(.5)/n);\n\n    for (int x = 0; x < 10; ++x){\n        has_false[x] = 0;\n    }\n\n    for (int x = 0; x < 10; ++x){\n        for (int y = 0; y < n; ++y){\n            if (rand() / (real_t)(RAND_MAX) < false_margin){\n                a[x * n + y] = 1;\n                a_copy[x * n + y] = 1;\n            }\n            else {\n                a[x * n + y] = 0;\n                a_copy[x * n + y] = 0;\n                has_false[x] = 1;\n            }\n        }\n    }\n\n    char temp = 1;\n    #pragma acc data copy(a[0:10*n])\n    {\n        #pragma acc kernels loop gang private(temp)\n        for (int x = 0; x < 10; ++x){\n            temp = 1;\n            #pragma acc loop worker reduction(&&:temp)\n            for (int y = 0; y < n; ++y){\n                temp = temp && a[x * n + y];\n            }\n            #pragma acc loop worker\n            for (int y = 0; y < n; ++y){\n                if(temp == 1){\n                    if  (a[x * n + y] == 1){\n                        a[x * n + y] = 0;\n                    }\n                    else {\n                        a[x * n + y] = 1;\n                    }\n                }\n            }\n        }\n    }\n\n\n    for (int x = 0; x < 10; ++x){\n        for (int y = 0; y < n; ++y){\n            if (has_false[x] == 1 && a[x * n + y] != a_copy[x * n + y]){\n                err = 1;\n            }\n            else if (has_false[x] == 0 && a[x * n + y] == a_copy[x * n + y]){\n                err = 1;\n            }\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "kernels",
                            "loop",
                            "reduction",
                            "combined-constructs"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "kernels_loop_reduction_and_vector_loop.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:kernels,private,reduction,combined-constructs,loop,V:1.0-2.7\n      LOGICAL FUNCTION test1()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x, y !Iterators\n        LOGICAL,DIMENSION(10*LOOPCOUNT):: a !Data\n        LOGICAL,DIMENSION(10):: b\n        LOGICAL,DIMENSION(10):: has_false\n        LOGICAL :: temp\n        REAL(8) :: false_margin\n        REAL(8),DIMENSION(10*LOOPCOUNT) :: randoms\n        INTEGER :: errors = 0\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(randoms)\n        false_margin = exp(log(.5) / LOOPCOUNT)\n        DO x = 1, 10\n          has_false(x) = .FALSE.\n          b(x) = .TRUE.\n        END DO\n\n        DO x = 0, 9\n          DO y = 1, LOOPCOUNT\n            IF (randoms(x * LOOPCOUNT + y) .lt. false_margin) THEN\n              a(x * LOOPCOUNT + y) = .TRUE.\n            ELSE\n              a(x * LOOPCOUNT + y) = .FALSE.\n              has_false(x + 1) = .TRUE.\n            END IF\n          END DO\n        END DO\n\n        !$acc data copyin(a(1:10*LOOPCOUNT)) copy(b(1:10))\n          !$acc kernels loop private(temp)\n          DO x = 0, 9\n            temp = .TRUE.\n            !$acc loop vector reduction(.AND.:temp)\n            DO y = 1, LOOPCOUNT\n              temp = temp .AND. a(x * LOOPCOUNT + y)\n            END DO\n            b(x + 1) = temp\n          END DO\n        !$acc end data\n\n        DO x = 0, 9\n          temp = .FALSE.\n          DO y = 1, LOOPCOUNT\n            IF (a(x * LOOPCOUNT + y) .eqv. .FALSE.) THEN\n              temp = .TRUE.\n            END IF\n          END DO\n          IF (temp .neqv. has_false(x + 1)) THEN\n            errors = 1\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "kernels",
                            "private",
                            "reduction",
                            "combined-constructs",
                            "loop"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "kernels_loop_reduction_and_vector_loop.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:kernels,loop,reduction,combined-constructs,V:1.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    char * a = (char *)malloc(10 * n * sizeof(char));\n    char * b = (char *)malloc(10 * sizeof(char));\n    char * has_false = (char *)malloc(10 * sizeof(char));\n    real_t false_margin = pow(exp(1), log(.5)/n);\n\n    for (int x = 0; x < 10; ++x){\n        has_false[x] = 0;\n    }\n    for (int x = 0; x < 10 * n; ++x){\n        if(rand() / (real_t)(RAND_MAX) < false_margin){\n            a[x] = 1;\n        }\n        else{\n            a[x] = 0;\n            has_false[x/n] = 1;\n        }\n    }\n    char temp = 1;\n    #pragma acc data copyin(a[0:10*n]) copy(b[0:10])\n    {\n        #pragma acc kernels loop private(temp)\n        for (int x = 0; x < 10; ++x){\n            temp = 1;\n            #pragma acc loop vector reduction(&&:temp)\n            for (int y = 0; y < n; ++y){\n                temp = temp && a[x * n + y];\n            }\n            b[x] = temp;\n        }\n    }\n    for (int x = 0; x < 10; ++x){\n        if (has_false[x] == b[x]){\n            err = 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "kernels",
                            "loop",
                            "reduction",
                            "combined-constructs"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "kernels_loop_reduction_bitand_general.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:kernels,reduction,combined-constructs,loop,V:1.0-2.7\n      LOGICAL FUNCTION test1()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x, y, z !Iterators\n        INTEGER,DIMENSION(LOOPCOUNT):: a !Data\n        INTEGER :: b\n        REAL(8),DIMENSION(16 * LOOPCOUNT):: randoms\n        REAL(8) :: false_margin\n        INTEGER :: errors = 0\n        INTEGER :: temp = 1\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(randoms)\n        false_margin = exp(log(.5)/n)\n        DO x = 1, LOOPCOUNT\n          DO y = 0, 15\n            IF (randoms(y * LOOPCOUNT + x) .lt. false_margin) THEN\n              temp = 1\n              DO z = 0, y\n                temp = temp * 2\n              END DO\n              a(x) = a(x) + temp\n            END IF\n          END DO\n        END DO\n\n        b = a(1)\n\n        !$acc data copyin(a(1:LOOPCOUNT))\n          !$acc kernels loop reduction(iand:b)\n          DO x = 1, LOOPCOUNT\n            b = iand(b, a(x))\n          END DO\n        !$acc end data\n\n        temp = a(1)\n        DO x = 2, LOOPCOUNT\n          temp = iand(a(x), temp)\n        END DO\n        IF (temp .ne. b) THEN\n          WRITE(*, *) temp\n          WRITE(*, *) b\n          errors = 1\n        END IF\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "kernels",
                            "reduction",
                            "combined-constructs",
                            "loop"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "kernels_loop_reduction_bitand_general.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:kernels,loop,reduction,combined-constructs,V:1.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    n = 10;\n    unsigned int * a = (unsigned int *)malloc(n * sizeof(unsigned int));\n    real_t false_margin = pow(exp(1), log(.5)/n);\n    unsigned int temp = 1;\n\n    for (int x = 0; x < n; ++x){\n        for (int y = 0; y < 16; ++y){\n            if (rand() / (real_t) RAND_MAX < false_margin){\n                for (int z = 0; z < y; ++z){\n                    temp *= 2;\n                }\n                a[x] += temp;\n                temp = 1;\n            }\n        }\n    }\n    unsigned int b = 0;\n    for (int x = 0; x < 16; ++x){\n        temp = 1;\n        for (int y = 0; y < x; ++y){\n            temp *= 2;\n        }\n        b += temp;\n    }\n    #pragma acc data copyin(a[0:n])\n    {\n        #pragma acc kernels loop reduction(&:b)\n        for (int x = 0; x < n; ++x){\n            b = b & a[x];\n        }\n    }\n    unsigned int host_b = a[0];\n\n    for (int x = 1; x < n; ++x){\n        host_b = host_b & a[x];\n    }\n    if (b != host_b){\n        err = 1;\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "kernels",
                            "loop",
                            "reduction",
                            "combined-constructs"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "kernels_loop_reduction_bitand_loop.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:kernels,private,reduction,combined-constructs,loop,V:1.0-2.7\n      LOGICAL FUNCTION test1()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x, y, z !Iterators\n        INTEGER,DIMENSION(10*LOOPCOUNT):: a, b, b_copy !Data\n        REAL(8),DIMENSION(10*LOOPCOUNT):: randoms2\n        INTEGER,DIMENSION(10) :: c\n        REAL(8) :: false_margin\n        REAL(8),DIMENSION(160*LOOPCOUNT)::randoms\n        INTEGER :: errors = 0\n        INTEGER :: temp\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(randoms)\n        CALL RANDOM_NUMBER(randoms2)\n        b = FLOOR(10000 * randoms2)\n        b_copy = b\n        false_margin = exp(log(.5)/LOOPCOUNT)\n        DO x = 1, 10 * LOOPCOUNT\n          DO y = 1, 16\n            IF (randoms((y - 1) * 10 * LOOPCOUNT + x) < false_margin) THEN\n              temp = 1\n              DO z = 1, y\n                temp = temp * 2\n              END DO\n              a(x) = a(x) + temp\n            END IF\n          END DO\n        END DO\n\n        DO x = 1, 10\n         c(x) = a((x - 1) * LOOPCOUNT + x)\n        END DO\n\n        !$acc data copyin(a(1:10*LOOPCOUNT)) copy(b(1:10*LOOPCOUNT), c(1:10))\n          !$acc kernels loop gang private(temp)\n          DO x = 1, 10\n            temp = a((x - 1) * LOOPCOUNT + 1)\n            !$acc loop worker reduction(iand:temp)\n            DO y = 2, LOOPCOUNT\n              temp = iand(temp, a((x - 1) * LOOPCOUNT + y))\n            END DO\n            c(x) = temp\n            !$acc loop worker\n            DO y = 1, LOOPCOUNT\n              b((x - 1) * LOOPCOUNT + y) = b((x - 1) * LOOPCOUNT + y) + c(x)\n            END DO\n          END DO\n        !$acc end data\n\n       DO x = 1, 10\n         temp = a((x - 1) * LOOPCOUNT + 1)\n         DO y = 2, LOOPCOUNT\n           temp = iand(temp, a((x - 1) * LOOPCOUNT + y))\n         END DO\n         IF (temp .ne. c(x)) THEN\n           errors = errors + 1\n         END IF\n         DO y = 1, LOOPCOUNT\n           IF (b((x - 1) * LOOPCOUNT + y) .ne. b_copy((x - 1) * LOOPCOUNT + y) + temp) THEN\n             errors = errors + 1\n           END IF\n         END DO\n       END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "kernels",
                            "private",
                            "reduction",
                            "combined-constructs",
                            "loop"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "kernels_loop_reduction_bitand_loop.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:kernels,loop,reduction,combined-constructs,V:1.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    unsigned int * a = (unsigned int *)malloc(10 * n * sizeof(unsigned int));\n    unsigned int * b = (unsigned int *)malloc(10 * n * sizeof(unsigned int));\n    unsigned int * b_copy = (unsigned int *)malloc(10 * n * sizeof(unsigned int));\n    unsigned int * c = (unsigned int *)malloc(10 * sizeof(unsigned int));\n\n    real_t false_margin = pow(exp(1), log(.5)/n);\n    unsigned int temp = 1;\n\n    for (int x = 0; x < 10 * n; ++x){\n        b[x] = (unsigned int) rand() / (real_t)(RAND_MAX / 1000);\n        b_copy[x] = b[x];\n        for (int y = 0; y < 16; ++y){\n            if (rand() / (real_t) RAND_MAX < false_margin){\n                for (int z = 0; z < y; ++z){\n                    temp *= 2;\n                }\n                a[x] += temp;\n                temp = 1;\n            }\n        }\n    }\n    #pragma acc data copyin(a[0:10 * n]) copy(b[0:10 * n], c[0:10])\n    {\n        #pragma acc kernels loop gang private(temp)\n        for (int y = 0; y < 10; ++y){\n            temp = a[y * n];\n            #pragma acc loop worker reduction(&:temp)\n            for (int x = 1; x < n; ++x){\n                temp = temp & a[y * n + x];\n            }\n            c[y] = temp;\n            #pragma acc loop worker\n            for (int x = 0; x < n; ++x){\n                b[y * n + x] = b[y * n + x] + c[y];\n            }\n        }\n    }\n    unsigned int* host_c = (unsigned int *)malloc(10 * sizeof(unsigned int));\n    for (int x = 0; x < 10; ++x){\n        host_c[x] = a[x * n];\n        for (int y = 1; y < n; ++y){\n            host_c[x] = host_c[x] & a[x * n + y];\n        }\n        if (host_c[x] != c[x]){\n          err += 1;\n        }\n    }\n\n    for (int x = 0; x < 10; ++x){\n        for (int y = 0; y < n; ++y){\n            if (b[x * n + y] != b_copy[x * n + y] + c[x]){\n                err += 1;\n            }\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "kernels",
                            "loop",
                            "reduction",
                            "combined-constructs"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "kernels_loop_reduction_bitand_vector_loop.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:kernels,private,reduction,combined-constructs,loop,V:1.0-2.7\n      LOGICAL FUNCTION test1()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x, y, z, i !Iterators\n        INTEGER,DIMENSION(10*LOOPCOUNT):: a !Data\n        INTEGER,DIMENSION(10):: b\n        INTEGER :: c\n        REAL(8),DIMENSION(160*LOOPCOUNT):: random\n        REAL(8) :: false_margin\n        INTEGER :: errors = 0\n        INTEGER :: temp\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(random)\n        false_margin = exp(log(.5) / n)\n        DO x = 0, 9\n          DO y = 1, LOOPCOUNT\n            DO z = 1, 16\n              IF (random(x * 16 * LOOPCOUNT + (y - 1) * 16 + z - 1) < false_margin) THEN\n                temp = 1\n                DO i = 1, z\n                  temp = temp * 2\n                END DO\n                a(x * LOOPCOUNT + y) = a(x * LOOPCOUNT + y) + temp\n              END IF\n            END DO\n          END DO\n        END DO\n\n        !$acc data copyin(a(1:10*LOOPCOUNT)), copy(b(1:10))\n          !$acc kernels loop private(c)\n          DO x = 0, 9\n            c = a(x * LOOPCOUNT + 1)\n            !$acc loop vector reduction(iand:c)\n            DO y = 1, LOOPCOUNT\n              c = iand(c, a(x * LOOPCOUNT + y))\n            END DO\n            b(x + 1) = c\n          END DO\n        !$acc end data\n\n        DO x = 0, 9\n          temp = a(x * LOOPCOUNT + 1)\n          DO y = 2, LOOPCOUNT\n            temp = iand(temp, a(x * LOOPCOUNT + y))\n          END DO\n          IF (b(x + 1) .ne. temp) THEN\n            errors = errors + 1\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "kernels",
                            "private",
                            "reduction",
                            "combined-constructs",
                            "loop"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "kernels_loop_reduction_bitand_vector_loop.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:kernels,loop,reduction,combined-constructs,V:1.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    unsigned int* a = (unsigned int *)malloc(10 * n * sizeof(unsigned int));\n    unsigned int* b = (unsigned int *)malloc(10 * sizeof(unsigned int));\n\n    real_t false_margin = pow(exp(1), log(.5)/n);\n    unsigned int temp = 1;\n    unsigned int c = 0;\n    unsigned int b_host;\n\n    for (int x = 0; x < 10 * n; ++x){\n        for (int y = 0; y < 16; ++y){\n            if (rand() / (real_t) RAND_MAX < false_margin){\n                for (int z = 0; z < y; ++z){\n                    temp *= 2;\n                }\n                a[x] += temp;\n                temp = 1;\n            }\n        }\n    }\n\n    #pragma acc data copyin(a[0:10*n]) copy(b[0:10])\n    {\n        #pragma acc kernels loop private(c)\n        for (int x = 0; x < 10; ++x){\n            c = a[x * n];\n            #pragma acc loop vector reduction(&:c)\n            for (int y = 1; y < n; ++y){\n                c = c & a[x * n + y];\n            }\n            b[x] = c;\n        }\n    }\n    for (int x = 0; x < 10; ++x){\n        b_host = a[x * n];\n        for (int y = 1; y < n; ++y){\n            b_host = b_host & a[x * n + y];\n        }\n        if (b_host != b[x]){\n            err = 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "kernels",
                            "loop",
                            "reduction",
                            "combined-constructs"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "kernels_loop_reduction_bitor_general.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:kernels,reduction,combined-constructs,loop,V:1.0-2.7\n      LOGICAL FUNCTION test1()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x, y, z !Iterators\n        INTEGER,DIMENSION(LOOPCOUNT):: a !Data\n        REAL(8) :: false_margin\n        REAL(8),DIMENSION(16*LOOPCOUNT):: random\n        INTEGER :: errors = 0\n        INTEGER :: temp\n        INTEGER :: b\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(random)\n        false_margin = exp(log(.5)/n)\n        DO x = 1, LOOPCOUNT\n          DO y = 1, 16\n            IF (random((y - 1) * LOOPCOUNT + x) < false_margin) THEN\n              temp = 1\n              DO z = 1, y\n                temp = temp * 2\n              END DO\n              a(x) = a(x) + temp\n            END IF\n          END DO\n        END DO\n        b = a(1)\n        !$acc data copyin(a(1:LOOPCOUNT))\n          !$acc kernels loop reduction(ior:b)\n          DO x = 2, LOOPCOUNT\n            b = ior(b, a(x))\n          END DO\n        !$acc end data\n        temp = a(1)\n        DO x = 2, LOOPCOUNT\n          temp = ior(temp, a(x))\n        END DO\n        IF (temp .ne. b) THEN\n          errors = errors + 1\n        END IF\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "kernels",
                            "reduction",
                            "combined-constructs",
                            "loop"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "kernels_loop_reduction_bitor_general.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:kernels,loop,reduction,combined-constructs,V:1.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    unsigned int * a = (unsigned int *)malloc(n * sizeof(unsigned int));\n    real_t false_margin = pow(exp(1), log(.5)/n);\n    unsigned int temp = 1;\n    unsigned int b = 0;\n    unsigned int host_b = a[0];\n\n    for (int x = 0; x < n; ++x){\n        for (int y = 0; y < 16; ++y){\n            if (rand() / (real_t) RAND_MAX > false_margin){\n                for (int z = 0; z < y; ++z){\n                    temp *= 2;\n                }\n                a[x] += temp;\n                temp = 1;\n            }\n        }\n    }\n\n    #pragma acc data copyin(a[0:n])\n    {\n        #pragma acc kernels loop reduction(|:b)\n        for (int x = 0; x < n; ++x){\n            b = b | a[x];\n        }\n    }\n\n\n    for (int x = 1; x < n; ++x){\n        host_b = host_b | a[x];\n    }\n    if (b != host_b){\n        err = 1;\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "kernels",
                            "loop",
                            "reduction",
                            "combined-constructs"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "kernels_loop_reduction_bitor_loop.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:kernels,private,reduction,combined-constructs,loop,V:1.0-2.7\n      LOGICAL FUNCTION test1()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x, y, z, i !Iterators\n        INTEGER,DIMENSION(10*LOOPCOUNT):: a, b, b_copy !Data\n        REAL(8),DIMENSION(10*LOOPCOUNT):: randoms2\n        INTEGER,DIMENSION(10) :: c\n        REAL(8),DIMENSION(160*LOOPCOUNT):: randoms\n        REAL(8) :: false_margin\n        INTEGER :: errors = 0\n        INTEGER :: temp\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(randoms)\n        CALL RANDOM_NUMBER(randoms2)\n        false_margin = exp(log(.5)/n)\n        b = FLOOR(6*randoms2)\n        b_copy = b\n        DO x = 0, 9\n          DO y = 1, LOOPCOUNT\n            DO z = 1, 16\n              IF (randoms(x * 16 * LOOPCOUNT + y * 16 + z - 1) .gt. false_margin) THEN\n                temp = 1\n                DO i = 1, z\n                  temp = temp * 2\n                END DO\n                a(x * LOOPCOUNT + y) = a(x * LOOPCOUNT + y) + temp\n              END IF\n            END DO\n          END DO\n        END DO\n\n        !$acc data copyin(a(1:10*LOOPCOUNT)) copy(b(1:10*LOOPCOUNT), c(1:10))\n          !$acc kernels loop gang private(temp)\n          DO x = 0, 9\n            temp = 0\n            !$acc loop worker reduction(ior:temp)\n            DO y = 1, LOOPCOUNT\n              temp = ior(temp, a(x * LOOPCOUNT + y))\n            END DO\n            c(x + 1) = temp\n            !$acc loop worker\n            DO y = 1, LOOPCOUNT\n              b(x * LOOPCOUNT + y) = b(x * LOOPCOUNT + y) + c(x + 1)\n            END DO\n          END DO\n        !$acc end data\n\n        DO x = 0, 9\n          temp = 0\n          DO y = 1, LOOPCOUNT\n            temp = ior(temp, a(x * LOOPCOUNT + y))\n          END DO\n          IF (temp .ne. c(x + 1)) THEN\n            errors = errors + 1\n          END IF\n          DO y = 1, LOOPCOUNT\n            IF (b(x * LOOPCOUNT + y) .ne. b_copy(x * LOOPCOUNT + y) + c(x + 1)) THEN\n              errors = errors + 1\n            END IF\n          END DO\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "kernels",
                            "private",
                            "reduction",
                            "combined-constructs",
                            "loop"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "kernels_loop_reduction_bitor_loop.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:kernels,loop,reduction,combined-constructs,V:1.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    unsigned int * a = (unsigned int *)malloc(10 * n * sizeof(unsigned int));\n    unsigned int * b = (unsigned int *)malloc(10 * n * sizeof(unsigned int));\n    unsigned int * b_copy = (unsigned int *)malloc(10 * n * sizeof(unsigned int));\n    unsigned int * c = (unsigned int *)malloc(10 * sizeof(unsigned int));\n\n    real_t false_margin = pow(exp(1), log(.5)/n);\n    unsigned int temp = 1;\n    unsigned int host_c;\n\n    for (int x = 0; x < 10; ++x){\n        for (int y = 0; y < n; ++y){\n            b[x * n + y] = (unsigned int) rand() / (real_t)(RAND_MAX / 1000);\n            b_copy[x * n + y] = b[x * n + y];\n            for (int z = 0; z < 16; ++z){\n                if (rand() / (real_t) RAND_MAX > false_margin){\n                    temp = 1;\n                    for (int i = 0; i < z; ++i){\n                        temp = temp * 2;\n                    }\n                    a[x * n + y] += temp;\n                }\n            }\n        }\n    }\n\n    #pragma acc data copyin(a[0:10*n]) copy(b[0:10*n], c[0:10])\n    {\n        #pragma acc kernels loop gang private(temp)\n        for (int x = 0; x < 10; ++x){\n            temp = 0;\n            #pragma acc loop worker reduction(|:temp)\n            for (int y = 0; y < n; ++y){\n                temp = temp | a[x * n + y];\n            }\n            c[x] = temp;\n            #pragma acc loop worker\n            for (int y = 0; y < n; ++y){\n                b[x * n + y] = b[x * n + y] + c[x];\n            }\n        }\n    }\n    for (int x = 0; x < 10; ++x){\n        host_c = a[x * n];\n        for (int y = 1; y < n; ++y){\n            host_c = host_c | a[x * n + y];\n        }\n        if (host_c != c[x]){\n            err += 1;\n        }\n        for (int y = 0; y < n; ++y){\n            if (b[x * n + y] != b_copy[x * n + y] + host_c){\n                err += 1;\n            }\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "kernels",
                            "loop",
                            "reduction",
                            "combined-constructs"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "kernels_loop_reduction_bitor_vector_loop.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:kernels,private,reduction,combined-constructs,loop,V:1.0-2.7\n      LOGICAL FUNCTION test1()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x, y, z !Iterators\n        INTEGER,DIMENSION(10 * LOOPCOUNT):: a !Data\n        INTEGER,DIMENSION(10) :: b\n        REAL(8) :: false_margin\n        REAL(8),DIMENSION(160 * LOOPCOUNT) :: randoms\n        INTEGER :: errors = 0\n        INTEGER :: temp\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(randoms)\n        false_margin = exp(log(.5) / n)\n        DO x = 1, 10 * LOOPCOUNT\n          DO y = 1, 16\n            IF (randoms(y * 10 * LOOPCOUNT + y - 1) .gt. false_margin) THEN\n              temp = 1\n              DO z = 1, y\n                temp = temp * 2\n              END DO\n              a(x) = a(x) + temp\n            END IF\n          END DO\n        END DO\n\n        !$acc data copyin(a(1:10*LOOPCOUNT)) copy(b(1:10))\n          !$acc kernels loop private(temp)\n          DO x = 0, 9\n            temp = 0\n            !$acc loop vector reduction(ior:temp)\n            DO y = 1, LOOPCOUNT\n              temp = ior(temp, a(x * LOOPCOUNT + y))\n            END DO\n            b(x + 1) = temp\n          END DO\n        !$acc end data\n\n        DO x = 0, 9\n          temp = 0\n          DO y = 1, LOOPCOUNT\n            temp = ior(temp, a(x * LOOPCOUNT + y))\n          END DO\n          IF (temp .ne. b(x + 1)) THEN\n            errors = errors + 1\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "kernels",
                            "private",
                            "reduction",
                            "combined-constructs",
                            "loop"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "kernels_loop_reduction_bitor_vector_loop.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:kernels,loop,reduction,combined-constructs,V:1.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    unsigned int* a = (unsigned int *)malloc(10 * n * sizeof(unsigned int));\n    unsigned int* b = (unsigned int *)malloc(10 * sizeof(unsigned int));\n\n    real_t false_margin = pow(exp(1), log(.5)/n);\n    unsigned int temp = 1;\n    unsigned int b_host;\n\n    for (int x = 0; x < 10 * n; ++x){\n        for (int y = 0; y < 16; ++y){\n            if (rand() / (real_t) RAND_MAX > false_margin){\n                for (int z = 0; z < y; ++z){\n                    temp *= 2;\n                }\n                a[x] += temp;\n                temp = 1;\n            }\n        }\n    }\n    temp = 0;\n    #pragma acc data copyin(a[0:10*n]) copy(b[0:10])\n    {\n        #pragma acc kernels loop private(temp)\n        for (int x = 0; x < 10; ++x){\n            temp = 0;\n            #pragma acc loop vector reduction(|:temp)\n            for (int y = 0; y < n; ++y){\n                temp = temp | a[x * n + y];\n            }\n            b[x] = temp;\n        }\n    }\n\n    for (int x = 0; x < 10; ++x){\n        b_host = a[x * n];\n        for (int y = 1; y < n; ++y){\n            b_host = b_host | a[x * n + y];\n        }\n        if (b_host != b[x]){\n            err = 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "kernels",
                            "loop",
                            "reduction",
                            "combined-constructs"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "kernels_loop_reduction_bitxor_general.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:kernels,reduction,combined-constructs,loop,V:1.0-2.7\n      LOGICAL FUNCTION test1()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x !Iterators\n        INTEGER,DIMENSION(LOOPCOUNT):: a !Data\n        REAL(8),DIMENSION(LOOPCOUNT):: randoms\n        INTEGER :: errors = 0\n        INTEGER :: b = 0\n        INTEGER :: temp = 0\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(randoms)\n        a = FLOOR(randoms*1000000)\n\n        !$acc data copyin(a(1:LOOPCOUNT))\n          !$acc kernels loop reduction(ieor:b)\n          DO x = 1, LOOPCOUNT\n            b = ieor(b, a(x))\n          END DO\n        !$acc end data\n\n        DO x = 1, LOOPCOUNT\n          temp = ieor(temp, a(x))\n        END DO\n        IF (temp .ne. b) THEN\n          errors = errors + 1\n        END IF\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "kernels",
                            "reduction",
                            "combined-constructs",
                            "loop"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "kernels_loop_reduction_bitxor_general.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:kernels,loop,reduction,combined-constructs,V:1.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    unsigned int * a = (unsigned int *)malloc(n * sizeof(unsigned int));\n    unsigned int b = 0;\n    unsigned int host_b = a[0];\n\n    for (int x = 0; x < n; ++x){\n        a[x] = (unsigned int) rand() / (real_t) (RAND_MAX / 2);\n    }\n\n    #pragma acc data copyin(a[0:n])\n    {\n        #pragma acc kernels loop reduction(^:b)\n        for (int x = 0; x < n; ++x){\n            b = b ^ a[x];\n        }\n    }\n\n\n    for (int x = 1; x < n; ++x){\n        host_b = host_b ^ a[x];\n    }\n    if (b != host_b){\n        err = 1;\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "kernels",
                            "loop",
                            "reduction",
                            "combined-constructs"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "kernels_loop_reduction_bitxor_loop.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:kernels,private,reduction,combined-constructs,loop,V:1.0-2.7\n      LOGICAL FUNCTION test1()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x, y !Iterators\n        INTEGER,DIMENSION(10*LOOPCOUNT):: a, b, b_copy !Data\n        REAL(8),DIMENSION(10*LOOPCOUNT):: randoms, randoms2\n        INTEGER,DIMENSION(10):: c\n        REAL*8 :: RAND\n        INTEGER :: errors = 0\n        INTEGER :: temp\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(randoms)\n        a = FLOOR(randoms*1000000)\n        CALL RANDOM_NUMBER(randoms2)\n        b = FLOOR(randoms2*1000000)\n        b_copy = b\n        c = 0\n\n        !$acc data copyin(a(1:10*LOOPCOUNT)) copy(b(1:10*LOOPCOUNT), c(1:10))\n          !$acc kernels loop gang private(temp)\n          DO x = 0, 9\n            temp = 0\n            !$acc loop worker reduction(ieor:temp)\n            DO y = 1, LOOPCOUNT\n              temp = ieor(temp, a(x * LOOPCOUNT + y))\n            END DO\n            c(x + 1) = temp\n            !$acc loop worker\n            DO y = 1, LOOPCOUNT\n              b(x * LOOPCOUNT + y) = b(x * LOOPCOUNT + y) + c(x + 1)\n            END DO\n          END DO\n        !$acc end data\n\n        DO x = 0, 9\n          temp = 0\n          DO y = 1, LOOPCOUNT\n            temp = ieor(temp, a(x * LOOPCOUNT + y))\n          END DO\n          IF (temp .ne. c(x + 1)) THEN\n            errors = errors + 1\n          END IF\n          DO y = 1, LOOPCOUNT\n            IF (b(x * LOOPCOUNT + y) .ne. b_copy(x * LOOPCOUNT + y) + c(x + 1)) THEN\n              errors = errors + 1\n            END IF\n          END DO\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "kernels",
                            "private",
                            "reduction",
                            "combined-constructs",
                            "loop"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "kernels_loop_reduction_bitxor_loop.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:kernels,loop,reduction,combined-constructs,V:1.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    unsigned int * a = (unsigned int *)malloc(10 * n * sizeof(unsigned int));\n    unsigned int * b = (unsigned int *)malloc(10 * n * sizeof(unsigned int));\n    unsigned int * b_copy = (unsigned int *)malloc(10 * n * sizeof(unsigned int));\n    unsigned int * c = (unsigned int *)malloc(10 * sizeof(unsigned int));\n    unsigned int temp = 0;\n\n    for (int x = 0; x < 10*n; ++x){\n        b[x] = (unsigned int) rand() / (real_t)(RAND_MAX / 1000);\n        b_copy[x] = b[x];\n        a[x] = (unsigned int) rand() / (real_t)(RAND_MAX / 1000);\n    }\n    for (int x = 0; x < 10; ++x){\n        c[x] = 0;\n    }\n\n    #pragma acc data copyin(a[0:10*n]) copy(b[0:10*n], c[0:10])\n    {\n        #pragma acc kernels loop gang private(temp)\n        for (int x = 0; x < 10; ++x){\n            temp = 0;\n            #pragma acc loop worker reduction(^:temp)\n            for (int y = 0; y < n; ++y){\n                temp = temp ^ a[x * n + y];\n            }\n            c[x] = temp;\n            #pragma acc loop worker\n            for (int y = 0; y < n; ++y){\n                b[x * n + y] = b[x * n + y] + c[x];\n            }\n        }\n    }\n\n    for (int x = 0; x < 10; ++x){\n        temp = 0;\n        for (int y = 0; y < n; ++y){\n            temp = temp ^ a[x * n + y];\n        }\n        if (temp != c[x]){\n            err += 1;\n        }\n        for (int y = 0; y < n; ++y){\n            if (b[x * n + y] != b_copy[x * n + y] + c[x]){\n                err += 1;\n            }\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "kernels",
                            "loop",
                            "reduction",
                            "combined-constructs"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "kernels_loop_reduction_bitxor_vector_loop.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:kernels,private,reduction,combined-constructs,loop,V:1.0-2.7\n      LOGICAL FUNCTION test1()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x, y !Iterators\n        INTEGER,DIMENSION(10*LOOPCOUNT):: a !Data\n        REAL(8),DIMENSION(10*LOOPCOUNT):: randoms\n        INTEGER,DIMENSION(10):: b\n        INTEGER :: errors = 0\n        INTEGER :: temp\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(randoms)\n        a = FLOOR(randoms*1000000)\n\n        !$acc data copyin(a(1:10*LOOPCOUNT)) copy(b(1:10))\n          !$acc kernels loop gang private(temp)\n          DO x = 0, 9\n            temp = 0\n            !$acc loop vector reduction(ieor:temp)\n            DO y = 1, LOOPCOUNT\n              temp = ieor(temp, a(x * LOOPCOUNT + y))\n            END DO\n            b(x + 1) = temp\n          END DO\n        !$acc end data\n\n        DO x = 0, 9\n          temp = 0\n          DO y = 1, LOOPCOUNT\n            temp = ieor(temp, a(x * LOOPCOUNT + y))\n          END DO\n          IF (temp .ne. b(x + 1)) THEN\n            errors = errors + 1\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "kernels",
                            "private",
                            "reduction",
                            "combined-constructs",
                            "loop"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "kernels_loop_reduction_bitxor_vector_loop.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:kernels,loop,reduction,combined-constructs,V:1.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    unsigned int* a = (unsigned int *)malloc(10 * n * sizeof(unsigned int));\n    unsigned int* b = (unsigned int *)malloc(10 * sizeof(unsigned int));\n\n    unsigned int temp = 0;\n    unsigned int b_host;\n\n    for (int x = 0; x < 10 * n; ++x){\n        a[x] = (unsigned int) rand() / (real_t) (RAND_MAX / 2);\n    }\n\n    #pragma acc data copyin(a[0:10*n]) copy(b[0:10])\n    {\n        #pragma acc kernels loop private(temp)\n        for (int x = 0; x < 10; ++x){\n            temp = 0;\n            #pragma acc loop vector reduction(^:temp)\n            for (int y = 0; y < n; ++y){\n                temp = temp ^ a[x * n + y];\n            }\n            b[x] = temp;\n        }\n    }\n\n    for (int x = 0; x < 10; ++x){\n        b_host = a[x * n];\n        for (int y = 1; y < n; ++y){\n            b_host = b_host ^ a[x * n + y];\n        }\n        if (b_host != b[x]){\n            err = 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "kernels",
                            "loop",
                            "reduction",
                            "combined-constructs"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "kernels_loop_reduction_max_general.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:kernels,reduction,combined-constructs,loop,V:1.0-2.7\n      LOGICAL FUNCTION test1()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT):: a, b !Data\n        REAL(8) :: maximum, temp\n        INTEGER :: errors = 0\n\n        !Initilization\n        maximum = 0\n        temp = 0\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(a)\n        CALL RANDOM_NUMBER(b)\n\n        !$acc data copyin(a(1:LOOPCOUNT), b(1:LOOPCOUNT))\n          !$acc kernels loop reduction(max:maximum)\n          DO x = 1, LOOPCOUNT\n            maximum = max(maximum, a(x) * b(x))\n          END DO\n        !$acc end data\n\n        DO x = 1, LOOPCOUNT\n          temp = max(temp, a(x) * b(x))\n        END DO\n        IF (abs(temp - maximum) .gt. PRECISION) THEN\n          errors = errors + 1\n        END IF\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "kernels",
                            "reduction",
                            "combined-constructs",
                            "loop"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "kernels_loop_reduction_max_general.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:kernels,loop,reduction,combined-constructs,V:1.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n    real_t max = 0.0;\n    int found = 0;\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX/10);\n        b[x] = rand() / (real_t)(RAND_MAX/10);\n    }\n    #pragma acc data copyin(a[0:n], b[0:n]) copy(max)\n    {\n        #pragma acc kernels loop reduction(max:max)\n        for (int x = 0; x < n; ++x){\n            max = fmax(a[x] * b[x], max);\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        if (fabs(max - (a[x] * b[x] + PRECISION)) < 0){\n            err = 1;\n        }\n        if (fabs(max - (a[x] * b[x] - PRECISION)) > 0){\n            found = 1;\n        }\n    }\n    if (found = 0){\n        err = 1;\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "kernels",
                            "loop",
                            "reduction",
                            "combined-constructs"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "kernels_loop_reduction_max_loop.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:kernels,private,reduction,combined-constructs,loop,V:1.0-2.7\n      LOGICAL FUNCTION test1()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x, y !Iterators\n        REAL(8),DIMENSION(10 * LOOPCOUNT):: a, b, c !Data\n        REAL(8),DIMENSION(10):: maximum\n        REAL(8) :: temp\n        INTEGER :: errors = 0\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(a)\n        CALL RANDOM_NUMBER(b)\n        c = 0\n\n        !$acc data copyin(a(1:10*LOOPCOUNT), b(1:10*LOOPCOUNT)) copy(c(1:10*LOOPCOUNT))\n          !$acc kernels loop gang private(temp)\n          DO x = 0, 9\n            temp = 0\n            !$acc loop worker reduction(max:temp)\n            DO y = 1, LOOPCOUNT\n              temp = max(temp, a(x * LOOPCOUNT + y) * b(x * LOOPCOUNT + y))\n            END DO\n            maximum(x + 1) = temp\n            !$acc loop worker\n            DO y = 1, LOOPCOUNT\n              c(x * LOOPCOUNT + y) = (a(x * LOOPCOUNT + y) * b(x * LOOPCOUNT + y)) / maximum(x + 1)\n            END DO\n          END DO\n        !$acc end data\n\n        DO x = 0, 9\n          DO y = 1, LOOPCOUNT\n            IF (a(x * LOOPCOUNT + y) * b(x * LOOPCOUNT + y) - maximum(x + 1) .gt. PRECISION) THEN\n              errors = errors + 1\n            ELSE IF ((c(x * LOOPCOUNT + y) - 1) .gt. PRECISION) THEN\n              errors = errors + 1\n            END IF\n          END DO\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "kernels",
                            "private",
                            "reduction",
                            "combined-constructs",
                            "loop"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "kernels_loop_reduction_max_loop.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:kernels,loop,reduction,combined-constructs,V:1.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(10 * n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(10 * n * sizeof(real_t));\n    real_t * c = (real_t *)malloc(10 * n * sizeof(real_t));\n    real_t * maximum = (real_t *)malloc(10 * sizeof(real_t));\n    real_t temp = 0;\n    real_t max = 0.0;\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX/10);\n        b[x] = rand() / (real_t)(RAND_MAX/10);\n        c[x] = 0.0;\n    }\n    for (int x = 0; x < 10; ++x){\n        maximum[x] = 0;\n    }\n\n    #pragma acc data copyin(a[0:10*n], b[0:10*n]) copy(c[0:10*n], maximum[0:10])\n    {\n        #pragma acc kernels loop gang private(temp)\n        for (int x = 0; x < 10; ++x){\n            temp = 0;\n            #pragma acc loop worker reduction(max:temp)\n            for (int y = 0; y < n; ++y){\n                temp = fmax(a[x * n + y] * b[x * n + y], temp);\n            }\n            maximum[x] = temp;\n            #pragma acc loop worker\n            for (int y = 0; y < n; ++y){\n                c[x * n + y] = (a[x * n + y] * b[x * n + y]) / maximum[x];\n            }\n        }\n    }\n    for (int x = 0; x < 10; ++x){\n        temp = 0;\n        for (int y = 0; y < n; ++y){\n            temp = fmax(temp, a[x * n + y] * b[x * n + y]);\n        }\n        if (fabs(temp - maximum[x]) > PRECISION){\n            err += 1;\n        }\n        for (int y = 0; y < n; ++y){\n            if (c[x * n + y] > 1){\n                err += 1;\n            }\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "kernels",
                            "loop",
                            "reduction",
                            "combined-constructs"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "kernels_loop_reduction_max_vector_loop.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:kernels,private,reduction,combined-constructs,loop,V:1.0-2.7\n      LOGICAL FUNCTION test1()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x, y !Iterators\n        REAL(8),DIMENSION(10 * LOOPCOUNT):: a, b !Data\n        REAL(8),DIMENSION(10):: maximum\n        INTEGER :: errors = 0\n        REAL(8) :: temp\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(a)\n        CALL RANDOM_NUMBER(b)\n        maximum = 0\n\n        !$acc data copyin(a(1:10*LOOPCOUNT), b(1:10*LOOPCOUNT)) copy(maximum(1:10))\n          !$acc kernels loop private(temp)\n          DO x = 0, 9\n            temp = 0\n            !$acc loop vector reduction(max:temp)\n            DO y = 1, LOOPCOUNT\n              temp = max(temp, a(x * LOOPCOUNT + y) * b(x * LOOPCOUNT + y))\n            END DO\n            maximum(x + 1) = temp\n          END DO\n        !$acc end data\n\n        DO x = 0, 9\n          temp = 0\n          DO y = 1, LOOPCOUNT\n            temp = max(temp, a(x * LOOPCOUNT + y) * b(x * LOOPCOUNT + y))\n          END DO\n          IF (abs(temp - maximum(x + 1)) .gt. PRECISION) THEN\n            errors = errors + 1\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "kernels",
                            "private",
                            "reduction",
                            "combined-constructs",
                            "loop"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "kernels_loop_reduction_max_vector_loop.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:kernels,loop,reduction,combined-constructs,V:1.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(10 * n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(10 * n * sizeof(real_t));\n    real_t * max = (real_t *)malloc(10 * sizeof(real_t));\n    real_t temp = 0;\n    real_t temp_max;\n\n    for (int x = 0; x < 10 * n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX/10);\n        b[x] = rand() / (real_t)(RAND_MAX/10);\n    }\n    #pragma acc data copyin(a[0:10*n], b[0:10*n]) copy(max[0:10])\n    {\n        #pragma acc kernels loop private(temp)\n        for (int x = 0; x < 10; ++x){\n            temp = 0;\n            #pragma acc loop vector reduction(max:temp)\n            for (int y = 0; y < n; ++y){\n                temp = fmax(a[x * n + y] * b[x * n + y], temp);\n            }\n            max[x] = temp;\n        }\n    }\n    for (int x = 0; x < 10; ++x){\n        temp_max = 0;\n        for (int y = 0; y < n; ++y){\n            if (temp_max < a[x * n + y] * b[x * n + y]){\n                temp_max = a[x * n + y] * b[x * n + y];\n            }\n        }\n        if (fabs(temp_max - max[x]) > PRECISION){\n            err = 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "kernels",
                            "loop",
                            "reduction",
                            "combined-constructs"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "kernels_loop_reduction_min_general.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:kernels,reduction,combined-constructs,loop,V:1.0-2.7\n      LOGICAL FUNCTION test1()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT):: a, b !Data\n        REAL(8):: minimum = 1000\n        REAL(8):: temp = 1000\n        INTEGER :: errors = 0\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(a)\n        CALL RANDOM_NUMBER(b)\n\n        !$acc data copyin(a(1:LOOPCOUNT), b(1:LOOPCOUNT))\n          !$acc kernels loop reduction(min:minimum)\n          DO x = 1, LOOPCOUNT\n            minimum = min(minimum, a(x) * b(x))\n          END DO\n        !$acc end data\n\n        DO x = 1, LOOPCOUNT\n          temp = min(temp, a(x) * b(x))\n        END DO\n        IF (abs(temp - minimum) .gt. PRECISION) THEN\n          errors = errors + 1\n        END IF\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "kernels",
                            "reduction",
                            "combined-constructs",
                            "loop"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "kernels_loop_reduction_min_general.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:kernels,loop,reduction,combined-constructs,V:1.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n    real_t min = 1000.0;\n    int found = 0;\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX/10);\n        b[x] = rand() / (real_t)(RAND_MAX/10);\n    }\n    #pragma acc data copyin(a[0:n], b[0:n]) copy(min)\n    {\n        #pragma acc kernels loop reduction(min:min)\n        for (int x = 0; x < n; ++x){\n            min = fmin(a[x] * b[x], min);\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        if (fabs((a[x] * b[x]) - (min + PRECISION)) < 0){\n            err = 1;\n        }\n        if (fabs(min - (a[x] * b[x])) < PRECISION){\n            found = 1;\n        }\n    }\n    if (found == 0){\n        err = 1;\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "kernels",
                            "loop",
                            "reduction",
                            "combined-constructs"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "kernels_loop_reduction_min_loop.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:kernels,private,reduction,combined-constructs,loop,V:1.0-2.7\n      LOGICAL FUNCTION test1()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x, y !Iterators\n        REAL(8),DIMENSION(10 * LOOPCOUNT):: a, b, c !Data\n        REAL(8),DIMENSION(10):: minimum\n        REAL(8):: temp\n        INTEGER :: errors = 0\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(a)\n        CALL RANDOM_NUMBER(b)\n        c = 0\n        a = a + 1\n        b = b + 1\n\n        !$acc data copyin(a(1:10*LOOPCOUNT), b(1:10*LOOPCOUNT)) copy(c(1:10*LOOPCOUNT)) copy(minimum(1:10))\n          !$acc kernels loop gang independent private(temp)\n          DO x = 0, 9\n            temp = 1000\n            !$acc loop worker independent reduction(min:temp)\n            DO y = 1, LOOPCOUNT\n              temp = min(temp, a(x * LOOPCOUNT + y) * b(x * LOOPCOUNT + y))\n            END DO\n            minimum(x + 1) = temp\n            !$acc loop independent\n            DO y = 1, LOOPCOUNT\n              c(x * LOOPCOUNT + y) = (a(x * LOOPCOUNT + y) * b(x * LOOPCOUNT + y)) / minimum(x + 1)\n            END DO\n          END DO\n        !$acc end data\n\n        DO x = 0, 9\n          temp = 1000\n          DO y = 1, LOOPCOUNT\n            temp = min(temp, a(x * LOOPCOUNT + y) * b(x * LOOPCOUNT + y))\n          END DO\n          IF (abs(temp - minimum(x + 1)) .gt. PRECISION) THEN\n            errors = errors + 1\n            WRITE(*, *) minimum(x + 1)\n          END IF\n          DO y = 1, LOOPCOUNT\n            IF (abs(c(x * LOOPCOUNT + y) - (a(x * LOOPCOUNT + y) * b(x * LOOPCOUNT + y) / temp)) .gt. PRECISION) THEN\n              errors = errors + 1\n            END IF\n          END DO\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "kernels",
                            "private",
                            "reduction",
                            "combined-constructs",
                            "loop"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "kernels_loop_reduction_min_loop.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:kernels,loop,reduction,combined-constructs,V:1.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(10 * n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(10 * n * sizeof(real_t));\n    real_t * c = (real_t *)malloc(10 * n * sizeof(real_t));\n    real_t * minimum = (real_t *)malloc(10 * sizeof(real_t));\n    real_t temp = 0;\n\n    for (int x = 0; x < 10 * n; ++x){\n        a[x] = 1 + rand() / (real_t)(RAND_MAX/10);\n        b[x] = 1 + rand() / (real_t)(RAND_MAX/10);\n        c[x] = 0.0;\n    }\n\n    #pragma acc data copyin(a[0:10*n], b[0:10*n]) copy(c[0:10*n], minimum[0:10])\n    {\n        #pragma acc kernels loop gang private(temp)\n        for (int x = 0; x < 10; ++x){\n            temp = 1000;\n            #pragma acc loop reduction(min:temp)\n            for (int y = 0; y < n; ++y){\n                temp = fmin(a[x * n + y] * b[x * n + y], temp);\n            }\n            minimum[x] = temp;\n            #pragma acc loop\n            for (int y = 0; y < n; ++y){\n                c[x * n + y] = (a[x * n + y] * b[x * n + y]) / minimum[x];\n            }\n        }\n    }\n\n    for (int x = 0; x < 10; ++x){\n        temp = 1000;\n        for (int y = 0; y < n; ++y){\n            temp = fmin(temp, a[x * n + y] * b[x * n + y]);\n        }\n        if (fabs(temp - minimum[x]) > PRECISION){\n            err += 1;\n        }\n        for (int y = 0; y < n; ++y){\n            if (fabs(c[x * n + y] - (a[x * n + y] * b[x * n + y] / minimum[x])) > PRECISION){\n                err += 1;\n            }\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "kernels",
                            "loop",
                            "reduction",
                            "combined-constructs"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "kernels_loop_reduction_min_vector_loop.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:kernels,private,reduction,combined-constructs,loop,V:1.0-2.7\n      LOGICAL FUNCTION test1()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x, y!Iterators\n        REAL(8),DIMENSION(10*LOOPCOUNT):: a, b !Data\n        REAL(8),DIMENSION(10):: minimum\n        REAL(8):: temp = 1000\n        INTEGER :: errors = 0\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(a)\n        CALL RANDOM_NUMBER(b)\n\n        !$acc data copyin(a(1:10*LOOPCOUNT), b(1:10*LOOPCOUNT)) copy(minimum(1:10))\n          !$acc kernels loop gang private(temp)\n          DO x = 0, 9\n            temp = 1000\n            !$acc loop vector reduction(min:temp)\n            DO y = 1, LOOPCOUNT\n              temp = min(temp, a(x * LOOPCOUNT + y) * b(x * LOOPCOUNT + y))\n            END DO\n            minimum(x + 1) = temp\n          END DO\n        !$acc end data\n\n        DO x = 0, 9\n          temp = 1000\n          DO y = 1, LOOPCOUNT\n            temp = min(temp, a(x * LOOPCOUNT + y) * b(x * LOOPCOUNT + y))\n          END DO\n          IF (abs(temp - minimum(x + 1)) .gt. PRECISION) THEN\n            errors = errors + 1\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "kernels",
                            "private",
                            "reduction",
                            "combined-constructs",
                            "loop"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "kernels_loop_reduction_min_vector_loop.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:kernels,loop,reduction,combined-constructs,V:1.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(10 * n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(10 * n * sizeof(real_t));\n    real_t * min = (real_t *)malloc(10 * sizeof(real_t));\n    real_t temp = 100;\n    real_t temp_min;\n\n    for (int x = 0; x < 10 * n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX/10);\n        b[x] = rand() / (real_t)(RAND_MAX/10);\n    }\n\n    #pragma acc data copyin(a[0:10*n], b[0:10*n]) copy(min[0:10])\n    {\n        #pragma acc kernels loop gang private(temp)\n        for (int x = 0; x < 10; ++x){\n            temp = 100;\n            #pragma acc loop vector reduction(min:temp)\n            for (int y = 0; y < n; ++y){\n                temp = fmin(a[x * n + y] * b[x * n + y], temp);\n            }\n            min[x] = temp;\n        }\n    }\n    for (int x = 0; x < 10; ++x){\n        temp_min = 100;\n        for (int y = 0; y < n; ++y){\n            if (temp_min > a[x * n + y] * b[x * n + y]){\n                temp_min = a[x * n + y] * b[x * n + y];\n            }\n        }\n        if (fabs(temp_min - min[x]) > PRECISION){\n            err = 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "kernels",
                            "loop",
                            "reduction",
                            "combined-constructs"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "kernels_loop_reduction_multiply_general.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:kernels,reduction,combined-constructs,loop,V:1.0-2.7\n      LOGICAL FUNCTION test1()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT):: a, b !Data\n        INTEGER :: errors = 0\n        REAL(8) :: temp = 1\n        REAL(8) :: multiplied_total = 1\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(a)\n        CALL RANDOM_NUMBER(b)\n        a = (999.4 + a)/1000\n        b = (999.4 + b)/1000\n\n        !$acc data copyin(a(1:LOOPCOUNT))\n          !$acc kernels loop reduction(*:multiplied_total)\n          DO x = 1, LOOPCOUNT\n            multiplied_total = multiplied_total * (a(x) + b(x))\n          END DO\n        !$acc end data\n\n        DO x = 1, LOOPCOUNT\n          temp = temp * (a(x) + b(x))\n        END DO\n        IF (abs(temp - multiplied_total) .gt. ((temp / 2) + (multiplied_total / 2)) * PRECISION) THEN\n          WRITE(*, *) temp\n          WRITE(*, *) multiplied_total\n          errors = errors + 1\n        END IF\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "kernels",
                            "reduction",
                            "combined-constructs",
                            "loop"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "kernels_loop_reduction_multiply_general.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:kernels,loop,reduction,combined-constructs,V:1.0-2.7\nint test1(){\n    int err = 0;\n    int multiplicitive_n = 128;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(multiplicitive_n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(multiplicitive_n * sizeof(real_t));\n\n    real_t multiplied_total = 1.0;\n\n    for (int x = 0; x < multiplicitive_n; ++x){\n        a[x] = rand() / (real_t) RAND_MAX;\n        b[x] = rand() / (real_t) RAND_MAX;\n    }\n\n    #pragma acc data copyin(a[0:multiplicitive_n], b[0:multiplicitive_n]) copy(multiplied_total)\n    {\n        #pragma acc kernels loop reduction(*:multiplied_total)\n        for (int x = 0; x < multiplicitive_n; ++x){\n            multiplied_total *= a[x] + b[x];\n        }\n    }\n\n    for (int x = 0; x < multiplicitive_n; ++x){\n        multiplied_total /= (a[x] + b[x]);\n    }\n    if (fabs(multiplied_total - 1) > PRECISION * (2 * multiplicitive_n - 1)){\n        err = 1;\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "kernels",
                            "loop",
                            "reduction",
                            "combined-constructs"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "kernels_loop_reduction_multiply_loop.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:kernels,private,reduction,combined-constructs,loop,V:1.0-2.7\n      LOGICAL FUNCTION test1()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x, y !Iterators\n        REAL(8),DIMENSION(10*LOOPCOUNT):: a, b, c !Data\n        REAL(8),DIMENSION(10):: totals\n        REAL(8) :: temp\n        INTEGER :: errors = 0\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(a)\n        CALL RANDOM_NUMBER(b)\n        c = 0\n        a = (999.4 + a) / 2000\n        b = (999.4 + b) / 2000\n\n        !$acc data copyin(a(1:10*LOOPCOUNT), b(1:10*LOOPCOUNT)) copy(c(1:10*LOOPCOUNT), totals(1:10))\n          !$acc kernels loop gang private(temp)\n          DO x = 0, 9\n            temp = 1\n            !$acc loop worker reduction(*:temp)\n            DO y = 1, LOOPCOUNT\n              temp = temp * (a(x * LOOPCOUNT + y) + b(x * LOOPCOUNT + y))\n            END DO\n            totals(x + 1) = temp\n            !$acc loop worker\n            DO y = 1, LOOPCOUNT\n              c(x * LOOPCOUNT + y) = (a(x * LOOPCOUNT + y) + b(x * LOOPCOUNT + y)) / totals(x + 1)\n            END DO\n          END DO\n        !$acc end data\n\n        DO x = 0, 9\n          temp = 1\n          DO y = 1, LOOPCOUNT\n            temp = temp * (a(x * LOOPCOUNT + y) + b(x * LOOPCOUNT + y))\n          END DO\n          IF (abs(temp - totals(x + 1)) .gt. ((temp / 2) + (totals(x + 1) / 2)) * PRECISION) THEN\n            errors = errors + 1\n            WRITE(*, *) temp\n            WRITE(*, *) totals(x + 1)\n            WRITE(*, *) \" \"\n          END IF\n          DO y = 1, LOOPCOUNT\n            IF (abs(c(x * LOOPCOUNT + y) - ((a(x * LOOPCOUNT + y) + b(x * LOOPCOUNT + y)) / totals(x + 1))) .gt. c(x * LOOPCOUNT + y) * PRECISION) THEN\n              errors = errors + 1\n              WRITE(*, *) c(x * LOOPCOUNT + y)\n              WRITE(*, *) a(x * LOOPCOUNT + y) + b(x * LOOPCOUNT + y)\n              WRITE(*, *) \" \"\n            END IF\n          END DO\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "kernels",
                            "private",
                            "reduction",
                            "combined-constructs",
                            "loop"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "kernels_loop_reduction_multiply_loop.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:kernels,loop,reduction,combined-constructs,V:1.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(10 * n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(10 * n * sizeof(real_t));\n    real_t * c = (real_t *)malloc(10 * n * sizeof(real_t));\n    real_t * totals = (real_t *)malloc(10 * sizeof(real_t));\n    real_t temp;\n\n    for (int x = 0; x < n; ++x){\n        a[x] = (999.4 + rand() / (real_t)(RAND_MAX)) / 1000;\n        b[x] = (999.4 + rand() / (real_t)(RAND_MAX)) / 1000;\n        c[x] = 0.0;\n    }\n\n\n    #pragma acc data copyin(a[0:10*n], b[0:10*n]) copyout(c[0:10*n]) copy(totals[0:10])\n    {\n        #pragma acc kernels loop gang private(temp)\n        for (int x = 0; x < 10; ++x){\n            temp = 1;\n            #pragma acc loop worker reduction(*:temp)\n            for (int y = 0; y < n; ++y){\n                temp *= a[x * n + y] + b[x * n + y];\n            }\n            totals[x] = temp;\n            #pragma acc loop worker\n            for (int y = 0; y < n; ++y){\n                c[x * n + y] = (a[x * n + y] + b[x * n + y]) / totals[x];\n            }\n        }\n    }\n\n    for (int x = 0; x < 10; ++x){\n        temp = 1;\n        for (int y = 0; y < n; ++y){\n            temp *= a[x * n + y] + b[x * n + y];\n        }\n        if (fabs(temp - totals[x]) > (temp / 2 + totals[x] / 2) * PRECISION){\n            err += 1;\n        }\n        for (int y = 0; y < n; ++y){\n            if (fabs(c[x * n + y] - ((a[x * n + y] + b[x * n + y]) / totals[x])) > PRECISION){\n                err += 1;\n            }\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "kernels",
                            "loop",
                            "reduction",
                            "combined-constructs"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "kernels_loop_reduction_multiply_vector_loop.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:kernels,private,reduction,combined-constructs,loop,V:1.0-2.7\n      LOGICAL FUNCTION test1()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x, y !Iterators\n        REAL(8),DIMENSION(10 * LOOPCOUNT):: a, b !Data\n        REAL(8),DIMENSION(10) :: c\n        REAL(8) :: temp\n        INTEGER :: errors = 0\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(a)\n        CALL RANDOM_NUMBER(b)\n        a = (999.4 + a) / 1000\n        b = (999.4 + b) / 1000\n\n        !$acc data copyin(a(1:10*LOOPCOUNT), b(1:10*LOOPCOUNT)) copyout(c(1:10))\n          !$acc parallel loop private(temp)\n          DO x = 0, 9\n            temp = 1\n            !$acc loop vector reduction(*:temp)\n            DO y = 1, LOOPCOUNT\n              temp = temp * (a(x * LOOPCOUNT + y) + b(x * LOOPCOUNT + y))\n            END DO\n            c(x + 1) = temp\n          END DO\n        !$acc end data\n\n        DO x = 0, 9\n          temp = 1\n          DO y = 1, LOOPCOUNT\n            temp = temp * (a(x * LOOPCOUNT + y) + b(x * LOOPCOUNT + y))\n          END DO\n          IF (abs(temp - c(x + 1)) .gt. ((temp / 2) + (c(x + 1) / 2)) * PRECISION) THEN\n            errors = errors + 1\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "kernels",
                            "private",
                            "reduction",
                            "combined-constructs",
                            "loop"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "kernels_loop_reduction_multiply_vector_loop.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:kernels,loop,reduction,combined-constructs,V:1.0-2.7\nint test1(){\n    int err = 0;\n    int multiplicitive_n = 128;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(10 * multiplicitive_n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(10 * multiplicitive_n * sizeof(real_t));\n    real_t * c = (real_t *)malloc(10 * sizeof(real_t));\n    real_t temp;\n\n    for (int x = 0; x < 10 * multiplicitive_n; ++x){\n        a[x] = rand() / (real_t) RAND_MAX;\n        b[x] = rand() / (real_t) RAND_MAX;\n    }\n\n    #pragma acc data copyin(a[0:10*multiplicitive_n], b[0:10*multiplicitive_n]) copyout(c[0:10])\n    {\n        #pragma acc kernels loop private(temp)\n        for (int x = 0; x < 10; ++x){\n            temp = 1.0;\n            #pragma acc loop vector reduction(*:temp)\n            for (int y = 0; y < multiplicitive_n; ++y){\n                temp *= a[(x * multiplicitive_n) + y] + b[(x * multiplicitive_n) + y];\n            }\n            c[x] = temp;\n        }\n    }\n\n    for (int x = 0; x < 10; ++x){\n        for (int y = 0; y < multiplicitive_n; ++y){\n            c[x] /= a[(x * multiplicitive_n) + y] + b[(x * multiplicitive_n) + y];\n        }\n    }\n\n    for (int x = 0; x < 10; ++x){\n        if (fabs(c[x] - 1) > PRECISION * (4 * multiplicitive_n - 1)){\n            err = 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "kernels",
                            "loop",
                            "reduction",
                            "combined-constructs"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "kernels_loop_reduction_or_general.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:kernels,reduction,combined-constructs,loop,V:1.0-2.7\n      LOGICAL FUNCTION test1()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x !Iterators\n        LOGICAL,DIMENSION(LOOPCOUNT):: a !Data\n        LOGICAL :: results = .FALSE.\n        LOGICAL :: temp = .FALSE.\n        REAL(8) :: false_margin = exp(log(.5) / n)\n        REAL(8),DIMENSION(LOOPCOUNT):: random\n        INTEGER :: errors = 0\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(random)\n        DO x = 1, LOOPCOUNT\n          IF (random(x) > false_margin) THEN\n            a(x) = .TRUE.\n          ELSE\n            a(x) = .FALSE.\n          END IF\n        END DO\n\n        !$acc data copyin(a(1:LOOPCOUNT))\n          !$acc kernels loop reduction(.OR.:results)\n          DO x = 1, LOOPCOUNT\n            results = results .OR. a(x)\n          END DO\n        !$acc end data\n\n        DO x = 1, LOOPCOUNT\n          temp = temp .OR. a(x)\n        END DO\n        IF (temp .neqv. results) THEN\n          errors = errors + 1\n        END IF\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "kernels",
                            "reduction",
                            "combined-constructs",
                            "loop"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "kernels_loop_reduction_or_general.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:kernels,loop,reduction,combined-constructs,V:1.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    char * a = (char *)malloc(n * sizeof(char));\n    real_t false_margin = pow(exp(1), log(.5)/n);\n    char result = 0;\n    char found = 0;\n\n    for (int x = 0; x < n; ++x){\n        if(a[x] = rand() / (real_t)(RAND_MAX) > false_margin){\n            a[x] = 1;\n        }\n        else{\n            a[x] = 0;\n        }\n    }\n\n\n    #pragma acc data copyin(a[0:n])\n    {\n        #pragma acc kernels loop reduction(||:result)\n        for (int x = 0; x < n; ++x){\n            result = result || a[x];\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        if (a[x] == 1){\n            found = 1;\n        }\n    }\n    if (found != result){\n        err = 1;\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "kernels",
                            "loop",
                            "reduction",
                            "combined-constructs"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "kernels_loop_reduction_or_loop.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:kernels,private,reduction,combined-constructs,loop,V:1.0-2.7\n      LOGICAL FUNCTION test1()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x, y !Iterators\n        LOGICAL,DIMENSION(10*LOOPCOUNT):: a, a_copy !Data\n        LOGICAL,DIMENSION(10) :: results\n        LOGICAL :: temp = .FALSE.\n        REAL(8),DIMENSION(10 * LOOPCOUNT) :: random\n        REAL(8) :: false_margin = exp(log(.5) / n)\n        INTEGER :: errors = 0\n\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(random)\n\n        !Initilization\n        DO x = 1, 10 * LOOPCOUNT\n          IF (random(x) .gt. false_margin) THEN\n            a(x) = .TRUE.\n          ELSE\n            a(x) = .FALSE.\n          END IF\n          a_copy(x) = a(x)\n        END DO\n\n        DO x = 1, 10\n          results(x) = .FALSE.\n        END DO\n\n        !$acc data copy(a(1:10*LOOPCOUNT), results(1:10))\n          !$acc kernels loop gang private(temp)\n          DO x = 0, 9\n            temp = .FALSE.\n            !$acc loop worker reduction(.OR.:temp)\n            DO y = 1, LOOPCOUNT\n              temp = temp .OR. a(x * LOOPCOUNT + y)\n            END DO\n            results(x + 1) = temp\n            !$acc loop worker\n            DO y = 1, LOOPCOUNT\n              IF (results(x + 1) .eqv. .TRUE.) THEN\n                IF(a(x * LOOPCOUNT + y) .eqv. .TRUE.) THEN\n                  a(x * LOOPCOUNT + y) = .FALSE.\n                ELSE\n                  a(x * LOOPCOUNT + y) = .TRUE.\n                END IF\n              END IF\n            END DO\n          END DO\n        !$acc end data\n\n        DO x = 0, 9\n          temp = .FALSE.\n          DO y = 1, LOOPCOUNT\n            temp = temp .OR. a_copy(x * LOOPCOUNT + y)\n          END DO\n          IF (temp .neqv. results(x + 1)) THEN\n            errors = errors + 1\n          END IF\n          DO y = 1, LOOPCOUNT\n            IF (temp .eqv. .FALSE.) THEN\n              IF (a(x * LOOPCOUNT + y) .neqv. a_copy(x * LOOPCOUNT + y)) THEN\n                errors = errors + 1\n              END IF\n            ELSE\n              IF (a(x * LOOPCOUNT + y) .eqv. a_copy(x * LOOPCOUNT + y)) THEN\n                errors = errors + 1\n              END IF\n            END IF\n          END DO\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "kernels",
                            "private",
                            "reduction",
                            "combined-constructs",
                            "loop"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "kernels_loop_reduction_or_loop.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:kernels,loop,reduction,combined-constructs,V:1.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    char * a = (char *)malloc(10 * n * sizeof(char));\n    char * a_copy = (char *)malloc(10 * n * sizeof(char));\n    char * results = (char *)malloc(10 * sizeof(char));\n    char temp = 0;\n    real_t false_margin = pow(exp(1), log(.5)/n);\n\n    for (int x = 0; x < 10 * n; ++x){\n        if (rand() / (real_t)(RAND_MAX) > false_margin){\n            a[x] = 1;\n            a_copy[x] = 1;\n        }\n        else{\n            a[x] = 0;\n            a_copy[x] = 0;\n        }\n    }\n    #pragma acc data copy(a[0:10*n])\n    {\n        #pragma acc kernels loop gang private(temp)\n        for (int x = 0; x < 10; ++x){\n            temp = 0;\n            #pragma acc loop worker reduction(||:temp)\n            for (int y = 0; y < n; ++y){\n                temp = temp || a[x * n + y];\n            }\n            results[x] = temp;\n            #pragma acc loop worker\n            for (int y = 0; y < n; ++y){\n                if(results[x] == 1){\n                    if (a[x * n + y] == 1){\n                        a[x * n + y] = 0;\n                    }\n                    else{\n                        a[x * n + y] = 1;\n                    }\n                }\n            }\n        }\n    }\n    for (int x = 0; x < 10; ++x){\n        temp = 0;\n        for (int y = 0; y < n; ++y){\n            temp = temp || a_copy[x * n + y];\n        }\n        if (temp != results[x]) {\n            err += 1;\n        }\n        for (int y = 0; y < n; ++y){\n            if (temp == 1){\n                if (a[x * n + y] == a_copy[x * n + y]){\n                    err += 1;\n                }\n            }\n            else {\n                if (a[x * n + y] != a_copy[x * n + y]){\n                    err += 1;\n                }\n            }\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "kernels",
                            "loop",
                            "reduction",
                            "combined-constructs"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "kernels_loop_reduction_or_vector_loop.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:kernels,private,reduction,combined-constructs,loop,V:1.0-2.7\n      LOGICAL FUNCTION test1()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x, y !Iterators\n        LOGICAL,DIMENSION(10*LOOPCOUNT):: a !Data\n        LOGICAL,DIMENSION(10) :: b\n        LOGICAL :: temp\n        REAL(8),DIMENSION(10*LOOPCOUNT):: randoms\n        REAL(8) :: false_margin = exp(log(.5) / 2)\n        INTEGER :: errors = 0\n\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(randoms)\n\n        !Initilization\n        DO x = 1, 10 * LOOPCOUNT\n          IF (randoms(x) > false_margin) THEN\n            a(x) = .TRUE.\n          ELSE\n            a(x) = .FALSE.\n          END IF\n        END DO\n\n        !$acc data copyin(a(1:10*LOOPCOUNT)), copy(b(1:10))\n          !$acc kernels loop private(temp)\n          DO x = 0, 9\n            temp = .FALSE.\n            !$acc loop vector reduction(.OR.:temp)\n            DO y = 1, LOOPCOUNT\n              temp = temp .OR. a(x * LOOPCOUNT + y)\n            END DO\n            b(x + 1) = temp\n          END DO\n        !$acc end data\n\n        DO x = 0, 9\n          temp = .FALSE.\n          DO y = 1, LOOPCOUNT\n            temp = temp .OR. a(x * LOOPCOUNT + y)\n          END DO\n          IF (temp .neqv. b(x + 1)) THEN\n            errors = errors + 1\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "kernels",
                            "private",
                            "reduction",
                            "combined-constructs",
                            "loop"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "kernels_loop_reduction_or_vector_loop.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:kernels,loop,reduction,combined-constructs,V:1.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    char * a = (char *)malloc(10 * n * sizeof(char));\n    char * b = (char *)malloc(10 * sizeof(char));\n    real_t false_margin = pow(exp(1), log(.5)/n);\n    char temp = 0;\n    char found;\n\n    for (int x = 0; x < 10 * n; ++x){\n        if(rand() / (real_t)(RAND_MAX) > false_margin){\n            a[x] = 1;\n        }\n        else{\n            a[x] = 0;\n        }\n    }\n    #pragma acc data copyin(a[0:10*n]) copy(b[0:10])\n    {\n        #pragma acc kernels loop private(temp)\n        for (int x = 0; x < 10; ++x){\n            temp = 0;\n            #pragma acc loop vector reduction(||:temp)\n            for (int y = 0; y < n; ++y){\n                temp = temp || a[x * n + y];\n            }\n            b[x] = temp;\n        }\n    }\n    for (int x = 0; x < 10; ++x){\n        found = 0;\n        for (int y = 0; y < n; ++y){\n            if (a[x * n + y] &! 0){\n                found = 1;\n            }\n        }\n        if (found != b[x]){\n            err = 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "kernels",
                            "loop",
                            "reduction",
                            "combined-constructs"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "kernels_loop_seq.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:kernels,combined-constructs,loop,V:1.0-2.7\n      LOGICAL FUNCTION test1()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT):: a, b !Data\n        INTEGER :: errors = 0\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(a)\n        b = 0\n\n        !$acc data copyin(a(1:LOOPCOUNT)) copy(b(1:LOOPCOUNT))\n          !$acc kernels loop seq\n          DO x = 2, LOOPCOUNT\n            b(x) = b(x - 1) + a(x)\n          END DO\n        !$acc end data\n\n        DO x = 2, LOOPCOUNT\n          IF (abs(b(x) - (b(x - 1) + a(x))) .gt. PRECISION) THEN\n            errors = errors + 1\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "kernels",
                            "combined-constructs",
                            "loop"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "kernels_loop_seq.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:kernels,loop,combined-constructs,V:1.0-2.7\nint test1(){\n  int err = 0;\n  srand(SEED);\n  real_t * a = (real_t *)malloc(n * sizeof(real_t));\n  real_t * b = (real_t *)malloc(n * sizeof(real_t));\n  real_t temp = 0.0;\n\n  for (int x = 0; x < n; ++x){\n      a[x] = rand() / (real_t)(RAND_MAX / 10);\n      b[x] = 0.0;\n  }\n\n  #pragma acc data copyin(a[0:n]) copy(b[0:n])\n  {\n      #pragma acc kernels loop seq\n      for (int x = 1; x < n; ++x){\n          b[x] = b[x-1] + a[x];\n      }\n  }\n\n  for (int x = 1; x < n; ++x){\n      temp += a[x];\n      if (fabs(b[x] - temp) > PRECISION){\n          err = 1;\n      }\n  }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "kernels",
                            "loop",
                            "combined-constructs"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "kernels_loop_tile.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:kernels,reduction,combined-constructs,loop,tile,V:2.0-2.7\n      LOGICAL FUNCTION test1()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x, y, z !Iterators\n        REAL(8),DIMENSION(SMALL_LOOPCOUNT):: a, b, c !Data\n        REAL(8),DIMENSION(SMALL_LOOPCOUNT,SMALL_LOOPCOUNT)::d\n        REAL(8) :: temp\n        INTEGER :: errors = 0\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(a)\n        CALL RANDOM_NUMBER(b)\n        CALL RANDOM_NUMBER(c)\n\n        !$acc data copyin(a(1:SMALL_LOOPCOUNT), b(1:SMALL_LOOPCOUNT), c(1:SMALL_LOOPCOUNT)) copyout(d(1:SMALL_LOOPCOUNT,1:SMALL_LOOPCOUNT))\n          !$acc kernels loop tile(*, *) reduction(+:temp)\n          DO x = 1, SMALL_LOOPCOUNT\n            DO y = 1, SMALL_LOOPCOUNT\n              temp = 0\n              DO z = 1, SMALL_LOOPCOUNT\n                temp = temp + a(z) + b(z) + c(z)\n              END DO\n              d(x,y) = temp\n            END DO\n          END DO\n        !$acc end data\n\n        DO x = 1, SMALL_LOOPCOUNT\n          DO y = 1, SMALL_LOOPCOUNT\n            temp = 0\n            DO z = 1, SMALL_LOOPCOUNT\n              temp = temp + a(z) + b(z) + c(z)\n            END DO\n            IF (abs(d(x,y) - temp) .gt. PRECISION) THEN\n              errors = errors + 1\n            END IF\n          END DO\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "kernels",
                            "reduction",
                            "combined-constructs",
                            "loop",
                            "tile"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "kernels_loop_tile.c": {
                "num tests": 2,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:kernels,loop,tile,reduction,combined-constructs,V:2.0-2.7\nint test1(){\n  int err = 0;\n  srand(SEED);\n  real_t * a = (real_t *)malloc(n * sizeof(real_t));\n  real_t * b = (real_t *)malloc(n * sizeof(real_t));\n  real_t * c = (real_t *)malloc(n * sizeof(real_t));\n  real_t * d2 = (real_t *)malloc(n * n * sizeof(real_t));\n  real_t * d3 = (real_t *)malloc(n * n * n * sizeof(real_t));\n  real_t temp = 0.0;\n\n  for (int x = 0; x < n; ++x){\n      a[x] = rand() / (real_t)(RAND_MAX / 10);\n      b[x] = rand() / (real_t)(RAND_MAX / 10);\n      c[x] = rand() / (real_t)(RAND_MAX / 10);\n  }\n  #pragma acc data copy(a[0:n], b[0:n], c[0:n], d2[0:n*n])\n  {\n      #pragma acc kernels loop tile(*, *) reduction(+:temp)\n      for (int x = 0; x < n; ++x){\n          for (int y = 0; y < n; ++y){\n              temp = 0;\n              for (int z = 0; z < n; ++z){\n                  temp += a[x] + b[y] + c[z];\n              }\n              d2[x * n + y] = temp;\n          }\n      }\n  }\n  for (int x = 0; x < n; ++x){\n      for (int y = 0; y < n; ++y){\n          temp = 0.0;\n          for (int z = 0; z < n; ++z){\n              temp += a[x] + b[y] + c[z];\n          }\n          if (fabs(temp - d2[x * n + y]) > PRECISION * n){\n              err += 1;\n          }\n      }\n  }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "kernels",
                            "loop",
                            "tile",
                            "reduction",
                            "combined-constructs"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "2": {
                        "content": "#ifndef T2\n//T2:kernels,loop,tile,combined-constructs,V:2.0-2.7\nint test2(){\n  int err = 0;\n  srand(SEED);\n  real_t * a = (real_t *)malloc(n * sizeof(real_t));\n  real_t * b = (real_t *)malloc(n * sizeof(real_t));\n  real_t * c = (real_t *)malloc(n * sizeof(real_t));\n  real_t * d2 = (real_t *)malloc(n * n * sizeof(real_t));\n  real_t * d3 = (real_t *)malloc(n * n * n * sizeof(real_t));\n  real_t temp = 0.0;\n\n  for (int x = 0; x < n; ++x){\n      a[x] = rand() / (real_t)(RAND_MAX / 10);\n      b[x] = rand() / (real_t)(RAND_MAX / 10);\n      c[x] = rand() / (real_t)(RAND_MAX / 10);\n  }\n\n  #pragma acc data copyin(a[0:n], b[0:n], c[0:n]) copyout(d3[0:n*n*n])\n  {\n      #pragma acc kernels loop tile(n/10, n, n*2)\n      for (int x = 0; x < n; ++x){\n          for (int y = 0; y < n; ++y){\n              for (int z = 0; z < n; ++z){\n                  d3[(n * n * x) + (n * y) + z] = a[x] + b[x] + c[x];\n              }\n          }\n      }\n  }\n\n  for (int x = 0; x < n; ++x){\n      for (int y = 0; y < n; ++y){\n          for (int z = 0; z < n; ++z){\n              if (fabs(d3[(n * n * x) + (n * y) + z] - a[x] - b[x] - c[x]) > PRECISION * 2){\n                  err = 1;\n              }\n          }\n      }\n  }\n\n    return err;\n}\n#endif\n#ifndef T2\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test2();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 1);\n    }\n#endif\n",
                        "tags": [
                            "kernels",
                            "loop",
                            "tile",
                            "combined-constructs"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "kernels_loop_vector_blocking.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:kernels,loop,V:1.0-2.7\n      LOGICAL FUNCTION test1()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT):: a, b, c !Data\n        REAL(8) :: multiplier\n        INTEGER :: errors = 0\n\n        multiplier = 1\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(a)\n        CALL RANDOM_NUMBER(b)\n        c = 0\n\n        !$acc data copyin(a(1:LOOPCOUNT), b(1:LOOPCOUNT)) copyout(c(1:LOOPCOUNT))\n          !$acc kernels\n            !$acc loop vector\n            DO x = 1, LOOPCOUNT\n              c(x) = (a(x) + b(x)) * multiplier\n            END DO\n            multiplier = multiplier + 1\n            !$acc loop vector\n            DO x = 1, LOOPCOUNT\n              c(x) = c(x) + ((a(x) + b(x)) * multiplier)\n            END DO\n          !$acc end kernels\n        !$acc end data\n\n        DO x = 1, LOOPCOUNT\n          IF (abs(c(x) - (3 * (a(x) + b(x)))) .gt. PRECISION) THEN\n            errors = errors + 1\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "kernels",
                            "loop"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "kernels_loop_vector_blocking.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:kernels,loop,V:1.0-2.7\nint test1(){\n  int err = 0;\n  srand(SEED);\n  real_t * a = (real_t *)malloc(n * sizeof(real_t));\n  real_t * b = (real_t *)malloc(n * sizeof(real_t));\n  real_t * c = (real_t *)malloc(n * sizeof(real_t));\n  real_t multiplyer = 1;\n\n  for (int x = 0; x < n; ++x){\n      a[x] = rand() / (real_t)(RAND_MAX / 10);\n      b[x] = rand() / (real_t)(RAND_MAX / 10);\n      c[x] = 0.0;\n  }\n\n  #pragma acc data copyin(a[0:n], b[0:n]) copyout(c[0:n])\n  {\n    #pragma acc kernels\n    {\n      #pragma acc loop vector\n      for (int x = 0; x < n; ++x){\n        c[x] = (a[x] + b[x]) * multiplyer;\n      }\n      multiplyer += 1;\n      #pragma acc loop vector\n      for (int x = 0; x < n; ++x){\n        c[x] += (a[x] + b[x]) * multiplyer;\n      }\n    }\n  }\n\n  for (int x = 0; x < n; ++x){\n    if (fabs(c[x] - 3 * (a[x] + b[x])) > PRECISION){\n      err + 1;\n      break;\n    }\n  }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "kernels",
                            "loop"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "kernels_loop_worker_blocking.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:kernels,loop,V:1.0-2.7\n      LOGICAL FUNCTION test1()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT):: a, b, c !Data\n        REAL(8) :: RAND\n        REAL(8) :: multiplier\n        INTEGER :: errors = 0\n\n        multiplier = 1\n\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(a)\n        CALL RANDOM_NUMBER(b)\n        c = 0\n\n        !$acc data copyin(a(1:LOOPCOUNT), b(1:LOOPCOUNT)) copyout(c(1:LOOPCOUNT))\n          !$acc kernels\n            !$acc loop worker\n            DO x = 1, LOOPCOUNT\n              c(x) = (a(x) + b(x)) * multiplier\n            END DO\n            multiplier = multiplier + 1\n            !$acc loop worker\n            DO x = 1, LOOPCOUNT\n              c(x) = c(x) + (a(x) + b(x)) * multiplier\n            END DO\n          !$acc end kernels\n        !$acc end data\n\n        DO x = 1, LOOPCOUNT\n          IF (abs(c(x) - (3 * (a(x) + b(x)))) .gt. PRECISION) THEN\n            errors = errors + 1\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "kernels",
                            "loop"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "kernels_loop_worker_blocking.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:kernels,loop,V:1.0-2.7\nint test1(){\n  int err = 0;\n  srand(SEED);\n  real_t * a = (real_t *)malloc(n * sizeof(real_t));\n  real_t * b = (real_t *)malloc(n * sizeof(real_t));\n  real_t * c = (real_t *)malloc(n * sizeof(real_t));\n  real_t multiplyer = 1;\n\n  for (int x = 0; x < n; ++x){\n      a[x] = rand() / (real_t)(RAND_MAX / 10);\n      b[x] = rand() / (real_t)(RAND_MAX / 10);\n      c[x] = 0.0;\n  }\n\n  #pragma acc data copyin(a[0:n], b[0:n]) copyout(c[0:n])\n  {\n    #pragma acc kernels\n    {\n      #pragma acc loop worker\n      for (int x = 0; x < n; ++x){\n        c[x] = (a[x] + b[x]) * multiplyer;\n      }\n      multiplyer += 1;\n      #pragma acc loop worker\n      for (int x = 0; x < n; ++x){\n        c[x] += (a[x] + b[x]) * multiplyer;\n      }\n    }\n  }\n\n  for (int x = 0; x < n; ++x){\n    if (fabs(c[x] - 3 * (a[x] + b[x])) > PRECISION){\n      err + 1;\n      break;\n    }\n  }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "kernels",
                            "loop"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "kernels_num_gangs.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:kernels,reduction,V:2.5-2.7\n      LOGICAL FUNCTION test1()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x !Iterators\n        INTEGER :: results !Data\n        INTEGER :: errors = 0\n\n        results = 0\n\n        !$acc kernels num_gangs(8)\n          !$acc loop gang reduction(+:results)\n          DO x = 1, LOOPCOUNT\n            results = 1\n          END DO\n        !$acc end kernels\n          \n        IF (results .ne. 8) THEN\n          errors = errors + 1\n        END IF\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "kernels",
                            "reduction"
                        ],
                        "versions": [
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "kernels_num_gangs.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:kernels,loop,V:2.5-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t * restrict a = (real_t *)malloc(n * sizeof(real_t));\n    real_t * restrict b = (real_t *)malloc(n * sizeof(real_t));\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = 0;\n    }\n\n    #pragma acc data copyin(a[0:n]) copyout(b[0:n])\n    {\n        #pragma acc kernels loop num_gangs(16)\n        for (int x = 0; x < n; ++x){\n            b[x] = a[x];\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        if (fabs(a[x] - b[x]) > PRECISION){\n            err += 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "kernels",
                            "loop"
                        ],
                        "versions": [
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "kernels_num_workers.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:kernels,V:2.5-2.7\n      LOGICAL FUNCTION test1()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT):: a, b !Data\n        INTEGER :: errors = 0\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(a)\n        b = 0\n\n        !$acc data copyin(a(1:LOOPCOUNT)) copyout(b(1:LOOPCOUNT))\n          !$acc kernels loop num_workers(16)\n          DO x = 1, LOOPCOUNT\n            b(x) = a(x)\n          END DO\n          !$acc end kernels\n        !$acc end data\n\n        DO x = 1, LOOPCOUNT\n          IF (abs(a(x) - b(x)) .gt. PRECISION) THEN\n            errors = errors + 1\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "kernels"
                        ],
                        "versions": [
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "kernels_num_workers.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:kernels,loop,V:2.5-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t * restrict a = (real_t *)malloc(n * sizeof(real_t));\n    real_t * restrict b = (real_t *)malloc(n * sizeof(real_t));\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = 0;\n    }\n\n    #pragma acc data copyin(a[0:n]) copyout(b[0:n])\n    {\n        #pragma acc kernels loop num_workers(16)\n        for (int x = 0; x < n; ++x){\n            b[x] = a[x];\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        if (fabs(a[x] - b[x]) > PRECISION){\n            err += 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "kernels",
                            "loop"
                        ],
                        "versions": [
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "kernels_present.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:kernels,V:2.0-2.7\n      LOGICAL FUNCTION test1()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT):: a, b !Data\n        INTEGER :: errors = 0\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(a)\n        b = 0\n\n        !$acc enter data copyin(a(1:LOOPCOUNT)) create(b(1:LOOPCOUNT))\n        !$acc kernels present(a(1:LOOPCOUNT), b(1:LOOPCOUNT))\n          !$acc loop\n          DO x = 1, LOOPCOUNT\n            b(x) = a(x)\n          END DO\n        !$acc end kernels\n        !$acc exit data delete(a(1:LOOPCOUNT)) copyout(b(1:LOOPCOUNT))\n\n        DO x = 1, LOOPCOUNT\n          IF (abs(a(x) - b(x)) .gt. PRECISION) THEN\n            errors = errors + 1\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "kernels"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "kernels_present.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:kernels,data,structured-data,V:2.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = 0.0;\n    }\n\n    #pragma acc enter data copyin(a[0:n]) create(b[0:n])\n    #pragma acc kernels present(a[0:n], b[0:n])\n    {\n        #pragma acc loop\n        for (int x = 0; x < n; ++x){\n            b[x] = a[x];\n        }\n    }\n    #pragma acc exit data copyout(b[0:n]) delete(a[0:n])\n\n    for (int x = 0; x < n; ++x){\n        if (fabs(b[x] - a[x]) > PRECISION){\n            err += 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "kernels",
                            "data",
                            "structured-data"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "kernels_scalar_default_copy.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:kernels,V:2.5-2.7\n      LOGICAL FUNCTION test1()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT):: a, b !Data\n        INTEGER :: errors = 0\n        REAL(8) :: total = 0.0\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(a)\n        CALL RANDOM_NUMBER(b)\n\n        DO x = 1, LOOPCOUNT\n          total = total + a(x)\n        END DO\n        !$acc data copyin(b(1:LOOPCOUNT))\n          !$acc kernels num_gangs(1) vector_length(1)\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              total = total + b(x)\n            END DO\n          !$acc end kernels\n        !$acc end data\n\n        DO x = 1, LOOPCOUNT\n          total = total - (a(x) + b(x))\n        END DO\n        IF (abs(total) .gt. (2 * LOOPCOUNT - 2) * PRECISION) THEN\n          errors = errors + 1\n        END IF\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "kernels"
                        ],
                        "versions": [
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "kernels_scalar_default_copy.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:kernels,data,data-region,default-mapping,V:2.5-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n    real_t sum = 0.0;\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n    }\n\n    for (int x = 0; x < n; ++x){\n        sum = sum + a[x];\n    }\n\n    #pragma acc data copyin(b[0:n])\n    {\n        #pragma acc kernels num_gangs(1) vector_length(1)\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                sum = sum + b[x];\n            }\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        sum = sum - (a[x] + b[x]);\n    }\n\n    if (fabs(sum) > (2 * n - 2) * PRECISION){\n        err += 1;\n        sum = 0.0;\n        for (int x = 0; x < n; ++x){\n            sum = sum + a[x];\n        }\n        sum = 0.0;\n        for (int x = 0; x < n; ++x){\n            sum = sum + b[x];\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "kernels",
                            "data",
                            "data-region",
                            "default-mapping"
                        ],
                        "versions": [
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "kernels_vector_length.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:kernels,V:2.5-2.7\n      LOGICAL FUNCTION test1()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT):: a, b !Data\n        INTEGER :: errors = 0\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(a)\n        b = 0\n\n        !$acc data copyin(a(1:LOOPCOUNT)) copyout(b(1:LOOPCOUNT))\n          !$acc kernels vector_length(16)\n            !$acc loop vector\n            DO x = 1, LOOPCOUNT\n              b(x) = a(x)\n            END DO\n          !$acc end kernels\n        !$acc end data\n\n        DO x = 1, LOOPCOUNT\n          IF (abs(a(x) - b(x)) .gt. PRECISION) THEN\n            errors = errors + 1\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "kernels"
                        ],
                        "versions": [
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "kernels_vector_length.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:kernels,V:2.5-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = 0;\n    }\n\n    #pragma acc data copyin(a[0:n]) copyout(b[0:n])\n    {\n        #pragma acc kernels vector_length(16)\n        {\n            #pragma acc loop vector\n            for (int x = 0; x < n; ++x){\n                b[x] = a[x];\n            }\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        if (fabs(a[x] - b[x]) > PRECISION) {\n            err += 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "kernels"
                        ],
                        "versions": [
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "kernels_wait.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:async,kernels,V:2.0-2.7\n      LOGICAL FUNCTION test1()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT):: a, b, c !Data\n        INTEGER :: errors = 0\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(a)\n        CALL RANDOM_NUMBER(b)\n        c = 0\n\n        !$acc enter data copyin(a(1:LOOPCOUNT), b(1:LOOPCOUNT), c(1:LOOPCOUNT)) async(1)\n        !$acc kernels wait(1)\n          !$acc loop\n          DO x = 1, LOOPCOUNT\n            c(x) = a(x) + b(x)\n          END DO\n        !$acc end kernels\n        !$acc exit data copyout(c(1:LOOPCOUNT)) delete(a(1:LOOPCOUNT), b(1:LOOPCOUNT))\n\n        DO x = 1, LOOPCOUNT\n          IF (abs(c(x) - (a(x) + b(x))) .gt. PRECISION) THEN\n            errors = errors + 1\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "async",
                            "kernels"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "kernels_wait.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:kernels,wait,V:2.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n    real_t * c = (real_t *)malloc(n * sizeof(real_t));\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n        c[x] = 0.0;\n    }\n\n    #pragma acc enter data copyin(a[0:n], b[0:n], c[0:n]) async(1)\n    #pragma acc kernels wait(1)\n    {\n        #pragma acc loop\n        for (int x = 0; x < n; ++x){\n            c[x] += a[x] + b[x];\n        }\n    }\n\n    #pragma acc exit data copyout(c[0:n]) delete(a[0:n], b[0:n])\n\n    for (int x = 0; x < n; ++x){\n        if (fabs(c[x] - (a[x] + b[x])) > PRECISION) {\n            err += 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "kernels",
                            "wait"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "loop_collapse.F90": {
                "num tests": 2,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:construct-independent,loop,V:1.0-2.7\n      LOGICAL FUNCTION test1()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x, y !Iterators\n        REAL(8),DIMENSION(10*LOOPCOUNT):: a, b, c !Data\n        REAL(8):: total\n        INTEGER :: errors = 0\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(a)\n        CALL RANDOM_NUMBER(b)\n        c = 0\n\n        DO x = 0, 9\n          c(x*LOOPCOUNT + 1) = a(x*LOOPCOUNT + 1) + b(x*LOOPCOUNT + 1)\n        END DO\n\n        !$acc data copyin(a(1:10*LOOPCOUNT), b(1:10*LOOPCOUNT)) copy(c(1:10*LOOPCOUNT))\n          !$acc parallel\n            !$acc loop independent\n            DO x = 0, 9\n              DO y = 2, LOOPCOUNT\n                c(x*LOOPCOUNT + y) = c(x*LOOPCOUNT + y - 1) + a(x*LOOPCOUNT + y) + b(x*LOOPCOUNT + y)\n              END DO\n            END DO\n          !$acc end parallel\n        !$acc end data\n        DO x = 0, 9\n          total = 0\n          DO y = 1, LOOPCOUNT\n            total = total + a(x * LOOPCOUNT + y) + b(x * LOOPCOUNT + y)\n            IF (abs(total - c(x * LOOPCOUNT + y)) .gt. PRECISION) THEN\n              errors = errors + 1\n            END IF\n          END DO\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "construct-independent",
                            "loop"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "2": {
                        "content": "#ifndef T2\n!T2:construct-independent,loop,V:1.0-2.7\n      LOGICAL FUNCTION test2()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x, y !Iterators\n        REAL(8),DIMENSION(10*LOOPCOUNT):: a, b, c !Data\n        REAL(8):: total\n        INTEGER :: errors = 0\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(a)\n        CALL RANDOM_NUMBER(b)\n        c = 0\n\n        !$acc data copyin(a(1:10*LOOPCOUNT), b(1:10*LOOPCOUNT)) copyout(c(1:10*LOOPCOUNT))\n          !$acc parallel\n            !$acc loop independent collapse(2)\n            DO x = 0, 9\n              DO y = 1, LOOPCOUNT\n                c(x*LOOPCOUNT + y) = a(x*LOOPCOUNT + y) + b(x*LOOPCOUNT + y)\n              END DO\n            END DO\n          !$acc end parallel\n        !$acc end data\n\n        DO x = 0, 9\n          DO y = 1, LOOPCOUNT\n            IF (abs(c(x*LOOPCOUNT+y) - (a(x*LOOPCOUNT+y)+b(x*LOOPCOUNT+y))) .gt. PRECISION) THEN\n              errors = errors + 1\n            END IF\n          END DO\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test2 = .FALSE.\n        ELSE\n          test2 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T2\n        LOGICAL :: test2\n#endif\n#ifndef T2\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test2()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 1\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "construct-independent",
                            "loop"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "loop_collapse.c": {
                "num tests": 2,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:loop,construct-independent,V:1.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(10 * n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(10 * n * sizeof(real_t));\n    real_t * c = (real_t *)malloc(10 * n * sizeof(real_t));\n\n    for (int x = 0; x < 10 * n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n        c[x] = 0;\n    }\n    for (int x = 0; x < 10; ++x){\n        c[x * n] = a[x * n] + b[x * n];\n    }\n\n    #pragma acc data copyin(a[0:10*n], b[0:10*n]) copy(c[0:10*n])\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop independent collapse(1)\n            for (int x = 0; x < 10; ++x){\n                for (int y = 1; y < n; ++y){\n                    c[x * n + y] = c[x * n + y - 1] + a[x * n + y] + b[x * n + y];\n                }\n            }\n        }\n    }\n\n    real_t total;\n    for (int x = 0; x < 10; ++x){\n        total = 0;\n        for (int y = 0; y < n; ++y){\n            total += a[x * n + y] + b[x * n + y];\n            if (fabs(c[x * n + y] - total) > PRECISION){\n                err += 1;\n            }\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "loop",
                            "construct-independent"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "2": {
                        "content": "#ifndef T2\n//T2:loop,syntactic,construct-independent,V:1.0-2.7\nint test2(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(10 * n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(10 * n * sizeof(real_t));\n    real_t * c = (real_t *)malloc(10 * n * sizeof(real_t));\n\n    for (int x = 0; x < 10 * n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n        c[x] = 0.0;\n    }\n\n    #pragma acc data copyin(a[0:10*n], b[0:10*n]) copyout(c[0:10*n])\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop independent collapse(2)\n            for (int x = 0; x < 10; ++x){\n                for (int y = 0; y < n; ++y){\n                    c[x * n + y] = a[x * n + y] + b[x * n + y];\n                }\n            }\n        }\n    }\n\n    for (int x = 0; x < 10 * n; ++x){\n        if (fabs(c[x] - (a[x] + b[x])) > PRECISION){\n            err += 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T2\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test2();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 1);\n    }\n#endif\n",
                        "tags": [
                            "loop",
                            "syntactic",
                            "construct-independent"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "loop_no_collapse.F90": {
                "num tests": 2,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:construct-independent,loop,V:1.0-2.7\n      LOGICAL FUNCTION test1()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x, y !Iterators\n        REAL(8),DIMENSION(10 * LOOPCOUNT):: a, b, c !Data\n        REAL(8):: total\n        INTEGER :: errors = 0\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(a)\n        CALL RANDOM_NUMBER(b)\n        c = 0\n\n        DO x = 0, 9\n          c(x * LOOPCOUNT + 1) = a(x * LOOPCOUNT + 1) + b(x * LOOPCOUNT + 1)\n        END DO\n\n        !$acc data copyin(a(1:10*LOOPCOUNT), b(1:10*LOOPCOUNT)) copy(c(1:10*LOOPCOUNT))\n          !$acc parallel\n            !$acc loop independent\n            DO x = 0, 9\n              DO y = 2, LOOPCOUNT\n                c(x * LOOPCOUNT + y) = c(x * LOOPCOUNT + y - 1) + a(x * LOOPCOUNT + y) + b(x * LOOPCOUNT + y)\n              END DO\n            END DO\n          !$acc end parallel\n        !$acc end data\n\n        DO x = 0, 9\n          total = 0\n          DO y = 1, LOOPCOUNT\n            total = total + a(x * LOOPCOUNT + y) + b(x * LOOPCOUNT + y)\n            IF (abs(total - c(x * LOOPCOUNT + y)) .gt. PRECISION) THEN\n              errors = errors + 1\n            END IF\n          END DO\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "construct-independent",
                            "loop"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "2": {
                        "content": "#ifndef T2\n!T2:construct-independent,loop,V:1.0-2.7\n      LOGICAL FUNCTION test2()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x, y !Iterators\n        REAL(8),DIMENSION(10 * LOOPCOUNT):: a, b, c !Data\n        REAL(8):: total\n        INTEGER :: errors = 0\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(a)\n        CALL RANDOM_NUMBER(b)\n        c = 0\n\n        DO x = 0, 9\n          c(x * LOOPCOUNT + 1) = a(x * LOOPCOUNT + 1) + b(x * LOOPCOUNT + 1)\n        END DO\n\n        !$acc data copyin(a(1:10*LOOPCOUNT), b(1:10*LOOPCOUNT)) copy(c(1:10*LOOPCOUNT))\n          !$acc kernels\n            !$acc loop independent\n            DO x = 0, 9\n              DO y = 2, LOOPCOUNT\n                c(x * LOOPCOUNT + y) = c(x * LOOPCOUNT + y - 1) + a(x * LOOPCOUNT + y) + b(x * LOOPCOUNT + y)\n              END DO\n            END DO\n          !$acc end kernels\n        !$acc end data\n\n        DO x = 0, 9\n          total = 0\n          DO y = 1, LOOPCOUNT\n            total = total + a(x * LOOPCOUNT + y) + b(x * LOOPCOUNT + y)\n            IF (abs(total - c(x * LOOPCOUNT + y)) .gt. PRECISION) THEN\n              errors = errors + 1\n            END IF\n          END DO\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test2 = .FALSE.\n        ELSE\n          test2 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T2\n        LOGICAL :: test2\n#endif\n#ifndef T2\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test2()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 1\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "construct-independent",
                            "loop"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "loop_no_collapse_default.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:loop,construct-independent,V:1.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(10 * n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(10 * n * sizeof(real_t));\n    real_t * c = (real_t *)malloc(10 * n * sizeof(real_t));\n    real_t total = 0;\n\n    for (int x = 0; x < 10 * n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n    }\n    for (int x = 0; x < 10; ++x){\n        c[x * n] = a[x * n] + b[x * n];\n    }\n\n    #pragma acc data copyin(a[0:10*n], b[0:10*n]) copy(c[0:10*n])\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop independent\n            for (int x = 0; x < 10; ++x){\n                for (int y = 1; y < n; ++y){\n                    c[x * n + y] = c[x * n + y - 1] + a[x * n + y] + b[x * n + y];\n                }\n            }\n        }\n    }\n    for (int x = 0; x < 10; ++x){\n        total = 0;\n        for (int y = 0; y < n; ++y){\n            total += a[x * n + y] + b[x * n +y];\n            if (fabs(total - c[x * n + y]) > PRECISION * y){\n                err += 1;\n            }\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "loop",
                            "construct-independent"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "parallel.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:parallel,V:1.0-2.7\n      LOGICAL FUNCTION test1()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x, i_a, i_b, i_c, i_d, i_e, i_f, i_g, i_h, i_i, i_j !Iterators\n        INTEGER, PARAMETER :: PRIVATE_LOOPCOUNT = 1024\n        REAL(8),DIMENSION(PRIVATE_LOOPCOUNT):: a, b, c !Data\n        INTEGER :: errors\n        errors = 0\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(a)\n        CALL RANDOM_NUMBER(b)\n        c = 0\n\n        !$acc data copyin(a(1:PRIVATE_LOOPCOUNT), b(1:PRIVATE_LOOPCOUNT)) copy(c(1:PRIVATE_LOOPCOUNT))\n          !$acc parallel\n            !$acc loop\n            DO i_a = 0, 1\n              !$acc loop\n              DO i_b = 0, 1\n                !$acc loop\n                DO i_c = 0, 1\n                  !$acc loop\n                  DO i_d = 0, 1\n                    !$acc loop\n                    DO i_e = 0, 1\n                      !$acc loop\n                      DO i_f = 0, 1\n                        !$acc loop\n                        DO i_g = 0, 1\n                          !$acc loop\n                          DO i_h = 0, 1\n                            !$acc loop\n                            DO i_i = 0, 1\n                              !$acc loop\n                              DO i_j = 0, 1\n                                c(i_a*512 + i_b*256 + i_c*128 + i_d*64 + i_e*32 + i_f*16 + i_g*8 + i_h*4 + i_i*2 + i_j + 1) = &\n                                a(i_a*512 + i_b*256 + i_c*128 + i_d*64 + i_e*32 + i_f*16 + i_g*8 + i_h*4 + i_i*2 + i_j + 1) + &\n                                b(i_a*512 + i_b*256 + i_c*128 + i_d*64 + i_e*32 + i_f*16 + i_g*8 + i_h*4 + i_i*2 + i_j + 1)\n                              END DO\n                            END DO\n                          END DO\n                        END DO\n                      END DO\n                    END DO\n                  END DO\n                END DO\n              END DO\n            END DO\n          !$acc end parallel\n        !$acc end data\n        DO x = 1, PRIVATE_LOOPCOUNT\n          IF (abs(c(x) - (a(x) + b(x))) .gt. PRECISION) THEN\n            errors = errors + 1\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "parallel"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "parallel.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:parallel,V:1.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t* a = (real_t *) malloc(1024 * sizeof(real_t));\n    real_t* b = (real_t *) malloc(1024 * sizeof(real_t));\n    real_t* c = (real_t *) malloc(1024 * sizeof(real_t));\n\n    for(int x = 0; x < 1024; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n        c[x] = 0.0;\n    }\n\n    #pragma acc data copyin(a[0:1024], b[0:1024]) copy(c[0:1024])\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int _0 = 0; _0 < 2; ++_0){\n                #pragma acc loop\n                for (int _1 = 0; _1 < 2; ++_1){\n                    #pragma acc loop\n                    for (int _2 = 0; _2 < 2; ++_2){\n                        #pragma acc loop\n                        for (int _3 = 0; _3 < 2; ++_3){\n                            #pragma acc loop\n                            for (int _4 = 0; _4 < 2; ++_4){\n                                #pragma acc loop\n                                for (int _5 = 0; _5 < 2; ++_5){\n                                    #pragma acc loop\n                                    for (int _6 = 0; _6 < 2; ++_6){\n                                        #pragma acc loop\n                                        for (int _7 = 0; _7 < 2; ++_7){\n                                            #pragma acc loop\n                                            for (int _8 = 0; _8 < 2; ++_8){\n                                                #pragma acc loop\n                                                for (int _9 = 0; _9 < 2; ++_9){\n                                                    c[_0*512 + _1*256 + _2*128 + _3*64 + _4*32 + _5*16 + _6*8+ _7*4 + _8*2 + _9] =\n                                                    a[_0*512 + _1*256 + _2*128 + _3*64 + _4*32 + _5*16 + _6*8+ _7*4 + _8*2 + _9] +\n                                                    b[_0*512 + _1*256 + _2*128 + _3*64 + _4*32 + _5*16 + _6*8+ _7*4 + _8*2 + _9];\n                                                }\n                                            }\n                                        }\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    for (int x = 0; x < 1024; ++x){\n        if(fabs(c[x] - (a[x] +b[x])) > PRECISION){\n            err = 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "parallel"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "parallel_async.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:async,parallel,update,V:2.0-2.7\n      LOGICAL FUNCTION test1()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x, y, z !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT):: a, b, c, d, e, f, g !Data\n        INTEGER :: errors = 0\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(a)\n        CALL RANDOM_NUMBER(b)\n        c = 0\n        CALL RANDOM_NUMBER(d)\n        CALL RANDOM_NUMBER(e)\n        f = 0\n        g = 0\n        \n        !$acc data copyin(a(1:LOOPCOUNT), b(1:LOOPCOUNT), d(1:LOOPCOUNT), e(1:LOOPCOUNT), c(1:LOOPCOUNT), f(1:LOOPCOUNT), g(1:LOOPCOUNT))\n          !$acc parallel async(1)\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              c(x) = a(x) + b(x)\n            END DO\n          !$acc end parallel\n          !$acc parallel async(2)\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              f(x) = d(x) + e(x)\n            END DO\n          !$acc end parallel\n          !$acc update host(c(1:LOOPCOUNT)) wait(1) async(4)\n          !$acc update host(f(1:LOOPCOUNT)) wait(2) async(5)\n          !$acc parallel wait(1, 2) async(3)\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              g(x) = c(x) + f(x)\n            END DO\n          !$acc end parallel\n          !$acc update host(g(1:LOOPCOUNT)) async(3)\n        !$acc end data\n        !$acc wait\n        DO x = 1, LOOPCOUNT\n          IF (abs(c(x) - (a(x) + b(x))) .gt. PRECISION) THEN\n            errors = errors + 1\n          ELSE IF (abs(f(x) - (d(x) + e(x))) .gt. PRECISION) THEN\n            errors = errors + 1\n          ELSE IF (abs(g(x) - (f(x) + c(x))) .gt. PRECISION) THEN\n            errors = errors + 1\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "async",
                            "parallel",
                            "update"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "parallel_async.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:parallel,async,wait,V:2.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n    real_t * c = (real_t *)malloc(n * sizeof(real_t));\n    real_t * d = (real_t *)malloc(n * sizeof(real_t));\n    real_t * e = (real_t *)malloc(n * sizeof(real_t));\n    real_t * f = (real_t *)malloc(n * sizeof(real_t));\n    real_t * g = (real_t *)malloc(n * sizeof(real_t));\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n        c[x] = 0.0;\n        d[x] = rand() / (real_t)(RAND_MAX / 10);\n        e[x] = rand() / (real_t)(RAND_MAX / 10);\n        f[x] = 0.0;\n        g[x] = 0.0;\n    }\n\n    #pragma acc data copyin(a[0:n], b[0:n], d[0:n], e[0:n], c[0:n], f[0:n], g[0:n])\n    {\n        #pragma acc parallel async(1)\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                c[x] = a[x] + b[x];\n            }\n        }\n        #pragma acc parallel async(2)\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                f[x] = d[x] + e[x];\n            }\n        }\n        #pragma acc parallel wait(1, 2) async(3)\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                g[x] = c[x] + f[x];\n            }\n        }\n        #pragma acc update host(c[0:n]) async(1)\n        #pragma acc update host(f[0:n]) async(2)\n        #pragma acc update host(g[0:n]) async(3)\n\n        #pragma acc wait(1)\n        for (int x = 0; x < n; ++x){\n            if (fabs(c[x] - (a[x] + b[x])) > PRECISION){\n                err += 1;\n            }\n        }\n        #pragma acc wait(2)\n        for (int x = 0; x < n; ++x){\n            if (fabs(f[x] - (d[x] + e[x])) > PRECISION){\n                err += 1;\n            }\n        }\n        #pragma acc wait(3)\n        for (int x = 0; x < n; ++x){\n            if (fabs(g[x] - (a[x] + b[x] + d[x] + e[x])) > PRECISION){\n                err += 1;\n            }\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "parallel",
                            "async",
                            "wait"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "parallel_copy.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:parallel,V:1.0-2.7\n      LOGICAL FUNCTION test1()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT):: a, a_host !Data\n        INTEGER :: errors = 0\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(a)\n        a_host = a\n\n        !$acc parallel copy(a(1:LOOPCOUNT))\n          !$acc loop\n          DO x = 1, LOOPCOUNT\n            a(x) = 2 * a(x)\n          END DO \n        !$acc end parallel\n    \n\n        DO x = 1, LOOPCOUNT\n          IF (abs(a_host(x) - (a(x) / 2)) .gt. PRECISION) THEN\n            errors = errors + 1\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "parallel"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "parallel_copy.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:parallel,data,data-region,V:1.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(n * sizeof(real_t));\n    real_t * a_host = (real_t *)malloc(n * sizeof(real_t));\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        a_host[x] = a[x];\n    }\n\n    #pragma acc parallel copy(a[0:n])\n    {\n        #pragma acc loop\n        for (int x = 0; x < n; ++x){\n            a[x] = 2 * a[x];\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        if (fabs(a[x] - (2 * a_host[x])) > PRECISION){\n            err = 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "parallel",
                            "data",
                            "data-region"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "parallel_copyin.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:parallel,V:2.0-2.7\n      LOGICAL FUNCTION test1()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT):: a, a_copy, b !Data\n        INTEGER :: errors = 0\n        INTEGER,DIMENSION(1):: hasDevice\n        hasDevice(1) = 1\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(a)\n        a_copy = a\n        b = 0\n\n        !$acc enter data copyin(hasDevice(1:1))\n        !$acc parallel present(hasDevice(1:1))\n          hasDevice(1) = 0\n        !$acc end parallel\n\n\n        !$acc parallel copyin(a(1:LOOPCOUNT))\n          !$acc loop\n          DO x = 1, LOOPCOUNT\n            a(x) = 0.0\n          END DO\n\n        !$acc end parallel\n\n        DO x = 1, LOOPCOUNT\n          IF ((abs(a(x) - a_copy(x)) > PRECISION .AND. hasDevice(1) .eq. 1) .OR. (hasDevice(1) .eq. 0 .AND. abs(a(x)) > PRECISION)) THEN\n            errors = errors + 1\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "parallel"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "parallel_copyin.c": {
                "num tests": 2,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:parallel,data,data-region,V:2.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(n * sizeof(real_t));\n    real_t * a_copy = (real_t *)malloc(n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n    int* hasDevice = (int *) malloc(sizeof(int));\n    hasDevice[0] = 1;\n    #pragma acc enter data copyin(hasDevice[0:1])\n    #pragma acc parallel present(hasDevice[0:1])\n    {\n      hasDevice[0] = 0;\n    }\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        a_copy[x] = a[x];\n        b[x] = 0.0;\n    }\n\n    #pragma acc parallel copyin(a[0:n])\n    {\n        #pragma acc loop\n        for (int x = 0; x < n; ++x){\n            a[x] = 0.0;\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        if (((fabs(a[x] - a_copy[x]) > PRECISION) && (hasDevice[0] == 1)) || ((hasDevice[0] == 0) && (fabs(a[x]) > PRECISION))){\n            err = 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "parallel",
                            "data",
                            "data-region"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "2": {
                        "content": "#ifndef T2\n//T2:parallel,data,data-region,V:1.0-2.7\nint test2(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(n * sizeof(real_t));\n    real_t * a_copy = (real_t *)malloc(n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n    }\n\n    #pragma acc data copy(b[0:n])\n    {\n        #pragma acc parallel copyin(a[0:n])\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                b[x] = a[x];\n            }\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        if (fabs(a[x] - b[x]) > PRECISION){\n            err = 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T2\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test2();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 1);\n    }\n#endif\n",
                        "tags": [
                            "parallel",
                            "data",
                            "data-region"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "parallel_copyout.F90": {
                "num tests": 3,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:parallel,V:2.0-2.7\n      LOGICAL FUNCTION test1()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT):: a, b !Data\n        INTEGER :: errors = 0\n        INTEGER,DIMENSION(1):: hasDevice\n        hasDevice(1) = 1\n        !$acc enter data copyin(hasDevice(1:1))\n        !$acc parallel present(hasDevice(1:1))\n          hasDevice(1) = 0\n        !$acc end parallel\n\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(a)\n        b = 0\n\n        !$acc data copyin(a(1:LOOPCOUNT))\n          !$acc parallel copyout(b(1:LOOPCOUNT))\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              b(x) = a(x)\n            END DO\n          !$acc end parallel\n        !$acc end data\n\n        DO x = 1, LOOPCOUNT\n          IF (abs(a(x) - b(x)) .gt. PRECISION) THEN\n            errors = errors + 1\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "parallel"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "2": {
                        "content": "#ifndef T2\n!T2:parallel,V:2.0-2.7\n      LOGICAL FUNCTION test2()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT):: a, b !Data\n        INTEGER :: errors = 0\n        INTEGER,DIMENSION(1):: hasDevice\n        hasDevice(1) = 1\n        !$acc enter data copyin(hasDevice(1:1))\n        !$acc parallel present(hasDevice(1:1))\n          hasDevice(1) = 0\n        !$acc end parallel\n\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(a)\n        b = a\n        IF (hasDevice(1) .eq. 1) THEN\n          !$acc data copyin(a(1:LOOPCOUNT), b(1:LOOPCOUNT))\n            !$acc parallel copyout(b(1:LOOPCOUNT))\n              !$acc loop\n              DO x = 1, LOOPCOUNT\n                b(x) = b(x) - a(x)\n              END DO\n            !$acc end parallel\n          !$acc end data\n\n          DO x = 1, LOOPCOUNT\n            IF (abs(a(x) - b(x)) .gt. PRECISION) THEN\n              errors = errors + 1\n            END IF\n          END DO\n        END IF\n\n        IF (errors .eq. 0) THEN\n          test2 = .FALSE.\n        ELSE\n          test2 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T2\n        LOGICAL :: test2\n#endif\n#ifndef T2\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test2()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 1\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "parallel"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "3": {
                        "content": "#ifndef T3\n!T3:parallel,update,V:2.0-2.7\n      LOGICAL FUNCTION test3()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT):: a, b !Data\n        INTEGER :: errors = 0\n        INTEGER,DIMENSION(1):: hasDevice\n        hasDevice(1) = 1\n        !$acc enter data copyin(hasDevice(1:1))\n        !$acc parallel present(hasDevice(1:1))\n          hasDevice(1) = 0\n        !$acc end parallel\n\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(a)\n        b = a\n\n        !$acc data copyin(a(1:LOOPCOUNT), b(1:LOOPCOUNT))\n          !$acc parallel copyout(b(1:LOOPCOUNT))\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              b(x) = b(x) - a(x)\n            END DO\n          !$acc end parallel\n          !$acc update host(b(1:LOOPCOUNT))\n        !$acc end data\n\n        DO x = 1, LOOPCOUNT\n          IF (abs(b(x)) > 2 * PRECISION) THEN\n            errors = errors + 1\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test3 = .FALSE.\n        ELSE\n          test3 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T3\n        LOGICAL :: test3\n#endif\n#ifndef T3\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test3()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 2\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "parallel",
                            "update"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "parallel_copyout.c": {
                "num tests": 3,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:parallel,data,data-region,V:1.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n\n    real_t * a = (real_t *)malloc(n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = 0.0;\n    }\n\n    #pragma acc data copyin(a[0:n])\n    {\n        #pragma acc parallel copyout(b[0:n])\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                b[x] = a[x];\n            }\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        if (fabs(a[x] - b[x]) > PRECISION){\n            err += 1;\n            break;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "parallel",
                            "data",
                            "data-region"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "2": {
                        "content": "#ifndef T2\n//T2:parallel,data,data-region,devonly,V:2.0-2.7\nint test2(){\n    int err = 0;\n    srand(SEED);\n\n    real_t * a = (real_t *)malloc(n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n\n    int* hasDevice = (int *) malloc(sizeof(int));\n    hasDevice[0] = 1;\n    #pragma acc enter data copyin(hasDevice[0:1])\n    #pragma acc parallel present(hasDevice[0:1])\n    {\n      hasDevice[0] = 0;\n    }\n\n    if (hasDevice[0] == 1){\n        for (int x = 0; x < n; ++x){\n            a[x] = rand() / (real_t)(RAND_MAX / 10);\n            b[x] = a[x];\n        }\n\n        #pragma acc data copyin(a[0:n], b[0:n])\n        {\n            #pragma acc parallel copyout(b[0:n])\n            {\n                #pragma acc loop\n                for (int x = 0; x < n; ++x){\n                    b[x] = b[x] - a[x];\n                }\n            }\n        }\n        for (int x = 0; x < n; ++x){\n          if (fabs(a[x] - b[x]) > PRECISION){\n            err += 2;\n            break;\n          }\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T2\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test2();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 1);\n    }\n#endif\n",
                        "tags": [
                            "parallel",
                            "data",
                            "data-region",
                            "devonly"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "3": {
                        "content": "#ifndef T3\n//T3:parallel,data,data-region,V:1.0-2.7\nint test3(){\n    int err = 0;\n    srand(SEED);\n\n    real_t * a = (real_t *)malloc(n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = a[x];\n    }\n\n    #pragma acc data copyin(a[0:n], b[0:n])\n    {\n        #pragma acc parallel copyout(b[0:n])\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                b[x] = b[x] - a[x];\n            }\n        }\n        #pragma acc update host(b[0:n])\n    }\n\n    for (int x = 0; x < n; ++x){\n        if (fabs(b[x]) > 2 * PRECISION){\n            err += 4;\n            break;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T3\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test3();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 2);\n    }\n#endif\n",
                        "tags": [
                            "parallel",
                            "data",
                            "data-region"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "parallel_create.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:parallel,V:1.0-2.7\n      LOGICAL FUNCTION test1()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT):: a, b, c !Data\n        INTEGER :: errors = 0\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(a)\n        b = 0\n        c = 0\n\n        !$acc data copyin(a(1:LOOPCOUNT)) copy(c(1:LOOPCOUNT))\n          !$acc parallel create(b(1:LOOPCOUNT))\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              b(x) = a(x)\n            END DO\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              c(x) = b(x)\n            END DO\n          !$acc end parallel\n        !$acc end data\n        DO x = 1, LOOPCOUNT\n          IF (abs(a(x) - c(x)) .gt. PRECISION) THEN\n            errors = errors + 1\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "parallel"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "parallel_create.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:parallel,data,data-region,V:1.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n    real_t * c = (real_t *)malloc(n * sizeof(real_t));\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = 0.0;\n        c[x] = 0.0;\n    }\n\n    #pragma acc data copyin(a[0:n]) copy(c[0:n])\n    {\n        #pragma acc parallel create(b[0:n])\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                b[x] = a[x];\n            }\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                c[x] = b[x];\n            }\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        if (fabs(a[x] - c[x]) > PRECISION){\n            err = 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "parallel",
                            "data",
                            "data-region"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "parallel_default_copy.F90": {
                "num tests": 2,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:devonly,parallel,V:2.0-2.7\n      LOGICAL FUNCTION test1()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT):: a, b, c !Data\n        INTEGER :: errors = 0\n        LOGICAL,DIMENSION(1):: devtest\n        devtest(1) = .TRUE.\n\n        !$acc enter data copyin(devtest(1:1))\n        !$acc parallel\n          devtest(1) = .FALSE.\n        !$acc end parallel\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(a)\n        CALL RANDOM_NUMBER(b)\n        c = 0\n\n        !$acc data copyin(a(1:LOOPCOUNT), b(1:LOOPCOUNT))\n          !$acc parallel\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              c(x) = c(x) + a(x) + b(x)\n            END DO\n          !$acc end parallel\n        !$acc end data\n        DO x = 1, LOOPCOUNT\n          IF (abs(c(x) - (a(x) + b(x))) .gt. PRECISION) THEN\n            errors = errors + 1\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "devonly",
                            "parallel"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "2": {
                        "content": "#ifndef T2\n!T2:devonly,parallel,V:2.0-2.7\n      LOGICAL FUNCTION test2()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT):: a, b, c !Data\n        INTEGER :: errors = 0\n        LOGICAL,DIMENSION(1):: devtest\n        devtest(1) = .TRUE.\n\n        !$acc enter data copyin(devtest(1:1))\n        !$acc parallel\n          devtest(1) = .FALSE.\n        !$acc end parallel\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        IF (devtest(1)) THEN\n          CALL RANDOM_NUMBER(a)\n          CALL RANDOM_NUMBER(b)\n          c = 1\n\n          !$acc enter data copyin(c(1:LOOPCOUNT))\n          c = 0\n          !$acc data copyin(a(1:LOOPCOUNT), b(1:LOOPCOUNT))\n            !$acc parallel\n              !$acc loop\n              DO x = 1, LOOPCOUNT\n                c(x) = c(x) + a(x) + b(x)\n              END DO\n            !$acc end parallel\n          !$acc end data\n          DO x = 1, LOOPCOUNT\n            IF (abs(c(x)) .gt. PRECISION) THEN\n              errors = errors + 1\n            END IF\n          END DO\n          !$acc exit data copyout(c(1:LOOPCOUNT))\n          DO x = 1, LOOPCOUNT\n            IF (abs(c(x) - (a(x) + b(x) + 1)) .gt. PRECISION) THEN\n              errors = errors + 1\n            END IF\n          END DO\n        END IF\n\n        IF (errors .eq. 0) THEN\n          test2 = .FALSE.\n        ELSE\n          test2 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T2\n        LOGICAL :: test2\n#endif\n#ifndef T2\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test2()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 1\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "devonly",
                            "parallel"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "parallel_default_copy.c": {
                "num tests": 2,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:parallel,data,data-region,default-mapping,V:1.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n    real_t c[n];\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n        c[x] = 0.0;\n    }\n\n    #pragma acc data copyin(a[0:n], b[0:n])\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                c[x] += a[x] + b[x];\n            }\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        if (fabs(c[x] - (a[x] + b[x])) > PRECISION){\n            err += 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "parallel",
                            "data",
                            "data-region",
                            "default-mapping"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "2": {
                        "content": "#ifndef T2\n//T2:parallel,data,data-region,default-mapping,V:2.0-2.7\nint test2(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n    real_t c[n];\n    int * devtest = (int *)malloc(sizeof(real_t));\n\n    devtest[0] = 1;\n    #pragma acc enter data copyin(devtest[0:1])\n    #pragma acc parallel present(devtest[0:1])\n    {\n        devtest[0] = 0;\n    }\n\n    if (devtest[0] == 1){\n        for (int x = 0; x < n; ++x){\n            a[x] = rand() / (real_t)(RAND_MAX / 10);\n            b[x] = rand() / (real_t)(RAND_MAX / 10);\n            c[x] = 1;\n        }\n\n        #pragma acc enter data copyin(c[0:n])\n        for (int x = 0; x < n; ++x){\n            c[x] = 0.0;\n        }\n        #pragma acc data copyin(a[0:n], b[0:n])\n        {\n            #pragma acc parallel\n            {\n                #pragma acc loop\n                for (int x = 0; x < n; ++x){\n                    c[x] += a[x] + b[x];\n                }\n            }\n        }\n\n        for (int x = 0; x < n; ++x){\n            if (fabs(c[x]) > PRECISION){\n                err += 1;\n            }\n        }\n\n        #pragma acc exit data copyout(c[0:n])\n\n        for (int x = 0; x < n; ++x){\n            if (fabs(c[x] - (a[x] + b[x] + 1)) > PRECISION){\n                err += 1;\n            }\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T2\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test2();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 1);\n    }\n#endif\n",
                        "tags": [
                            "parallel",
                            "data",
                            "data-region",
                            "default-mapping"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "parallel_default_present.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:parallel,default,V:2.5-2.7\n      LOGICAL FUNCTION test1()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT):: a !Data\n        INTEGER :: errors = 0\n\n        a = 0\n\n        !$acc data copy(a(1:LOOPCOUNT))\n          !$acc parallel default(present)\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              a(x) = 1.0\n            END DO\n          !$acc end parallel\n        !$acc end data\n\n        DO x = 1, LOOPCOUNT\n          IF (abs(a(x) - 1) .gt. PRECISION) THEN\n            errors = errors + 1\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "parallel",
                            "default"
                        ],
                        "versions": [
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "parallel_default_present.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:parallel,default,data,data-region,V:2.5-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(n * sizeof(real_t));\n\n    for (int x = 0; x < n; ++x){\n        a[x] = 0.0;\n    }\n    #pragma acc enter data copyin(a[0:n])\n    #pragma acc parallel default(present)\n    {\n        #pragma acc loop\n        for (int x = 0; x < n; ++x){\n            a[x] = 1.0;\n        }\n    }\n    #pragma acc exit data copyout(a[0:n])\n\n    for (int x = 0; x < n; ++x){\n        if (fabs(a[x] - 1.0) > PRECISION){\n            err = 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "parallel",
                            "default",
                            "data",
                            "data-region"
                        ],
                        "versions": [
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "parallel_deviceptr.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:parallel,runtime,V:2.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(n * sizeof(real_t));\n    real_t * b;\n\n    for (int x = 0; x < n; ++x){\n        a[x] = 0;\n    }\n\n    #pragma acc enter data copyin(a[0:n])\n    b = (real_t *) acc_deviceptr(a);\n    if (b == NULL){\n        err = 1;\n    }\n    else{\n        #pragma acc parallel deviceptr(b)\n        {\n            #pragma acc loop\n            for (int x = 0; x < (int) n/2; ++x){\n                b[x] = 1;\n            }\n        }\n        #pragma acc exit data copyout(a[0:n])\n    }\n    for (int x = 0; x < n; ++x){\n        if (x < (int) n/2){\n            if (fabs(a[x] - 1) > PRECISION){\n                err = 1;\n            }\n        }\n        else {\n            if (fabs(a[x]) > PRECISION){\n                err = 1;\n            }\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "parallel",
                            "runtime"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "parallel_firstprivate.F90": {
                "num tests": 2,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:parallel,firstprivate,V:1.0-2.7\n      LOGICAL FUNCTION test1()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x, y !Iterators\n        REAL(8),DIMENSION(10 * LOOPCOUNT):: a, b, d !Data\n        REAL(8),DIMENSION(LOOPCOUNT):: c, c_copy\n        REAL*8 :: RAND\n        INTEGER :: errors = 0\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(a)\n        CALL RANDOM_NUMBER(b)\n        CALL RANDOM_NUMBER(c)\n        c_copy = c\n        d = 0\n        \n        !$acc data copyin(a(1:10*LOOPCOUNT), b(1:10*LOOPCOUNT)) copy(d(1:10*LOOPCOUNT))\n          !$acc parallel firstprivate(c(1:LOOPCOUNT))\n            !$acc loop gang\n            DO x = 0, 9\n              !$acc loop worker\n              DO y = 1, LOOPCOUNT\n                d(x * LOOPCOUNT + y) = a(x * LOOPCOUNT + y) + b(x * LOOPCOUNT + y) + c(y)\n              END DO\n            END DO\n          !$acc end parallel\n        !$acc end data\n\n        DO x = 0, 9\n          DO y = 1, LOOPCOUNT\n            IF (abs(d(x * LOOPCOUNT + y) - (a(x * LOOPCOUNT + y) + b(x * LOOPCOUNT + y) + c(y))) .gt. PRECISION) THEN\n              errors = errors + 1\n            END IF\n          END DO\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "parallel",
                            "firstprivate"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "2": {
                        "content": "#ifndef T2\n!T2:parallel,firstprivate,V:1.0-2.7\n      LOGICAL FUNCTION test2()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x, y !Iterators\n        REAL(8),DIMENSION(10 * LOOPCOUNT):: a, b, d !Data\n        REAL(8),DIMENSION(LOOPCOUNT):: c, c_copy\n        REAL*8 :: RAND\n        INTEGER :: errors = 0\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(a)\n        CALL RANDOM_NUMBER(b)\n        c = 0\n        d = 0\n        \n        !$acc data copyin(a(1:10*LOOPCOUNT), b(1:10*LOOPCOUNT)) copy(d(1:10*LOOPCOUNT))\n          !$acc parallel firstprivate(c(1:LOOPCOUNT))\n            !$acc loop gang independent\n            DO x = 0, 9\n              !$acc loop worker independent\n              DO y = 1, LOOPCOUNT\n                c(y) = a(x * LOOPCOUNT + y) - b(x * LOOPCOUNT + y)\n              END DO\n              !$acc loop worker independent\n              DO y = 1, LOOPCOUNT\n                d(x * LOOPCOUNT + y) = a(x * LOOPCOUNT + y) + b(x * LOOPCOUNT + y) + c(y)\n              END DO\n            END DO\n          !$acc end parallel\n        !$acc end data\n\n        DO x = 1, 10 * LOOPCOUNT\n          IF (abs(d(x) - (2 * a(x))) .gt. PRECISION) THEN\n            errors = errors + 1\n          END IF\n        END DO       \n\n        IF (errors .eq. 0) THEN\n          test2 = .FALSE.\n        ELSE\n          test2 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T2\n        LOGICAL :: test2\n#endif\n#ifndef T2\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test2()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 1\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "parallel",
                            "firstprivate"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "parallel_firstprivate.c": {
                "num tests": 2,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:parallel,firstprivate,V:1.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(10 * n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(10 * n * sizeof(real_t));\n    real_t * c = (real_t *)malloc(n * sizeof(real_t));\n    real_t * c_copy = (real_t *)malloc(n * sizeof(real_t));\n    real_t * d = (real_t *)malloc(10 * n * sizeof(real_t));\n\n    for (int x = 0; x < 10*n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n        d[x] = 0.0;\n    }\n    for (int x = 0; x < n; ++x){\n        c[x] = rand() / (real_t)(RAND_MAX / 10);\n        c_copy[x] = c[x];\n    }\n    #pragma acc data copyin(a[0:10*n], b[0:10*n]) copy(d[0:10*n])\n    {\n        #pragma acc parallel firstprivate(c[0:n])\n        {\n            #pragma acc loop gang\n            for (int x = 0; x < 10; ++x){\n                #pragma acc loop worker\n                for (int y = 0; y < n; ++y){\n                    d[x * n + y] = a[x * n + y] + b[x * n + y] + c[y];\n                }\n            }\n        }\n    }\n\n    for (int x = 0; x < 10; ++x){\n        for (int y = 0; y < n; ++y){\n            if (fabs(d[x * n + y] - (a[x * n + y] + b[x * n + y] + c_copy[y])) > PRECISION){\n                err += 1;\n            }\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "parallel",
                            "firstprivate"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "2": {
                        "content": "#ifndef T2\n//T2:parallel,firstprivate,V:1.0-2.7\nint test2(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(10 * n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(10 * n * sizeof(real_t));\n    real_t * c = (real_t *)malloc(n * sizeof(real_t));\n    real_t * c_copy = (real_t *)malloc(n * sizeof(real_t));\n    real_t * d = (real_t *)malloc(10 * n * sizeof(real_t));\n\n    for (int x = 0; x < 10*n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n        d[x] = 0.0;\n    }\n    for (int x = 0; x < n; ++x){\n        c[x] = 0.0;\n    }\n\n    #pragma acc data copyin(a[0:10*n], b[0:10*n]) copy(d[0:10*n])\n    {\n        #pragma acc parallel firstprivate(c[0:n])\n        {\n            #pragma acc loop gang independent\n            for (int x = 0; x < 10; ++x){\n                #pragma acc loop worker independent\n                for (int y = 0; y < n; ++y){\n                    c[y] = a[x * n + y] - b[x * n + y];\n                }\n                #pragma acc loop worker independent\n                for (int y = 0; y < n; ++y){\n                    d[x * n + y] = a[x * n + y] + b[x * n + y] + c[y];\n                }\n            }\n        }\n    }\n\n    for (int x = 0; x < 10 * n; ++x){\n        if (fabs(d[x] - 2 * a[x]) > PRECISION){\n            err += 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T2\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test2();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 1);\n    }\n#endif\n",
                        "tags": [
                            "parallel",
                            "firstprivate"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "parallel_if.F90": {
                "num tests": 3,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:devonly,parallel,if,V:2.0-2.7\n      LOGICAL FUNCTION test1()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT):: a, b, c !Data\n        INTEGER :: errors = 0\n        LOGICAL :: host = .FALSE.\n        LOGICAL :: device = .TRUE.\n        INTEGER,DIMENSION(1) :: dev_test\n        dev_test(1) = 0\n\n        !$acc enter data copyin(dev_test(1:1))\n        !$acc parallel present(dev_test(1:1))\n          dev_test(1) = 1\n        !$acc end parallel\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(a)\n        CALL RANDOM_NUMBER(b)\n        c = 0\n\n        !$acc parallel if(host)\n          !$acc loop\n          DO x = 1, LOOPCOUNT\n            c(x) = a(x) + b(x)\n          END DO\n        !$acc end parallel\n\n        DO x = 1, LOOPCOUNT\n          IF (abs(c(x) - (a(x) + b(x))) .gt. PRECISION) THEN\n            errors = errors + 1\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "devonly",
                            "parallel",
                            "if"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "2": {
                        "content": "#ifndef T2\n!T2:devonly,parallel,if,V:2.0-2.7\n      LOGICAL FUNCTION test2()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT):: a, b, c !Data\n        INTEGER :: errors = 0\n        LOGICAL :: host = .FALSE.\n        LOGICAL :: device = .TRUE.\n        INTEGER,DIMENSION(1) :: dev_test\n        dev_test(1) = 0\n\n        !$acc enter data copyin(dev_test(1:1))\n        !$acc parallel present(dev_test(1:1))\n          dev_test(1) = 1\n        !$acc end parallel\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        IF (dev_test(1) .eq. 0) THEN\n          CALL RANDOM_NUMBER(a)\n          CALL RANDOM_NUMBER(b)\n          c = a + b\n\n          !$acc enter data copyin(a(1:LOOPCOUNT), b(1:LOOPCOUNT), c(1:LOOPCOUNT))\n          !$acc parallel if(host) present(a(1:LOOPCOUNT), b(1:LOOPCOUNT), c(1:LOOPCOUNT))\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              c(x) = c(x) + a(x) + b(x)\n            END DO\n          !$acc end parallel\n          !$acc exit data delete(a(1:LOOPCOUNT), b(1:LOOPCOUNT)) copyout(c(1:LOOPCOUNT))\n\n          DO x = 1, LOOPCOUNT\n            IF (abs(c(x) - (a(x) + b(x))) .gt. PRECISION) THEN\n              errors = errors + 1\n            END IF\n          END DO\n        END IF\n\n        IF (errors .eq. 0) THEN\n          test2 = .FALSE.\n        ELSE\n          test2 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T2\n        LOGICAL :: test2\n#endif\n#ifndef T2\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test2()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 1\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "devonly",
                            "parallel",
                            "if"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "3": {
                        "content": "#ifndef T3\n!T3:devonly,parallel,if,V:2.0-2.7\n      LOGICAL FUNCTION test3()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT):: a, b, c !Data\n        INTEGER :: errors = 0\n        LOGICAL :: host = .FALSE.\n        LOGICAL :: device = .TRUE.\n        INTEGER,DIMENSION(1) :: dev_test\n        dev_test(1) = 0\n\n        !$acc enter data copyin(dev_test(1:1))\n        !$acc parallel present(dev_test(1:1))\n          dev_test(1) = 1\n        !$acc end parallel\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(a)\n        CALL RANDOM_NUMBER(b)\n        c = a + b\n        !$acc enter data copyin(a(1:LOOPCOUNT), b(1:LOOPCOUNT), c(1:LOOPCOUNT))\n        !$acc parallel if(device) present(a(1:LOOPCOUNT), b(1:LOOPCOUNT), c(1:LOOPCOUNT))\n          !$acc loop\n          DO x = 1, LOOPCOUNT\n            c(x) = c(x) + a(x) + b(x)\n          END DO\n        !$acc end parallel\n        !$acc exit data delete(a(1:LOOPCOUNT), b(1:LOOPCOUNT)), copyout(c(1:LOOPCOUNT))\n\n        DO x = 1, LOOPCOUNT\n          IF (abs(c(x) - (2 * (a(x) + b(x)))) .gt. 2 * PRECISION) THEN\n            errors = errors + 1\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test3 = .FALSE.\n        ELSE\n          test3 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T3\n        LOGICAL :: test3\n#endif\n#ifndef T3\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test3()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 2\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "devonly",
                            "parallel",
                            "if"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "parallel_if.c": {
                "num tests": 3,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:parallel,if,V:1.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n    real_t * c = (real_t *)malloc(n * sizeof(real_t));\n    int accel = 1;\n    int host = 0;\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n        c[x] = 0.0;\n    }\n    #pragma acc parallel if(host)\n    {\n        #pragma acc loop\n        for (int x = 0; x < n; ++x){\n            c[x] = a[x] + b[x];\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        if (fabs(c[x] - (a[x] + b[x])) > PRECISION){\n            err = 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "parallel",
                            "if"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "2": {
                        "content": "#ifndef T2\n//T2:parallel,if,devonly,V:2.0-2.7\nint test2(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n    real_t * c = (real_t *)malloc(n * sizeof(real_t));\n    int * dev_test = (int *)malloc(sizeof(int));\n    int accel = 1;\n    int host = 0;\n\n    dev_test[0] = 1;\n    #pragma acc data copyin(dev_test[0:1])\n    #pragma acc parallel\n    {\n      dev_test[0] = 0;\n    }\n\n    if (devtest[0] != 0){\n        for (int x = 0; x < n;  ++x){\n            a[x] = rand() / (real_t)(RAND_MAX / 10);\n            b[x] = rand() / (real_t)(RAND_MAX / 10);\n            c[x] = 0;\n        }\n\n        #pragma acc enter data copyin(a[0:n], b[0:n], c[0:n])\n        #pragma acc parallel if(host) present(a[0:n], b[0:n], c[0:n])\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                c[x] += a[x] + b[x];\n            }\n        }\n        #pragma acc exit data delete(a[0:n], b[0:n]) copyout(c[0:n])\n\n        for (int x = 0; x < n; ++x){\n            if (fabs(c[x]) > PRECISION){\n                err = 1;\n            }\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T2\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test2();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 1);\n    }\n#endif\n",
                        "tags": [
                            "parallel",
                            "if",
                            "devonly"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "3": {
                        "content": "#ifndef T3\n//T3:parallel,if,V:2.0-2.7\nint test3(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n    real_t * c = (real_t *)malloc(n * sizeof(real_t));\n    int accel = 1;\n    int host = 0;\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n        c[x] = 0;\n    }\n\n    #pragma acc enter data copyin(a[0:n], b[0:n], c[0:n])\n\n    #pragma acc parallel if(accel) present(a[0:n], b[0:n], c[0:n])\n    {\n        #pragma acc loop\n        for (int x = 0; x < n; ++x){\n            c[x] += a[x] + b[x];\n        }\n    }\n\n    #pragma acc exit data delete(a[0:n], b[0:n]) copyout(c[0:n])\n\n    for (int x = 0; x < n; ++x){\n        if (fabs(c[x] - (a[x] + b[x])) > PRECISION * 2){\n            err = 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T3\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test3();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 2);\n    }\n#endif\n",
                        "tags": [
                            "parallel",
                            "if"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "parallel_loop.F90": {
                "num tests": 2,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:parallel,loop,V:1.0-2.7\n      LOGICAL FUNCTION test1()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT):: a, b, c !Data\n        INTEGER :: errors = 0\n\n        !Initilization\n        a = 0\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        !$acc data copy(a(1:LOOPCOUNT))\n          !$acc parallel loop\n          DO x = 1, LOOPCOUNT\n            a(x) = 1\n          END DO\n        !$acc end data\n\n        DO x = 1, LOOPCOUNT\n          IF (abs(a(x) - 1) .gt. PRECISION) THEN\n            errors = errors + 1\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "parallel",
                            "loop"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "2": {
                        "content": "#ifndef T2\n!T2:parallel,loop,V:1.0-2.7\n      LOGICAL FUNCTION test2()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT):: a, b, c !Data\n        INTEGER :: errors = 0\n\n        !Initilization\n        a = 0\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(b)\n        CALL RANDOM_NUMBER(c)\n\n        !$acc data copy(a(1:LOOPCOUNT), b(1:LOOPCOUNT), c(1:LOOPCOUNT))\n          !$acc parallel\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              a(x) = b(x)\n            END DO\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              a(x) = a(x) + c(x)\n            END DO\n          !$acc end parallel\n        !$acc end data\n\n        DO x = 1, LOOPCOUNT\n          IF (abs(a(x) - (b(x) + c(x))) .gt. PRECISION) THEN\n            errors = errors + 1\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test2 = .FALSE.\n        ELSE\n          test2 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T2\n        LOGICAL :: test2\n#endif\n#ifndef T2\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test2()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 1\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "parallel",
                            "loop"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "parallel_loop.c": {
                "num tests": 2,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:parallel,loop,combined-constructs,V:1.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n    real_t * c = (real_t *)malloc(n * sizeof(real_t));\n\n    for (int x = 0; x < n; ++x){\n        a[x] = 0;\n    }\n\n    #pragma acc data copy(a[0:n])\n    {\n        #pragma acc parallel loop\n        for (int x = 0; x < n; ++x){\n            a[x] = 1.0;\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        if (fabs(a[x] - 1.0) > PRECISION){\n            err = 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "parallel",
                            "loop",
                            "combined-constructs"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "2": {
                        "content": "#ifndef T2\n//T2:parallel,loop,V:1.0-2.7\nint test2(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n    real_t * c = (real_t *)malloc(n * sizeof(real_t));\n\n    for (int x = 0; x < n; ++x){\n      a[x] = 0.0;\n      b[x] = rand() / (real_t)(RAND_MAX / 10);\n      c[x] = rand() / (real_t)(RAND_MAX / 10);\n    }\n    #pragma acc data copy(a[0:n], b[0:n], c[0:n])\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                a[x] = b[x];\n            }\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                a[x] += c[x];\n            }\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        if (fabs(a[x] - (b[x] + c[x])) > PRECISION * 2){\n            err = 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T2\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test2();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 1);\n    }\n#endif\n",
                        "tags": [
                            "parallel",
                            "loop"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "parallel_loop_async.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:async,parallel,reduction,combined-constructs,loop,V:1.0-2.7\n      LOGICAL FUNCTION test1()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x, y !Iterators\n        REAL(8),DIMENSION(10 * LOOPCOUNT):: a, b, c, d !Data\n\t\t\t\tINTEGER,DIMENSION(10):: errors_array\n        INTEGER :: errors\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(a)\n        CALL RANDOM_NUMBER(b)\n        c = 0\n        d = a + b\n\t\t\t\terrors = 0\n\n        !$acc data copyin(a(1:10*LOOPCOUNT), b(1:10*LOOPCOUNT), c(1:10*LOOPCOUNT), d(1:10*LOOPCOUNT)) copy(errors(1:10))\n          DO x = 0, 9\n            !$acc parallel loop async(x)\n            DO y = 1, LOOPCOUNT\n              c(x * LOOPCOUNT + y) = a(x * LOOPCOUNT + y) + b(x * LOOPCOUNT + y)\n            END DO\n            !$acc parallel loop async(x) reduction(+:errors(x))\n            DO y = 1, LOOPCOUNT\n              IF (c(x * LOOPCOUNT + y) - d(x * LOOPCOUNT + y) .gt. PRECISION .OR. d(x * LOOPCOUNT + y) - c(x * LOOPCOUNT + y) .gt. PRECISION) THEN\n                errors_array(x) = errors_array(x) + 1\n              END IF\n            END DO\n          END DO\n\t\t\t\t\t!$acc wait\n        !$acc end data\n\n\t\t\t\tDO x = 1, 10\n\t\t\t\t\terrors = errors + errors_array(x)\n\t\t\t\tEND DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "async",
                            "parallel",
                            "reduction",
                            "combined-constructs",
                            "loop"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "parallel_loop_async.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:parallel,loop,async,combined-constructs,V:1.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(10 * n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(10 * n * sizeof(real_t));\n    real_t * c = (real_t *)malloc(10 * n * sizeof(real_t));\n    real_t * d = (real_t *)malloc(10 * n * sizeof(real_t));\n\t\tint * errors = (int *)malloc(10 * sizeof(int));\n\n\t\tfor (int x = 0; x < 10; ++x){\n\t\t\terrors[x] = 0;\n\t\t}\n\n    for (int x = 0; x < 10 * n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n        c[x] = 0.0;\n        d[x] = a[x] + b[x];\n    }\n\n    #pragma acc data copyin(a[0:10*n], b[0:10*n], c[0:10*n], d[0:10*n]) copy(errors[0:10])\n    {\n        for (int x = 0; x < 10; ++x){\n            #pragma acc parallel loop async(x)\n            for (int y = 0; y < n; ++y){\n                c[x * n + y] = a[x * n + y] + b[x * n + y];\n            }\n            #pragma acc parallel loop async(x) reduction(+:errors[x])\n            for (int y = 0; y < n; ++y){\n                if(c[x * n + y] - d[x * n + y] > PRECISION || d[x * n + y] - c[x * n + y] > PRECISION){\n                    errors[x] += 1;\n                }\n            }\n        }\n\t\t\t\t#pragma acc wait\n    }\n\n    for (int x = 0; x < 10; ++x){\n        err += errors[x];\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "parallel",
                            "loop",
                            "async",
                            "combined-constructs"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "parallel_loop_auto.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:parallel,combined-constructs,loop,auto,V:2.0-2.7\n      LOGICAL FUNCTION test1()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT):: a, a_copy, b !Data\n        REAL(8) :: temp\n        INTEGER :: errors = 0\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(a)\n        a_copy = a\n        b = 0\n\n        !$acc data copyin(a(1:LOOPCOUNT)) copyout(b(1:LOOPCOUNT))\n          !$acc parallel loop auto\n          DO x = 1, LOOPCOUNT\n            b(x) = a(x)\n          END DO\n        !$acc end data\n\n        DO x = 1, LOOPCOUNT\n          IF (abs(a(x) - b(x)) .gt. PRECISION) THEN\n            errors = errors + 1\n          END IF\n        END DO\n\n        !$acc data copy(a(1:LOOPCOUNT))\n          !$acc parallel loop auto\n          DO x = 2, LOOPCOUNT\n            a(x) = a(x - 1) + a(x)\n          END DO\n        !$acc end data\n\n        temp = 0\n        DO x = 1, LOOPCOUNT\n          temp = temp + a_copy(x)\n          IF (abs(temp - a(x)) .gt. PRECISION) THEN\n            errors = errors + 1\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "parallel",
                            "combined-constructs",
                            "loop",
                            "auto"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "parallel_loop_auto.c": {
                "num tests": 2,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:parallel,loop,combined-constructs,syntactic,V:2.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(n * sizeof(real_t));\n    real_t * a_copy = (real_t *)malloc(n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = 0;\n    }\n\n    #pragma acc data copyin(a[0:n]) copyout(b[0:n])\n    {\n      #pragma acc parallel loop auto\n      for (int x = 0; x < n; ++x){\n        b[x] = a[x];\n      }\n    }\n\n    for (int x = 0; x < n; ++x){\n      if (fabs(b[x] - a[x]) > PRECISION){\n        err = 1;\n      }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "parallel",
                            "loop",
                            "combined-constructs",
                            "syntactic"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "2": {
                        "content": "#ifndef T2\n//T2:parallel,loop,combined-constructs,V:2.0-2.7\nint test2(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(n * sizeof(real_t));\n    real_t * a_copy = (real_t *)malloc(n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        a_copy[x] = a[x];\n    }\n\n    #pragma acc data copy(a[0:n])\n    {\n      #pragma acc parallel loop auto\n      for (int x = 1; x < n; ++x){\n        a[x] = a[x - 1] + a[x];\n      }\n    }\n\n    real_t rolling_total = 0.0;\n    for (int x = 0; x < n; ++x){\n      rolling_total += a_copy[x];\n      if (fabs(rolling_total - a[x]) > PRECISION){\n        err = 1;\n      }\n    }\n\n    return err;\n}\n#endif\n#ifndef T2\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test2();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 1);\n    }\n#endif\n",
                        "tags": [
                            "parallel",
                            "loop",
                            "combined-constructs"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "parallel_loop_gang.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:parallel,combined-constructs,loop,V:1.0-2.7\n      LOGICAL FUNCTION test1()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT):: a, b, c !Data\n        INTEGER :: errors = 0\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(a)\n        CALL RANDOM_NUMBER(b)\n        c = 0\n\n        !$acc data copyin(a(1:LOOPCOUNT), b(1:LOOPCOUNT)) copy(c(1:LOOPCOUNT))\n          !$acc parallel loop gang\n          DO x = 1, LOOPCOUNT\n            c(x) = a(x) + b(x)\n          END DO\n        !$acc end data\n\n        DO x = 1, LOOPCOUNT\n          IF (abs(c(x) - (a(x) + b(x))) .gt. PRECISION) THEN\n            errors = errors + 1\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "parallel",
                            "combined-constructs",
                            "loop"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "parallel_loop_gang.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:parallel,loop,combined-constructs,V:1.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n    real_t * c = (real_t *)malloc(n * sizeof(real_t));\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n        c[x] = 0.0;\n    }\n\n    #pragma acc data copyin(a[0:n], b[0:n]) copy(c[0:n])\n    {\n        #pragma acc parallel loop gang\n        for (int x = 0; x < n; ++x){\n            c[x] = a[x] + b[x];\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        if (fabs(c[x] - (a[x] + b[x])) > PRECISION){\n            err = 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "parallel",
                            "loop",
                            "combined-constructs"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "parallel_loop_reduction_add_general.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:parallel,reduction,combined-constructs,loop,V:1.0-2.7\n      LOGICAL FUNCTION test1()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT):: a, b !Data\n        REAL(8) :: total\n        INTEGER :: errors = 0\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(a)\n        CALL RANDOM_NUMBER(b)\n        total = 0\n        !$acc data copyin(a(1:LOOPCOUNT), b(1:LOOPCOUNT)) copy(total)\n          !$acc parallel loop reduction(+:total)\n          DO x = 1, LOOPCOUNT\n            total = total + a(x) + b(x)\n          END DO\n        !$acc end data\n        DO x = 1, LOOPCOUNT\n          total = total - (a(x) + b(x))\n        END DO\n        IF (abs(total) .gt. LOOPCOUNT * PRECISION) THEN\n          WRITE(*, *) total\n          errors = 1\n        END IF\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "parallel",
                            "reduction",
                            "combined-constructs",
                            "loop"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "parallel_loop_reduction_add_general.c": {
                "num tests": 2,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:parallel,loop,reduction,combined-constructs,V:1.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n    real_t total;\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n    }\n\n    total = 10;\n    #pragma acc data copyin(a[0:n], b[0:n]) copy(total)\n    {\n        #pragma acc parallel loop reduction(+:total)\n        for (int x = 0; x < n; ++x){\n            total += a[x] + b[x];\n        }\n    }\n    for (int x = 0; x < n; ++x){\n        total -= a[x] + b[x];\n    }\n    if (fabs(total - 10) > PRECISION * (2 * n - 1)){ //199 = # of mathematical operations necessary\n        err = 1;\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "parallel",
                            "loop",
                            "reduction",
                            "combined-constructs"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "2": {
                        "content": "#ifndef T2\n//T2:parallel,loop,reduction,combined-constructs,V:2.7-2.7\nint test2(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(n * 10 * sizeof(real_t));\n    real_t * b = (real_t *)malloc(n * 10 * sizeof(real_t));\n    real_t c[10];\n    real_t c_host[10];\n\n    for (int x = 0; x < 10 * n; ++x) {\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n    }\n\n    for (int x = 0; x < 10; ++x) {\n        c[x] = 1.0;\n        c_host[x] = 1.0;\n    }\n\n    #pragma acc data copyin(a[0:10*n], b[0:10*n])\n    {\n        #pragma acc parallel loop reduction(+:c[0:10])\n        for (int x = 0; x < n; ++x) {\n            for (int y = 0; y < 10; ++y) {\n                c[y] += a[x * 10 + y] + b[x * 10 + y];\n            }\n        }\n    }\n\n    for (int x = 0; x < n; ++x) {\n        for (int y = 0; y < 10; ++y) {\n            c_host[y] += a[x * 10 + y] + b[x * 10 + y];\n        }\n    }\n\n    for (int x = 0; x < 10; ++x) {\n        if (fabs(c_host[x] - c[x]) > PRECISION) {\n            err += 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T2\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test2();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 1);\n    }\n#endif\n",
                        "tags": [
                            "parallel",
                            "loop",
                            "reduction",
                            "combined-constructs"
                        ],
                        "versions": [
                            "2.7"
                        ]
                    }
                }
            },
            "parallel_loop_reduction_add_general_type_check_pt1.c": {
                "num tests": 8,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:parallel,reduction,combined-constructs,loop,V:1.0-2.7\nint test1() {\n    int err = 0;\n    srand(SEED);\n    _Bool* a = (_Bool*)malloc(n * sizeof(_Bool));\n    _Bool* b = (_Bool*)malloc(n * sizeof(_Bool));\n    _Bool total = 1;\n    _Bool host_total = 1;\n\n    for (int x = 0; x < n; ++x) {\n        if ((rand()/((real_t) RAND_MAX)) > .5) {\n            a[x] = 1;\n        }\n        else {\n            a[x] = 0;\n        }\n        if ((rand()/((real_t) RAND_MAX)) > .5) {\n            b[x] = 1;\n        }\n        else {\n            b[x] = 0;\n        }\n    }\n    \n    #pragma acc data copyin(a[0:n], b[0:n])\n    {\n        #pragma acc parallel loop reduction(+:total)\n        for (int x = 0; x < n; ++x) {\n            total += a[x] + b[x];\n        }\n    }\n    \n\n    for (int x = 0; x < n; ++x) {\n        host_total += a[x] + b[x];\n    }\n\n    if (total != host_total) {\n        err += 1;\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x) {\n        failed = failed + test1();\n    }\n    if (failed != 0) {\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "parallel",
                            "reduction",
                            "combined-constructs",
                            "loop"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "2": {
                        "content": "#ifndef T2\n//T2:parallel,reduction,combined-constructs,loop,V:1.0-2.7\nint test2(){\n    int err = 0;\n    srand(SEED);\n    char * a = (char *)malloc(n * sizeof(char));\n    char * b = (char *)malloc(n * sizeof(char));\n    char total = 10;\n    char host_total = 10;\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(UCHAR_MAX / 10);\n        b[x] = rand() / (real_t)(UCHAR_MAX / 10);\n    }\n\n    #pragma acc data copyin(a[0:n], b[0:n])\n    {\n        #pragma acc parallel loop reduction(+:total)\n        for (int x = 0; x < n; ++x) {\n            total += a[x] + b[x];\n        }\n    }\n\n    for (int x = 0; x < n; ++x) {\n        host_total += a[x] + b[x];\n    }\n\n    if (host_total != total) {\n        err += 1;\n    }\n\n    return err;\n}\n#endif\n#ifndef T2\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test2();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 1);\n    }\n#endif\n",
                        "tags": [
                            "parallel",
                            "reduction",
                            "combined-constructs",
                            "loop"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "3": {
                        "content": "#ifndef T3\n//T3:parallel,reduction,combined-constructs,loop,V:1.0-2.7\nint test3(){\n    int err = 0;\n    srand(SEED);\n    signed char * a = (signed char *)malloc(n * sizeof(signed char));\n    signed char * b = (signed char *)malloc(n * sizeof(signed char));\n    signed char total = 10;\n    signed char host_total = 10;\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n    }\n\n    #pragma acc data copyin(a[0:n], b[0:n])\n    {\n        #pragma acc parallel loop reduction(+:total)\n        for (int x = 0; x < n; ++x) {\n            total += a[x] + b[x];\n        }\n    }\n\n    for (int x = 0; x < n; ++x) {\n        host_total += a[x] + b[x];\n    }\n\n    if (host_total != total) {\n        err += 1;\n    }\n\n    return err;\n}\n#endif\n#ifndef T3\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test3();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 2);\n    }\n#endif\n",
                        "tags": [
                            "parallel",
                            "reduction",
                            "combined-constructs",
                            "loop"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "4": {
                        "content": "#ifndef T4\n//T4:parallel,reduction,combined-constructs,loop,V:1.0-2.7\nint test4(){\n    int err = 0;\n    srand(SEED);\n    unsigned char * a = (unsigned char *)malloc(n * sizeof(unsigned char));\n    unsigned char * b = (unsigned char *)malloc(n * sizeof(unsigned char));\n    unsigned char total = 10;\n    unsigned char host_total = 10;\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n    }\n\n    #pragma acc data copyin(a[0:n], b[0:n])\n    {\n        #pragma acc parallel loop reduction(+:total)\n        for (int x = 0; x < n; ++x) {\n            total += a[x] + b[x];\n        }\n    }\n\n    for (int x = 0; x < n; ++x) {\n        host_total += a[x] + b[x];\n    }\n\n    if (total != host_total) {\n        err += 1;\n    }\n\n    return err;\n}\n#endif\n#ifndef T4\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test4();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 3);\n    }\n#endif\n",
                        "tags": [
                            "parallel",
                            "reduction",
                            "combined-constructs",
                            "loop"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "5": {
                        "content": "#ifndef T5\n//T5:parallel,reduction,combined-constructs,loop,V:1.0-2.7\nint test5(){\n    int err = 0;\n    srand(SEED);\n    short int * a = (short int *)malloc(n * sizeof(short int));\n    short int * b = (short int *)malloc(n * sizeof(short int));\n    short int total = 10;\n    short int host_total = 10;    \n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n    }\n\n    #pragma acc data copyin(a[0:n], b[0:n])\n    {\n        #pragma acc parallel loop reduction(+:total)\n        for (int x = 0; x < n; ++x) {\n            total += a[x] + b[x];\n        }\n    }\n\n    for (int x = 0; x < n; ++x) {\n        host_total += a[x] + b[x];\n    }\n\n    if (total != host_total) {\n        err += 1;\n    }\n\n    return err;\n}\n#endif\n#ifndef T5\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test5();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 4);\n    }\n#endif\n",
                        "tags": [
                            "parallel",
                            "reduction",
                            "combined-constructs",
                            "loop"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "6": {
                        "content": "#ifndef T6\n//T6:parallel,reduction,combined-constructs,loop,V:1.0-2.7\nint test6(){\n    int err = 0;\n    srand(SEED);\n    int * a = (int *)malloc(n * sizeof(int));\n    int * b = (int *)malloc(n * sizeof(int));\n    int total = 10;\n    int host_total = 10;\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n    }\n\n    #pragma acc data copyin(a[0:n], b[0:n])\n    {\n        #pragma acc parallel loop reduction(+:total)\n        for (int x = 0; x < n; ++x) {\n            total += a[x] + b[x];\n        }\n    }\n\n    for (int x = 0; x < n; ++x) {\n        host_total += a[x] + b[x];\n    }\n\n    if (total != host_total) {\n        err += 1;\n    }\n\n    return err;\n}\n#endif\n#ifndef T6\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test6();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 5);\n    }\n#endif\n",
                        "tags": [
                            "parallel",
                            "reduction",
                            "combined-constructs",
                            "loop"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "7": {
                        "content": "#ifndef T7\n//T7:parallel,reduction,combined-constructs,loop,nonvalidating,V:1.0-2.7\nint test7(){\n    int err = 0;\n    srand(SEED);\n    long int * a = (long int *)malloc(n * sizeof(long int));\n    long int * b = (long int *)malloc(n * sizeof(long int));\n    long int total = 10;\n    long int host_total = 10;\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n    }\n\n    #pragma acc data copyin(a[0:n], b[0:n])\n    {\n        #pragma acc parallel loop reduction(+:total)\n        for (int x = 0; x < n; ++x) {\n            total += a[x] + b[x];\n        }\n    }\n\n    for (int x = 0; x < n; ++x) {\n        host_total += a[x] + b[x];\n    }\n\n    return err;\n}\n#endif\n#ifndef T7\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test7();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 6);\n    }\n#endif\n",
                        "tags": [
                            "parallel",
                            "reduction",
                            "combined-constructs",
                            "loop",
                            "nonvalidating"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "8": {
                        "content": "#ifndef T8\n//T8:parallel,reduction,combined-constructs,loop,V:1.0-2.7\nint test8(){\n    int err = 0;\n    srand(SEED);\n    long long int * a = (long long int *)malloc(n * sizeof(long long int));\n    long long int * b = (long long int *)malloc(n * sizeof(long long int));\n    long long int total = 10;\n    long long int host_total = 10;\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n    }\n\n    #pragma acc data copyin(a[0:n], b[0:n])\n    {\n        #pragma acc parallel loop reduction(+:total)\n        for (int x = 0; x < n; ++x) {\n            total += a[x] + b[x];\n        }\n    }\n\n    for (int x = 0; x < n; ++x) {\n        host_total += a[x] + b[x];\n    }\n\n    if (host_total != total) {\n        err += 1;\n    }\n\n    return err;\n}\n#endif\n#ifndef T8\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test8();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 7);\n    }\n#endif\n",
                        "tags": [
                            "parallel",
                            "reduction",
                            "combined-constructs",
                            "loop"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "parallel_loop_reduction_add_general_type_check_pt2.c": {
                "num tests": 8,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:parallel,reduction,combined-constructs,loop,V:1.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    unsigned short int * a = (unsigned short int*)malloc(n * sizeof(unsigned short int));\n    unsigned short int * b = (unsigned short int *)malloc(n * sizeof(unsigned short int));\n    unsigned short int total = 10;\n    unsigned short int host_total = 10;\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n    }\n\n    #pragma acc data copyin(a[0:n], b[0:n])\n    {\n        #pragma acc parallel loop reduction(+:total)\n        for (int x = 0; x < n; ++x) {\n            total += a[x] + b[x];\n        }\n    }\n\n    for (int x = 0; x < n; ++x) {\n        host_total += a[x] + b[x];\n    }\n\n    if (host_total != total) {\n        err += 1;\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "parallel",
                            "reduction",
                            "combined-constructs",
                            "loop"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "2": {
                        "content": "#ifndef T2\n//T2:parallel,reduction,combined-constructs,loop,V:1.0-2.7\nint test2(){\n    int err = 0;\n    srand(SEED);\n    unsigned int * a = (unsigned int *)malloc(n * sizeof(unsigned int));\n    unsigned int * b = (unsigned int *)malloc(n * sizeof(unsigned int));\n    unsigned int total = 10;\n    unsigned int host_total = 10;\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n    }\n\n    #pragma acc data copyin(a[0:n], b[0:n])\n    {\n        #pragma acc parallel loop reduction(+:total)\n        for (int x = 0; x < n; ++x) {\n            total += a[x] + b[x];\n        }\n    }\n\n    for (int x = 0; x < n; ++x) {\n        host_total += a[x] + b[x];\n    }\n\n    if (host_total != total) {\n        err += 1;\n    }\n\n    return err;\n}\n#endif\n#ifndef T2\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test2();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 1);\n    }\n#endif\n",
                        "tags": [
                            "parallel",
                            "reduction",
                            "combined-constructs",
                            "loop"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "3": {
                        "content": "#ifndef T3\n//T3:parallel,reduction,combined-constructs,loop,V:1.0-2.7\nint test3(){\n    int err = 0;\n    srand(SEED);\n    unsigned long int * a = (unsigned long int *)malloc(n * sizeof(unsigned long int));\n    unsigned long int * b = (unsigned long int *)malloc(n * sizeof(unsigned long int));\n    unsigned long int total = 10;\n    unsigned long int host_total = 10;\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n    }\n\n    #pragma acc data copyin(a[0:n], b[0:n])\n    {\n        #pragma acc parallel loop reduction(+:total)\n        for (int x = 0; x < n; ++x) {\n            total += a[x] + b[x];\n        }\n    }\n\n    for (int x = 0; x < n; ++x) {\n        host_total += a[x] + b[x];\n    }\n\n    if (host_total != total) {\n        err += 1;\n    }\n\n    return err;\n}\n#endif\n#ifndef T3\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test3();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 2);\n    }\n#endif\n",
                        "tags": [
                            "parallel",
                            "reduction",
                            "combined-constructs",
                            "loop"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "4": {
                        "content": "#ifndef T4\n//T4:parallel,reduction,combined-constructs,loop,V:1.0-2.7\nint test4(){\n    int err = 0;\n    srand(SEED);\n    unsigned long long int * a = (unsigned long long int *)malloc(n * sizeof(unsigned long long int));\n    unsigned long long int * b = (unsigned long long int *)malloc(n * sizeof(unsigned long long int));\n    unsigned long long int total = 10;\n    unsigned long long int host_total = 10;\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n    }\n\n    #pragma acc data copyin(a[0:n], b[0:n])\n    {\n        #pragma acc parallel loop reduction(+:total)\n        for (int x = 0; x < n; ++x) {\n            total += a[x] + b[x];\n        }\n    }\n\n    for (int x = 0; x < n; ++x) {\n        host_total += a[x] + b[x];\n    }\n    \n    if (total != host_total) {\n        err += 1;\n    }\n\n    return err;\n}\n#endif\n#ifndef T4\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test4();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 3);\n    }\n#endif\n",
                        "tags": [
                            "parallel",
                            "reduction",
                            "combined-constructs",
                            "loop"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "5": {
                        "content": "#ifndef T5\n//T5:parallel,reduction,combined-constructs,loop,V:1.0-2.7\nint test5(){\n    int err = 0;\n    srand(SEED);\n    float * a = (float *)malloc(n * sizeof(float));\n    float * b = (float *)malloc(n * sizeof(float));\n    float total = 10;\n    float host_total = 10;\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n    }\n\n    #pragma acc data copyin(a[0:n], b[0:n])\n    {\n        #pragma acc parallel loop reduction(+:total)\n        for (int x = 0; x < n; ++x) {\n            total += a[x] + b[x];\n        }\n    }\n\n    for (int x = 0; x < n; ++x) {\n        host_total += a[x] + b[x];\n    }\n\n    if (fabsf(total - host_total) > PRECISION) {\n        err += 1;\n    }\n\n    return err;\n}\n#endif\n#ifndef T5\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test5();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 4);\n    }\n#endif\n",
                        "tags": [
                            "parallel",
                            "reduction",
                            "combined-constructs",
                            "loop"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "6": {
                        "content": "#ifndef T6\n//T6:parallel,reduction,combined-constructs,loop,V:1.0-2.7\nint test6(){\n    int err = 0;\n    srand(SEED);\n    double * a = (double *)malloc(n * sizeof(double));\n    double * b = (double *)malloc(n * sizeof(double));\n    double total = 10;\n    double host_total = 10;\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n    }\n\n    #pragma acc data copyin(a[0:n], b[0:n])\n    {\n        #pragma acc parallel loop reduction(+:total)\n        for (int x = 0; x < n; ++x) {\n            total += a[x] + b[x];\n        }\n    }\n\n    for (int x = 0; x < n; ++x) {\n        host_total += a[x] + b[x];\n    }\n\n    if (fabs(host_total - total) > PRECISION) {\n        err += 1;\n    }\n\n    return err;\n}\n#endif\n#ifndef T6\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test6();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 5);\n    }\n#endif\n",
                        "tags": [
                            "parallel",
                            "reduction",
                            "combined-constructs",
                            "loop"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "7": {
                        "content": "#ifndef T7\n//T7:parallel,reduction,combined-constructs,loop,V:1.0-2.7\nint test7(){\n    int err = 0;\n    srand(SEED);\n    long double * a = (long double *)malloc(n * sizeof(long double));\n    long double * b = (long double *)malloc(n * sizeof(long double));\n    long double total = 10;\n    long double host_total = 10;\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n    }\n    \n    #pragma acc data copyin(a[0:n], b[0:n])\n    {\n        #pragma acc parallel loop reduction(+:total)\n        for (int x = 0; x < n; ++x){\n            total += a[x] + b[x];\n        }\n    }\n    \n    for (int x = 0; x < n; ++x) {\n        host_total += a[x] + b[x];\n    }\n\n    if (fabsl(host_total - total) > PRECISION) {\n        err += 1;\n    }\n\n    return err;\n}\n#endif\n#ifndef T7\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test7();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 6);\n    }\n#endif\n",
                        "tags": [
                            "parallel",
                            "reduction",
                            "combined-constructs",
                            "loop"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "8": {
                        "content": "#ifndef T8\n//T8:parallel,reduction,combined-constructs,loop,V:1.0-2.7\nint test8(){\n    int err = 0;\n    srand(SEED);\n    float _Complex * a = (float _Complex *)malloc(n * sizeof(float _Complex));\n    float _Complex * b = (float _Complex *)malloc(n * sizeof(float _Complex));\n    float _Complex total = 10 + 10 * I;\n    float _Complex host_total = 10 + 10 * I;\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10) + rand() / (real_t)(RAND_MAX / 10) * I;\n        b[x] = rand() / (real_t)(RAND_MAX / 10) + rand() / (real_t)(RAND_MAX / 10) * I;\n    }\n\n    #pragma acc data copyin(a[0:n], b[0:n])\n    {\n        #pragma acc parallel loop reduction(+:total)\n        for (int x = 0; x < n; ++x) {\n            total += a[x] + b[x];\n        }\n    }\n\n    for (int x = 0; x < n; ++x) {\n        host_total += a[x] + b[x];\n    }\n\n    if (fabsf(crealf(total) - crealf(host_total)) > PRECISION) {\n        err += 1;\n    }\n    if (fabsf(cimagf(total) - cimagf(host_total)) > PRECISION) {\n        err += 1;\n    }\n\n    return err;\n}\n#endif\n#ifndef T8\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test8();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 7);\n    }\n#endif\n",
                        "tags": [
                            "parallel",
                            "reduction",
                            "combined-constructs",
                            "loop"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "parallel_loop_reduction_add_general_type_check_pt3.c": {
                "num tests": 2,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:parallel,reduction,combined-constructs,loop,V:1.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    double _Complex * a = (double _Complex *)malloc(n * sizeof(double _Complex));\n    double _Complex * b = (double _Complex *)malloc(n * sizeof(double _Complex));\n    double _Complex total = 10 + 10 * I;\n    double _Complex host_total = 10 + 10 * I;\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10) + rand() / (real_t)(RAND_MAX / 10) * I;\n        b[x] = rand() / (real_t)(RAND_MAX / 10) + rand() / (real_t)(RAND_MAX / 10) * I;\n    }\n\n    #pragma acc data copyin(a[0:n], b[0:n])\n    {\n        #pragma acc parallel loop reduction(+:total)\n        for (int x = 0; x < n; ++x) {\n            total += a[x] + b[x];\n        }\n    }\n\n    for (int x = 0; x < n; ++x) {\n        host_total += a[x] + b[x];\n    }\n\n    if (fabs(creal(total) - creal(host_total)) > PRECISION) {\n        err += 1;\n    }\n    if (fabs(cimag(total) - cimag(host_total)) > PRECISION) {\n        err += 1;\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "parallel",
                            "reduction",
                            "combined-constructs",
                            "loop"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "2": {
                        "content": "#ifndef T2\n//T2:parallel,reduction,combined-constructs,loop,V:1.0-2.7\nint test2(){\n    int err = 0;\n    srand(SEED);\n    long double _Complex * a = (long double _Complex*)malloc(n * sizeof(long double _Complex));\n    long double _Complex * b = (long double _Complex*)malloc(n * sizeof(long double _Complex));\n    long double _Complex total = 10 + 10 * I;\n    long double _Complex host_total = 10 + 10 * I;\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10) + rand() / (real_t)(RAND_MAX / 10) * I;\n        b[x] = rand() / (real_t)(RAND_MAX / 10) + rand() / (real_t)(RAND_MAX / 10) * I;\n    }\n\n    #pragma acc data copyin(a[0:n], b[0:n])\n    {\n        #pragma acc parallel loop reduction(+:total)\n        for (int x = 0; x < n; ++x) {\n            total += a[x] + b[x];\n        }\n    }\n\n    for (int x = 0; x < n; ++x) {\n        host_total += a[x] + b[x];\n    }\n\n    if (fabsl(creall(total) - creall(host_total)) > PRECISION) {\n        err += 1;\n    }\n    if (fabsl(cimagl(total) - cimagl(host_total)) > PRECISION) {\n        err += 1;\n    }\n\n    return err;\n}\n#endif\n#ifndef T2\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test2();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 1);\n    }\n#endif\n",
                        "tags": [
                            "parallel",
                            "reduction",
                            "combined-constructs",
                            "loop"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "parallel_loop_reduction_add_loop.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:parallel,private,reduction,combined-constructs,loop,V:1.0-2.7\n      LOGICAL FUNCTION test1()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x, y !Iterators\n        REAL(8),DIMENSION(10*LOOPCOUNT):: a, b, c, d !Data\n        REAL(8) :: avg\n        INTEGER :: errors = 0\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(a)\n        CALL RANDOM_NUMBER(b)\n        avg = 0\n        !$acc data copyin(a(1:10*LOOPCOUNT), b(1:10*LOOPCOUNT)) create(c(1:10*LOOPCOUNT)) copyout(d(1:10*LOOPCOUNT))\n          !$acc parallel loop gang private(avg)\n          DO x = 0, 9\n            avg = 0\n            !$acc loop worker reduction(+:avg)\n            DO y = 1, LOOPCOUNT\n              avg = avg + a(x * LOOPCOUNT + y) + b(x * LOOPCOUNT + y)\n              c(x * LOOPCOUNT + y) = a(x * LOOPCOUNT + y) + b(x * LOOPCOUNT + y)\n            END DO\n            avg = avg / LOOPCOUNT\n            !$acc loop worker\n            DO y = 1, LOOPCOUNT\n              d(x * LOOPCOUNT + y) = c(x * LOOPCOUNT + y) / avg\n            END DO\n          END DO\n        !$acc end data\n        DO x = 0, 9\n          avg = 0\n          DO y = 1, LOOPCOUNT\n            avg = avg + a(x * LOOPCOUNT + y) + b(x * LOOPCOUNT + y)\n          END DO\n          avg = avg / LOOPCOUNT\n          DO y = 1, LOOPCOUNT\n            IF (abs(d(x * LOOPCOUNT + y) - ((a(x * LOOPCOUNT + y) + b(x * LOOPCOUNT + y)) / avg)) .gt. PRECISION) THEN\n              errors = errors + 1\n            END IF\n          END DO\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "parallel",
                            "private",
                            "reduction",
                            "combined-constructs",
                            "loop"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "parallel_loop_reduction_add_loop.c": {
                "num tests": 2,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:parallel,loop,reduction,combined-constructs,V:1.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(10 * n * sizeof(real_t));\n    real_t* b = (real_t*)malloc(10 * n * sizeof(real_t));\n    real_t* c = (real_t*)malloc(10 * n * sizeof(real_t));\n    real_t* d = (real_t*)malloc(10 * n * sizeof(real_t));\n    real_t avg = 0.0;\n    real_t rolling_total = 0;\n\n    for (int x = 0; x < 10 * n; ++x) {\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n    }\n\n    #pragma acc data copyin(a[0:10*n], b[0:10*n]) create(c[0:10*n]) copyout(d[0:10*n])\n    {\n        #pragma acc parallel loop gang private(avg)\n        for (int x = 0; x < 10; ++x) {\n            avg = 0;\n            #pragma acc loop worker reduction(+:avg)\n            for (int y = 0; y < n; ++y) {\n                avg += c[x * n + y] = a[x * n + y] + b[x * n + y];\n            }\n            avg = avg / n;\n            #pragma acc loop worker\n            for (int y = 0; y < n; ++y) {\n                d[x * n + y] = c[x * n + y] - avg;\n            }\n        }\n    }\n\n\n    for (int x = 0; x < 10; ++x) {\n        rolling_total = 0;\n        for (int y = 0; y < n; ++y) {\n            rolling_total += a[x * n + y] + b[x * n + y];\n        }\n        rolling_total = rolling_total / n;\n        for (int y = 0; y < n; ++y) {\n            if (fabs(d[x * n + y] - ((a[x * n + y] + b[x * n + y]) - rolling_total)) > PRECISION) {\n                err += 1;\n            }\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "parallel",
                            "loop",
                            "reduction",
                            "combined-constructs"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "2": {
                        "content": "#ifndef T2\n//T2:parallel,loop,reduction,combined-constructs,V:2.7-2.7\nint test2() {\n    int err = 0;\n    srand(SEED);\n    real_t* a = (real_t*)malloc(25 * n * sizeof(real_t));\n    real_t* b = (real_t*)malloc(25 * n * sizeof(real_t));\n    real_t* c = (real_t*)malloc(25 * n * sizeof(real_t));\n    real_t* d = (real_t*)malloc(25 * n * sizeof(real_t));\n    real_t avgs[5];\n    real_t host_avgs[5];\n\n    for (int x = 0; x < 25 * n; ++x) {\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n        c[x] = 0;\n        d[x] = 0;\n    }\n\n    #pragma acc data copyin(a[0:25*n], b[0:25*n]) copyout(c[0:25*n], d[0:25*n])\n    {\n        #pragma acc parallel loop gang private(avgs)\n        for (int x = 0; x < 5; ++x) {\n            for (int y = 0; y < 5; ++y) {\n                avgs[y] = 0;\n            }\n            #pragma acc loop worker reduction(+:avgs)\n            for (int y = 0; y < 5 * n; ++y) {\n                avgs[y % 5] += c[x * 5 * n + y] = a[x * 5 * n + y] + b[x * 5 * n + y];\n            }\n            for (int y = 0; y < 5; ++y) {\n                avgs[y] = avgs[y] / n;\n            }\n            #pragma acc loop worker\n            for (int y = 0; y < 5 * n; ++y) {\n                d[x * 5 * n + y] = c[x * 5 * n + y] - avgs[y % 5];\n            }\n        }\n    }\n\n    for (int x = 0; x < 5; ++x) {\n        for (int y = 0; y < 5; ++y) {\n            host_avgs[y] = 0;\n        }\n        for (int y = 0; y < 5 * n; ++y) {\n            host_avgs[y % 5] += a[x * 5 * n + y] + b[x * 5 * n + y];\n            if (fabs(c[x * 5 * n + y] - (a[x * n * 5 + y] + b[x * n * 5 + y])) > PRECISION) {\n                err += 1;\n            }\n        }\n        for (int y = 0; y < 5; ++y) {\n            host_avgs[y] = host_avgs[y] / n;\n        }\n        for (int y = 0; y < 5 * n; ++y) {\n            if (fabs(d[x * 5 * n + y] - (c[x * 5 * n + y] - host_avgs[y % 5])) > PRECISION){\n                err += 1;\n            \n            }\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T2\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test2();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 1);\n    }\n#endif\n",
                        "tags": [
                            "parallel",
                            "loop",
                            "reduction",
                            "combined-constructs"
                        ],
                        "versions": [
                            "2.7"
                        ]
                    }
                }
            },
            "parallel_loop_reduction_add_loop_type_check_pt1.c": {
                "num tests": 2,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:parallel,private,reduction,combined-constructs,loop,V:1.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    _Bool * a = (_Bool *)malloc(10 * n * sizeof(_Bool));\n    _Bool * b = (_Bool *)malloc(10 * n * sizeof(_Bool));\n    _Bool * c = (_Bool *)malloc(10 * n * sizeof(_Bool));\n    _Bool * d = (_Bool *)malloc(10 * n * sizeof(_Bool));\n    _Bool total = 1;\n    _Bool host_total = 1;\n\n    for (int x = 0; x < 10 * n; ++x){\n        if ((rand() / ((real_t)RAND_MAX)) > .5) {\n            a[x] = 1;\n        }\n        else {\n            a[x] = 0;\n        }\n        if ((rand() / ((real_t)RAND_MAX)) > .5) {\n            b[x] = 1;\n        }\n        else {\n            b[x] = 0;\n        }\n        if ((rand() / ((real_t)RAND_MAX)) > .5) {\n            c[x] = 1;\n        }\n        else {\n            c[x] = 0;\n        }\n    }\n    /*\n    #pragma acc data copyin(a[0:10*n], b[0:10*n], c[0:10*n]) copyout(d[0:10*n])\n    {\n        #pragma acc parallel loop gang private(total)\n        for (int x = 0; x < 10; ++x) {\n            total = 1;\n            #pragma acc loop worker reduction(+:total)\n            for (int y = 0; y < n; ++y) {\n                total += a[x * n + y] + b[x * n + y];\n            }\n            #pragma acc loop worker\n            for (int y = 0; y < n; ++y) {\n                d[x * n + y] = c[x * n + y] + total;\n            }\n        }\n    }\n    */\n    for (int x = 0; x < 10; ++x) {\n        host_total = 1;\n        for (int y = 0; y < n; ++y) {\n            host_total += a[x * n + y] + b[x * n + y];\n        }\n        for (int y = 0; y < n; ++y) {\n            if (d[x * n + y] != (host_total + c[x * n + y])) {\n                err += 1;\n            }\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "parallel",
                            "private",
                            "reduction",
                            "combined-constructs",
                            "loop"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "2": {
                        "content": "#ifndef T2\n//T2:parallel,private,reduction,combined-constructs,loop,V:1.0-2.7\nint test2(){\n    int err = 0;\n    srand(SEED);\n    char * a = (char *)malloc(10 * n * sizeof(char));\n    char * b = (char *)malloc(10 * n * sizeof(char));\n    char * c = (char *)malloc(10 * n * sizeof(char));\n    char * d = (char *)malloc(10 * n * sizeof(char));\n    char total = 10;\n    char host_total = 10;\n    char temp;\n\n    for (int x = 0; x < 10 * n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n        c[x] = rand() / (real_t)(RAND_MAX / 10);\n    }\n\n    #pragma acc data copyin(a[0:10*n],b[0:10*n], c[0:10*n]) copyout(d[0:10*n])\n    {\n        #pragma acc parallel loop gang private(total)\n        for (int x = 0; x < 10; ++x) {\n            total = 10;\n            #pragma acc loop worker reduction(+:total)\n            for (int y = 0; y < n; ++y) {\n                total += a[x * n + y] + b[x * n + y];\n            }\n            #pragma acc loop worker\n            for (int y = 0; y < n; ++y) {\n                d[x * n + y] = c[x * n + y] + total;\n            }\n        }\n    }\n    int error_count = 0;\n    int total_count = 0;\n    for (int x = 0; x < 10; ++x) {\n        host_total = 10;\n        for (int y = 0; y < n; ++y) {\n            host_total += a[x * n + y] + b[x * n + y];\n        }\n        for (int y = 0; y < n; ++y) {\n            temp = host_total + c[x * n + y];\n            if (d[x * n + y] != (host_total + c[x * n + y])) {\n                err += 1;\n                error_count += 1;\n                printf(\"Error location x: %d \\t y: %d\\n\", x, y); \n                printf(\"%d != %d\\n\", d[x * n + y], host_total + c[x * n + y]);\n            }\n            total_count += 1;\n        }\n    }\n\n    printf(\"%d out of %d failed\\n\", error_count, total_count);\n\n    return err;\n}\n#endif\n#ifndef T2\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test2();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 1);\n    }\n#endif\n",
                        "tags": [
                            "parallel",
                            "private",
                            "reduction",
                            "combined-constructs",
                            "loop"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "parallel_loop_reduction_add_vector_loop.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:parallel,private,reduction,combined-constructs,loop,V:1.0-2.7\n      LOGICAL FUNCTION test1()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x, y !Iterators\n        REAL(8),DIMENSION(10*LOOPCOUNT):: a, b !Data\n        REAL(8),DIMENSION(10) :: c\n        REAL(8) :: temp\n        INTEGER :: errors = 0\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(a)\n        CALL RANDOM_NUMBER(b)\n\n        !$acc data copyin(a(1:10*LOOPCOUNT), b(1:10*LOOPCOUNT)) copyout(c(1:10))\n          !$acc parallel loop private(temp)\n          DO x = 0, 9\n            temp = 0.0\n            !$acc loop vector reduction(+:temp)\n            DO y = 1, LOOPCOUNT\n              temp = temp + a(x * LOOPCOUNT + y) + b(x * LOOPCOUNT + y)\n            END DO\n            c(x + 1) = temp\n          END DO\n        !$acc end data\n\n        DO x = 0, 9\n          temp = 0\n          DO y = 1, LOOPCOUNT\n            temp = temp + a(x * LOOPCOUNT + y) + b(x * LOOPCOUNT + y)\n          END DO\n          IF (abs(temp - c(x + 1)) .gt. PRECISION) THEN\n            errors = errors + 1\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "parallel",
                            "private",
                            "reduction",
                            "combined-constructs",
                            "loop"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "parallel_loop_reduction_add_vector_loop.c": {
                "num tests": 2,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:parallel,private,reduction,combined-constructs,loop,V:1.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(10 * n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(10 * n * sizeof(real_t));\n    real_t * c = (real_t *)malloc(10 * sizeof(real_t));\n    real_t temp = 0.0;\n\n    for(int x = 0; x < 10 * n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n    }\n    #pragma acc data copyin(a[0:10*n], b[0:10*n]) copyout(c[0:10])\n    {\n        #pragma acc parallel loop private(temp)\n        for (int x = 0; x < 10; ++x){\n            temp = 0.0;\n            #pragma acc loop vector reduction(+:temp)\n            for (int y = 0; y < n; ++y){\n                temp += a[(x * n) + y] + b[(x * n) + y];\n            }\n            c[x] = temp;\n        }\n    }\n    for (int x = 0; x < 10; ++x){\n        for (int y = 0; y < n; ++y){\n            c[x] -= a[(x * n) + y] + b[(x * n) + y];\n        }\n        if (fabs(c[x]) > PRECISION * (2 * n - 1)){\n            err = 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "parallel",
                            "private",
                            "reduction",
                            "combined-constructs",
                            "loop"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "2": {
                        "content": "#ifndef T2\n//T2:parallel,private,reduction,combined-constructs,loop,V:2.7-2.7\nint test2(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(25 * n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(25 * n * sizeof(real_t));\n    real_t * c = (real_t *)malloc(25 * sizeof(real_t));\n    real_t * c_host = (real_t *)malloc(25 * sizeof(real_t));\n    real_t temp[5];\n\n    for (int x = 0; x < 25 * n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n    }\n\n    for (int x = 0; x < 25; ++x) {\n        c[x] = 0;\n        c_host[x] = 0;\n    }\n\n    #pragma acc data copyin(a[0:25*n], b[0:25*n]) copyout(c[0:25])\n    {\n        #pragma acc parallel loop private(temp)\n        for (int x = 0; x < 5; ++x) {\n            for (int y = 0; y < 5; ++y) {\n                temp[y] = 0;\n            }\n            #pragma acc loop vector reduction(+:temp)\n            for (int y = 0; y < 5 * n; ++y) {\n                temp[y % 5] += a[x * 5 * n + y] + b[x * 5 * n + y];\n            }\n            for (int y = 0; y < 5; ++y) {\n                c[x * 5 + y] = temp[y];\n            }\n        }\n    }\n\n    for (int x = 0; x < 5; ++x) {\n        for (int y = 0; y < 5 * n; ++y) {\n            c_host[x * 5 + (y % 5)] += a[x * 5 * n + y] + b[x * 5 * n + y];\n        }\n    }\n\n    for (int x = 0; x < 25; ++x) {\n        if (fabs(c[x] - c_host[x]) > PRECISION) {\n            err += 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T2\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test2();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 1);\n    }\n#endif\n",
                        "tags": [
                            "parallel",
                            "private",
                            "reduction",
                            "combined-constructs",
                            "loop"
                        ],
                        "versions": [
                            "2.7"
                        ]
                    }
                }
            },
            "parallel_loop_reduction_and_general.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:parallel,reduction,combined-constructs,loop,V:1.0-2.7\n      LOGICAL FUNCTION test1()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT):: randoms\n        LOGICAL,DIMENSION(LOOPCOUNT):: a !Data\n        LOGICAL :: results = .TRUE.\n        LOGICAL :: host_results = .TRUE.\n        REAL(8) :: false_margin\n        INTEGER :: errors = 0\n        false_margin = exp(log(.5) / LOOPCOUNT)\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(randoms)\n        DO x = 1, LOOPCOUNT\n          IF (randoms(x) .lt. false_margin) THEN\n            a(x) = .TRUE.\n          ELSE\n            a(x) = .FALSE.\n          END IF\n        END DO\n\n        !$acc data copyin(a(1:LOOPCOUNT))\n          !$acc parallel loop reduction(.and.:results)\n          DO x = 1, LOOPCOUNT\n            results = results .and. a(x)\n          END DO\n        !$acc end data\n\n        DO x = 1, LOOPCOUNT\n          host_results = host_results .and. a(x)\n        END DO\n        IF (host_results .neqv. results) THEN\n          errors = 1\n        END IF\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "parallel",
                            "reduction",
                            "combined-constructs",
                            "loop"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "parallel_loop_reduction_and_general.c": {
                "num tests": 2,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:parallel,loop,reduction,combined-constructs,V:1.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n\n    char * a = (char *)malloc(n * sizeof(char));\n    real_t false_margin = pow(exp(1), log(.5)/n);\n    char result = 1;\n    char found = 0;\n\n    for (int x = 0; x < n; ++x){\n        if(rand() / (real_t)(RAND_MAX) < false_margin){\n            a[x] = 1;\n        }\n        else{\n            a[x] = 0;\n        }\n    }\n\n    #pragma acc data copyin(a[0:n])\n    {\n        #pragma acc parallel loop reduction(&&:result)\n        for (int x = 0; x < n; ++x){\n            result = result && a[x];\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        if (a[x] == 0){\n            found = 1;\n            break;\n        }\n    }\n    if (found == result){\n        err = 1;\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "parallel",
                            "loop",
                            "reduction",
                            "combined-constructs"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "2": {
                        "content": "#ifndef T2\n//T2:parallel,combined-constructs,loop,V:2.7-2.7\nint test2(){\n    int err = 0;\n    srand(SEED);\n    char * a = (char *)malloc(n * 5 * sizeof(char));\n    real_t false_margin = pow(exp(1), log(.5/n));\n    char result[5];\n    char host_result[5];\n\n    for (int x = 0; x < 5; ++x) {\n        result[x] = 1;\n        host_result[x] = 1;\n    }\n\n    for (int x = 0; x < 5 * n; ++x) {\n        if (rand() / (real_t)(RAND_MAX) < false_margin) {\n            a[x] = 1;\n        }\n        else {\n            a[x] = 0;\n        }\n    }\n\n    #pragma acc data copyin(a[0:5*n])\n    {\n        #pragma acc parallel loop reduction(&&:result)\n        for (int x = 0; x < 5 * n; ++x) {\n            result[x%5] = result[x%5] && a[x];\n        }\n    }\n\n    for (int x = 0; x < 5 * n; ++x) {\n        host_result[x%5] = host_result[x%5] && a[x];\n    }\n\n    for (int x = 0; x < 5; ++x){\n        if (host_result[x] != result[x]) {\n            err += 1;\n        } \n    }\n\n    return err;\n}\n#endif\n#ifndef T2\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test2();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 1);\n    }\n#endif\n",
                        "tags": [
                            "parallel",
                            "combined-constructs",
                            "loop"
                        ],
                        "versions": [
                            "2.7"
                        ]
                    }
                }
            },
            "parallel_loop_reduction_and_loop.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:parallel,reduction,combined-constructs,loop,V:1.0-2.7\n      LOGICAL FUNCTION test1()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x, y !Iterators\n        LOGICAL,DIMENSION(10*LOOPCOUNT):: a, a_copy !Data\n        LOGICAL,DIMENSION(10) :: results, has_false\n        LOGICAL :: host_results = .TRUE.\n        LOGICAL :: temp = .TRUE.\n        REAL(8),DIMENSION(10*LOOPCOUNT):: randoms\n        REAL(8) :: false_margin = exp(log(.5) / LOOPCOUNT)\n        INTEGER :: errors = 0\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(randoms)\n        DO x = 1, 10\n          results(x) = .TRUE.\n          has_false(x) = .FALSE.\n        END DO\n        DO x = 1, 10*LOOPCOUNT\n          IF (randoms(x) .lt. false_margin) THEN\n            a(x) = .TRUE.\n            a_copy(x) = .TRUE.\n          ELSE\n            a(x) = .FALSE.\n            a_copy(x) = .FALSE.\n            has_false(x / LOOPCOUNT) = .TRUE.\n          END IF\n        END DO\n\n        !$acc data copy(a(1:10*LOOPCOUNT), results(1:10))\n          !$acc parallel loop gang\n          DO x = 0, 9\n            temp = .TRUE.\n            !$acc loop worker reduction(.AND.:temp)\n            DO y = 1, LOOPCOUNT\n              temp = temp .AND. a(x * LOOPCOUNT + y)\n            END DO\n            results(x + 1) = temp\n            !$acc loop worker\n            DO y = 1, LOOPCOUNT\n              IF (temp .eqv. .TRUE.) THEN\n                IF (a(x * LOOPCOUNT + y) .eqv. .TRUE.) THEN\n                  a(x * LOOPCOUNT + y) = .FALSE.\n                ELSE\n                  a(x * LOOPCOUNT + y) = .TRUE.\n                END IF\n              END IF\n            END DO\n          END DO\n        !$acc end data\n        DO x = 0, 9\n          temp = .TRUE.\n          DO y = 1, LOOPCOUNT\n            temp = temp .AND. a_copy(x * LOOPCOUNT + y)\n          END DO\n          IF (temp .neqv. results(x + 1)) THEN\n            errors = errors + 1\n          END IF\n          DO y = 1, LOOPCOUNT\n            IF (temp .eqv. .TRUE.) THEN\n              IF (a(x * LOOPCOUNT + y) .eqv. a_copy(x * LOOPCOUNT + y)) THEN\n                errors = errors + 1\n              END IF\n            ELSE\n              IF (a(x * LOOPCOUNT + y) .neqv. a_copy(x * LOOPCOUNT + y)) THEN\n                errors = errors + 1\n              END IF\n            END IF\n          END DO\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "parallel",
                            "reduction",
                            "combined-constructs",
                            "loop"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "parallel_loop_reduction_and_loop.c": {
                "num tests": 2,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:parallel,loop,reduction,combined-constructs,V:1.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    char * a = (char *)malloc(10 * n * sizeof(char));\n    char * a_copy = (char *)malloc(10 * n * sizeof(char));\n    char * has_false = (char *)malloc(10 * sizeof(char));\n    real_t false_margin = pow(exp(1), log(.5)/n);\n    char temp = 1;\n\n    for (int x = 0; x < 10; ++x){\n        has_false[x] = 0;\n    }\n\n    for (int x = 0; x < 10; ++x){\n        for (int y = 0; y < n; ++y){\n            if (rand() / (real_t)(RAND_MAX) < false_margin){\n                a[x * n + y] = 1;\n                a_copy[x * n + y] = 1;\n            }\n            else {\n                a[x * n + y] = 0;\n                a_copy[x * n + y] = 0;\n                has_false[x] = 1;\n            }\n        }\n    }\n\n    #pragma acc data copy(a[0:10*n])\n    {\n        #pragma acc parallel loop gang private(temp)\n        for (int x = 0; x < 10; ++x){\n            temp = 1;\n            #pragma acc loop worker reduction(&&:temp)\n            for (int y = 0; y < n; ++y){\n                temp = temp && a[x * n + y];\n            }\n            #pragma acc loop worker\n            for (int y = 0; y < n; ++y){\n                a[x * n + y] = a[x * n + y] ^ temp;\n            }\n        }\n    }\n\n\n    for (int x = 0; x < 10; ++x){\n        for (int y = 0; y < n; ++y){\n            if (has_false[x] == 1 && a[x * n + y] != a_copy[x * n + y]){\n                err = 1;\n            }\n            else if (has_false[x] == 0 && a[x * n + y] == a_copy[x * n + y]){\n                err = 1;\n            }\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "parallel",
                            "loop",
                            "reduction",
                            "combined-constructs"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "2": {
                        "content": "#ifndef T2\n//T2:parallel,private,reduction,combined-constructs,loop,V:2.7-2.7\nint test2(){\n    int err = 0;\n    srand(SEED);\n    char * a = (char *)malloc(n * 25 * sizeof(char));\n    char * a_copy = (char *)malloc(n * 25 * sizeof(char));\n    char * has_false = (char *)malloc(25 * sizeof(char));\n    real_t false_margin = pow(exp(1), log(.5)/n);\n    char device[5];\n    char host[5];\n\n    for (int x = 0; x < 5; ++x) {\n        device[x] = 1;\n        host[x] = 1;\n        for (int y = 0; y < 5; ++y) {\n            has_false[x * 5 + y] = 0;\n        }\n    }\n\n    for (int x = 0; x < 25 * n; ++x){\n        if (rand() / (real_t)(RAND_MAX) < false_margin) {\n            a[x] = 1;\n            a_copy[x] = 1;\n        }\n        else {\n            a[x] = 0;\n            a_copy[x] = 0;\n            has_false[x % 25] = 1;\n        }\n    }\n\n    #pragma acc data copy(a[0:25*n])\n    {\n        #pragma acc parallel loop gang private(device)\n        for (int x = 0; x < 5; ++x) {\n            for (int y = 0; y < 5; ++y) {\n                device[y] = 1;\n            }\n            #pragma acc loop worker reduction(&&:device)\n            for (int y = 0; y < 5 * n; ++y) {\n                device[y%5] = device[y%5] && a[x * 5 * n + y];\n            }\n            #pragma acc loop worker\n            for (int y = 0; y < 5 * n; ++y) {\n                a[x * 5 * n + y] = a[x * 5 * n + y] ^ device[y%5];\n            }\n        }\n    }\n\n    for (int x = 0; x < 5; ++x) {\n        for (int y = 0; y < 5; ++y) {\n            host[y] = 1;\n        }\n        for (int y = 0; y < 5 * n; ++y) {\n            host[y%5] = host[y%5] && a_copy[x * 5 * n + y];\n        }\n        for (int y = 0; y < 5 * n; ++y) {\n            if (a[x * 5 * n + y] != (a_copy[x * 5 * n + y] ^ host[y % 5])) {\n                err += 1;\n            }\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T2\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test2();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 1);\n    }\n#endif\n",
                        "tags": [
                            "parallel",
                            "private",
                            "reduction",
                            "combined-constructs",
                            "loop"
                        ],
                        "versions": [
                            "2.7"
                        ]
                    }
                }
            },
            "parallel_loop_reduction_and_vector_loop.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:parallel,private,reduction,combined-constructs,loop,V:1.0-2.7\n      LOGICAL FUNCTION test1()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x, y !Iterators\n        LOGICAL,DIMENSION(10*LOOPCOUNT):: a !Data\n        LOGICAL,DIMENSION(10):: b\n        LOGICAL,DIMENSION(10):: has_false\n        LOGICAL :: temp\n        REAL(8) :: false_margin\n        REAL(8),DIMENSION(10*LOOPCOUNT) :: randoms\n        INTEGER :: errors = 0\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(randoms)\n        false_margin = exp(log(.5) / LOOPCOUNT)\n        DO x = 1, 10\n          has_false(x) = .FALSE.\n          b(x) = .TRUE.\n        END DO\n\n        DO x = 0, 9\n          DO y = 1, LOOPCOUNT\n            IF (randoms(x * LOOPCOUNT + y) .lt. false_margin) THEN\n              a(x * LOOPCOUNT + y) = .TRUE.\n            ELSE\n              a(x * LOOPCOUNT + y) = .FALSE.\n              has_false(x + 1) = .TRUE.\n            END IF\n          END DO\n        END DO\n\n        !$acc data copyin(a(1:10*LOOPCOUNT)) copy(b(1:10))\n          !$acc parallel loop private(temp)\n          DO x = 0, 9\n            temp = .TRUE.\n            !$acc loop vector reduction(.AND.:temp)\n            DO y = 1, LOOPCOUNT\n              temp = temp .AND. a(x * LOOPCOUNT + y)\n            END DO\n            b(x + 1) = temp\n          END DO\n        !$acc end data\n\n        DO x = 0, 9\n          temp = .FALSE.\n          DO y = 1, LOOPCOUNT\n            IF (a(x * LOOPCOUNT + y) .eqv. .FALSE.) THEN\n              temp = .TRUE.\n            END IF\n          END DO\n          IF (temp .neqv. has_false(x + 1)) THEN\n            errors = 1\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "parallel",
                            "private",
                            "reduction",
                            "combined-constructs",
                            "loop"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "parallel_loop_reduction_and_vector_loop.c": {
                "num tests": 2,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:parallel,loop,reduction,combined-constructs,V:1.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    char * a = (char *)malloc(10 * n * sizeof(char));\n    char * b = (char *)malloc(10 * sizeof(char));\n    char * has_false = (char *)malloc(10 * sizeof(char));\n    real_t false_margin = pow(exp(1), log(.5)/n);\n    char temp = 1;\n\n    for (int x = 0; x < 10; ++x){\n        has_false[x] = 0;\n    }\n    for (int x = 0; x < 10 * n; ++x){\n        if(rand() / (real_t)(RAND_MAX) < false_margin){\n            a[x] = 1;\n        }\n        else{\n            a[x] = 0;\n            has_false[x/n] = 1;\n        }\n    }\n    #pragma acc data copyin(a[0:10*n]) copy(b[0:10])\n    {\n        #pragma acc parallel loop private(temp)\n        for (int x = 0; x < 10; ++x){\n            temp = 1;\n            #pragma acc loop vector reduction(&&:temp)\n            for (int y = 0; y < n; ++y){\n                temp = temp && a[x * n + y];\n            }\n            b[x] = temp;\n        }\n    }\n    for (int x = 0; x < 10; ++x){\n        if (has_false[x] == b[x]){\n            err = 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "parallel",
                            "loop",
                            "reduction",
                            "combined-constructs"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "2": {
                        "content": "#ifndef T2\n//T2:parallel,private,reduction,combined-constructs,loop,V:2.7-2.7\nint test2(){\n    int err = 0;\n    srand(SEED);\n    char * a = (char *)malloc(25 * n * sizeof(char));\n    char * b = (char *)malloc(25 * sizeof(char));\n    char * has_false = (char *)malloc(25 * sizeof(char));\n    real_t false_margin = pow(exp(1), log(.5)/n);\n    char device[5];\n    char host[5];\n\n    for (int x = 0; x < 5; ++x) {\n        for (int y = 0; y < 5 * n; ++y){\n            if (rand() / (real_t)(RAND_MAX) < false_margin) {\n                a[x] = 1;\n            }\n            else {\n                a[x] = 0;\n                has_false[x * 5 + y % 5];\n            }\n        }\n    }\n\n    #pragma acc data copyin(a[0:25*n]) copy(b[0:25])\n    {\n        #pragma acc parallel loop private(device)\n        for (int x = 0; x < 5; ++x) {\n            for (int y = 0; y < 5; ++y) {\n                device[y] = 1;\n            }\n            #pragma acc loop vector reduction(&&:device)\n            for (int y = 0; y < 5 * n; ++y) {\n                device[y%5] = device[y%5] && a[x * 5 * n + y];\n            }\n            for (int y = 0; y < 5; ++y){\n                b[x * 5 + y] = device[y];\n            }\n        }\n    }\n\n    for (int x = 0; x < 5; ++x) {\n        for (int y = 0; y < 5; ++y) {\n            host[y] = 1;\n        }\n        for (int y = 0; y < 5 * n; ++y) {\n            host[y%5] = host[y%5] && a[x * 5 * n + y];\n        }\n        for (int y = 0; y < 5; ++y) {\n            if (b[x * 5 + y] != host[y]) {\n                err += 1;\n            }\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T2\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test2();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 1);\n    }\n#endif\n",
                        "tags": [
                            "parallel",
                            "private",
                            "reduction",
                            "combined-constructs",
                            "loop"
                        ],
                        "versions": [
                            "2.7"
                        ]
                    }
                }
            },
            "parallel_loop_reduction_bitand_general.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:parallel,reduction,combined-constructs,loop,V:1.0-2.7\n      LOGICAL FUNCTION test1()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x, y, z !Iterators\n        INTEGER,DIMENSION(LOOPCOUNT):: a !Data\n        INTEGER :: b\n        REAL(8),DIMENSION(16 * LOOPCOUNT):: randoms\n        REAL(8) :: false_margin\n        INTEGER :: errors = 0\n        INTEGER :: temp = 1\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(randoms)\n        false_margin = exp(log(.5)/n)\n        DO x = 1, LOOPCOUNT\n          DO y = 0, 15\n            IF (randoms(y * LOOPCOUNT + x) .lt. false_margin) THEN\n              temp = 1\n              DO z = 0, y\n                temp = temp * 2\n              END DO\n              a(x) = a(x) + temp\n            END IF\n          END DO\n        END DO\n        \n        b = a(1)\n\n        !$acc data copyin(a(1:LOOPCOUNT))\n          !$acc parallel loop reduction(iand:b)\n          DO x = 1, LOOPCOUNT\n            b = iand(b, a(x))\n          END DO\n        !$acc end data\n \n        temp = a(1)\n        DO x = 2, LOOPCOUNT\n          temp = iand(a(x), temp)\n        END DO\n        IF (temp .ne. b) THEN\n          WRITE(*, *) temp\n          WRITE(*, *) b\n          errors = 1\n        END IF\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "parallel",
                            "reduction",
                            "combined-constructs",
                            "loop"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "parallel_loop_reduction_bitand_general.c": {
                "num tests": 2,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:parallel,loop,reduction,combined-constructs,V:1.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    n = 10;\n    unsigned int * a = (unsigned int *)malloc(n * sizeof(unsigned int));\n    real_t false_margin = pow(exp(1), log(.5)/n);\n    unsigned int temp = 1;\n    unsigned int b;\n    unsigned int host_b;\n\n    for (int x = 0; x < n; ++x){\n        a[x] = 0;\n        for (int y = 0; y < 16; ++y){\n            if (rand() / (real_t) RAND_MAX < false_margin){\n                for (int z = 0; z < y; ++z){\n                    temp *= 2;\n                }\n                a[x] += temp;\n                temp = 1;\n            }\n        }\n    }\n\n    b = a[0];\n    host_b = a[0];\n\n    #pragma acc data copyin(a[0:n])\n    {\n        #pragma acc parallel loop reduction(&:b)\n        for (int x = 0; x < n; ++x){\n            b = b & a[x];\n        }\n    }\n\n    for (int x = 1; x < n; ++x){\n        host_b = host_b & a[x];\n    }\n    if (b != host_b){\n        err = 1;\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "parallel",
                            "loop",
                            "reduction",
                            "combined-constructs"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "2": {
                        "content": "#ifndef T2\n//T2:parallel,reduction,combined-constructs,loop,V:2.7-2.7\nint test2(){\n    int err = 0;\n    srand(SEED);\n    unsigned int * a = (unsigned int *)malloc(10 * n * sizeof(int));\n    real_t false_margin = pow(exp(1), log(.5)/n);\n    unsigned int device[10];\n    unsigned int host[10];\n\n    for (int x = 0; x < 10 * n; ++x) {\n        a[x] = 0;\n        for (int y = 0; y < 16; ++y){\n            if (rand() / (real_t)RAND_MAX < false_margin) {\n                a[x] += 1<<y;\n            }\n        }\n    }\n\n    for (int x = 0; x < 10; ++x) {\n        device[x] = 0;\n        host[x] = 0;\n        for (int y = 0; y < 16; ++y) {\n            device[x] += 1<<y;\n            host[x] += 1<<y;\n        }\n    }\n\n    #pragma acc data copyin(a[0:10*n])\n    {\n        #pragma acc parallel loop reduction(&:device)\n        for (int x = 0; x < 10 * n; ++x) {\n            device[x%10] = device[x%10] & a[x];\n        }\n    }\n\n    for (int x = 0; x < 10 * n; ++x) {\n        host[x%10] = host[x%10] & a[x];\n    }\n\n    for (int x = 0; x < 10; ++x) {\n        if (host[x] != device[x]) {\n            err += 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T2\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test2();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 1);\n    }\n#endif\n",
                        "tags": [
                            "parallel",
                            "reduction",
                            "combined-constructs",
                            "loop"
                        ],
                        "versions": [
                            "2.7"
                        ]
                    }
                }
            },
            "parallel_loop_reduction_bitand_loop.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:parallel,private,reduction,combined-constructs,loop,V:1.0-2.7\n      LOGICAL FUNCTION test1()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x, y, z !Iterators\n        INTEGER,DIMENSION(10*LOOPCOUNT):: a, b, b_copy !Data\n        REAL(8),DIMENSION(10*LOOPCOUNT):: randoms2\n        INTEGER,DIMENSION(10) :: c\n        REAL(8) :: false_margin\n        REAL(8),DIMENSION(160*LOOPCOUNT)::randoms\n        INTEGER :: errors = 0\n        INTEGER :: temp\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(randoms)\n        CALL RANDOM_NUMBER(randoms2)\n        b = FLOOR(10000 * randoms2)\n        b_copy = b\n        false_margin = exp(log(.5)/LOOPCOUNT)\n        DO x = 1, 10 * LOOPCOUNT\n          DO y = 1, 16\n            IF (randoms((y - 1) * 10 * LOOPCOUNT + x) < false_margin) THEN\n              temp = 1\n              DO z = 1, y\n                temp = temp * 2\n              END DO\n              a(x) = a(x) + temp\n            END IF\n          END DO\n        END DO\n        \n        DO x = 1, 10\n         c(x) = a((x - 1) * LOOPCOUNT + x)\n        END DO\n        \n        \n\n        !$acc data copyin(a(1:10*LOOPCOUNT)) copy(b(1:10*LOOPCOUNT), c(1:10))\n          !$acc parallel loop gang private(temp)\n          DO x = 1, 10\n            temp = a((x - 1) * LOOPCOUNT + 1)\n            !$acc loop worker reduction(iand:temp)\n            DO y = 2, LOOPCOUNT\n              temp = iand(temp, a((x - 1) * LOOPCOUNT + y))\n            END DO\n            c(x) = temp\n            !$acc loop worker\n            DO y = 1, LOOPCOUNT\n              b((x - 1) * LOOPCOUNT + y) = b((x - 1) * LOOPCOUNT + y) + c(x)\n            END DO\n          END DO\n        !$acc end data\n\n       DO x = 1, 10\n         temp = a((x - 1) * LOOPCOUNT + 1)\n         DO y = 2, LOOPCOUNT\n           temp = iand(temp, a((x - 1) * LOOPCOUNT + y))\n         END DO\n         IF (temp .ne. c(x)) THEN\n           errors = errors + 1\n         END IF\n         DO y = 1, LOOPCOUNT\n           IF (b((x - 1) * LOOPCOUNT + y) .ne. b_copy((x - 1) * LOOPCOUNT + y) + temp) THEN\n             errors = errors + 1\n           END IF\n         END DO\n       END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "parallel",
                            "private",
                            "reduction",
                            "combined-constructs",
                            "loop"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "parallel_loop_reduction_bitand_loop.c": {
                "num tests": 2,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:parallel,loop,reduction,combined-constructs,V:1.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    unsigned int * a = (unsigned int *)malloc(10 * n * sizeof(unsigned int));\n    unsigned int * b = (unsigned int *)malloc(10 * n * sizeof(unsigned int));\n    unsigned int * b_copy = (unsigned int *)malloc(10 * n * sizeof(unsigned int));\n    unsigned int * c = (unsigned int *)malloc(10 * sizeof(unsigned int));\n    unsigned int * host_c = (unsigned int *)malloc(10 * sizeof(unsigned int));\n\n    real_t false_margin = pow(exp(1), log(.5)/n);\n    unsigned int temp = 1;\n\n    for (int x = 0; x < 10 * n; ++x){\n        a[x] = 0;\n        b[x] = (unsigned int) rand() / (real_t)(RAND_MAX / 1000);\n        b_copy[x] = b[x];\n        for (int y = 0; y < 16; ++y){\n            if (rand() / (real_t) RAND_MAX < false_margin){\n                a[x] += 1 << y;\n            }\n        }\n    }\n    #pragma acc data copyin(a[0:10 * n]) copy(b[0:10 * n], c[0:10])\n    {\n        #pragma acc parallel loop gang private(temp)\n        for (int y = 0; y < 10; ++y){\n            temp = a[y * n];\n            #pragma acc loop worker reduction(&:temp)\n            for (int x = 1; x < n; ++x){\n                temp = temp & a[y * n + x];\n            }\n            c[y] = temp;\n            #pragma acc loop worker\n            for (int x = 0; x < n; ++x){\n                b[y * n + x] = b[y * n + x] + c[y];\n            }\n        }\n    }\n    for (int x = 0; x < 10; ++x){\n        host_c[x] = a[x * n];\n        for (int y = 1; y < n; ++y){\n            host_c[x] = host_c[x] & a[x * n + y];\n        }\n        if (host_c[x] != c[x]){\n          err += 1;\n        }\n    }\n\n    for (int x = 0; x < 10; ++x){\n        for (int y = 0; y < n; ++y){\n            if (b[x * n + y] != b_copy[x * n + y] + c[x]){\n                err += 1;\n            }\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "parallel",
                            "loop",
                            "reduction",
                            "combined-constructs"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "2": {
                        "content": "#ifndef T2\n//T2:parallel,private,reduction,combined-constructs,loop,V:2.7-2.7\nint test2(){\n    int err = 0;\n    srand(SEED);\n    unsigned int * a = (unsigned int *)malloc(25 * n * sizeof(unsigned int));\n    unsigned int * b = (unsigned int *)malloc(25 * n * sizeof(unsigned int));\n    unsigned int * b_copy = (unsigned int *)malloc(25 * n * sizeof(unsigned int));\n    unsigned int * c = (unsigned int *)malloc(25 * sizeof(unsigned int));\n    unsigned int device[5];\n    unsigned int host[5];\n\n    real_t false_margin = pow(exp(1), log(.5)/n);\n    \n    for (int x = 0; x < 25 * n; ++x){\n        a[x] = 0;\n        b[x] = (unsigned int) rand() / (real_t)(RAND_MAX / 1000);\n        b_copy[x] = b[x];\n        for (int y = 0; y < 16; ++y) {\n            if (rand() / (real_t)RAND_MAX < false_margin) {\n                a[x] += 1 << y;\n            }\n        }\n    }\n\n    #pragma acc data copyin(a[0:25*n]) copy(b[0:25*n], c[0:25])\n    {\n        #pragma acc parallel loop gang private(device)\n        for (int x = 0; x < 5; ++x) {\n            for (int y = 0; y < 5; ++y) {\n                device[y] = a[x * 5 * n + y];\n            }\n            #pragma acc loop worker reduction(&:device)\n            for (int y = 0; y < 5 * n; ++y) {\n                device[y%5] = device[y%5] & a[x * 5 * n + y];\n            }\n            for (int y = 0; y < 5; ++y) {\n                c[x * 5 + y] = device[y];\n            }\n            #pragma acc loop worker\n            for (int y = 0; y < 5 * n; ++y) {\n                b[x * 5 * n + y] = b[x * 5 * n + y] + c[x * 5 + (y % 5)];\n            }\n        }\n    }\n\n    for (int x = 0; x < 5; ++x) {\n        for (int y = 0; y < 5; ++y) {\n            host[y] = a[x * 5 * n + y];\n        }\n        for (int y = 0; y < 5 * n; ++y) {\n            host[y%5] = host[y%5] & a[x * 5 * n + y];\n        }\n        for (int y = 0; y < 5; ++y) {\n            if (host[y] != c[x * 5 + y]) {\n                err += 1;\n            }\n        }\n        for (int y = 0; y < 5 * n; ++y) {\n            if (b[x * 5 * n + y] != (host[y%5] + b_copy[x * 5 * n + y])) {\n                err += 1;\n            }\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T2\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test2();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 1);\n    }\n#endif\n",
                        "tags": [
                            "parallel",
                            "private",
                            "reduction",
                            "combined-constructs",
                            "loop"
                        ],
                        "versions": [
                            "2.7"
                        ]
                    }
                }
            },
            "parallel_loop_reduction_bitand_vector_loop.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:parallel,private,reduction,combined-constructs,loop,V:1.0-2.7\n      LOGICAL FUNCTION test1()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x, y, z, i !Iterators\n        INTEGER,DIMENSION(10*LOOPCOUNT):: a !Data\n        INTEGER,DIMENSION(10):: b\n        INTEGER :: c\n        REAL(8),DIMENSION(160*LOOPCOUNT):: random\n        REAL(8) :: false_margin\n        INTEGER :: errors = 0\n        INTEGER :: temp\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(random)\n        false_margin = exp(log(.5) / n)\n        DO x = 0, 9\n          DO y = 1, LOOPCOUNT\n            DO z = 1, 16\n              IF (random(x * 16 * LOOPCOUNT + (y - 1) * 16 + z - 1) < false_margin) THEN\n                temp = 1\n                DO i = 1, z\n                  temp = temp * 2\n                END DO\n                a(x * LOOPCOUNT + y) = a(x * LOOPCOUNT + y) + temp\n              END IF\n            END DO\n          END DO\n        END DO\n                \n        !$acc data copyin(a(1:10*LOOPCOUNT)), copy(b(1:10))\n          !$acc parallel loop private(c)\n          DO x = 0, 9\n            c = a(x * LOOPCOUNT + 1)\n            !$acc loop vector reduction(iand:c)\n            DO y = 1, LOOPCOUNT\n              c = iand(c, a(x * LOOPCOUNT + y))\n            END DO\n            b(x + 1) = c\n          END DO\n        !$acc end data\n\n        DO x = 0, 9\n          temp = a(x * LOOPCOUNT + 1)\n          DO y = 2, LOOPCOUNT\n            temp = iand(temp, a(x * LOOPCOUNT + y))\n          END DO\n          IF (b(x + 1) .ne. temp) THEN\n            errors = errors + 1\n          END IF\n        END DO       \n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "parallel",
                            "private",
                            "reduction",
                            "combined-constructs",
                            "loop"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "parallel_loop_reduction_bitand_vector_loop.c": {
                "num tests": 2,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:parallel,loop,reduction,combined-constructs,V:1.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    unsigned int* a = (unsigned int *)malloc(10 * n * sizeof(unsigned int));\n    unsigned int* b = (unsigned int *)malloc(10 * sizeof(unsigned int));\n\n    real_t false_margin = pow(exp(1), log(.5)/n);\n    unsigned int temp = 1;\n    unsigned int c = 0;\n    unsigned int b_host;\n\n    for (int x = 0; x < 10 * n; ++x){\n        a[x] = 0;\n        for (int y = 0; y < 16; ++y){\n            if (rand() / (real_t) RAND_MAX < false_margin){\n                a[x] += 1 << y;\n            }\n        }\n    }\n\n    #pragma acc data copyin(a[0:10*n]) copyout(b[0:10])\n    {\n        #pragma acc parallel loop private(c)\n        for (int x = 0; x < 10; ++x){\n            c = a[x * n];\n            #pragma acc loop vector reduction(&:c)\n            for (int y = 1; y < n; ++y){\n                c = c & a[x * n + y];\n            }\n            b[x] = c;\n        }\n    }\n    for (int x = 0; x < 10; ++x){\n        b_host = a[x * n];\n        for (int y = 1; y < n; ++y){\n            b_host = b_host & a[x * n + y];\n        }\n        if (b_host != b[x]){\n            err = 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "parallel",
                            "loop",
                            "reduction",
                            "combined-constructs"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "2": {
                        "content": "#ifndef T2\n//T2:parallel,private,reduction,combined-constructs,loop,V:2.7-2.7\nint test2(){\n    int err = 0;\n    srand(SEED);\n    unsigned int * a = (unsigned int *)malloc(25 * n * sizeof(unsigned int));\n    unsigned int * b = (unsigned int *)malloc(25 * sizeof(unsigned int));\n    real_t false_margin = pow(exp(1), log(.5)/n);\n    unsigned int c[5];\n    unsigned int * b_host = (unsigned int *)malloc(5 * sizeof(unsigned int));\n    \n\n    for (int x = 0; x < 25 * n; ++x){\n        a[x] = 0;\n        for (int y = 0; y < 16; ++y) {\n            if (rand() / (real_t)RAND_MAX < false_margin) {\n                a[x] += 1 << y;\n            }\n        }\n    }\n\n    #pragma acc data copyin(a[0:25*n]) copyout(b[0:25])\n    {\n        #pragma acc parallel loop private(c)\n        for (int x = 0; x < 5; ++x) {\n            for (int y = 0; y < 5; ++y) {\n                c[y] = a[x * 5 * n + y];\n            }\n            #pragma acc loop vector reduction(&:c)\n            for (int y = 0; y < 5 * n; ++y) {\n                c[y%5] = c[y%5] & a[x * 5 * n + y];\n            }\n            for (int y = 0; y < 5; ++y) {\n                b[x * 5 + y] = c[y];\n            }\n        }\n    }\n\n    for (int x = 0; x < 5; ++x) {\n        for (int y = 0; y < 5; ++y) {\n            b_host[y] = a[x * 5 * n + y];\n        }\n        for (int y = 0; y < 5 * n; ++y) {\n            b_host[y%5] = b_host[y%5] & a[x * 5 * n + y];\n        }\n        for (int y = 0; y < 5; ++y) {\n            if (b_host[y] != b[x * 5 + y]){\n                err += 1;\n            }\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T2\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test2();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 1);\n    }\n#endif\n",
                        "tags": [
                            "parallel",
                            "private",
                            "reduction",
                            "combined-constructs",
                            "loop"
                        ],
                        "versions": [
                            "2.7"
                        ]
                    }
                }
            },
            "parallel_loop_reduction_bitor_general.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:parallel,reduction,combined-constructs,loop,V:1.0-2.7\n      LOGICAL FUNCTION test1()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x, y, z !Iterators\n        INTEGER,DIMENSION(LOOPCOUNT):: a !Data\n        REAL(8) :: false_margin\n        REAL(8),DIMENSION(16*LOOPCOUNT):: random\n        INTEGER :: errors = 0\n        INTEGER :: temp\n        INTEGER :: b\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(random)\n        false_margin = exp(log(.5)/n)\n        DO x = 1, LOOPCOUNT\n          DO y = 1, 16\n            IF (random((y - 1) * LOOPCOUNT + x) < false_margin) THEN\n              temp = 1\n              DO z = 1, y\n                temp = temp * 2\n              END DO\n              a(x) = a(x) + temp\n            END IF\n          END DO\n        END DO\n        b = a(1)\n        !$acc data copyin(a(1:LOOPCOUNT))\n          !$acc parallel loop reduction(ior:b)\n          DO x = 2, LOOPCOUNT\n            b = ior(b, a(x))\n          END DO\n        !$acc end data\n        temp = a(1)\n        DO x = 2, LOOPCOUNT\n          temp = ior(temp, a(x))\n        END DO\n        IF (temp .ne. b) THEN\n          errors = errors + 1\n        END IF\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "parallel",
                            "reduction",
                            "combined-constructs",
                            "loop"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "parallel_loop_reduction_bitor_general.c": {
                "num tests": 2,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:parallel,loop,reduction,combined-constructs,V:1.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    unsigned int * a = (unsigned int *)malloc(n * sizeof(unsigned int));\n    real_t false_margin = pow(exp(1), log(.5)/n);\n    unsigned int temp = 1;\n    unsigned int b = 0;\n    unsigned int host_b;\n\n    for (int x = 0; x < n; ++x){\n        a[x] = 0;\n        for (int y = 0; y < 16; ++y){\n            if (rand() / (real_t) RAND_MAX > false_margin){\n                a[x] += 1 << y;\n            }\n        }\n    }\n\n    #pragma acc data copyin(a[0:n])\n    {\n        #pragma acc parallel loop reduction(|:b)\n        for (int x = 0; x < n; ++x){\n            b = b | a[x];\n        }\n    }\n\n    host_b = a[0];\n    for (int x = 1; x < n; ++x){\n        host_b = host_b | a[x];\n    }\n\n    if (b != host_b){\n        err = 1;\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "parallel",
                            "loop",
                            "reduction",
                            "combined-constructs"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "2": {
                        "content": "#ifndef T2\n//T2:parallel,reduction,combined-constructs,loop,V:2.7-2.7\nint test2(){\n    int err = 0;\n    srand(SEED);\n    unsigned int * a = (unsigned int *)malloc(5 * n * sizeof(unsigned int));\n    real_t false_margin = pow(exp(1), log(.5)/n);\n    unsigned int b[5];\n    unsigned int host_b[5];\n\n    for (int x = 0; x < 5 * n; ++x){\n        a[x] = 0;\n        for (int y = 0; y < 16; ++y) {\n            if (rand() / (real_t) RAND_MAX > false_margin) {\n                a[x] += 1 << y;\n            }\n        }\n    }\n\n    for (int x = 0; x < 5; ++x) {\n        b[x] = 0;\n        host_b[x] = 0;\n    }\n\n    #pragma acc data copyin(a[0:5*n])\n    {\n        #pragma acc parallel loop reduction(|:b)\n        for (int x = 0; x < 5 * n; ++x) {\n            b[x%5] = b[x%5] | a[x];\n        }\n    }\n\n    for (int x = 0; x < 5 * n; ++x){\n        host_b[x%5] = host_b[x%5] | a[x];\n    }\n\n    for (int x = 0; x < 5; ++x) {\n        if (host_b[x] != b[x]) {\n            err += 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T2\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test2();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 1);\n    }\n#endif\n",
                        "tags": [
                            "parallel",
                            "reduction",
                            "combined-constructs",
                            "loop"
                        ],
                        "versions": [
                            "2.7"
                        ]
                    }
                }
            },
            "parallel_loop_reduction_bitor_loop.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:parallel,private,reduction,combined-constructs,loop,V:1.0-2.7\n      LOGICAL FUNCTION test1()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x, y, z, i !Iterators\n        INTEGER,DIMENSION(10*LOOPCOUNT):: a, b, b_copy !Data\n        REAL(8),DIMENSION(10*LOOPCOUNT):: randoms2\n        INTEGER,DIMENSION(10) :: c\n        REAL(8),DIMENSION(160*LOOPCOUNT):: randoms\n        REAL(8) :: false_margin\n        INTEGER :: errors = 0\n        INTEGER :: temp\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(randoms)\n        CALL RANDOM_NUMBER(randoms2)\n        false_margin = exp(log(.5)/n)\n        b = FLOOR(6*randoms2)\n        b_copy = b\n        DO x = 0, 9\n          DO y = 1, LOOPCOUNT\n            DO z = 1, 16\n              IF (randoms(x * 16 * LOOPCOUNT + y * 16 + z - 1) .gt. false_margin) THEN\n                temp = 1\n                DO i = 1, z\n                  temp = temp * 2\n                END DO\n                a(x * LOOPCOUNT + y) = a(x * LOOPCOUNT + y) + temp\n              END IF\n            END DO\n          END DO\n        END DO\n\n        !$acc data copyin(a(1:10*LOOPCOUNT)) copy(b(1:10*LOOPCOUNT), c(1:10))\n          !$acc parallel loop gang private(temp)\n          DO x = 0, 9\n            temp = 0\n            !$acc loop worker reduction(ior:temp)\n            DO y = 1, LOOPCOUNT\n              temp = ior(temp, a(x * LOOPCOUNT + y))\n            END DO\n            c(x + 1) = temp\n            !$acc loop worker\n            DO y = 1, LOOPCOUNT\n              b(x * LOOPCOUNT + y) = b(x * LOOPCOUNT + y) + c(x + 1)\n            END DO\n          END DO\n        !$acc end data\n        \n        DO x = 0, 9\n          temp = 0\n          DO y = 1, LOOPCOUNT\n            temp = ior(temp, a(x * LOOPCOUNT + y))\n          END DO\n          IF (temp .ne. c(x + 1)) THEN\n            errors = errors + 1\n          END IF\n          DO y = 1, LOOPCOUNT\n            IF (b(x * LOOPCOUNT + y) .ne. b_copy(x * LOOPCOUNT + y) + c(x + 1)) THEN\n              errors = errors + 1\n            END IF\n          END DO\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "parallel",
                            "private",
                            "reduction",
                            "combined-constructs",
                            "loop"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "parallel_loop_reduction_bitor_loop.c": {
                "num tests": 2,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:parallel,loop,reduction,combined-constructs,V:1.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    unsigned int * a = (unsigned int *)malloc(10 * n * sizeof(unsigned int));\n    unsigned int * b = (unsigned int *)malloc(10 * n * sizeof(unsigned int));\n    unsigned int * b_copy = (unsigned int *)malloc(10 * n * sizeof(unsigned int));\n    unsigned int * c = (unsigned int *)malloc(10 * sizeof(unsigned int));\n\n    real_t false_margin = pow(exp(1), log(.5)/n);\n    unsigned int temp = 1;\n    unsigned int host_c;\n\n    for (int x = 0; x < 10; ++x){\n        for (int y = 0; y < n; ++y){\n            b[x * n + y] = (unsigned int) rand() / (real_t)(RAND_MAX / 1000);\n            b_copy[x * n + y] = b[x * n + y];\n            for (int z = 0; z < 16; ++z){\n                a[x * n + y] += (1<<z);\n            }\n        }\n    }\n\n    #pragma acc data copyin(a[0:10*n]) copy(b[0:10*n], c[0:10])\n    {\n        #pragma acc parallel loop gang private(temp)\n        for (int x = 0; x < 10; ++x){\n            temp = 0;\n            #pragma acc loop worker reduction(|:temp)\n            for (int y = 0; y < n; ++y){\n                temp = temp | a[x * n + y];\n            }\n            c[x] = temp;\n            #pragma acc loop worker\n            for (int y = 0; y < n; ++y){\n                b[x * n + y] = b[x * n + y] + c[x];\n            }\n        }\n    }\n    for (int x = 0; x < 10; ++x){\n        host_c = a[x * n];\n        for (int y = 1; y < n; ++y){\n            host_c = host_c | a[x * n + y];\n        }\n        if (host_c != c[x]){\n            err += 1;\n        }\n        for (int y = 0; y < n; ++y){\n            if (b[x * n + y] != b_copy[x * n + y] + host_c){\n                err += 1;\n            }\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "parallel",
                            "loop",
                            "reduction",
                            "combined-constructs"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "2": {
                        "content": "#ifndef T2\n//T2:parallel,private,reduction,combined-constructs,loop,V:2.7-2.7\nint test2(){\n    int err = 0;\n    srand(SEED);\n    unsigned int * a = (unsigned int *)malloc(25 * n * sizeof(unsigned int));\n    unsigned int * b = (unsigned int *)malloc(25 * n * sizeof(unsigned int));\n    unsigned int * b_copy = (unsigned int *)malloc(25 * n * sizeof(unsigned int));\n    unsigned int * c = (unsigned int *)malloc(25 * sizeof(unsigned int));\n    unsigned int temp[5];\n\n    real_t false_margin = pow(exp(1), log(.5)/n);\n\n    for (int x = 0; x < 25 * n; ++x){\n        b[x] = (unsigned int) rand() / (real_t)(RAND_MAX / 1000);\n        b_copy[x] = b[x];\n        for (int y = 0; y < 16; ++y) {\n            if (rand() / (real_t)RAND_MAX > false_margin) {\n                a[x] += (1<<y);\n            }\n        }\n    }\n\n    #pragma acc data copyin(a[0:25*n]) copy(b[0:25*n], c[0:25])\n    {\n        #pragma acc parallel loop gang private(temp)\n        for (int x = 0; x < 5; ++x) {\n            for (int y = 0; y < 5; ++y) {\n                temp[y] = 0;\n            }\n            #pragma acc loop worker reduction(|:temp)\n            for (int y = 0; y < 5 * n; ++y) {\n                temp[y%5] = temp[y%5] | a[x * 5 * n + y];\n            }\n            for (int y = 0; y < 5; ++y) {\n                c[x * 5 + y] = temp[y];\n            }\n            #pragma acc loop worker\n            for (int y = 0; y < 5 * n; ++y) {\n                b[x * 5 * n + y] = b[x * 5 * n + y] + c[x * 5 + (y % 5)];\n            }\n        }\n    }\n\n    for (int x = 0; x < 5; ++x){\n        for (int y = 0; y < 5; ++y){\n            temp[y] = 0;\n        }\n        for (int y = 0; y < 5 * n; ++y) {\n            temp[y%5] = temp[y%5] | a[x * 5 * n + y];\n        }\n        for (int y = 0; y < 5; ++y){\n            if (c[x * 5 + y] != temp[y]) {\n                err += 1;\n            }\n        }\n        for (int y = 0; y < 5 * n; ++y) {\n            if ((b_copy[x * 5 * n + y] + c[x * 5 + (y % 5)]) != b[x * 5 * n + y]) {\n                err += 1;\n            }\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T2\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test2();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 1);\n    }\n#endif\n",
                        "tags": [
                            "parallel",
                            "private",
                            "reduction",
                            "combined-constructs",
                            "loop"
                        ],
                        "versions": [
                            "2.7"
                        ]
                    }
                }
            },
            "parallel_loop_reduction_bitor_vector_loop.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:parallel,private,reduction,combined-constructs,loop,V:1.0-2.7\n      LOGICAL FUNCTION test1()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x, y, z !Iterators\n        INTEGER,DIMENSION(10 * LOOPCOUNT):: a !Data\n        INTEGER,DIMENSION(10) :: b\n        REAL(8) :: false_margin\n        REAL(8),DIMENSION(160 * LOOPCOUNT) :: randoms\n        INTEGER :: errors = 0\n        INTEGER :: temp\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(randoms)\n        false_margin = exp(log(.5) / n)\n        DO x = 1, 10 * LOOPCOUNT\n          DO y = 1, 16\n            IF (randoms(y * 10 * LOOPCOUNT + y - 1) .gt. false_margin) THEN\n              temp = 1\n              DO z = 1, y\n                temp = temp * 2\n              END DO\n              a(x) = a(x) + temp\n            END IF\n          END DO\n        END DO\n\n        !$acc data copyin(a(1:10*LOOPCOUNT)) copy(b(1:10))\n          !$acc parallel loop private(temp)\n          DO x = 0, 9\n            temp = 0\n            !$acc loop vector reduction(ior:temp)\n            DO y = 1, LOOPCOUNT\n              temp = ior(temp, a(x * LOOPCOUNT + y))\n            END DO\n            b(x + 1) = temp\n          END DO\n        !$acc end data\n\n        DO x = 0, 9\n          temp = 0\n          DO y = 1, LOOPCOUNT\n            temp = ior(temp, a(x * LOOPCOUNT + y))\n          END DO\n          IF (temp .ne. b(x + 1)) THEN\n            errors = errors + 1\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "parallel",
                            "private",
                            "reduction",
                            "combined-constructs",
                            "loop"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "parallel_loop_reduction_bitor_vector_loop.c": {
                "num tests": 2,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:parallel,loop,reduction,combined-constructs,V:1.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    unsigned int* a = (unsigned int *)malloc(10 * n * sizeof(unsigned int));\n    unsigned int* b = (unsigned int *)malloc(10 * sizeof(unsigned int));\n\n    real_t false_margin = pow(exp(1), log(.5)/n);\n    unsigned int temp = 1;\n    unsigned int b_host;\n\n    for (int x = 0; x < 10 * n; ++x){\n        for (int y = 0; y < 16; ++y){\n            if (rand() / (real_t) RAND_MAX > false_margin){\n                for (int z = 0; z < y; ++z){\n                    temp *= 2;\n                }\n                a[x] += temp;\n                temp = 1;\n            }\n        }\n    }\n    temp = 0;\n    #pragma acc data copyin(a[0:10*n]) copy(b[0:10])\n    {\n        #pragma acc parallel loop private(temp)\n        for (int x = 0; x < 10; ++x){\n            temp = 0;\n            #pragma acc loop vector reduction(|:temp)\n            for (int y = 0; y < n; ++y){\n                temp = temp | a[x * n + y];\n            }\n            b[x] = temp;\n        }\n    }\n\n    for (int x = 0; x < 10; ++x){\n        b_host = a[x * n];\n        for (int y = 1; y < n; ++y){\n            b_host = b_host | a[x * n + y];\n        }\n        if (b_host != b[x]){\n            err = 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "parallel",
                            "loop",
                            "reduction",
                            "combined-constructs"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "2": {
                        "content": "#ifndef T2\n//T2:parallel,private,reduction,combined-constructs,loop,V:2.7-2.7\nint test2(){\n    int err = 0;\n    srand(SEED);\n    unsigned int * a = (unsigned int *)malloc(25 * n * sizeof(unsigned int));\n    unsigned int * b = (unsigned int *)malloc(25 * sizeof(unsigned int));\n\n    unsigned int reduced[5];\n    real_t false_margin = pow(exp(1), log(.5)/n);\n    \n    for (int x = 0; x < 25 * n; ++x) {\n        a[x] = 0;\n        for (int y = 0; y < 16; ++y) {\n            if (rand() / (real_t)RAND_MAX > false_margin) {\n                a[x] += 1<<y;\n            }\n        }\n    }\n\n    #pragma acc data copyin(a[0:25*n]) copy(b[0:25])\n    {\n        #pragma acc parallel loop private(reduced)\n        for (int x = 0; x < 5; ++x) {\n            for (int y = 0; y < 5; ++y) {\n                reduced[y] = 0;\n            }\n            #pragma acc loop vector reduction(|:reduced)\n            for (int y = 0; y < 5 * n; ++y) {\n                reduced[y%5] = reduced[y%5] | a[x * 5 * n + y];\n            }\n            for (int y = 0; y < 5; ++y) {\n                b[x * 5 + y] = reduced[y];\n            }\n        }\n    }\n\n    for (int x = 0; x < 5; ++x) {\n        for (int y = 0; y < 5; ++y) {\n            reduced[y] = 0;\n        }\n        for (int y = 0; y < 5 * n; ++y) {\n            reduced[y%5] = reduced[y%5] | a[x * 5 * n + y];\n        }\n        for (int y = 0; y < 5; ++y) {\n            if (b[x * 5 + y] != reduced[y]) {\n                err += 1;\n            }\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T2\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test2();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 1);\n    }\n#endif\n",
                        "tags": [
                            "parallel",
                            "private",
                            "reduction",
                            "combined-constructs",
                            "loop"
                        ],
                        "versions": [
                            "2.7"
                        ]
                    }
                }
            },
            "parallel_loop_reduction_bitxor_general.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:parallel,reduction,combined-constructs,loop,V:1.0-2.7\n      LOGICAL FUNCTION test1()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x !Iterators\n        INTEGER,DIMENSION(LOOPCOUNT):: a !Data\n        REAL(8),DIMENSION(LOOPCOUNT):: randoms\n        INTEGER :: errors = 0\n        INTEGER :: b = 0\n        INTEGER :: temp = 0\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(randoms)\n        a = FLOOR(randoms*1000000)\n\n        !$acc data copyin(a(1:LOOPCOUNT))\n          !$acc parallel loop reduction(ieor:b)\n          DO x = 1, LOOPCOUNT\n            b = ieor(b, a(x))\n          END DO\n        !$acc end data\n\n        DO x = 1, LOOPCOUNT\n          temp = ieor(temp, a(x))\n        END DO\n        IF (temp .ne. b) THEN\n          errors = errors + 1\n        END IF\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "parallel",
                            "reduction",
                            "combined-constructs",
                            "loop"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "parallel_loop_reduction_bitxor_general.c": {
                "num tests": 2,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:parallel,reduction,combined-constructs,loop,V:1.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    unsigned int * a = (unsigned int *)malloc(n * sizeof(unsigned int));\n    unsigned int b = 0;\n    unsigned int host_b = 0;\n\n    for (int x = 0; x < n; ++x){\n        a[x] = (unsigned int) rand() / (real_t) (RAND_MAX / 2);\n    }\n\n    #pragma acc data copyin(a[0:n])\n    {\n        #pragma acc parallel loop reduction(^:b)\n        for (int x = 0; x < n; ++x){\n            b = b ^ a[x];\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        host_b = host_b ^ a[x];\n    }\n    if (b != host_b){\n        err = 1;\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "parallel",
                            "reduction",
                            "combined-constructs",
                            "loop"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "2": {
                        "content": "#ifndef T2\n//T2:parallel,reduction,combined-constructs,loop,V:2.7-2.7\nint test2(){\n    int err = 0;\n    srand(SEED);\n    unsigned int * a = (unsigned int *)malloc(10 * n * sizeof(unsigned int));\n    unsigned int b[10];\n    unsigned int host_b[10];\n\n    for (int x = 0; x < 10 * n; ++x){\n        a[x] = (unsigned int) rand() / (real_t) (RAND_MAX / 2);\n    }\n\n    for (int x = 0; x < 10; ++x) {\n        b[x] = 0;\n        host_b[x] = 0;\n    }\n\n    #pragma acc data copyin(a[0:10*n])\n    {\n        #pragma acc parallel loop reduction(^:b)\n        for (int x = 0; x < 10 * n; ++x) {\n            b[x % 10] = b[x % 10] ^ a[x];\n        }\n    }\n\n    for (int x = 0; x < 10 * n; ++x) {\n        host_b[x % 10] = host_b[x % 10] ^ a[x];\n    }\n\n    for (int x = 0; x < 10; ++x) {\n        if (host_b[x] != b[x]) {\n            err += 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T2\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test2();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 1);\n    }\n#endif\n",
                        "tags": [
                            "parallel",
                            "reduction",
                            "combined-constructs",
                            "loop"
                        ],
                        "versions": [
                            "2.7"
                        ]
                    }
                }
            },
            "parallel_loop_reduction_bitxor_loop.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:parallel,private,reduction,combined-constructs,loop,V:1.0-2.7\n      LOGICAL FUNCTION test1()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x, y !Iterators\n        INTEGER,DIMENSION(10*LOOPCOUNT):: a, b, b_copy !Data\n        REAL(8),DIMENSION(10*LOOPCOUNT):: randoms, randoms2\n        INTEGER,DIMENSION(10):: c\n        REAL*8 :: RAND\n        INTEGER :: errors = 0\n        INTEGER :: temp\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(randoms)\n        a = FLOOR(randoms*1000000)\n        CALL RANDOM_NUMBER(randoms2)\n        b = FLOOR(randoms2*1000000)\n        b_copy = b\n        c = 0\n\n        !$acc data copyin(a(1:10*LOOPCOUNT)) copy(b(1:10*LOOPCOUNT), c(1:10))\n          !$acc parallel loop gang private(temp)\n          DO x = 0, 9\n            temp = 0\n            !$acc loop worker reduction(ieor:temp)\n            DO y = 1, LOOPCOUNT\n              temp = ieor(temp, a(x * LOOPCOUNT + y))\n            END DO\n            c(x + 1) = temp\n            !$acc loop worker\n            DO y = 1, LOOPCOUNT\n              b(x * LOOPCOUNT + y) = b(x * LOOPCOUNT + y) + c(x + 1)\n            END DO\n          END DO\n        !$acc end data\n\n        DO x = 0, 9\n          temp = 0\n          DO y = 1, LOOPCOUNT\n            temp = ieor(temp, a(x * LOOPCOUNT + y))\n          END DO\n          IF (temp .ne. c(x + 1)) THEN\n            errors = errors + 1\n          END IF\n          DO y = 1, LOOPCOUNT\n            IF (b(x * LOOPCOUNT + y) .ne. b_copy(x * LOOPCOUNT + y) + c(x + 1)) THEN\n              errors = errors + 1\n            END IF\n          END DO\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "parallel",
                            "private",
                            "reduction",
                            "combined-constructs",
                            "loop"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "parallel_loop_reduction_bitxor_loop.c": {
                "num tests": 2,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:parallel,loop,reduction,combined-constructs,V:1.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    unsigned int * a = (unsigned int *)malloc(10 * n * sizeof(unsigned int));\n    unsigned int * b = (unsigned int *)malloc(10 * n * sizeof(unsigned int));\n    unsigned int * b_copy = (unsigned int *)malloc(10 * n * sizeof(unsigned int));\n    unsigned int * c = (unsigned int *)malloc(10 * sizeof(unsigned int));\n    unsigned int temp = 0;\n\n    for (int x = 0; x < 10*n; ++x){\n        b[x] = (unsigned int) rand() / (real_t)(RAND_MAX / 1000);\n        b_copy[x] = b[x];\n        a[x] = (unsigned int) rand() / (real_t)(RAND_MAX / 1000);\n    }\n    for (int x = 0; x < 10; ++x){\n        c[x] = 0;\n    }\n\n    #pragma acc data copyin(a[0:10*n]) copy(b[0:10*n], c[0:10])\n    {\n        #pragma acc parallel loop gang private(temp)\n        for (int x = 0; x < 10; ++x){\n            temp = 0;\n            #pragma acc loop worker reduction(^:temp)\n            for (int y = 0; y < n; ++y){\n                temp = temp ^ a[x * n + y];\n            }\n            c[x] = temp;\n            #pragma acc loop worker\n            for (int y = 0; y < n; ++y){\n                b[x * n + y] = b[x * n + y] + c[x];\n            }\n        }\n    }\n\n    for (int x = 0; x < 10; ++x){\n        temp = 0;\n        for (int y = 0; y < n; ++y){\n            temp = temp ^ a[x * n + y];\n        }\n        if (temp != c[x]){\n            err += 1;\n        }\n        for (int y = 0; y < n; ++y){\n            if (b[x * n + y] != b_copy[x * n + y] + c[x]){\n                err += 1;\n            }\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "parallel",
                            "loop",
                            "reduction",
                            "combined-constructs"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "2": {
                        "content": "#ifndef T2\n//T2:parallel,private,reduction,combined-constructs,loop,nonvalidating,V:2.7-2.7\nint test2(){\n    int err = 0;\n    srand(SEED);\n    unsigned int * a = (unsigned int *)malloc(25 * n * sizeof(unsigned int));\n    unsigned int * b = (unsigned int *)malloc(25 * n * sizeof(unsigned int));\n    unsigned int * b_copy = (unsigned int *)malloc(25 * n * sizeof(unsigned int));\n    unsigned int * c = (unsigned int *)malloc(25 * sizeof(unsigned int));\n\n    unsigned int temp[5];\n\n    for (int x = 0; x < n; ++x){\n        a[x] = (unsigned int) rand() / (real_t)(RAND_MAX / 1000);\n        b[x] = (unsigned int) rand() / (real_t)(RAND_MAX / 1000);\n        b_copy[x] = b[x];\n    }\n\n    for (int x = 0; x < 25; ++x) {\n        c[x] = 0;\n    }\n\n    for (int x = 0; x < 5; ++x) {\n        temp[x] = 0;\n    }\n\n    #pragma acc data copyin(a[0:25*n]) copy(b[0:25*n], c[0:25])\n    {\n        #pragma acc parallel loop gang private(temp)\n        for (int x = 0; x < 5; ++x) {\n            for (int y = 0; y < 5; ++y) {\n                temp[y] = 0;\n            }\n            #pragma acc loop worker reduction(^:temp)\n            for (int y = 0; y < 5 * n; ++y) {\n                temp[y % 5] = temp[y % 5] ^ a[x * 5 * n + y];\n            }\n            for (int y = 0; y < 5; ++y) {\n                c[x * 5 + y] = temp[y];\n            }\n            #pragma acc loop worker\n            for (int y = 0; y < 5 * n; ++y) {\n                b[x * 5 * n + y] = b[x * 5 * n + y] + c[x * 5 + (y % 5)];\n            }\n        }\n    }\n\n    for (int x = 0; x < 5; ++x) {\n        for (int y = 0; y < 5; ++y) {\n            temp[y] = 0;\n        }\n        for (int y = 0; y < 5 * n; ++y) {\n            temp[y % 5] = temp[y % 5] ^ a[x * 5 * n + y];\n        }\n        \n    }\n\n    return err;\n}\n#endif\n#ifndef T2\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test2();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 1);\n    }\n#endif\n",
                        "tags": [
                            "parallel",
                            "private",
                            "reduction",
                            "combined-constructs",
                            "loop",
                            "nonvalidating"
                        ],
                        "versions": [
                            "2.7"
                        ]
                    }
                }
            },
            "parallel_loop_reduction_bitxor_vector_loop.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:parallel,private,reduction,combined-constructs,loop,V:1.0-2.7\n      LOGICAL FUNCTION test1()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x, y !Iterators\n        INTEGER,DIMENSION(10*LOOPCOUNT):: a !Data\n        REAL(8),DIMENSION(10*LOOPCOUNT):: randoms\n        INTEGER,DIMENSION(10):: b\n        INTEGER :: errors = 0\n        INTEGER :: temp\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(randoms)\n        a = FLOOR(randoms*1000000)\n\n        !$acc data copyin(a(1:10*LOOPCOUNT)) copy(b(1:10))\n          !$acc parallel loop gang private(temp)\n          DO x = 0, 9\n            temp = 0\n            !$acc loop vector reduction(ieor:temp)\n            DO y = 1, LOOPCOUNT\n              temp = ieor(temp, a(x * LOOPCOUNT + y))\n            END DO\n            b(x + 1) = temp\n          END DO\n        !$acc end data\n        \n        DO x = 0, 9\n          temp = 0\n          DO y = 1, LOOPCOUNT\n            temp = ieor(temp, a(x * LOOPCOUNT + y))\n          END DO\n          IF (temp .ne. b(x + 1)) THEN\n            errors = errors + 1\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "parallel",
                            "private",
                            "reduction",
                            "combined-constructs",
                            "loop"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "parallel_loop_reduction_bitxor_vector_loop.c": {
                "num tests": 2,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:parallel,loop,reduction,combined-constructs,V:1.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    unsigned int* a = (unsigned int *)malloc(10 * n * sizeof(unsigned int));\n    unsigned int* b = (unsigned int *)malloc(10 * sizeof(unsigned int));\n\n    unsigned int temp = 0;\n    unsigned int b_host;\n\n    for (int x = 0; x < 10 * n; ++x){\n        a[x] = (unsigned int) rand() / (real_t) (RAND_MAX / 2);\n    }\n\n    #pragma acc data copyin(a[0:10*n]) copy(b[0:10])\n    {\n        #pragma acc parallel loop private(temp)\n        for (int x = 0; x < 10; ++x){\n            temp = 0;\n            #pragma acc loop vector reduction(^:temp)\n            for (int y = 0; y < n; ++y){\n                temp = temp ^ a[x * n + y];\n            }\n            b[x] = temp;\n        }\n    }\n\n    for (int x = 0; x < 10; ++x){\n        b_host = a[x * n];\n        for (int y = 1; y < n; ++y){\n            b_host = b_host ^ a[x * n + y];\n        }\n        if (b_host != b[x]){\n            err = 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "parallel",
                            "loop",
                            "reduction",
                            "combined-constructs"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "2": {
                        "content": "#ifndef T2\n//T2:parallel,private,reduction,combined-constructs,loop,V:2.7-2.7\nint test2(){\n    int err = 0;\n    srand(SEED);\n    unsigned int * a = (unsigned int *)malloc(25 * n * sizeof(unsigned int));\n    unsigned int * b = (unsigned int *)malloc(25 * sizeof(unsigned int));\n\n    unsigned int temp[5];\n\n    for (int x = 0; x < 25 * n; ++x){\n        a[x] = (unsigned int) rand() / (real_t) (RAND_MAX / 2);\n    }\n\n    #pragma acc data copyin(a[0:25*n]) copy(b[0:25])\n    {\n        #pragma acc parallel loop private(temp)\n        for (int x = 0; x < 5; ++x) {\n            for (int y = 0; y < 5; ++y){\n                temp[y] = 0;\n            }\n            #pragma acc loop vector reduction(^:temp)\n            for (int y = 0; y < 5 * n; ++y) {\n                temp[y % 5] = temp[y % 5] ^ a[x * 5 * n + y];\n            }\n            for (int y = 0; y < 5; ++y) {\n                b[x * 5 + y] = temp[y];\n            }\n        }\n    }\n\n    for (int x = 0; x < 5; ++x) {\n        for (int y = 0; y < 5; ++y) {\n            temp[y] = 0;\n        }\n        for (int y = 0; y < 5 * n; ++y) {\n            temp[y % 5] = temp[y % 5] ^ a[x * 5 * n + y];\n        }\n        for (int y = 0; y < 5; ++y) {\n            if (b[x * 5 + y] != temp[y]) {\n                err += 1;\n            }\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T2\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test2();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 1);\n    }\n#endif\n",
                        "tags": [
                            "parallel",
                            "private",
                            "reduction",
                            "combined-constructs",
                            "loop"
                        ],
                        "versions": [
                            "2.7"
                        ]
                    }
                }
            },
            "parallel_loop_reduction_max_general.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:parallel,reduction,combined-constructs,loop,V:1.0-2.7\n      LOGICAL FUNCTION test1()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT):: a, b !Data\n        REAL(8) :: maximum, temp\n        INTEGER :: errors = 0\n\n        !Initilization\n        maximum = 0\n        temp = 0\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(a)\n        CALL RANDOM_NUMBER(b)\n\n        !$acc data copyin(a(1:LOOPCOUNT), b(1:LOOPCOUNT))\n          !$acc parallel loop reduction(max:maximum)\n          DO x = 1, LOOPCOUNT\n            maximum = max(maximum, a(x) * b(x))\n          END DO\n        !$acc end data\n\n        DO x = 1, LOOPCOUNT\n          temp = max(temp, a(x) * b(x))\n        END DO\n        IF (abs(temp - maximum) .gt. PRECISION) THEN\n          errors = errors + 1\n        END IF\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "parallel",
                            "reduction",
                            "combined-constructs",
                            "loop"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "parallel_loop_reduction_max_general.c": {
                "num tests": 2,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:parallel,loop,reduction,combined-constructs,V:1.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n    real_t max = 0.0;\n    int found = 0;\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX/10);\n        b[x] = rand() / (real_t)(RAND_MAX/10);\n    }\n    #pragma acc data copyin(a[0:n], b[0:n])\n    {\n        #pragma acc parallel loop reduction(max:max)\n        for (int x = 0; x < n; ++x){\n            max = fmax(a[x] * b[x], max);\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        if (fabs(max - (a[x] * b[x] + PRECISION)) < 0){\n            err = 1;\n        }\n        if (fabs(max - (a[x] * b[x] - PRECISION)) > 0){\n            found = 1;\n        }\n    }\n    if (found = 0){\n        err = 1;\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "parallel",
                            "loop",
                            "reduction",
                            "combined-constructs"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "2": {
                        "content": "#ifndef T2\n//T2:parallel,reduction,combined-constructs,loop,V:2.7-2.7\nint test2(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(10 * n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(10 * n * sizeof(real_t));\n    real_t maximums[10];\n    real_t max_host[10];\n\n    for (int x = 0; x < 10 * n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n    }\n\n    for (int x = 0; x < 10; ++x) {\n        maximums[x] = 0;\n        max_host[x] = 0;\n    }\n\n    #pragma acc data copyin(a[0:10*n], b[0:10*n])\n    {\n        #pragma acc parallel loop reduction(max:maximums)\n        for (int x = 0; x < 10 * n; ++x) {\n            maximums[x%10] = fmax(a[x] * b[x], maximums[x%10]);\n        }\n    }\n\n    for (int x = 0; x < 10 * n; ++x) {\n        max_host[x%10] = fmax(a[x] * b[x], maximums[x%10]);\n    }\n    \n    for (int x = 0; x < 10; ++x) {\n        if (fabs(max_host[x] - maximums[x]) > PRECISION) {\n            err += 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T2\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test2();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 1);\n    }\n#endif\n",
                        "tags": [
                            "parallel",
                            "reduction",
                            "combined-constructs",
                            "loop"
                        ],
                        "versions": [
                            "2.7"
                        ]
                    }
                }
            },
            "parallel_loop_reduction_max_loop.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:parallel,private,reduction,combined-constructs,loop,V:1.0-2.7\n      LOGICAL FUNCTION test1()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x, y !Iterators\n        REAL(8),DIMENSION(10 * LOOPCOUNT):: a, b, c !Data\n        REAL(8),DIMENSION(10):: maximum\n        REAL(8) :: temp\n        INTEGER :: errors = 0\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(a)\n        CALL RANDOM_NUMBER(b)\n        c = 0\n\n        !$acc data copyin(a(1:10*LOOPCOUNT), b(1:10*LOOPCOUNT)) copy(c(1:10*LOOPCOUNT))\n          !$acc parallel loop gang private(temp)\n          DO x = 0, 9\n            temp = 0\n            !$acc loop worker reduction(max:temp)\n            DO y = 1, LOOPCOUNT\n              temp = max(temp, a(x * LOOPCOUNT + y) * b(x * LOOPCOUNT + y))\n            END DO\n            maximum(x + 1) = temp\n            !$acc loop worker\n            DO y = 1, LOOPCOUNT\n              c(x * LOOPCOUNT + y) = (a(x * LOOPCOUNT + y) * b(x * LOOPCOUNT + y)) / maximum(x + 1)\n            END DO\n          END DO\n        !$acc end data\n        \n        DO x = 0, 9\n          DO y = 1, LOOPCOUNT\n            IF (a(x * LOOPCOUNT + y) * b(x * LOOPCOUNT + y) - maximum(x + 1) .gt. PRECISION) THEN\n              errors = errors + 1\n            ELSE IF ((c(x * LOOPCOUNT + y) - 1) .gt. PRECISION) THEN\n              errors = errors + 1\n            END IF\n          END DO\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "parallel",
                            "private",
                            "reduction",
                            "combined-constructs",
                            "loop"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "parallel_loop_reduction_max_loop.c": {
                "num tests": 2,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:parallel,loop,reduction,combined-constructs,V:1.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(10 * n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(10 * n * sizeof(real_t));\n    real_t * c = (real_t *)malloc(10 * n * sizeof(real_t));\n    real_t * maximum = (real_t *)malloc(10 * sizeof(real_t));\n    real_t temp = 0;\n    real_t max = 0.0;\n\n    for (int x = 0; x < 10 * n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX/10);\n        b[x] = rand() / (real_t)(RAND_MAX/10);\n        c[x] = 0.0;\n    }\n    for (int x = 0; x < 10; ++x){\n        maximum[x] = 0;\n    }\n\n    #pragma acc data copyin(a[0:10*n], b[0:10*n]) copy(c[0:10*n], maximum[0:10])\n    {\n        #pragma acc parallel loop gang private(temp)\n        for (int x = 0; x < 10; ++x){\n            temp = 0;\n            #pragma acc loop worker reduction(max:temp)\n            for (int y = 0; y < n; ++y){\n                temp = fmax(a[x * n + y] * b[x * n + y], temp);\n            }\n            maximum[x] = temp;\n            #pragma acc loop worker\n            for (int y = 0; y < n; ++y){\n                c[x * n + y] = (a[x * n + y] * b[x * n + y]) / maximum[x];\n            }\n        }\n    }\n    for (int x = 0; x < 10; ++x){\n        temp = 0;\n        for (int y = 0; y < n; ++y){\n            temp = fmax(temp, a[x * n + y] * b[x * n + y]);\n        }\n        if (fabs(temp - maximum[x]) > PRECISION){\n            err += 1;\n        }\n        for (int y = 0; y < n; ++y){\n            if (c[x * n + y] > 1){\n                err += 1;\n            }\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "parallel",
                            "loop",
                            "reduction",
                            "combined-constructs"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "2": {
                        "content": "#ifndef T2\n//T2:parallel,private,reduction,combined-constructs,loop,V:2.7-2.7\nint test2(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(25 * n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(25 * n * sizeof(real_t));\n    real_t * c = (real_t *)malloc(25 * n * sizeof(real_t));\n    real_t * maximum = (real_t *)malloc(25 * sizeof(real_t));\n    real_t * host_maximum = (real_t *)malloc(25 * sizeof(real_t));\n    real_t temp[5];\n\n    for (int x = 0; x < 25 * n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n        c[x] = 0;\n    }\n\n    for (int x = 0; x < 25; ++x) {\n        maximum[x] = 0;\n        host_maximum[x] = 0;\n    }\n\n    #pragma acc data copyin(a[0:25*n], b[0:25*n]) copy(c[0:25*n], maximum[0:25])\n    {\n        #pragma acc parallel loop gang private(temp)\n        for (int x = 0; x < 5; ++x) {\n            for (int y = 0; y < 5; ++y) {\n                temp[y] = 0;\n            }\n            #pragma acc loop worker reduction(max:temp)\n            for (int y = 0; y < 5 * n; ++y) {\n                temp[y%5] = fmax(a[x * 5 * n + y] * b[x * 5 * n + y], temp[y%5]);\n            }\n            for (int y = 0; y < 5; ++y) {\n                maximum[x * 5 + y] = temp[y];\n            }\n            #pragma acc loop worker\n            for (int y = 0; y < 5 * n; ++y) {\n                c[x * 5 * n + y] = (a[x * 5 * n + y] * b[x * 5 * n + y]) / maximum[x * 5 + (y % 5)];\n            }\n        }\n    }\n\n    for (int x = 0; x < 5; ++x) {\n        for (int y = 0; y < 5 * n; ++y) {\n            host_maximum[x * 5 + (y % 5)] = fmax(a[x * 5 * n + y] * b[x * 5 * n + y], host_maximum[x * 5 + (y % 5)]);\n        }\n        for (int y = 0; y < 5; ++y) {\n            if (fabs(host_maximum[x * 5 + y] - maximum[x * 5 + y]) > PRECISION) {\n                err += 1;\n            }\n        }\n        for (int y = 0; y < 5 * n; ++y) {\n            if (fabs(c[x * 5 * n + y] - ((a[x * 5 * n + y] * b[x * 5 * n + y]) / maximum[x * 5 + (y % 5)])) > PRECISION) {\n                err += 1;\n            }\n        }\n    }\n\n\n    return err;\n}\n#endif\n#ifndef T2\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test2();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 1);\n    }\n#endif\n",
                        "tags": [
                            "parallel",
                            "private",
                            "reduction",
                            "combined-constructs",
                            "loop"
                        ],
                        "versions": [
                            "2.7"
                        ]
                    }
                }
            },
            "parallel_loop_reduction_max_vector_loop.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:parallel,private,reduction,combined-constructs,loop,V:1.0-2.7\n      LOGICAL FUNCTION test1()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x, y !Iterators\n        REAL(8),DIMENSION(10 * LOOPCOUNT):: a, b !Data\n        REAL(8),DIMENSION(10):: maximum\n        INTEGER :: errors = 0\n        REAL(8) :: temp\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(a)\n        CALL RANDOM_NUMBER(b)\n        maximum = 0\n\n        !$acc data copyin(a(1:10*LOOPCOUNT), b(1:10*LOOPCOUNT)) copy(maximum(1:10))\n          !$acc parallel loop private(temp)\n          DO x = 0, 9\n            temp = 0\n            !$acc loop vector reduction(max:temp)\n            DO y = 1, LOOPCOUNT\n              temp = max(temp, a(x * LOOPCOUNT + y) * b(x * LOOPCOUNT + y))\n            END DO\n            maximum(x + 1) = temp\n          END DO\n        !$acc end data\n\n        DO x = 0, 9\n          temp = 0\n          DO y = 1, LOOPCOUNT\n            temp = max(temp, a(x * LOOPCOUNT + y) * b(x * LOOPCOUNT + y))\n          END DO\n          IF (abs(temp - maximum(x + 1)) .gt. PRECISION) THEN\n            errors = errors + 1\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "parallel",
                            "private",
                            "reduction",
                            "combined-constructs",
                            "loop"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "parallel_loop_reduction_max_vector_loop.c": {
                "num tests": 2,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:parallel,loop,reduction,combined-constructs,V:1.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(10 * n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(10 * n * sizeof(real_t));\n    real_t * max = (real_t *)malloc(10 * sizeof(real_t));\n    real_t temp = 0;\n    real_t temp_max;\n\n    for (int x = 0; x < 10 * n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX/10);\n        b[x] = rand() / (real_t)(RAND_MAX/10);\n    }\n    #pragma acc data copyin(a[0:10*n], b[0:10*n]) copy(max[0:10])\n    {\n        #pragma acc parallel loop private(temp)\n        for (int x = 0; x < 10; ++x){\n            temp = 0;\n            #pragma acc loop vector reduction(max:temp)\n            for (int y = 0; y < n; ++y){\n                temp = fmax(a[x * n + y] * b[x * n + y], temp);\n            }\n            max[x] = temp;\n        }\n    }\n    for (int x = 0; x < 10; ++x){\n        temp_max = 0;\n        for (int y = 0; y < n; ++y){\n            if (temp_max < a[x * n + y] * b[x * n + y]){\n                temp_max = a[x * n + y] * b[x * n + y];\n            }\n        }\n        if (fabs(temp_max - max[x]) > PRECISION){\n            err = 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "parallel",
                            "loop",
                            "reduction",
                            "combined-constructs"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "2": {
                        "content": "#ifndef T2\n//T2:parallel,private,reduction,combined-constructs,loop,V:2.7-2.7\nint test2(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(25 * n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(25 * n * sizeof(real_t));\n    real_t * maximums = (real_t *)malloc(25 * sizeof(real_t));\n    real_t reduced[5];\n\n    for (int x = 0; x < 25 * n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n    }\n\n    for (int x = 0; x < 25; ++x) {\n        maximums[x] = 0;\n    }\n\n    #pragma acc data copyin(a[0:25*n], b[0:25*n]) copy(maximums[0:25])\n    {\n        #pragma acc parallel loop private(reduced)\n        for (int x = 0; x < 5; ++x) {\n            for (int y = 0; y < 5; ++y) {\n                reduced[y] = 0;\n            }\n            #pragma acc loop vector reduction(max:reduced)\n            for (int y = 0; y < 5 * n; ++y) {\n                reduced[y%5] = fmax(a[x * 5 * n + y] * b[x * 5 * n + y], reduced[y%5]);\n            }\n            for (int y = 0; y < 5; ++y) {\n                maximums[x * 5 + y] = reduced[y];\n            }\n        }\n    }\n\n    for (int x = 0; x < 5; ++x) {\n        for (int y = 0; y < 5; ++y) {\n            reduced[y] = 0;\n        }\n        for (int y = 0; y < 5 * n; ++y) {\n            reduced[y%5] = fmax(a[x * 5 * n + y] * b[x * 5 * n + y], reduced[y%5]);\n        }\n        for (int y = 0; y < 5; ++y) {\n            if (fabs(maximums[x * 5 + y] - reduced[y]) > PRECISION) {\n                err += 1;\n            }\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T2\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test2();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 1);\n    }\n#endif\n",
                        "tags": [
                            "parallel",
                            "private",
                            "reduction",
                            "combined-constructs",
                            "loop"
                        ],
                        "versions": [
                            "2.7"
                        ]
                    }
                }
            },
            "parallel_loop_reduction_min_general.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:parallel,reduction,combined-constructs,loop,V:1.0-2.7\n      LOGICAL FUNCTION test1()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT):: a, b !Data\n        REAL(8):: minimum = 1000\n        REAL(8):: temp = 1000\n        INTEGER :: errors = 0\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(a)\n        CALL RANDOM_NUMBER(b)\n\n        !$acc data copyin(a(1:LOOPCOUNT), b(1:LOOPCOUNT))\n          !$acc parallel loop reduction(min:minimum)\n          DO x = 1, LOOPCOUNT\n            minimum = min(minimum, a(x) * b(x))\n          END DO\n        !$acc end data\n\n        DO x = 1, LOOPCOUNT\n          temp = min(temp, a(x) * b(x))\n        END DO\n        IF (abs(temp - minimum) .gt. PRECISION) THEN\n          errors = errors + 1\n        END IF\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "parallel",
                            "reduction",
                            "combined-constructs",
                            "loop"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "parallel_loop_reduction_min_general.c": {
                "num tests": 2,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:parallel,loop,reduction,combined-constructs,V:1.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n    real_t min = 1000.0;\n    int found = 0;\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX/10);\n        b[x] = rand() / (real_t)(RAND_MAX/10);\n    }\n    #pragma acc data copyin(a[0:n], b[0:n]) copy(min)\n    {\n        #pragma acc parallel loop reduction(min:min)\n        for (int x = 0; x < n; ++x){\n            min = fmin(a[x] * b[x], min);\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        if (fabs((a[x] * b[x]) - (min + PRECISION)) < 0){\n            err = 1;\n        }\n        if (fabs(min - (a[x] * b[x])) < PRECISION){\n            found = 1;\n        }\n    }\n    if (found == 0){\n        err = 1;\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "parallel",
                            "loop",
                            "reduction",
                            "combined-constructs"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "2": {
                        "content": "#ifndef T2\n//T2:parallel,reduction,combined-constructs,loop,V:2.7-2.7\nint test2(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(10 * n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(10 * n * sizeof(real_t));\n    real_t minimums[10];\n    real_t host_minimums[10];\n\n    for (int x = 0; x < 10 * n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n    }\n\n    for (int x = 0; x < 10; ++x) {\n        minimums[x] = 1000;\n        host_minimums[x] = 1000;\n    }\n\n    printf(\"Here\");\n\n    #pragma acc data copyin(a[0:10*n], b[0:10*n])\n    {\n        #pragma acc parallel loop reduction(min:minimums)\n        for (int x = 0; x < 10 * n; ++x) {\n            minimums[x%10] = fmin(a[x] * b[x], minimums[x%10]);\n        }\n    }\n\n    for (int x = 0; x < 10 * n; ++x) {\n        host_minimums[x%10] = fmin(a[x] * b[x], host_minimums[x%10]);\n    }\n    for (int x = 0; x < 10; ++x) {\n        if (fabs(minimums[x] - host_minimums[x]) > PRECISION) {\n            err += 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T2\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test2();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 1);\n    }\n#endif\n",
                        "tags": [
                            "parallel",
                            "reduction",
                            "combined-constructs",
                            "loop"
                        ],
                        "versions": [
                            "2.7"
                        ]
                    }
                }
            },
            "parallel_loop_reduction_min_loop.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:parallel,private,reduction,combined-constructs,loop,V:1.0-2.7\n      LOGICAL FUNCTION test1()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x, y !Iterators\n        REAL(8),DIMENSION(10 * LOOPCOUNT):: a, b, c !Data\n        REAL(8),DIMENSION(10):: minimum\n        REAL(8):: temp\n        INTEGER :: errors = 0\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(a)\n        CALL RANDOM_NUMBER(b)\n        c = 0\n        a = a + 1\n        b = b + 1\n\n        !$acc data copyin(a(1:10*LOOPCOUNT), b(1:10*LOOPCOUNT)) copy(c(1:10*LOOPCOUNT)) copy(minimum(1:10))\n          !$acc parallel loop gang private(temp)\n          DO x = 0, 9\n            temp = 1000\n            !$acc loop worker reduction(min:temp)\n            DO y = 1, LOOPCOUNT\n              temp = min(temp, a(x * LOOPCOUNT + y) * b(x * LOOPCOUNT + y))\n            END DO\n            minimum(x + 1) = temp\n            !$acc loop\n            DO y = 1, LOOPCOUNT\n              c(x * LOOPCOUNT + y) = (a(x * LOOPCOUNT + y) * b(x * LOOPCOUNT + y)) / minimum(x + 1)\n            END DO\n          END DO\n        !$acc end data\n\n        DO x = 0, 9\n          temp = 1000\n          DO y = 1, LOOPCOUNT\n            temp = min(temp, a(x * LOOPCOUNT + y) * b(x * LOOPCOUNT + y))\n          END DO\n          IF (abs(temp - minimum(x + 1)) .gt. PRECISION) THEN\n            errors = errors + 1\n          END IF\n          DO y = 1, LOOPCOUNT\n            IF (abs(c(x * LOOPCOUNT + y) - (a(x * LOOPCOUNT + y) * b(x * LOOPCOUNT + y) / temp)) .gt. PRECISION) THEN\n              errors = errors + 1\n            END IF\n          END DO\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "parallel",
                            "private",
                            "reduction",
                            "combined-constructs",
                            "loop"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "parallel_loop_reduction_min_loop.c": {
                "num tests": 2,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:parallel,loop,reduction,combined-constructs,V:1.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(10 * n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(10 * n * sizeof(real_t));\n    real_t * c = (real_t *)malloc(10 * n * sizeof(real_t));\n    real_t * minimum = (real_t *)malloc(10 * sizeof(real_t));\n    real_t temp = 0;\n\n    for (int x = 0; x < 10 * n; ++x){\n        a[x] = 1 + rand() / (real_t)(RAND_MAX/10);\n        b[x] = 1 + rand() / (real_t)(RAND_MAX/10);\n        c[x] = 0.0;\n    }\n\n    #pragma acc data copyin(a[0:10*n], b[0:10*n]) copy(c[0:10*n], minimum[0:10])\n    {\n        #pragma acc parallel loop gang private(temp)\n        for (int x = 0; x < 10; ++x){\n            temp = 1000;\n            #pragma acc loop reduction(min:temp)\n            for (int y = 0; y < n; ++y){\n                temp = fmin(a[x * n + y] * b[x * n + y], temp);\n            }\n            minimum[x] = temp;\n            #pragma acc loop\n            for (int y = 0; y < n; ++y){\n                c[x * n + y] = (a[x * n + y] * b[x * n + y]) / minimum[x];\n            }\n        }\n    }\n\n    for (int x = 0; x < 10; ++x){\n        temp = 1000;\n        for (int y = 0; y < n; ++y){\n            temp = fmin(temp, a[x * n + y] * b[x * n + y]);\n        }\n        if (fabs(temp - minimum[x]) > PRECISION){\n            err += 1;\n        }\n        for (int y = 0; y < n; ++y){\n            if (fabs(c[x * n + y] - (a[x * n + y] * b[x * n + y] / minimum[x])) > PRECISION){\n                err += 1;\n            }\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "parallel",
                            "loop",
                            "reduction",
                            "combined-constructs"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "2": {
                        "content": "#ifndef T2\n//T2:parallel,private,reduction,combined-constructs,loop,V:2.7-2.7\nint test2(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(25 * n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(25 * n * sizeof(real_t));\n    real_t * c = (real_t *)malloc(25 * n * sizeof(real_t));\n    real_t minimums[25];\n    real_t host_minimums[25];\n    real_t reduced[5];\n\n    for (int x = 0; x < n; ++x){\n        a[x] = 1 + rand() / (real_t)(RAND_MAX / 10);\n        b[x] = 1 + rand() / (real_t)(RAND_MAX / 10);\n        c[x] = 0.0;\n    }\n\n    #pragma acc data copyin(a[0:25*n], b[0:25*n]) copy(minimums[0:25], c[0:25*n])\n    {\n        #pragma acc parallel loop gang private(reduced)\n        for (int x = 0; x < 5; ++x) {\n            for (int y = 0; y < 5; ++y) {\n                reduced[y] = 1000;\n            }\n            #pragma acc loop reduction(min:reduced)\n            for (int y = 0; y < 5 * n; ++y) {\n                reduced[y%5] = fmin(a[x * 5 * n + y] * b[x * 5 * n + y], reduced[y%5]);\n            }\n            for (int y = 0; y < 5; ++y) {\n                minimums[x * 5 + y] = reduced[y];\n            }\n            #pragma acc loop\n            for (int y = 0; y < 5 * n; ++y) {\n                c[x * 5 * n + y] = (a[x * 5 * n + y] * b[x * 5 * n + y]) / minimums[x * 5 + (y % 5)];\n            }\n        }\n    }\n\n    for (int x = 0; x < 5; ++x) {\n        for (int y = 0; y < 5; ++y) {\n            reduced[y] = 1000;\n        }\n        for (int y = 0; y < 5 * n; ++y) {\n            reduced[y%5] = fmin(a[x * 5 * n + y] * b[x * 5 * n + y], reduced[y%5]);\n        }\n        for (int y = 0; y < 5; ++y) {\n            host_minimums[x * 5 + y] = reduced[y];\n            if (fabs(host_minimums[x * 5 + y] - minimums[x * 5 + y]) > PRECISION) {\n                err += 1;\n            }\n        }\n        for (int y = 0; y < 5 * n; ++y) {\n            if (fabs(c[x * 5 * n + y] - ((a[x * 5 * n + y] * b[x * 5 * n + y]) / minimums[x * 5 + (y % 5)])) > PRECISION) {\n                err += 1;\n            }\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T2\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test2();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 1);\n    }\n#endif\n",
                        "tags": [
                            "parallel",
                            "private",
                            "reduction",
                            "combined-constructs",
                            "loop"
                        ],
                        "versions": [
                            "2.7"
                        ]
                    }
                }
            },
            "parallel_loop_reduction_min_vector_loop.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:parallel,private,reduction,combined-constructs,loop,V:1.0-2.7\n      LOGICAL FUNCTION test1()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x, y!Iterators\n        REAL(8),DIMENSION(10*LOOPCOUNT):: a, b !Data\n        REAL(8),DIMENSION(10):: minimum\n        REAL(8):: temp = 1000\n        INTEGER :: errors = 0\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(a)\n        CALL RANDOM_NUMBER(b)\n\n        !$acc data copyin(a(1:10*LOOPCOUNT), b(1:10*LOOPCOUNT)) copy(minimum(1:10))\n          !$acc parallel loop gang private(temp)\n          DO x = 0, 9\n            temp = 1000\n            !$acc loop vector reduction(min:temp)\n            DO y = 1, LOOPCOUNT\n              temp = min(temp, a(x * LOOPCOUNT + y) * b(x * LOOPCOUNT + y))\n            END DO\n            minimum(x + 1) = temp\n          END DO\n        !$acc end data\n        \n        DO x = 0, 9\n          temp = 1000\n          DO y = 1, LOOPCOUNT\n            temp = min(temp, a(x * LOOPCOUNT + y) * b(x * LOOPCOUNT + y))\n          END DO\n          IF (abs(temp - minimum(x + 1)) .gt. PRECISION) THEN\n            errors = errors + 1\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "parallel",
                            "private",
                            "reduction",
                            "combined-constructs",
                            "loop"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "parallel_loop_reduction_min_vector_loop.c": {
                "num tests": 2,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:parallel,loop,reduction,combined-constructs,V:1.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(10 * n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(10 * n * sizeof(real_t));\n    real_t * min = (real_t *)malloc(10 * sizeof(real_t));\n    real_t temp = 100;\n    real_t temp_min;\n\n    for (int x = 0; x < 10 * n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX/10);\n        b[x] = rand() / (real_t)(RAND_MAX/10);\n    }\n\n    #pragma acc data copyin(a[0:10*n], b[0:10*n]) copy(min[0:10])\n    {\n        #pragma acc parallel loop gang private(temp)\n        for (int x = 0; x < 10; ++x){\n            temp = 100;\n            #pragma acc loop vector reduction(min:temp)\n            for (int y = 0; y < n; ++y){\n                temp = fmin(a[x * n + y] * b[x * n + y], temp);\n            }\n            min[x] = temp;\n        }\n    }\n    for (int x = 0; x < 10; ++x){\n        temp_min = 100;\n        for (int y = 0; y < n; ++y){\n            if (temp_min > a[x * n + y] * b[x * n + y]){\n                temp_min = a[x * n + y] * b[x * n + y];\n            }\n        }\n        if (fabs(temp_min - min[x]) > PRECISION){\n            err = 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "parallel",
                            "loop",
                            "reduction",
                            "combined-constructs"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "2": {
                        "content": "#ifndef T2\n//T2:parallel,private,reduction,combined-constructs,loop,V:2.7-2.7\nint test2(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(25 * n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(25 * n * sizeof(real_t));\n    real_t * minimums = (real_t *)malloc(25 * sizeof(real_t));\n    real_t reduced[5];\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n    }\n\n    #pragma acc data copyin(a[0:25*n], b[0:25*n]) copy(minimums[0:25])\n    {\n        #pragma acc parallel loop gang private(reduced)\n        for (int x = 0; x < 5; ++x) {\n            for (int y = 0; y < 5; ++y) {\n                reduced[y] = 1000;\n            }\n            #pragma acc loop vector reduction(min:reduced)\n            for (int y = 0; y < 5 * n; ++y) {\n                reduced[y%5] = fmin(a[x * 5 * n + y] * b[x * 5 * n + y], reduced[y % 5]);\n            }\n            for (int y = 0; y < 5; ++y) {\n                minimums[x * 5 + y] = reduced[y];\n            }\n        }\n    }\n\n    for (int x = 0; x < 5; ++x) {\n        for (int y = 0; y < 5; ++y) {\n            reduced[y] = 1000;\n        }\n        for (int y = 0; y < 5 * n; ++y) {\n            reduced[y%5] = fmin(a[x * 5 * n + y] * b[x * 5 * n + y], reduced[y % 5]);\n        }\n        for (int y = 0; y < 5; ++y) {\n            if (fabs(reduced[y] - minimums[x * 5 + y]) > PRECISION) {\n                err += 1;\n            }\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T2\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test2();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 1);\n    }\n#endif\n",
                        "tags": [
                            "parallel",
                            "private",
                            "reduction",
                            "combined-constructs",
                            "loop"
                        ],
                        "versions": [
                            "2.7"
                        ]
                    }
                }
            },
            "parallel_loop_reduction_multiply_general.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:parallel,reduction,combined-constructs,loop,V:1.0-2.7\n      LOGICAL FUNCTION test1()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT):: a, b !Data\n        INTEGER :: errors = 0\n        REAL(8) :: temp = 1\n        REAL(8) :: multiplied_total = 1\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(a)\n        CALL RANDOM_NUMBER(b)\n        a = (999.4 + a)/1000\n        b = (999.4 + b)/1000\n\n        !$acc data copyin(a(1:LOOPCOUNT))\n          !$acc parallel loop reduction(*:multiplied_total)\n          DO x = 1, LOOPCOUNT\n            multiplied_total = multiplied_total * (a(x) + b(x))\n          END DO\n        !$acc end data\n\n        DO x = 1, LOOPCOUNT\n          temp = temp * (a(x) + b(x))\n        END DO\n        IF (abs(temp - multiplied_total) .gt. ((temp / 2) + (multiplied_total / 2)) * PRECISION) THEN\n          WRITE(*, *) temp\n          WRITE(*, *) multiplied_total\n          errors = errors + 1\n        END IF\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "parallel",
                            "reduction",
                            "combined-constructs",
                            "loop"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "parallel_loop_reduction_multiply_general.c": {
                "num tests": 2,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:parallel,loop,reduction,combined-constructs,V:1.0-2.7\nint test1(){\n    int err = 0;\n    int multiplicitive_n = 128;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(multiplicitive_n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(multiplicitive_n * sizeof(real_t));\n\n    real_t multiplied_total = 1.0;\n\n    for (int x = 0; x < multiplicitive_n; ++x){\n        a[x] = rand() / (real_t) RAND_MAX;\n        b[x] = rand() / (real_t) RAND_MAX;\n    }\n\n    #pragma acc data copyin(a[0:multiplicitive_n], b[0:multiplicitive_n]) copy(multiplied_total)\n    {\n        #pragma acc parallel loop reduction(*:multiplied_total)\n        for (int x = 0; x < multiplicitive_n; ++x){\n            multiplied_total *= a[x] + b[x];\n        }\n    }\n\n    for (int x = 0; x < multiplicitive_n; ++x){\n        multiplied_total /= (a[x] + b[x]);\n    }\n    if (fabs(multiplied_total - 1) > PRECISION * (2 * multiplicitive_n - 1)){\n        err = 1;\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "parallel",
                            "loop",
                            "reduction",
                            "combined-constructs"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "2": {
                        "content": "#ifndef T2\n//T2:parallel,reduction,combined-constructs,loop,V:2.7-2.7\nint test2(){\n    int err = 0;\n    int m_n = 128;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(10 * m_n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(10 * m_n * sizeof(real_t));\n\n    real_t multiplicitive_total[10];\n\n    for (int x = 0; x < m_n; ++x){\n        a[x] = rand() / (real_t) RAND_MAX;\n        b[x] = rand() / (real_t) RAND_MAX;\n    }\n\n    for (int x = 0; x < 10; ++x) {\n        multiplicitive_total[x] = 1.0;\n    }\n\n    #pragma acc data copyin(a[0:10*m_n], b[0:10*m_n])\n    {\n        #pragma acc parallel loop reduction(*:multiplicitive_total)\n        for (int x = 0; x < 10 * m_n; ++x) {\n            multiplicitive_total[x%10] = multiplicitive_total[x%10] * (a[x] + b[x]);\n        }\n    }\n\n    for (int x = 0; x < 10 * m_n; ++x) {\n        multiplicitive_total[x%10] /= (a[x] + b[x]);\n    }\n\n    for (int x = 0; x < 10; ++x) {\n        if (fabs(multiplicitive_total[x]) > PRECISION) {\n            err += 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T2\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test2();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 1);\n    }\n#endif\n",
                        "tags": [
                            "parallel",
                            "reduction",
                            "combined-constructs",
                            "loop"
                        ],
                        "versions": [
                            "2.7"
                        ]
                    }
                }
            },
            "parallel_loop_reduction_multiply_loop.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:parallel,private,reduction,combined-constructs,loop,V:1.0-2.7\n      LOGICAL FUNCTION test1()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x, y !Iterators\n        REAL(8),DIMENSION(10*LOOPCOUNT):: a, b, c !Data\n        REAL(8),DIMENSION(10):: totals\n        REAL(8) :: temp\n        INTEGER :: errors = 0\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(a)\n        CALL RANDOM_NUMBER(b)\n        c = 0\n        a = (999.4 + a) / 2000\n        b = (999.4 + b) / 2000\n\n        !$acc data copyin(a(1:10*LOOPCOUNT), b(1:10*LOOPCOUNT)) copy(c(1:10*LOOPCOUNT), totals(1:10))\n          !$acc parallel loop gang private(temp)\n          DO x = 0, 9\n            temp = 1\n            !$acc loop worker reduction(*:temp)\n            DO y = 1, LOOPCOUNT\n              temp = temp * (a(x * LOOPCOUNT + y) + b(x * LOOPCOUNT + y))\n            END DO\n            totals(x + 1) = temp\n            !$acc loop worker\n            DO y = 1, LOOPCOUNT\n              c(x * LOOPCOUNT + y) = (a(x * LOOPCOUNT + y) + b(x * LOOPCOUNT + y)) / totals(x + 1)\n            END DO\n          END DO\n        !$acc end data\n\n        DO x = 0, 9\n          temp = 1\n          DO y = 1, LOOPCOUNT\n            temp = temp * (a(x * LOOPCOUNT + y) + b(x * LOOPCOUNT + y))\n          END DO\n          IF (abs(temp - totals(x + 1)) .gt. ((temp / 2) + (totals(x + 1) / 2)) * PRECISION) THEN\n            errors = errors + 1\n            WRITE(*, *) temp\n            WRITE(*, *) totals(x + 1)\n            WRITE(*, *) \" \"\n          END IF\n          DO y = 1, LOOPCOUNT \n            IF (abs(c(x * LOOPCOUNT + y) - ((a(x * LOOPCOUNT + y) + b(x * LOOPCOUNT + y)) / totals(x + 1))) .gt. c(x * LOOPCOUNT + y) * PRECISION) THEN\n              errors = errors + 1\n              WRITE(*, *) c(x * LOOPCOUNT + y)\n              WRITE(*, *) a(x * LOOPCOUNT + y) + b(x * LOOPCOUNT + y)\n              WRITE(*, *) \" \"\n            END IF\n          END DO\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "parallel",
                            "private",
                            "reduction",
                            "combined-constructs",
                            "loop"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "parallel_loop_reduction_multiply_loop.c": {
                "num tests": 2,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:parallel,loop,reduction,combined-constructs,V:1.0-2.7\nint test1(){\n    int err = 0;\n    int m_n = 128;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(10 * m_n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(10 * m_n * sizeof(real_t));\n    real_t * c = (real_t *)malloc(10 * m_n * sizeof(real_t));\n    real_t * totals = (real_t *)malloc(10 * sizeof(real_t));\n    real_t temp;\n\n    for (int x = 0; x < 10 * m_n; ++x){\n        a[x] = .05 + rand() / (real_t)(RAND_MAX);\n        b[x] = .05 + rand() / (real_t)(RAND_MAX);\n        c[x] = 0.0;\n    }\n\n\n    #pragma acc data copyin(a[0:10*m_n], b[0:10*m_n]) copyout(c[0:10*m_n], totals[0:10])\n    {\n        #pragma acc parallel loop gang private(temp)\n        for (int x = 0; x < 10; ++x){\n            temp = 1;\n            #pragma acc loop worker reduction(*:temp)\n            for (int y = 0; y < m_n; ++y){\n                temp *= a[x * m_n + y] + b[x * m_n + y];\n            }\n            totals[x] = temp;\n            #pragma acc loop worker\n            for (int y = 0; y < m_n; ++y){\n                c[x * m_n + y] = (a[x * m_n + y] + b[x * m_n + y]) / totals[x];\n            }\n        }\n    }\n\n    for (int x = 0; x < 10; ++x){\n        temp = 1;\n        for (int y = 0; y < m_n; ++y){\n            temp *= a[x * m_n + y] + b[x * m_n + y];\n        }\n        if (fabs(temp - totals[x]) > (temp / 2 + totals[x] / 2) * PRECISION){\n            err += 1;\n        }\n        for (int y = 0; y < m_n; ++y){\n            if (fabs(c[x * m_n + y] - ((a[x * m_n + y] + b[x * m_n + y]) / totals[x])) > PRECISION){\n                err += 1;\n            }\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "parallel",
                            "loop",
                            "reduction",
                            "combined-constructs"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "2": {
                        "content": "#ifndef T2\n//T2:parallel,private,reduction,combined-constructs,loop,V:2.7-2.7\nint test2(){\n    int err = 0;\n    int m_n = 128;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(25 * m_n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(25 * m_n * sizeof(real_t));\n    real_t * c = (real_t *)malloc(25 * m_n * sizeof(real_t));\n\n    real_t * totals = (real_t *)malloc(25 * sizeof(real_t));\n    real_t reduced[5];\n\n    for (int x = 0; x < n; ++x){\n        a[x] = .05 + rand() / (real_t)(RAND_MAX / 10);\n        b[x] = .05 + rand() / (real_t)(RAND_MAX / 10);\n        c[x] = 0;\n    }\n\n    #pragma acc data copyin(a[0:25*m_n], b[0:25*m_n]) copyout(c[0:25*m_n], totals[0:25])\n    {\n        #pragma acc parallel loop gang private(reduced)\n        for (int x = 0; x < 5; ++x) {\n            for (int y = 0; y < 5; ++y) {\n                reduced[y] = 1.0;\n            }\n            #pragma acc loop worker reduction(*:reduced)\n            for (int y = 0; y < 5 * m_n; ++y) {\n                reduced[y%5] *= a[x * 5 * m_n + y] + b[x * 5 * m_n + y];\n            }\n            for (int y = 0; y < 5; ++y) {\n                totals[x * 5 + y] = reduced[y];\n            }\n            for (int y = 0; y < 5 * m_n; ++y) {\n                c[x * 5 * m_n + y] = (a[x * 5 * m_n + y] + b[x * 5 * m_n + y]) / totals[x * 5 + (y%5)];\n            }\n        }\n    }\n\n    for (int x = 0; x < 5; ++x) {\n        for (int y = 0; y < 5; ++y) {\n            reduced[y] = 1;\n        }\n        for (int y = 0; y < 5 * m_n; ++y) {\n            reduced[y%5] *= a[x * 5 * m_n + y] + b[x * 5 * m_n + y];\n        }\n        for (int y = 0; y < 5; ++y) {\n            if (fabs(totals[x * 5 + y] - reduced[y]) > PRECISION) {\n                err += 1;\n            }\n        }\n        for (int y = 0; y < 5 * m_n; ++y) {\n            if (fabs(c[x * 5 * m_n + y] - ((a[x * 5 * m_n + y] + b[x * 5 * m_n + y]) / totals[x * 5 + (y % 5)])) > PRECISION) {\n                err += 1;\n            }\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T2\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test2();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 1);\n    }\n#endif\n",
                        "tags": [
                            "parallel",
                            "private",
                            "reduction",
                            "combined-constructs",
                            "loop"
                        ],
                        "versions": [
                            "2.7"
                        ]
                    }
                }
            },
            "parallel_loop_reduction_multiply_vector_loop.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:parallel,private,reduction,combined-constructs,loop,V:1.0-2.7\n      LOGICAL FUNCTION test1()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x, y !Iterators\n        REAL(8),DIMENSION(10 * LOOPCOUNT):: a, b !Data\n        REAL(8),DIMENSION(10) :: c\n        REAL(8) :: temp\n        INTEGER :: errors = 0\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(a)\n        CALL RANDOM_NUMBER(b)\n        a = (999.4 + a) / 1000\n        b = (999.4 + b) / 1000\n\n        !$acc data copyin(a(1:10*LOOPCOUNT), b(1:10*LOOPCOUNT)) copyout(c(1:10))\n          !$acc parallel loop private(temp)\n          DO x = 0, 9\n            temp = 1\n            !$acc loop vector reduction(*:temp)\n            DO y = 1, LOOPCOUNT\n              temp = temp * (a(x * LOOPCOUNT + y) + b(x * LOOPCOUNT + y))\n            END DO\n            c(x + 1) = temp\n          END DO\n        !$acc end data\n\n        DO x = 0, 9\n          temp = 1\n          DO y = 1, LOOPCOUNT\n            temp = temp * (a(x * LOOPCOUNT + y) + b(x * LOOPCOUNT + y))\n          END DO\n          IF (abs(temp - c(x + 1)) .gt. ((temp / 2) + (c(x + 1) / 2)) * PRECISION) THEN\n            errors = errors + 1\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "parallel",
                            "private",
                            "reduction",
                            "combined-constructs",
                            "loop"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "parallel_loop_reduction_multiply_vector_loop.c": {
                "num tests": 3,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:parallel,loop,reduction,combined-constructs,V:1.0-2.7\nint test1() {\n    int err = 0;\n    int multiplicitive_n = 128;\n    srand(SEED);\n    real_t* a = (real_t*)malloc(10 * multiplicitive_n * sizeof(real_t));\n    real_t* b = (real_t*)malloc(10 * multiplicitive_n * sizeof(real_t));\n    real_t* c = (real_t*)malloc(10 * sizeof(real_t));\n    real_t temp;\n\n    for (int x = 0; x < 10 * multiplicitive_n; ++x) {\n        a[x] = rand() / (real_t)RAND_MAX;\n        b[x] = rand() / (real_t)RAND_MAX;\n    }\n\n#pragma acc data copyin(a[0:10*multiplicitive_n], b[0:10*multiplicitive_n]) copyout(c[0:10])\n    {\n#pragma acc parallel loop private(temp)\n        for (int x = 0; x < 10; ++x) {\n            temp = 1.0;\n#pragma acc loop vector reduction(*:temp)\n            for (int y = 0; y < multiplicitive_n; ++y) {\n                temp *= a[(x * multiplicitive_n) + y] + b[(x * multiplicitive_n) + y];\n            }\n            c[x] = temp;\n        }\n    }\n\n    for (int x = 0; x < 10; ++x) {\n        for (int y = 0; y < multiplicitive_n; ++y) {\n            c[x] /= a[(x * multiplicitive_n) + y] + b[(x * multiplicitive_n) + y];\n        }\n    }\n\n    for (int x = 0; x < 10; ++x) {\n        if (fabs(c[x] - 1) > PRECISION* (4 * multiplicitive_n - 1)) {\n            err = 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "parallel",
                            "loop",
                            "reduction",
                            "combined-constructs"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "2": {
                        "content": "#ifndef T2\n//T2:parallel,private,reduction,combined-constructs,loop,V:2.7-2.7\nint test2() {\n    int err = 0;\n    int m_n = 128;\n    srand(SEED);\n    real_t* a = (real_t*)malloc(25 * m_n * sizeof(real_t));\n    real_t* b = (real_t*)malloc(25 * m_n * sizeof(real_t));\n    real_t* c = (real_t*)malloc(25 * m_n * sizeof(real_t));\n    real_t* totals = (real_t*)malloc(25 * sizeof(real_t));\n    real_t reduced[5];\n\n    for (int x = 0; x < n; ++x) {\n        a[x] = .05 + rand() / (real_t)(RAND_MAX / 10);\n        b[x] = .05 + rand() / (real_t)(RAND_MAX / 10);\n        c[x] = 0;\n    }\n\n    #pragma acc data copyin(a[0:25*m_n], b[0:25*m_n]) copyout(c[0:25*m_n], totals[0:25])\n    {\n        #pragma acc parallel loop gang private(reduced)\n        for (int x = 0; x < 5; ++x) {\n            for (int y = 0; y < 5; ++y) {\n                reduced[y] = 1.0;\n            }\n            #pragma acc loop worker reduction(*:reduced)\n            for (int y = 0; y < 5 * m_n; ++y) {\n                reduced[y % 5] *= a[x * 5 * m_n + y] + b[x * 5 * m_n + y];\n            }\n            for (int y = 0; y < 5; ++y) {\n                totals[x * 5 + y] = reduced[y];\n            }\n            #pragma acc loop worker\n            for (int y = 0; y < 5 * m_n; ++y) {\n                c[x * 5 * m_n + y] = (a[x * 5 * m_n + y] + b[x * 5 * m_n + y]) / totals[(x * 5) + (y % 5)];\n            }\n        }\n    }\n\n    for (int x = 0; x < 5; ++x) {\n        for (int y = 0; y < 5; ++y) {\n            reduced[y] = 1;\n        }\n        for (int y = 0; y < 5 * m_n; ++y) {\n            reduced[y % 5] *= a[x * 5 * m_n + y] + b[x * 5 * m_n + y];\n        }\n        for (int y = 0; y < 5; ++y) {\n            if (fabs(totals[x * 5 + y] - reduced[y]) > PRECISION) {\n                err += 1;\n            }\n        }\n        for (int y = 0; y < 5 * m_n; ++y) {\n            if (fabs(c[x * 5 * m_n + y] - ((a[x * 5 * m_n + y] + b[x * 5 * m_n + y]) / totals[x * 5 + (y % 5)])) > PRECISION){\n                err += 1;\n            }   \n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T2\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test2();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 1);\n    }\n#endif\n",
                        "tags": [
                            "parallel",
                            "private",
                            "reduction",
                            "combined-constructs",
                            "loop"
                        ],
                        "versions": [
                            "2.7"
                        ]
                    },
                    "3": {
                        "content": "#ifndef T3\n//T3:\nint test3(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n    real_t * c = (real_t *)malloc(n * sizeof(real_t));\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n        c[x] = 0;\n    }\n\n    return err;\n}\n#endif\n#ifndef T3\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test3();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 2);\n    }\n#endif\n",
                        "tags": [
                            ""
                        ],
                        "versions": []
                    }
                }
            },
            "parallel_loop_reduction_or_general.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:parallel,reduction,combined-constructs,loop,V:1.0-2.7\n      LOGICAL FUNCTION test1()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x !Iterators\n        LOGICAL,DIMENSION(LOOPCOUNT):: a !Data\n        LOGICAL :: results = .FALSE.\n        LOGICAL :: temp = .FALSE.\n        REAL(8) :: false_margin = exp(log(.5) / n)\n        REAL(8),DIMENSION(LOOPCOUNT):: random\n        INTEGER :: errors = 0\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(random)\n        DO x = 1, LOOPCOUNT\n          IF (random(x) > false_margin) THEN\n            a(x) = .TRUE.\n          ELSE\n            a(x) = .FALSE.\n          END IF\n        END DO\n\n        !$acc data copyin(a(1:LOOPCOUNT))\n          !$acc parallel loop reduction(.OR.:results)\n          DO x = 1, LOOPCOUNT\n            results = results .OR. a(x)\n          END DO\n        !$acc end data\n\n        DO x = 1, LOOPCOUNT\n          temp = temp .OR. a(x)\n        END DO\n        IF (temp .neqv. results) THEN\n          errors = errors + 1\n        END IF\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "parallel",
                            "reduction",
                            "combined-constructs",
                            "loop"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "parallel_loop_reduction_or_general.c": {
                "num tests": 2,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:parallel,loop,reduction,combined-constructs,V:1.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    char * a = (char *)malloc(n * sizeof(char));\n    real_t false_margin = pow(exp(1), log(.5)/n);\n    char result = 0;\n    char found = 0;\n\n    for (int x = 0; x < n; ++x){\n        if(rand() / (real_t)(RAND_MAX) > false_margin){\n            a[x] = 1;\n        }\n        else{\n            a[x] = 0;\n        }\n    }\n\n\n    #pragma acc data copyin(a[0:n])\n    {\n        #pragma acc parallel loop reduction(||:result)\n        for (int x = 0; x < n; ++x){\n            result = result || a[x];\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        if (a[x] == 1){\n            found = 1;\n        }\n    }\n    if (found != result){\n        err = 1;\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "parallel",
                            "loop",
                            "reduction",
                            "combined-constructs"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "2": {
                        "content": "#ifndef T2\n//T2:parallel,reduction,combined-constructs,loop,V:2.7-2.7\nint test2(){\n    int err = 0;\n    srand(SEED);\n    char* a = (char *)malloc(5 * n * sizeof(char));\n    char result[5];\n    char host_result[5];\n    real_t false_margin = pow(exp(1), log(.5)/n);\n\n    for (int x = 0; x < 5; ++x) {\n        result[x] = 0;\n        host_result[x] = 0;\n    }\n\n    for (int x = 0; x < 5 * n; ++x) {\n        if (rand() / (real_t)(RAND_MAX) > false_margin) {\n            a[x] = 1;\n        }\n        else {\n            a[x] = 0;\n        }\n    }\n\n    #pragma acc data copyin(a[0:5*n])\n    {\n        #pragma acc parallel loop reduction(||:result)\n        for (int x = 0; x < 5 * n; ++x) {\n            result[x%5] = result[x%5] || a[x];\n        }\n    }\n\n    for (int x = 0; x < 5 * n; ++x) {\n        host_result[x%5] = host_result[x%5] || a[x];\n    }\n    \n    for (int x = 0; x < 5; ++x) {\n        if (host_result[x] != result[x]) {\n            err += 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T2\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test2();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 1);\n    }\n#endif\n",
                        "tags": [
                            "parallel",
                            "reduction",
                            "combined-constructs",
                            "loop"
                        ],
                        "versions": [
                            "2.7"
                        ]
                    }
                }
            },
            "parallel_loop_reduction_or_loop.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:parallel,private,reduction,combined-constructs,loop,V:1.0-2.7\n      LOGICAL FUNCTION test1()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x, y !Iterators\n        LOGICAL,DIMENSION(10*LOOPCOUNT):: a, a_copy !Data\n        LOGICAL,DIMENSION(10) :: results\n        LOGICAL :: temp = .FALSE.\n        REAL(8),DIMENSION(10 * LOOPCOUNT) :: random\n        REAL(8) :: false_margin = exp(log(.5) / n)\n        INTEGER :: errors = 0\n\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(random)\n\n        !Initilization\n        DO x = 1, 10 * LOOPCOUNT\n          IF (random(x) .gt. false_margin) THEN\n            a(x) = .TRUE.\n          ELSE\n            a(x) = .FALSE.\n          END IF\n          a_copy(x) = a(x)\n        END DO\n\n        DO x = 1, 10\n          results(x) = .FALSE.\n        END DO\n\n        !$acc data copy(a(1:10*LOOPCOUNT), results(1:10))\n          !$acc parallel loop gang private(temp)\n          DO x = 0, 9\n            temp = .FALSE.\n            !$acc loop worker reduction(.OR.:temp)\n            DO y = 1, LOOPCOUNT\n              temp = temp .OR. a(x * LOOPCOUNT + y)\n            END DO\n            results(x + 1) = temp\n            !$acc loop worker\n            DO y = 1, LOOPCOUNT\n              IF (results(x + 1) .eqv. .TRUE.) THEN\n                IF(a(x * LOOPCOUNT + y) .eqv. .TRUE.) THEN\n                  a(x * LOOPCOUNT + y) = .FALSE.\n                ELSE\n                  a(x * LOOPCOUNT + y) = .TRUE.\n                END IF\n              END IF\n            END DO\n          END DO\n        !$acc end data\n\n        DO x = 0, 9\n          temp = .FALSE.\n          DO y = 1, LOOPCOUNT\n            temp = temp .OR. a_copy(x * LOOPCOUNT + y)\n          END DO\n          IF (temp .neqv. results(x + 1)) THEN\n            errors = errors + 1\n          END IF\n          DO y = 1, LOOPCOUNT\n            IF (temp .eqv. .FALSE.) THEN\n              IF (a(x * LOOPCOUNT + y) .neqv. a_copy(x * LOOPCOUNT + y)) THEN\n                errors = errors + 1\n              END IF\n            ELSE\n              IF (a(x * LOOPCOUNT + y) .eqv. a_copy(x * LOOPCOUNT + y)) THEN\n                errors = errors + 1\n              END IF\n            END IF\n          END DO\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "parallel",
                            "private",
                            "reduction",
                            "combined-constructs",
                            "loop"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "parallel_loop_reduction_or_loop.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:parallel,loop,reduction,combined-constructs,V:1.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    char * a = (char *)malloc(10 * n * sizeof(char));\n    char * a_copy = (char *)malloc(10 * n * sizeof(char));\n    char * results = (char *)malloc(10 * sizeof(char));\n    char temp = 0;\n    real_t false_margin = pow(exp(1), log(.5)/n);\n\n    for (int x = 0; x < 10 * n; ++x){\n        if (rand() / (real_t)(RAND_MAX) > false_margin){\n            a[x] = 1;\n            a_copy[x] = 1;\n        }\n        else{\n            a[x] = 0;\n            a_copy[x] = 0;\n        }\n    }\n    #pragma acc data copy(a[0:10*n])\n    {\n        #pragma acc parallel loop gang private(temp)\n        for (int x = 0; x < 10; ++x){\n            temp = 0;\n            #pragma acc loop worker reduction(||:temp)\n            for (int y = 0; y < n; ++y){\n                temp = temp || a[x * n + y];\n            }\n            results[x] = temp;\n            #pragma acc loop worker\n            for (int y = 0; y < n; ++y){\n                if(results[x] == 1){\n                    if (a[x * n + y] == 1){\n                        a[x * n + y] = 0;\n                    }\n                    else{\n                        a[x * n + y] = 1;\n                    }\n                }\n            }\n        }\n    }\n    for (int x = 0; x < 10; ++x){\n        temp = 0;\n        for (int y = 0; y < n; ++y){\n            temp = temp || a_copy[x * n + y];\n        }\n        if (temp != results[x]) {\n            err += 1;\n        }\n        for (int y = 0; y < n; ++y){\n            if (temp == 1){\n                if (a[x * n + y] == a_copy[x * n + y]){\n                    err += 1;\n                }\n            }\n            else {\n                if (a[x * n + y] != a_copy[x * n + y]){\n                    err += 1;\n                }\n            }\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "parallel",
                            "loop",
                            "reduction",
                            "combined-constructs"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "parallel_loop_reduction_or_vector_loop.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:parallel,private,reduction,combined-constructs,loop,V:1.0-2.7\n      LOGICAL FUNCTION test1()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x, y !Iterators\n        LOGICAL,DIMENSION(10*LOOPCOUNT):: a !Data\n        LOGICAL,DIMENSION(10) :: b\n        LOGICAL :: temp\n        REAL(8),DIMENSION(10*LOOPCOUNT):: randoms\n        REAL(8) :: false_margin = exp(log(.5) / 2)\n        INTEGER :: errors = 0\n\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(randoms)\n\n        !Initilization\n        DO x = 1, 10 * LOOPCOUNT\n          IF (randoms(x) > false_margin) THEN\n            a(x) = .TRUE.\n          ELSE\n            a(x) = .FALSE.\n          END IF\n        END DO\n\n        !$acc data copyin(a(1:10*LOOPCOUNT)), copy(b(1:10))\n          !$acc parallel loop private(temp)\n          DO x = 0, 9\n            temp = .FALSE.\n            !$acc loop vector reduction(.OR.:temp)\n            DO y = 1, LOOPCOUNT\n              temp = temp .OR. a(x * LOOPCOUNT + y)\n            END DO\n            b(x + 1) = temp\n          END DO\n        !$acc end data\n\n        DO x = 0, 9\n          temp = .FALSE.\n          DO y = 1, LOOPCOUNT\n            temp = temp .OR. a(x * LOOPCOUNT + y)\n          END DO\n          IF (temp .neqv. b(x + 1)) THEN\n            errors = errors + 1\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "parallel",
                            "private",
                            "reduction",
                            "combined-constructs",
                            "loop"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "parallel_loop_reduction_or_vector_loop.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:parallel,loop,reduction,combined-constructs,V:1.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    char * a = (char *)malloc(10 * n * sizeof(char));\n    char * b = (char *)malloc(10 * sizeof(char));\n    real_t false_margin = pow(exp(1), log(.5)/n);\n    char temp = 0;\n    char found;\n\n    for (int x = 0; x < 10 * n; ++x){\n        if(rand() / (real_t)(RAND_MAX) > false_margin){\n            a[x] = 1;\n        }\n        else{\n            a[x] = 0;\n        }\n    }\n    #pragma acc data copyin(a[0:10*n]) copy(b[0:10])\n    {\n        #pragma acc parallel loop private(temp)\n        for (int x = 0; x < 10; ++x){\n            temp = 0;\n            #pragma acc loop vector reduction(||:temp)\n            for (int y = 0; y < n; ++y){\n                temp = temp || a[x * n + y];\n            }\n            b[x] = temp;\n        }\n    }\n    for (int x = 0; x < 10; ++x){\n        found = 0;\n        for (int y = 0; y < n; ++y){\n            if (a[x * n + y] &! 0){\n                found = 1;\n            }\n        }\n        if (found != b[x]){\n            err = 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "parallel",
                            "loop",
                            "reduction",
                            "combined-constructs"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "parallel_loop_seq.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:parallel,combined-constructs,loop,V:1.0-2.7\n      LOGICAL FUNCTION test1()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT):: a, b !Data\n        INTEGER :: errors = 0\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(a)\n        b = 0\n\n        !$acc data copyin(a(1:LOOPCOUNT)) copy(b(1:LOOPCOUNT))\n          !$acc parallel loop seq\n          DO x = 2, LOOPCOUNT\n            b(x) = b(x - 1) + a(x)\n          END DO\n        !$acc end data\n        \n        DO x = 2, LOOPCOUNT\n          IF (abs(b(x) - (b(x - 1) + a(x))) .gt. PRECISION) THEN\n            errors = errors + 1\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "parallel",
                            "combined-constructs",
                            "loop"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "parallel_loop_seq.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:parallel,loop,combined-constructs,V:1.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n    real_t temp = 0.0;\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = 0.0;\n    }\n\n    #pragma acc data copyin(a[0:n]) copy(b[0:n])\n    {\n        #pragma acc parallel loop seq\n        for (int x = 1; x < n; ++x){\n            b[x] = b[x-1] + a[x];\n        }\n    }\n\n    for (int x = 1; x < n; ++x){\n        temp += a[x];\n        if (fabs(b[x] - temp) > PRECISION){\n            err = 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "parallel",
                            "loop",
                            "combined-constructs"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "parallel_loop_tile.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:parallel,reduction,combined-constructs,loop,tile,V:2.0-2.7\n      LOGICAL FUNCTION test1()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x, y, z !Iterators\n        REAL(8),DIMENSION(SMALL_LOOPCOUNT):: a, b, c !Data\n        REAL(8),DIMENSION(SMALL_LOOPCOUNT,SMALL_LOOPCOUNT)::d\n        REAL(8) :: temp\n        INTEGER :: errors = 0\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(a)\n        CALL RANDOM_NUMBER(b)\n        CALL RANDOM_NUMBER(c)\n\n        !$acc data copyin(a(1:SMALL_LOOPCOUNT), b(1:SMALL_LOOPCOUNT), c(1:SMALL_LOOPCOUNT)) copyout(d(1:SMALL_LOOPCOUNT,1:SMALL_LOOPCOUNT))\n          !$acc parallel loop tile(*, *) reduction(+:temp)\n          DO x = 1, SMALL_LOOPCOUNT\n            DO y = 1, SMALL_LOOPCOUNT \n              temp = 0\n              DO z = 1, SMALL_LOOPCOUNT\n                temp = temp + a(z) + b(z) + c(z)\n              END DO\n              d(x,y) = temp\n            END DO\n          END DO\n        !$acc end data\n        \n        DO x = 1, SMALL_LOOPCOUNT \n          DO y = 1, SMALL_LOOPCOUNT \n            temp = 0\n            DO z = 1, SMALL_LOOPCOUNT\n              temp = temp + a(z) + b(z) + c(z) \n            END DO\n            IF (abs(d(x,y) - temp) .gt. PRECISION) THEN\n              errors = errors + 1\n            END IF\n          END DO\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "parallel",
                            "reduction",
                            "combined-constructs",
                            "loop",
                            "tile"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "parallel_loop_tile.c": {
                "num tests": 2,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:parallel,loop,tile,reduction,combined-constructs,V:2.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n    real_t * c = (real_t *)malloc(n * sizeof(real_t));\n    real_t * d2 = (real_t *)malloc(n * n * sizeof(real_t));\n    real_t * d3 = (real_t *)malloc(n * n * n * sizeof(real_t));\n    real_t temp = 0.0;\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n        c[x] = rand() / (real_t)(RAND_MAX / 10);\n    }\n    #pragma acc data copy(a[0:n], b[0:n], c[0:n], d2[0:n*n])\n    {\n        #pragma acc parallel loop tile(*, *) reduction(+:temp)\n        for (int x = 0; x < n; ++x){\n            for (int y = 0; y < n; ++y){\n                temp = 0;\n                for (int z = 0; z < n; ++z){\n                    temp += a[x] + b[y] + c[z];\n                }\n                d2[x * n + y] = temp;\n            }\n        }\n    }\n    for (int x = 0; x < n; ++x){\n        for (int y = 0; y < n; ++y){\n            temp = 0.0;\n            for (int z = 0; z < n; ++z){\n                temp += a[x] + b[y] + c[z];\n            }\n            if (fabs(temp - d2[x * n + y]) > PRECISION * n){\n                err += 1;\n            }\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "parallel",
                            "loop",
                            "tile",
                            "reduction",
                            "combined-constructs"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "2": {
                        "content": "#ifndef T2\n//T2:parallel,loop,tile,combined-constructs,V:2.0-2.7\nint test2(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n    real_t * c = (real_t *)malloc(n * sizeof(real_t));\n    real_t * d2 = (real_t *)malloc(n * n * sizeof(real_t));\n    real_t * d3 = (real_t *)malloc(n * n * n * sizeof(real_t));\n    real_t temp = 0.0;\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n        c[x] = rand() / (real_t)(RAND_MAX / 10);\n    }\n\n    #pragma acc data copyin(a[0:n], b[0:n], c[0:n]) copyout(d3[0:n*n*n])\n    {\n        #pragma acc parallel loop tile(2, 4, 8)\n        for (int x = 0; x < n; ++x){\n            for (int y = 0; y < n; ++y){\n                for (int z = 0; z < n; ++z){\n                    d3[(n * n * x) + (n * y) + z] = a[x] + b[x] + c[x];\n                }\n            }\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        for (int y = 0; y < n; ++y){\n            for (int z = 0; z < n; ++z){\n                if (fabs(d3[(n * n * x) + (n * y) + z] - a[x] - b[x] - c[x]) > PRECISION * 2){\n                    err = 1;\n                }\n            }\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T2\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test2();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 1);\n    }\n#endif\n",
                        "tags": [
                            "parallel",
                            "loop",
                            "tile",
                            "combined-constructs"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "parallel_loop_vector.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:parallel,combined-constructs,loop,V:1.0-2.7\n      LOGICAL FUNCTION test1()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT):: a, b, c !Data\n        INTEGER :: errors = 0\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(a)\n        CALL RANDOM_NUMBER(b)\n        c = 0\n\n        !$acc data copyin(a(1:LOOPCOUNT), b(1:LOOPCOUNT)) copy(c(1:LOOPCOUNT))\n          !$acc parallel loop vector\n          DO x = 1, LOOPCOUNT\n            c(x) = a(x) + b(x)\n          END DO\n        !$acc end data\n        \n        DO x = 1, LOOPCOUNT\n          IF (abs(c(x) - (a(x) + b(x))) .gt. PRECISION) THEN\n            errors = errors + 1\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "parallel",
                            "combined-constructs",
                            "loop"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "parallel_loop_vector.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:parallel,loop,vector,combined-constructs,V:1.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n    real_t * c = (real_t *)malloc(n * sizeof(real_t));\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n        c[x] = 0.0;\n    }\n\n    #pragma acc data copyin(a[0:n], b[0:n]) copy(c[0:n])\n    {\n        #pragma acc parallel loop vector\n        for (int x = 0; x < n; ++x){\n            c[x] = a[x] + b[x];\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        if(fabs(c[x] - (a[x] + b[x])) > PRECISION){\n            err = 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "parallel",
                            "loop",
                            "vector",
                            "combined-constructs"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "parallel_loop_vector_blocking.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:parallel,loop,V:1.0-2.7\n      LOGICAL FUNCTION test1()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT):: a, b, c !Data\n        REAL(8) :: multiplyer\n        INTEGER :: errors = 0\n\n        multiplyer = 1\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(a)\n        CALL RANDOM_NUMBER(b)\n        c = 0\n\n        !$acc data copyin(a(1:LOOPCOUNT), b(1:LOOPCOUNT)) copyout(c(1:LOOPCOUNT))\n          !$acc parallel\n            !$acc loop vector\n            DO x = 1, LOOPCOUNT\n              c(x) = (a(x) + b(x)) * multiplyer\n            END DO\n            multiplyer = multiplyer + 1\n            !$acc loop vector\n            DO x = 1, LOOPCOUNT\n              c(x) = c(x) + ((a(x) + b(x)) * multiplyer)\n            END DO\n          !$acc end parallel\n        !$acc end data\n\n        DO x = 1, LOOPCOUNT\n          IF (abs(c(x) - (3 * (a(x) + b(x)))) .gt. PRECISION) THEN\n            errors = errors + 1\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "parallel",
                            "loop"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "parallel_loop_vector_blocking.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:parallel,loop,V:1.0-2.7\nint test1(){\n  int err = 0;\n  srand(SEED);\n  real_t * a = (real_t *)malloc(n * sizeof(real_t));\n  real_t * b = (real_t *)malloc(n * sizeof(real_t));\n  real_t * c = (real_t *)malloc(n * sizeof(real_t));\n  real_t multiplyer = 1;\n\n  for (int x = 0; x < n; ++x){\n      a[x] = rand() / (real_t)(RAND_MAX / 10);\n      b[x] = rand() / (real_t)(RAND_MAX / 10);\n      c[x] = 0.0;\n  }\n\n  #pragma acc data copyin(a[0:n], b[0:n]) copyout(c[0:n])\n  {\n    #pragma acc parallel\n    {\n      #pragma acc loop vector\n      for (int x = 0; x < n; ++x){\n        c[x] = (a[x] + b[x]) * multiplyer;\n      }\n      multiplyer += 1;\n      #pragma acc loop vector\n      for (int x = 0; x < n; ++x){\n        c[x] += (a[x] + b[x]) * multiplyer;\n      }\n    }\n  }\n\n  for (int x = 0; x < n; ++x){\n    if (fabs(c[x] - 3 * (a[x] + b[x])) > PRECISION){\n      err + 1;\n      break;\n    }\n  }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "parallel",
                            "loop"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "parallel_loop_worker.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:parallel,combined-constructs,loop,V:1.0-2.7\n      LOGICAL FUNCTION test1()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT):: a, b, c !Data\n        INTEGER :: errors = 0\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(a)\n        CALL RANDOM_NUMBER(b)\n        c = 0\n\n        !$acc data copyin(a(1:LOOPCOUNT), b(1:LOOPCOUNT)) copyout(c(1:LOOPCOUNT))\n          !$acc parallel loop worker\n          DO x = 1, LOOPCOUNT\n            c(x) = a(x) + b(x)\n          END DO\n        !$acc end data\n\n        DO x = 1, LOOPCOUNT\n          IF (abs(c(x) - (a(x) + b(x))) .gt. PRECISION) THEN\n            errors = errors + 1\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "parallel",
                            "combined-constructs",
                            "loop"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "parallel_loop_worker.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:parallel,loop,combined-constructs,V:1.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n    real_t * c = (real_t *)malloc(n * sizeof(real_t));\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n        c[x] = 0.0;\n    }\n\n    #pragma acc data copyin(a[0:n], b[0:n]) copy(c[0:n])\n    {\n        #pragma acc parallel loop worker\n        for (int x = 0; x < n; ++x){\n            c[x] = a[x] + b[x];\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        if (fabs(c[x] - (a[x] + b[x])) > PRECISION){\n            err = 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "parallel",
                            "loop",
                            "combined-constructs"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "parallel_loop_worker_blocking.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:parallel,loop,V:1.0-2.7\n      LOGICAL FUNCTION test1()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT):: a, b, c !Data\n        REAL(8) :: multiplyer\n        INTEGER :: errors = 0\n\n        multiplyer = 1\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(a)\n        CALL RANDOM_NUMBER(b)\n\n        !$acc data copyin(a(1:LOOPCOUNT), b(1:LOOPCOUNT)) copyout(c(1:LOOPCOUNT))\n          !$acc parallel\n            !$acc loop worker\n            DO x = 1, LOOPCOUNT\n              c(x) = (a(x) + b(x)) * multiplyer\n            END DO\n            multiplyer = multiplyer + 1\n            !$acc loop worker\n            DO x = 1, LOOPCOUNT\n              c(x) = c(x) + (a(x) + b(x)) * multiplyer\n            END DO\n          !$acc end parallel\n        !$acc end data\n\n        DO x = 1, LOOPCOUNT\n          IF (abs(c(x) - (3 * (a(x) + b(x)))) .gt. PRECISION) THEN\n            errors = errors + 1\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "parallel",
                            "loop"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "parallel_loop_worker_blocking.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:parallel,loop,V:1.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n    real_t * c = (real_t *)malloc(n * sizeof(real_t));\n    real_t multiplyer = 1;\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n        c[x] = 0.0;\n    }\n\n    #pragma acc data copyin(a[0:n], b[0:n]) copyout(c[0:n])\n    {\n      #pragma acc parallel\n      {\n        #pragma acc loop worker\n        for (int x = 0; x < n; ++x){\n          c[x] = (a[x] + b[x]) * multiplyer;\n        }\n        multiplyer += 1;\n        #pragma acc loop worker\n        for (int x = 0; x < n; ++x){\n          c[x] += (a[x] + b[x]) * multiplyer;\n        }\n      }\n    }\n\n    for (int x = 0; x < n; ++x){\n      if (fabs(c[x] - 3 * (a[x] + b[x])) > PRECISION){\n        err + 1;\n        break;\n      }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "parallel",
                            "loop"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "parallel_present.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:parallel,V:2.0-2.7\n      LOGICAL FUNCTION test1()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT):: a, b, c !Data\n        INTEGER :: errors = 0\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(a)\n        CALL RANDOM_NUMBER(b)\n        c = 0\n\n        !$acc enter data copyin(a(1:LOOPCOUNT), b(1:LOOPCOUNT))\n        !$acc parallel present(a(1:LOOPCOUNT), b(1:LOOPCOUNT)) copy(c(1:LOOPCOUNT))\n          !$acc loop\n          DO x = 1, LOOPCOUNT\n            c(x) = a(x) + b(x)\n          END DO\n        !$acc end parallel\n        !$acc exit data delete(a(1:LOOPCOUNT), b(1:LOOPCOUNT))\n\n        DO x = 1, LOOPCOUNT\n          IF (abs(c(x) - (a(x) + b(x))) .gt. PRECISION) THEN\n            errors = errors + 1\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "parallel"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "parallel_present.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:parallel,present,V:2.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n    real_t * c = (real_t *)malloc(n * sizeof(real_t));\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n        c[x] = 0.0;\n    }\n\n    #pragma acc enter data copyin(a[0:n], b[0:n])\n    #pragma acc parallel present(a[0:n], b[0:n]) copy(c[0:n])\n    {\n        #pragma acc loop\n        for (int x = 0; x < n; ++x){\n            c[x] = a[x] + b[x];\n        }\n    }\n    #pragma acc exit data delete(a[0:n], b[0:n])\n\n    for (int x = 0; x < n; ++x){\n        if (fabs(c[x] - (a[x] + b[x])) > PRECISION){\n            err += 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "parallel",
                            "present"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "parallel_private.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:parallel,private,V:2.0-2.7\n      LOGICAL FUNCTION test1()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x, y !Iterators\n        REAL(8),DIMENSION(10 * LOOPCOUNT):: a, b !Data\n        REAL(8),DIMENSION(LOOPCOUNT):: c\n        REAL(8),DIMENSION(10)::d\n        REAL(8) :: temp\n        INTEGER :: errors = 0\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(a)\n        CALL RANDOM_NUMBER(b)\n        c = 0\n        d = 0\n\n        !$acc enter data copyin(a(1:10*LOOPCOUNT), b(1:10*LOOPCOUNT), d(1:10)) \n        !$acc parallel num_gangs(10) private(c(1:LOOPCOUNT))\n          !$acc loop gang\n          DO x = 1, 10\n            !$acc loop worker\n            DO y = 1, LOOPCOUNT\n              c(y) = a((x - 1) * LOOPCOUNT + y) + b((x - 1) * LOOPCOUNT + y)\n            END DO\n            !$acc loop seq\n            DO y = 1, LOOPCOUNT\n              d(x) = d(x) + c(y)\n            END DO\n          END DO\n        !$acc end parallel\n        !$acc exit data copyout(d(1:10)) delete(a(1:10*LOOPCOUNT), b(1:10*LOOPCOUNT))\n\n        DO x = 0, 9\n          temp = 0\n          DO y = 1, LOOPCOUNT\n            temp = temp + a(x * LOOPCOUNT + y) + b(x * LOOPCOUNT + y)\n          END DO\n          IF (abs(temp - d(x + 1)) .gt. 2 * PRECISION * LOOPCOUNT) THEN\n            errors = errors + 1\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "parallel",
                            "private"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "parallel_private.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:parallel,private,V:2.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(10 * n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(10 * n * sizeof(real_t));\n    real_t * c = (real_t *)malloc(n * sizeof(real_t));\n    real_t * d = (real_t *)malloc(10 * sizeof(real_t));\n\n    for (int x = 0; x < 10; ++x){\n        for (int y = 0; y < n; ++y){\n            a[x * n + y] = rand() / (real_t)(RAND_MAX / 10);\n            b[x * n + y] = rand() / (real_t)(RAND_MAX / 10);\n            c[y] = 0.0;\n        }\n        d[x] = 0.0;\n    }\n\n    #pragma acc enter data copyin(a[0:10*n], b[0:10*n], d[0:10])\n    #pragma acc parallel num_gangs(10) private(c[0:n])\n    {\n        #pragma acc loop gang\n        for (int x = 0; x < 10; ++x){\n            #pragma acc loop worker\n            for (int y = 0; y < n; ++y){\n                c[y] = a[x * n + y] + b[x * n + y];\n            }\n            #pragma acc loop seq\n            for (int y = 0; y < n; ++y){\n                d[x] += c[y];\n            }\n        }\n    }\n    #pragma acc exit data copyout(d[0:10]) delete(a[0:10*n], b[0:10*n])\n\n    real_t temp;\n    for (int x = 0; x < 10; ++x){\n        temp = 0.0;\n        for (int y = 0; y < n; ++y){\n            temp += a[x * n + y] + b[x * n + y];\n        }\n        if (fabs(temp - d[x]) > (2 * PRECISION * n)){\n            err = 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "parallel",
                            "private"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "parallel_reduction.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:parallel,reduction,V:1.0-2.7\n      LOGICAL FUNCTION test1()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT):: a !Data\n        REAL(8) :: results = 0\n        INTEGER :: errors = 0\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(a)\n\n        !$acc data copyin(a(1:LOOPCOUNT))\n          !$acc parallel reduction(+:results)\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              results = results + a(x)\n            END DO\n          !$acc end parallel\n        !$acc end data\n        DO x = 1, LOOPCOUNT\n          results = results - a(x)\n        END DO\n        IF (abs(results) .gt. PRECISION) THEN\n          errors = errors + 1\n        END IF\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "parallel",
                            "reduction"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "parallel_reduction.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:parallel,reduction,V:1.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(n * sizeof(real_t));\n    real_t reduction;\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n    }\n\n    #pragma acc parallel copyin(a[0:n]) reduction(+:reduction)\n    {\n        #pragma acc loop\n        for (int x = 0; x < n; ++x){\n            reduction = reduction + a[x];\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        reduction = reduction - a[x];\n    }\n    if (fabs(reduction) > PRECISION){\n        err += 1;\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "parallel",
                            "reduction"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "parallel_scalar_default_firstprivate.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:parallel,V:1.0-2.7\n      LOGICAL FUNCTION test1()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT):: a, b !Data\n        REAL(8),DIMENSION(1):: random\n        INTEGER :: errors = 0\n        REAL(8) :: scalar\n        REAL(8) :: scalar_copy\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(random)\n        scalar = random(1)\n        scalar_copy = scalar\n        CALL RANDOM_NUMBER(a)\n        b = 0\n\n        !$acc data copyin(a(1:LOOPCOUNT)) copyout(b(1:LOOPCOUNT))\n          !$acc parallel\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              b(x) = a(x) + scalar\n            END DO\n          !$acc end parallel\n        !$acc end data\n        DO x = 1, LOOPCOUNT\n          IF (abs(b(x) - (a(x) + scalar_copy)) .gt. PRECISION) THEN\n            errors = errors + 1\n          END IF\n        END DO\n        IF (abs(scalar_copy - scalar) .gt. PRECISION) THEN\n          errors = errors + 1\n        END IF\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "parallel"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "parallel_scalar_default_firstprivate.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:parallel,data,data-region,default-mapping,V:2.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n    real_t scalar = rand() / (real_t)(RAND_MAX / 10);\n    real_t scalar_copy = scalar;\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = 0.0;\n    }\n\n    #pragma acc data copyin(a[0:n]) copyout(b[0:n])\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                b[x] = a[x] + scalar;\n            }\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        if (fabs(b[x] - (a[x] + scalar_copy)) > PRECISION){\n            err += 1;\n        }\n    }\n    if (fabs(scalar_copy - scalar) > PRECISION){\n        err += 1;\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "parallel",
                            "data",
                            "data-region",
                            "default-mapping"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "parallel_switch.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:parallel,V:2.0-2.7\n      LOGICAL FUNCTION test1()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x !Iterators\n        INTEGER,DIMENSION(LOOPCOUNT):: a\n        REAL(8),DIMENSION(LOOPCOUNT):: b, c, randoms!Data\n        INTEGER :: errors = 0\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(b)\n        c = 0\n        CALL RANDOM_NUMBER(randoms)\n        a = floor(randoms * 3)\n\n        !$acc enter data copyin(a(1:LOOPCOUNT), b(1:LOOPCOUNT), c(1:LOOPCOUNT))\n        !$acc parallel present(a(1:LOOPCOUNT), b(1:LOOPCOUNT), c(1:LOOPCOUNT))\n          !$acc loop\n          DO x = 1, LOOPCOUNT\n            SELECT CASE (a(x))\n              CASE (0)\n                c(x) = b(x) * b(x)\n              CASE (1)\n                c(x) = b(x) / b(x)\n              CASE (2)\n                c(x) = b(x) / 2\n            END SELECT\n          END DO\n        !$acc end parallel\n        !$acc exit data delete(a(1:LOOPCOUNT), b(1:LOOPCOUNT)) copyout(c(1:LOOPCOUNT))\n\n        DO x = 1, LOOPCOUNT\n          SELECT CASE (a(x))\n            CASE (0)\n              IF (abs(c(x) - (b(x) * b(x))) .gt. PRECISION) THEN\n                errors = errors + 1\n              END IF\n            CASE (1)\n              IF (abs(c(x) - (b(x) / b(x))) .gt. PRECISION) THEN\n                errors = errors + 1\n              END IF\n            CASE (2)\n              IF (abs(c(x) - (b(x) / 2)) .gt. PRECISION) THEN\n                errors = errors + 1\n              END IF\n          END SELECT\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "parallel"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "parallel_switch.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:parallel,syntactic,V:2.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    int * a = (int *)malloc(n * sizeof(int));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n    real_t * b_host = (real_t *)malloc(n * sizeof(real_t));\n    real_t * c = (real_t *)malloc(n * sizeof(real_t));\n    real_t tempc = 0.0;\n\n    for (int x = 0; x < n; ++x){\n        a[x] = floor(rand() / (real_t)(RAND_MAX / 10));\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n        b_host[x] = b[x];\n        c[x] = 0.0;\n    }\n    #pragma acc enter data copyin(a[0:n], b[0:n], c[0:n])\n    #pragma acc parallel present(a[0:n], b[0:n], c[0:n])\n    {\n        #pragma acc loop\n        for (int x = 0; x < n; ++x){\n            switch(a[x]){\n                case 0:\n                    c[x] = b[x] * b[x];\n                    break;\n                case 1:\n                    c[x] = b[x] / b[x];\n                    break;\n                case 2:\n                    b[x] = b[x] / 2;\n                default:\n                    c[x] = a[x] + b[x];\n\n\n            }\n        }\n    }\n    #pragma acc exit data delete(a[0:n], b[0:n]) copyout(c[0:n])\n\n    for (int x = 0; x < n; ++x){\n        switch(a[x]){\n            case 0:\n                tempc = b_host[x] * b_host[x];\n                break;\n            case 1:\n                tempc = b_host[x] / b_host[x];\n                break;\n            case 2:\n                b_host[x] = b_host[x] / 2;\n            default:\n                tempc = a[x] + b_host[x];\n        }\n        if (fabs(c[x] - tempc) > PRECISION){\n            err = 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "parallel",
                            "syntactic"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "parallel_wait.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:async,parallel,update,V:2.0-2.7\n      LOGICAL FUNCTION test1()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT):: a, b !Data\n        INTEGER :: errors = 0\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(a)\n        b = a\n\n        !$acc enter data create(a(1:LOOPCOUNT))\n        !$acc update device(a(1:LOOPCOUNT)) async(1)\n        !$acc parallel present(a(1:LOOPCOUNT)) wait(1)\n          !$acc loop\n          DO x = 1, LOOPCOUNT\n            a(x) = a(x) + 1\n          END DO\n        !$acc end parallel\n        !$acc exit data copyout(a(1:LOOPCOUNT))\n\n        DO x = 1, LOOPCOUNT\n          IF (abs(a(x) - (b(x) + 1)) .gt. PRECISION) THEN\n            errors = errors + 1\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "async",
                            "parallel",
                            "update"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "parallel_wait.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:parallel,wait,async,V:2.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t *a = (real_t *)malloc(n * sizeof(real_t));\n    real_t *b = (real_t *)malloc(n * sizeof(real_t));\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = a[x];\n    }\n\n    #pragma acc enter data create(a[0:n])\n    #pragma acc update device(a[0:n]) async(1)\n    #pragma acc parallel present(a[0:n]) wait(1)\n    {\n        #pragma acc loop\n        for (int x = 0; x < n; ++x){\n            a[x] += 1;\n        }\n    }\n    #pragma acc exit data copyout(a[0:n])\n    for (int x = 0; x < n; ++x){\n        if (fabs(a[x] - (b[x] + 1)) > PRECISION){\n            err = 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "parallel",
                            "wait",
                            "async"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "parallel_while_loop.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:parallel,reduction,loop,V:1.0-2.7\n      LOGICAL FUNCTION test1()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x, y !Iterators\n        REAL(8),DIMENSION(10, LOOPCOUNT):: a !Data\n        REAL(8) :: avg\n        INTEGER :: errors = 0\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(a)\n \n        !$acc data copy(a(1:10, 1:LOOPCOUNT))\n          !$acc parallel\n            !$acc loop\n            DO x = 1, 10\n              avg = 0.0\n              DO WHILE (avg - 1000 .lt. PRECISION * LOOPCOUNT)\n                avg = 0.0\n                !$acc loop\n                DO y = 1, LOOPCOUNT\n                  a(x, y) = a(x, y) * 1.5\n                END DO\n                !$acc loop reduction(+:avg)\n                DO y = 1, LOOPCOUNT\n                  avg = avg + (a(x, y) / LOOPCOUNT)\n                END DO\n              END DO\n            END DO\n          !$acc end parallel\n        !$acc end data\n\n        DO x = 1, 10\n          avg = 0.0\n          DO y = 1, LOOPCOUNT\n            avg = avg + (a(x, y) / LOOPCOUNT)\n          END DO\n          IF (avg < 1000 .OR. avg > 1600) THEN\n            errors = errors + 1\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "parallel",
                            "reduction",
                            "loop"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "parallel_while_loop.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:parallel,syntactic,V:1.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(10 * n * sizeof(real_t));\n    real_t avg = 0.0;\n\n    for (int x = 0; x < 10 * n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        avg += a[x]/(n * 10);\n    }\n\n    #pragma acc data copy(a[0:10*n])\n    {\n        #pragma acc parallel\n        {\n            real_t avg = 0.0;\n            #pragma acc loop\n            for (int y = 0; y < 10; ++y){\n                avg = 0.0;\n                while (avg - 1000 < PRECISION * n){\n                    avg = 0.0;\n                    #pragma acc loop reduction(+:avg)\n                    for (int x = 0; x < n; ++x){\n                        a[n * y + x] *= 1.5;\n                        avg += a[n * y + x] / n;\n                    }\n                }\n            }\n        }\n    }\n\n    avg = 0.0;\n    for (int x = 0; x < n; ++x){\n        avg += a[x]/n;\n    }\n\n    if (avg < 1000 || avg > 1600){\n        err = 1;\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "parallel",
                            "syntactic"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "routine_bind.c": {
                "num tests": 4,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:routine,construct-independent,V:2.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t **a = (real_t **)malloc(n * sizeof(real_t *));\n    real_t *b = (real_t *)malloc(n * sizeof(real_t));\n    int on_host = (acc_get_device_type() == acc_device_none);\n    for (int x = 0; x < n; ++x){\n        a[x] = (real_t *)malloc(n * sizeof(real_t));\n    }\n\n    for (int x = 0; x < n; ++x){\n        for (int y = 0; y < n; ++y){\n            a[x][y] = rand() / (real_t)(RAND_MAX / 10);\n        }\n        b[x] = 0;\n    }\n\n    #pragma acc data copyin(a[0:n][0:n]) copyout(b[0:n])\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop gang worker vector\n            for (int x = 0; x < n; ++x){\n                b[x] = host_function_identifier_unnamed(a[x], n);\n            }\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        if ((!on_host) && (fabs(host_function_identifier_unnamed(a[x], n) + b[x]) > PRECISION)){\n            err += 1;\n            return 1;\n        }\n        else if ((on_host) && (fabs(host_function_identifier_unnamed(a[x], n) - b[x]) > PRECISION)){\n            err += 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "routine",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "2": {
                        "content": "#ifndef T2\n//T2:routine,construct-independent,V:2.0-2.7\nint test2(){\n    int err = 0;\n    srand(SEED);\n    real_t **a = (real_t **)malloc(n * sizeof(real_t *));\n    real_t *b = (real_t *)malloc(n * sizeof(real_t));\n    int on_host = (acc_get_device_type() == acc_device_none);\n    for (int x = 0; x < n; ++x){\n        a[x] = (real_t *)malloc(n * sizeof(real_t));\n    }\n\n    for (int x = 0; x < n; ++x){\n        for (int y = 0; y < n; ++y){\n            a[x][y] = rand() / (real_t)(RAND_MAX / 10);\n        }\n    }\n\n    #pragma acc data copyin(a[0:n][0:n]) copyout(b[0:n])\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop gang worker vector\n            for (int x = 0; x < n; ++x){\n                b[x] = host_function_string_unnamed(a[x], n);\n            }\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        if (!on_host && fabs(host_function_string_unnamed(a[x], n) + b[x]) > PRECISION){\n            err += 1;\n        }\n        else if (on_host && fabs(host_function_string_unnamed(a[x], n) - b[x]) > PRECISION){\n            err += 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T2\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test2();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 1);\n    }\n#endif\n",
                        "tags": [
                            "routine",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "3": {
                        "content": "#ifndef T3\n//T3:routine,construct-independent,V:2.0-2.7\nint test3(){\n    int err = 0;\n    srand(SEED);\n    real_t **a = (real_t **)malloc(n * sizeof(real_t *));\n    real_t *b = (real_t *)malloc(n * sizeof(real_t));\n    int on_host = (acc_get_device_type() == acc_device_none);\n    for (int x = 0; x < n; ++x){\n        a[x] = (real_t *)malloc(n * sizeof(real_t));\n    }\n\n    for (int x = 0; x < n; ++x){\n        for (int y = 0; y < n; ++y){\n            a[x][y] = rand() / (real_t)(RAND_MAX / 10);\n        }\n    }\n\n    #pragma acc data copyin(a[0:n][0:n]) copyout(b[0:n])\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop gang worker vector\n            for (int x = 0; x < n; ++x){\n                b[x] = host_function_identifier_named(a[x], n);\n            }\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        if (!on_host && fabs(host_function_identifier_named(a[x], n) + b[x]) > PRECISION){\n            err += 1;\n        }\n        else if (on_host && fabs(host_function_identifier_named(a[x], n) - b[x]) > PRECISION){\n            err += 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T3\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test3();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 2);\n    }\n#endif\n",
                        "tags": [
                            "routine",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "4": {
                        "content": "#ifndef T4\n//T4:routine,construct-independent,V:2.0-2.7\nint test4(){\n    int err = 0;\n    srand(SEED);\n    real_t **a = (real_t **)malloc(n * sizeof(real_t *));\n    real_t *b = (real_t *)malloc(n * sizeof(real_t));\n    int on_host = (acc_get_device_type() == acc_device_none);\n    for (int x = 0; x < n; ++x){\n        a[x] = (real_t *)malloc(n * sizeof(real_t));\n    }\n\n    for (int x = 0; x < n; ++x){\n        for (int y = 0; y < n; ++y){\n            a[x][y] = rand() / (real_t)(RAND_MAX / 10);\n        }\n    }\n\n    #pragma acc data copyin(a[0:n][0:n]) copyout(b[0:n])\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop gang worker vector\n            for (int x = 0; x < n; ++x){\n                b[x] = host_function_string_named(a[x], n);\n            }\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        if (!on_host && fabs(host_function_string_named(a[x], n) + b[x]) > PRECISION){\n            err += 1;\n        }\n        else if (on_host && fabs(host_function_string_named(a[x], n) - b[x]) > PRECISION){\n            err += 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T4\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test4();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 3);\n    }\n#endif\n",
                        "tags": [
                            "routine",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "routine_gang.c": {
                "num tests": 10,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:routine,construct-independent,V:2.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t ** a = (real_t **)malloc(n * sizeof(real_t *));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n    for (int x = 0; x < n; ++x){\n        a[x] = (real_t *)malloc(n * sizeof(real_t));\n    }\n\n    for (int x = 0; x < n; ++x)\n        for (int y = 0; y < n; ++y){\n            a[x][y] = rand() / (real_t)(RAND_MAX / 10);\n        }\n        b[x] = 0;\n    }\n\n    #pragma acc data copyin(a[0:n][0:n]) copy(b[0:n])\n    {\n        #pragma acc parallel\n        {\n              test_routine_gang_loop_unnamed(a, b, n);\n        }\n    }\n\n    if (validate_data(a, b)){\n        err += 1;\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "routine",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "10": {
                        "content": "#ifndef T10\n//T10:routine,construct-independent,V:2.0-2.7\nint test10(){\n    int err = 0;\n    srand(SEED);\n    real_t ** a = (real_t **)malloc(n * sizeof(real_t *));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n    for (int x = 0; x < n; ++x){\n        a[x] = (real_t *)malloc(n * sizeof(real_t));\n    }\n\n    for (int x = 0; x < n; ++x){\n        for (int y = 0; y < n; ++y){\n            a[x][y] = rand() / (real_t)(RAND_MAX / 10);\n        }\n        b[x] = 0;\n    }\n\n    #pragma acc data copyin(a[0:n][0:n]) copy(b[0:n])\n    {\n        #pragma acc parallel\n        {\n            test_routine_gang_seq_named(a, b, n);\n        }\n    }\n\n    if (validate_data(a, b)){\n        err += 1;\n    }\n\n    return err;\n}\n#endif\n#ifndef T10\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test10();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 9);\n    }\n#endif\n",
                        "tags": [
                            "routine",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "2": {
                        "content": "#ifndef T2\n//T2:routine,construct-independent,V:2.0-2.7\nint test2(){\n    int err = 0;\n    srand(SEED);\n    real_t ** a = (real_t **)malloc(n * sizeof(real_t *));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n    for (int x = 0; x < n; ++x){\n        a[x] = (real_t *)malloc(n * sizeof(real_t));\n    }\n\n    for (int x = 0; x < n; ++x){\n        for (int y = 0; y < n; ++y){\n            a[x][y] = rand() / (real_t)(RAND_MAX / 10);\n        }\n        b[x] = 0;\n    }\n\n    #pragma acc data copyin(a[0:n][0:n]) copy(b[0:n])\n    {\n        #pragma acc parallel\n        {\n            test_routine_gang_loop_named(a, b, n);\n        }\n    }\n\n    if (validate_data(a, b)){\n        err += 1;\n    }\n\n    return err;\n}\n#endif\n#ifndef T2\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test2();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 1);\n    }\n#endif\n",
                        "tags": [
                            "routine",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "3": {
                        "content": "#ifndef T3\n//T3:routine,construct-independent,V:2.0-2.7\nint test3(){\n    int err = 0;\n    srand(SEED);\n    real_t ** a = (real_t **)malloc(n * sizeof(real_t *));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n    for (int x = 0; x < n; ++x){\n        a[x] = (real_t *)malloc(n * sizeof(real_t));\n    }\n\n    for (int x = 0; x < n; ++x){\n        for (int y = 0; y < n; ++y){\n            a[x][y] = rand() / (real_t)(RAND_MAX / 10);\n        }\n        b[x] = 0;\n    }\n\n    #pragma acc data copyin(a[0:n][0:n]) copy(b[0:n])\n    {\n        #pragma acc parallel\n        {\n            test_routine_gang_gang_unnamed(a, b, n);\n        }\n    }\n\n    if (validate_data(a, b)){\n        err += 1;\n    }\n\n    return err;\n}\n#endif\n#ifndef T3\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test3();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 2);\n    }\n#endif\n",
                        "tags": [
                            "routine",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "4": {
                        "content": "#ifndef T4\n//T4:routine,construct-independent,V:2.0-2.7\nint test4(){\n    int err = 0;\n    srand(SEED);\n    real_t ** a = (real_t **)malloc(n * sizeof(real_t *));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n    for (int x = 0; x < n; ++x){\n        a[x] = (real_t *)malloc(n * sizeof(real_t));\n    }\n\n    for (int x = 0; x < n; ++x){\n        for (int y = 0; y < n; ++y){\n            a[x][y] = rand() / (real_t)(RAND_MAX / 10);\n        }\n        b[x] = 0;\n    }\n\n    #pragma acc data copyin(a[0:n][0:n]) copy(b[0:n])\n    {\n        #pragma acc parallel\n        {\n            test_routine_gang_gang_named(a, b, n);\n        }\n    }\n\n    if (validate_data(a, b)){\n        err += 1;\n    }\n\n    return err;\n}\n#endif\n#ifndef T4\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test4();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 3);\n    }\n#endif\n",
                        "tags": [
                            "routine",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "5": {
                        "content": "#ifndef T5\n//T5:routine,construct-independent,V:2.0-2.7\nint test5(){\n    int err = 0;\n    srand(SEED);\n    real_t ** a = (real_t **)malloc(n * sizeof(real_t *));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n    for (int x = 0; x < n; ++x){\n        a[x] = (real_t *)malloc(n * sizeof(real_t));\n    }\n\n    for (int x = 0; x < n; ++x){\n        for (int y = 0; y < n; ++y){\n            a[x][y] = rand() / (real_t)(RAND_MAX / 10);\n        }\n        b[x] = 0;\n    }\n\n    #pragma acc data copyin(a[0:n][0:n]) copy(b[0:n])\n    {\n        #pragma acc parallel\n        {\n            test_routine_gang_worker_unnamed(a, b, n);\n        }\n    }\n\n    if (validate_data(a, b)){\n        err += 1;\n    }\n\n    return err;\n}\n#endif\n#ifndef T5\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test5();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 4);\n    }\n#endif\n",
                        "tags": [
                            "routine",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "6": {
                        "content": "#ifndef T6\n//T6:routine,construct-independent,V:2.0-2.7\nint test6(){\n    int err = 0;\n    srand(SEED);\n    real_t ** a = (real_t **)malloc(n * sizeof(real_t *));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n    for (int x = 0; x < n; ++x){\n        a[x] = (real_t *)malloc(n * sizeof(real_t));\n    }\n\n    for (int x = 0; x < n; ++x){\n        for (int y = 0; y < n; ++y){\n            a[x][y] = rand() / (real_t)(RAND_MAX / 10);\n        }\n        b[x] = 0;\n    }\n\n    #pragma acc data copyin(a[0:n][0:n]) copy(b[0:n])\n    {\n        #pragma acc parallel\n        {\n            test_routine_gang_worker_named(a, b, n);\n        }\n    }\n\n    if (validate_data(a, b)){\n        err += 1;\n    }\n\n    return err;\n}\n#endif\n#ifndef T6\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test6();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 5);\n    }\n#endif\n",
                        "tags": [
                            "routine",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "7": {
                        "content": "#ifndef T7\n//T7:routine,construct-independent,V:2.0-2.7\nint test7(){\n    int err = 0;\n    srand(SEED);\n    real_t ** a = (real_t **)malloc(n * sizeof(real_t *));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n    for (int x = 0; x < n; ++x){\n        a[x] = (real_t *)malloc(n * sizeof(real_t));\n    }\n\n    for (int x = 0; x < n; ++x){\n        for (int y = 0; y < n; ++y){\n            a[x][y] = rand() / (real_t)(RAND_MAX / 10);\n        }\n        b[x] = 0;\n    }\n\n    #pragma acc data copyin(a[0:n][0:n]) copy(b[0:n])\n    {\n        #pragma acc parallel\n        {\n            test_routine_gang_vector_unnamed(a, b, n);\n        }\n    }\n\n    if (validate_data(a, b)){\n        err += 1;\n    }\n\n    return err;\n}\n#endif\n#ifndef T7\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test7();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 6);\n    }\n#endif\n",
                        "tags": [
                            "routine",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "8": {
                        "content": "#ifndef T8\n//T8:routine,construct-independent,V:2.0-2.7\nint test8(){\n    int err = 0;\n    srand(SEED);\n    real_t ** a = (real_t **)malloc(n * sizeof(real_t *));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n    for (int x = 0; x < n; ++x){\n        a[x] = (real_t *)malloc(n * sizeof(real_t));\n    }\n\n    for (int x = 0; x < n; ++x){\n        for (int y = 0; y < n; ++y){\n            a[x][y] = rand() / (real_t)(RAND_MAX / 10);\n        }\n        b[x] = 0;\n    }\n\n    #pragma acc data copyin(a[0:n][0:n]) copy(b[0:n])\n    {\n        #pragma acc parallel\n        {\n            test_routine_gang_vector_named(a, b, n);\n        }\n    }\n\n    if (validate_data(a, b)){\n        err += 1;\n    }\n\n    return err;\n}\n#endif\n#ifndef T8\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test8();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 7);\n    }\n#endif\n",
                        "tags": [
                            "routine",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "9": {
                        "content": "#ifndef T9\n//T9:routine,construct-independent,V:2.0-2.7\nint test9(){\n    int err = 0;\n    srand(SEED);\n    real_t ** a = (real_t **)malloc(n * sizeof(real_t *));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n    for (int x = 0; x < n; ++x){\n        a[x] = (real_t *)malloc(n * sizeof(real_t));\n    }\n\n    for (int x = 0; x < n; ++x){\n        for (int y = 0; y < n; ++y){\n            a[x][y] = rand() / (real_t)(RAND_MAX / 10);\n        }\n        b[x] = 0;\n    }\n\n    #pragma acc data copyin(a[0:n][0:n]) copy(b[0:n])\n    {\n        #pragma acc parallel\n        {\n            test_routine_gang_seq_unnamed(a, b, n);\n        }\n    }\n\n    if (validate_data(a, b)){\n        err += 1;\n    }\n\n    return err;\n}\n#endif\n#ifndef T9\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test9();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 8);\n    }\n#endif\n",
                        "tags": [
                            "routine",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "routine_nohost.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:routine,construct-independent,V:2.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t ** a = (real_t **)malloc(n * sizeof(real_t *));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n    real_t summation;\n\n    for (int x = 0; x < n; ++x){\n        a[x] = (real_t *)malloc(n * sizeof(real_t));\n        for (int y = 0; y < n; ++y){\n            a[x][y] = rand() / (real_t)(RAND_MAX / 10);\n        }\n        b[x] = 0;\n    }\n\n    #pragma acc data copyin(a[0:n][0:n]) copyout(b[0:n])\n    {\n        #pragma acc parallel\n        {\n            #pragma acc loop gang\n            for (int x = 0; x < n; ++x){\n                b[x] = function(a[x], n);\n            }\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        summation = 0;\n        for (int y = 0; y < n; ++y){\n            summation += a[x][y];\n        }\n        if (fabs(summation - b[x]) > PRECISION){\n            err += 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "routine",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "routine_seq.c": {
                "num tests": 4,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:routine,construct-independent,V:2.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t ** a = (real_t **)malloc(n * sizeof(real_t *));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n\n    for (int x = 0; x < n; ++x){\n        a[x] = (real_t *)malloc(n * sizeof(real_t));\n    }\n\n    for (int x = 0; x < n; ++x){\n        for (int y = 0; y < n; ++y){\n            a[x][y] = rand() / (real_t)(RAND_MAX / 10);\n        }\n        b[x] = 0;\n    }\n\n    #pragma acc data copyin(a[0:n][0:n]) copy(b[0:n])\n    {\n        #pragma acc parallel\n        {\n              test_routine_seq_loop_unnamed(a, b, n);\n        }\n    }\n\n    if (validate_data(a, b)){\n        err += 1;\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "routine",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "2": {
                        "content": "#ifndef T2\n//T2:routine,construct-independent,V:2.0-2.7\nint test2(){\n    int err = 0;\n    srand(SEED);\n    real_t ** a = (real_t **)malloc(n * sizeof(real_t *));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n\n    for (int x = 0; x < n; ++x){\n        a[x] = (real_t *)malloc(n * sizeof(real_t));\n    }\n\n    for (int x = 0; x < n; ++x){\n        for (int y = 0; y < n; ++y){\n            a[x][y] = rand() / (real_t)(RAND_MAX / 10);\n        }\n        b[x] = 0;\n    }\n\n    #pragma acc data copyin(a[0:n][0:n]) copy(b[0:n])\n    {\n        #pragma acc parallel\n        {\n            test_routine_seq_loop_named(a, b, n);\n        }\n    }\n\n    if (validate_data(a, b)){\n        err += 1;\n    }\n\n    return err;\n}\n#endif\n#ifndef T2\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test2();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 1);\n    }\n#endif\n",
                        "tags": [
                            "routine",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "3": {
                        "content": "#ifndef T3\n//T3:routine,construct-independent,V:2.0-2.7\nint test3(){\n    int err = 0;\n    srand(SEED);\n    real_t ** a = (real_t **)malloc(n * sizeof(real_t *));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n\n    for (int x = 0; x < n; ++x){\n        a[x] = (real_t *)malloc(n * sizeof(real_t));\n    }\n\n    for (int x = 0; x < n; ++x){\n        for (int y = 0; y < n; ++y){\n            a[x][y] = rand() / (real_t)(RAND_MAX / 10);\n        }\n        b[x] = 0;\n    }\n\n    #pragma acc data copyin(a[0:n][0:n]) copy(b[0:n])\n    {\n        #pragma acc parallel\n        {\n            test_routine_seq_seq_unnamed(a, b, n);\n        }\n    }\n\n    if (validate_data(a, b)){\n        err += 1;\n    }\n\n    return err;\n}\n#endif\n#ifndef T3\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test3();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 2);\n    }\n#endif\n",
                        "tags": [
                            "routine",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "4": {
                        "content": "#ifndef T4\n//T4:routine,construct-independent,V:2.0-2.7\nint test4(){\n    int err = 0;\n    srand(SEED);\n    real_t ** a = (real_t **)malloc(n * sizeof(real_t *));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n\n    for (int x = 0; x < n; ++x){\n        a[x] = (real_t *)malloc(n * sizeof(real_t));\n    }\n\n    for (int x = 0; x < n; ++x){\n        for (int y = 0; y < n; ++y){\n            a[x][y] = rand() / (real_t)(RAND_MAX / 10);\n        }\n        b[x] = 0;\n    }\n\n    #pragma acc data copyin(a[0:n][0:n]) copy(b[0:n])\n    {\n        #pragma acc parallel\n        {\n            test_routine_seq_seq_named(a, b, n);\n        }\n    }\n\n    if (validate_data(a, b)){\n        err += 1;\n    }\n\n    return err;\n}\n#endif\n#ifndef T4\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test4();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 3);\n    }\n#endif\n",
                        "tags": [
                            "routine",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "routine_vector.c": {
                "num tests": 6,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:routine,construct-independent,V:2.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t ** a = (real_t **)malloc(n * sizeof(real_t *));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n\n    for (int x = 0; x < n; ++x){\n        a[x] = (real_t *)malloc(n * sizeof(real_t));\n    }\n\n    for (int x = 0; x < n; ++x){\n        for (int y = 0; y < n; ++y){\n            a[x][y] = rand() / (real_t)(RAND_MAX / 10);\n        }\n        b[x] = 0;\n    }\n\n    #pragma acc data copyin(a[0:n][0:n]) copy(b[0:n])\n    {\n        #pragma acc parallel\n        {\n              test_routine_vector_loop_unnamed(a, b, n);\n        }\n    }\n\n    if (validate_data(a, b)){\n        err += 1;\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "routine",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "2": {
                        "content": "#ifndef T2\n//T2:routine,construct-independent,V:2.0-2.7\nint test2(){\n    int err = 0;\n    srand(SEED);\n    real_t ** a = (real_t **)malloc(n * sizeof(real_t *));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n\n    for (int x = 0; x < n; ++x){\n        a[x] = (real_t *)malloc(n * sizeof(real_t));\n    }\n\n    for (int x = 0; x < n; ++x){\n        for (int y = 0; y < n; ++y){\n            a[x][y] = rand() / (real_t)(RAND_MAX / 10);\n        }\n        b[x] = 0;\n    }\n\n    #pragma acc data copyin(a[0:n][0:n]) copy(b[0:n])\n    {\n        #pragma acc parallel\n        {\n            test_routine_vector_loop_named(a, b, n);\n        }\n    }\n\n    if (validate_data(a, b)){\n        err += 1;\n    }\n\n    return err;\n}\n#endif\n#ifndef T2\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test2();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 1);\n    }\n#endif\n",
                        "tags": [
                            "routine",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "3": {
                        "content": "#ifndef T3\n//T3:routine,construct-independent,V:2.0-2.7\nint test3(){\n    int err = 0;\n    srand(SEED);\n    real_t ** a = (real_t **)malloc(n * sizeof(real_t *));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n\n    for (int x = 0; x < n; ++x){\n        a[x] = (real_t *)malloc(n * sizeof(real_t));\n    }\n\n    for (int x = 0; x < n; ++x){\n        for (int y = 0; y < n; ++y){\n            a[x][y] = rand() / (real_t)(RAND_MAX / 10);\n        }\n        b[x] = 0;\n    }\n\n    #pragma acc data copyin(a[0:n][0:n]) copy(b[0:n])\n    {\n        #pragma acc parallel\n        {\n            test_routine_vector_vector_unnamed(a, b, n);\n        }\n    }\n\n    if (validate_data(a, b)){\n        err += 1;\n    }\n\n    return err;\n}\n#endif\n#ifndef T3\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test3();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 2);\n    }\n#endif\n",
                        "tags": [
                            "routine",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "4": {
                        "content": "#ifndef T4\n//T4:routine,construct-independent,V:2.0-2.7\nint test4(){\n    int err = 0;\n    srand(SEED);\n    real_t ** a = (real_t **)malloc(n * sizeof(real_t *));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n\n    for (int x = 0; x < n; ++x){\n        a[x] = (real_t *)malloc(n * sizeof(real_t));\n    }\n\n    for (int x = 0; x < n; ++x){\n        for (int y = 0; y < n; ++y){\n            a[x][y] = rand() / (real_t)(RAND_MAX / 10);\n        }\n        b[x] = 0;\n    }\n\n    #pragma acc data copyin(a[0:n][0:n]) copy(b[0:n])\n    {\n        #pragma acc parallel\n        {\n            test_routine_vector_vector_named(a, b, n);\n        }\n    }\n\n    if (validate_data(a, b)){\n        err += 1;\n    }\n\n    return err;\n}\n#endif\n#ifndef T4\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test4();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 3);\n    }\n#endif\n",
                        "tags": [
                            "routine",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "5": {
                        "content": "#ifndef T5\n//T5:routine,construct-independent,V:2.0-2.7\nint test5(){\n    int err = 0;\n    srand(SEED);\n    real_t ** a = (real_t **)malloc(n * sizeof(real_t *));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n\n    for (int x = 0; x < n; ++x){\n        a[x] = (real_t *)malloc(n * sizeof(real_t));\n    }\n\n    for (int x = 0; x < n; ++x){\n        for (int y = 0; y < n; ++y){\n            a[x][y] = rand() / (real_t)(RAND_MAX / 10);\n        }\n        b[x] = 0;\n    }\n\n    #pragma acc data copyin(a[0:n][0:n]) copy(b[0:n])\n    {\n        #pragma acc parallel\n        {\n            test_routine_vector_seq_unnamed(a, b, n);\n        }\n    }\n\n    if (validate_data(a, b)){\n        err += 1;\n    }\n\n    return err;\n}\n#endif\n#ifndef T5\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test5();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 4);\n    }\n#endif\n",
                        "tags": [
                            "routine",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "6": {
                        "content": "#ifndef T6\n//T6:routine,construct-independent,V:2.0-2.7\nint test6(){\n    int err = 0;\n    srand(SEED);\n    real_t ** a = (real_t **)malloc(n * sizeof(real_t *));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n\n    for (int x = 0; x < n; ++x){\n        a[x] = (real_t *)malloc(n * sizeof(real_t));\n    }\n\n    for (int x = 0; x < n; ++x){\n        for (int y = 0; y < n; ++y){\n            a[x][y] = rand() / (real_t)(RAND_MAX / 10);\n        }\n        b[x] = 0;\n    }\n\n    #pragma acc data copyin(a[0:n][0:n]) copy(b[0:n])\n    {\n        #pragma acc parallel\n        {\n            test_routine_vector_seq_named(a, b, n);\n        }\n    }\n\n    if (validate_data(a, b)){\n        err += 1;\n    }\n\n    return err;\n}\n#endif\n#ifndef T6\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test6();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 5);\n    }\n#endif\n",
                        "tags": [
                            "routine",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "routine_worker.c": {
                "num tests": 8,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:routine,construct-independent,V:2.0-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t ** a = (real_t **)malloc(n * sizeof(real_t *));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n\n    for (int x = 0; x < n; ++x){\n        a[x] = (real_t *)malloc(n * sizeof(real_t));\n    }\n\n    for (int x = 0; x < n; ++x){\n        for (int y = 0; y < n; ++y){\n            a[x][y] = rand() / (real_t)(RAND_MAX / 10);\n        }\n        b[x] = 0;\n    }\n\n    #pragma acc data copyin(a[0:n][0:n]) copy(b[0:n])\n    {\n        #pragma acc parallel\n        {\n              test_routine_worker_loop_unnamed(a, b, n);\n        }\n    }\n\n    if (validate_data(a, b)){\n        err += 1;\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "routine",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "2": {
                        "content": "#ifndef T2\n//T2:routine,construct-independent,V:2.0-2.7\nint test2(){\n    int err = 0;\n    srand(SEED);\n    real_t ** a = (real_t **)malloc(n * sizeof(real_t *));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n\n    for (int x = 0; x < n; ++x){\n        a[x] = (real_t *)malloc(n * sizeof(real_t));\n    }\n\n    for (int x = 0; x < n; ++x){\n        for (int y = 0; y < n; ++y){\n            a[x][y] = rand() / (real_t)(RAND_MAX / 10);\n        }\n        b[x] = 0;\n    }\n\n    #pragma acc data copyin(a[0:n][0:n]) copy(b[0:n])\n    {\n        #pragma acc parallel\n        {\n            test_routine_worker_loop_named(a, b, n);\n        }\n    }\n\n    if (validate_data(a, b)){\n        err += 1;\n    }\n\n    return err;\n}\n#endif\n#ifndef T2\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test2();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 1);\n    }\n#endif\n",
                        "tags": [
                            "routine",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "3": {
                        "content": "#ifndef T3\n//T3:routine,construct-independent,V:2.0-2.7\nint test3(){\n    int err = 0;\n    srand(SEED);\n    real_t ** a = (real_t **)malloc(n * sizeof(real_t *));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n\n    for (int x = 0; x < n; ++x){\n        a[x] = (real_t *)malloc(n * sizeof(real_t));\n    }\n\n    for (int x = 0; x < n; ++x){\n        for (int y = 0; y < n; ++y){\n            a[x][y] = rand() / (real_t)(RAND_MAX / 10);\n        }\n        b[x] = 0;\n    }\n\n    #pragma acc data copyin(a[0:n][0:n]) copy(b[0:n])\n    {\n        #pragma acc parallel\n        {\n            test_routine_worker_worker_unnamed(a, b, n);\n        }\n    }\n\n    if (validate_data(a, b)){\n        err += 1;\n    }\n\n    return err;\n}\n#endif\n#ifndef T3\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test3();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 2);\n    }\n#endif\n",
                        "tags": [
                            "routine",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "4": {
                        "content": "#ifndef T4\n//T4:routine,construct-independent,V:2.0-2.7\nint test4(){\n    int err = 0;\n    srand(SEED);\n    real_t ** a = (real_t **)malloc(n * sizeof(real_t *));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n\n    for (int x = 0; x < n; ++x){\n        a[x] = (real_t *)malloc(n * sizeof(real_t));\n    }\n\n    for (int x = 0; x < n; ++x){\n        for (int y = 0; y < n; ++y){\n            a[x][y] = rand() / (real_t)(RAND_MAX / 10);\n        }\n        b[x] = 0;\n    }\n\n    #pragma acc data copyin(a[0:n][0:n]) copy(b[0:n])\n    {\n        #pragma acc parallel\n        {\n            test_routine_worker_worker_named(a, b, n);\n        }\n    }\n\n    if (validate_data(a, b)){\n        err += 1;\n    }\n\n    return err;\n}\n#endif\n#ifndef T4\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test4();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 3);\n    }\n#endif\n",
                        "tags": [
                            "routine",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "5": {
                        "content": "#ifndef T5\n//T5:routine,construct-independent,V:2.0-2.7\nint test5(){\n    int err = 0;\n    srand(SEED);\n    real_t ** a = (real_t **)malloc(n * sizeof(real_t *));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n\n    for (int x = 0; x < n; ++x){\n        a[x] = (real_t *)malloc(n * sizeof(real_t));\n    }\n\n    for (int x = 0; x < n; ++x){\n        for (int y = 0; y < n; ++y){\n            a[x][y] = rand() / (real_t)(RAND_MAX / 10);\n        }\n        b[x] = 0;\n    }\n\n    #pragma acc data copyin(a[0:n][0:n]) copy(b[0:n])\n    {\n        #pragma acc parallel\n        {\n            test_routine_worker_vector_unnamed(a, b, n);\n        }\n    }\n\n    if (validate_data(a, b)){\n        err += 1;\n    }\n\n    return err;\n}\n#endif\n#ifndef T5\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test5();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 4);\n    }\n#endif\n",
                        "tags": [
                            "routine",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "6": {
                        "content": "#ifndef T6\n//T6:routine,construct-independent,V:2.0-2.7\nint test6(){\n    int err = 0;\n    srand(SEED);\n    real_t ** a = (real_t **)malloc(n * sizeof(real_t *));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n\n    for (int x = 0; x < n; ++x){\n        a[x] = (real_t *)malloc(n * sizeof(real_t));\n    }\n\n    for (int x = 0; x < n; ++x){\n        for (int y = 0; y < n; ++y){\n            a[x][y] = rand() / (real_t)(RAND_MAX / 10);\n        }\n        b[x] = 0;\n    }\n\n    #pragma acc data copyin(a[0:n][0:n]) copy(b[0:n])\n    {\n        #pragma acc parallel\n        {\n            test_routine_worker_vector_named(a, b, n);\n        }\n    }\n\n    if (validate_data(a, b)){\n        err += 1;\n    }\n\n    return err;\n}\n#endif\n#ifndef T6\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test6();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 5);\n    }\n#endif\n",
                        "tags": [
                            "routine",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "7": {
                        "content": "#ifndef T7\n//T7:routine,construct-independent,V:2.0-2.7\nint test7(){\n    int err = 0;\n    srand(SEED);\n    real_t ** a = (real_t **)malloc(n * sizeof(real_t *));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n\n    for (int x = 0; x < n; ++x){\n        a[x] = (real_t *)malloc(n * sizeof(real_t));\n    }\n\n    for (int x = 0; x < n; ++x){\n        for (int y = 0; y < n; ++y){\n            a[x][y] = rand() / (real_t)(RAND_MAX / 10);\n        }\n        b[x] = 0;\n    }\n\n    #pragma acc data copyin(a[0:n][0:n]) copy(b[0:n])\n    {\n        #pragma acc parallel\n        {\n            test_routine_worker_seq_unnamed(a, b, n);\n        }\n    }\n\n    if (validate_data(a, b)){\n        err += 1;\n    }\n\n    return err;\n}\n#endif\n#ifndef T7\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test7();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 6);\n    }\n#endif\n",
                        "tags": [
                            "routine",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    },
                    "8": {
                        "content": "#ifndef T8\n//T8:routine,construct-independent,V:2.0-2.7\nint test8(){\n    int err = 0;\n    srand(SEED);\n    real_t ** a = (real_t **)malloc(n * sizeof(real_t *));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n\n    for (int x = 0; x < n; ++x){\n        a[x] = (real_t *)malloc(n * sizeof(real_t));\n    }\n\n    for (int x = 0; x < n; ++x){\n        for (int y = 0; y < n; ++y){\n            a[x][y] = rand() / (real_t)(RAND_MAX / 10);\n        }\n        b[x] = 0;\n    }\n\n    #pragma acc data copyin(a[0:n][0:n]) copy(b[0:n])\n    {\n        #pragma acc parallel\n        {\n            test_routine_worker_seq_named(a, b, n);\n        }\n    }\n\n    if (validate_data(a, b)){\n        err += 1;\n    }\n\n    return err;\n}\n#endif\n#ifndef T8\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test8();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 7);\n    }\n#endif\n",
                        "tags": [
                            "routine",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "serial.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:,V:2.6-2.7\n      LOGICAL FUNCTION test1()\n  IMPLICIT NONE\n  INCLUDE \"acc_testsuite.Fh\"\n  INTEGER :: x, i_a, i_b, i_c, i_d, i_e, i_f, i_g, i_h, i_i, i_j !Iterators\n  INTEGER, PARAMETER :: PRIVATE_LOOPCOUNT = 1024\n  REAL(8),DIMENSION(PRIVATE_LOOPCOUNT):: a, b, c !Data\n  INTEGER :: errors\n  errors = 0\n\n  !Initilization\n  SEEDDIM(1) = 1\n# ifdef SEED\n  SEEDDIM(1) = SEED\n# endif\n  CALL RANDOM_SEED(PUT=SEEDDIM)\n\n  CALL RANDOM_NUMBER(a)\n  CALL RANDOM_NUMBER(b)\n  c = 0\n\n  !$acc data copyin(a(1:PRIVATE_LOOPCOUNT), b(1:PRIVATE_LOOPCOUNT)) copy(c(1:PRIVATE_LOOPCOUNT))\n    !$acc serial\n      !$acc loop\n      DO i_a = 0, 1\n        !$acc loop\n        DO i_b = 0, 1\n          !$acc loop\n          DO i_c = 0, 1\n            !$acc loop\n            DO i_d = 0, 1\n              !$acc loop\n              DO i_e = 0, 1\n                !$acc loop\n                DO i_f = 0, 1\n                  !$acc loop\n                  DO i_g = 0, 1\n                    !$acc loop\n                    DO i_h = 0, 1\n                      !$acc loop\n                      DO i_i = 0, 1\n                        !$acc loop\n                        DO i_j = 0, 1\n                          c(i_a*512 + i_b*256 + i_c*128 + i_d*64 + i_e*32 + i_f*16 + i_g*8 + i_h*4 + i_i*2 + i_j + 1) = &\n                          a(i_a*512 + i_b*256 + i_c*128 + i_d*64 + i_e*32 + i_f*16 + i_g*8 + i_h*4 + i_i*2 + i_j + 1) + &\n                          b(i_a*512 + i_b*256 + i_c*128 + i_d*64 + i_e*32 + i_f*16 + i_g*8 + i_h*4 + i_i*2 + i_j + 1)\n                        END DO\n                      END DO\n                    END DO\n                  END DO\n                END DO\n              END DO\n            END DO\n          END DO\n        END DO\n      END DO\n    !$acc end serial\n  !$acc end data\n\n  DO x = 1, PRIVATE_LOOPCOUNT\n    IF (abs(c(x) - (a(x) + b(x))) .gt. PRECISION) THEN\n      errors = errors + 1\n    END IF\n  END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            ""
                        ],
                        "versions": [
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "serial.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:serial,V:2.6-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t* a = (real_t *) malloc(1024 * sizeof(real_t));\n    real_t* b = (real_t *) malloc(1024 * sizeof(real_t));\n    real_t* c = (real_t *) malloc(1024 * sizeof(real_t));\n\n    for(int x = 0; x < 1024; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n        c[x] = 0.0;\n    }\n\n    #pragma acc data copyin(a[0:1024], b[0:1024]) copy(c[0:1024])\n    {\n        #pragma acc serial\n        {\n            #pragma acc loop\n            for (int _0 = 0; _0 < 2; ++_0){\n                #pragma acc loop\n                for (int _1 = 0; _1 < 2; ++_1){\n                    #pragma acc loop\n                    for (int _2 = 0; _2 < 2; ++_2){\n                        #pragma acc loop\n                        for (int _3 = 0; _3 < 2; ++_3){\n                            #pragma acc loop\n                            for (int _4 = 0; _4 < 2; ++_4){\n                                #pragma acc loop\n                                for (int _5 = 0; _5 < 2; ++_5){\n                                    #pragma acc loop\n                                    for (int _6 = 0; _6 < 2; ++_6){\n                                        #pragma acc loop\n                                        for (int _7 = 0; _7 < 2; ++_7){\n                                            #pragma acc loop\n                                            for (int _8 = 0; _8 < 2; ++_8){\n                                                #pragma acc loop\n                                                for (int _9 = 0; _9 < 2; ++_9){\n                                                    c[_0*512 + _1*256 + _2*128 + _3*64 + _4*32 + _5*16 + _6*8+ _7*4 + _8*2 + _9] =\n                                                    a[_0*512 + _1*256 + _2*128 + _3*64 + _4*32 + _5*16 + _6*8+ _7*4 + _8*2 + _9] +\n                                                    b[_0*512 + _1*256 + _2*128 + _3*64 + _4*32 + _5*16 + _6*8+ _7*4 + _8*2 + _9];\n                                                }\n                                            }\n                                        }\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    for (int x = 0; x < 1024; ++x){\n        if(fabs(c[x] - (a[x] +b[x])) > PRECISION){\n            err = 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "serial"
                        ],
                        "versions": [
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "serial_async.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:async,serial,update,V:2.6-2.7\n      LOGICAL FUNCTION test1()\n  IMPLICIT NONE\n  INCLUDE \"acc_testsuite.Fh\"\n  INTEGER:: errors\n  REAL(8),DIMENSION(LOOPCOUNT):: a, b, c, d, e, f, g\n  INTEGER:: x\n\n  errors = 0\n\n  SEEDDIM(1) = 1\n# ifdef SEED\n  SEEDDIM(1) = SEED\n# endif\n  CALL RANDOM_SEED(PUT=SEEDDIM)\n\n  CALL RANDOM_NUMBER(a)\n  CALL RANDOM_NUMBER(b)\n  c = 0\n  CALL RANDOM_NUMBER(d)\n  CALL RANDOM_NUMBER(e)\n  f = 0\n  g = 0\n\n  !$acc data copyin(a(1:LOOPCOUNT), b(1:LOOPCOUNT), c(1:LOOPCOUNT), d(1:LOOPCOUNT), e(1:LOOPCOUNT), f(1:LOOPCOUNT), g(1:LOOPCOUNT))\n    !$acc serial async(1)\n      !$acc loop\n      DO x = 1, LOOPCOUNT\n        c(x) = a(x) + b(x)\n      END DO\n    !$acc end serial\n    !$acc serial async(2)\n      !$acc loop\n      DO x = 1, LOOPCOUNT\n        f(x) = d(x) + e(x)\n      END DO\n    !$acc end serial\n    !$acc serial wait(1, 2) async(3)\n      !$acc loop\n      DO x = 1, LOOPCOUNT\n        g(x) = c(x) + f(x)\n      END DO\n    !$acc end serial\n\n    !$acc update host(c(1:LOOPCOUNT)) async(1)\n    !$acc update host(f(1:LOOPCOUNT)) async(2)\n    !$acc update host(g(1:LOOPCOUNT)) async(3)\n\n    !$acc wait(1)\n    DO x = 1, LOOPCOUNT\n      IF (abs(c(x) - (a(x) + b(x))) .gt. PRECISION) THEN\n        errors = errors + 1\n      END IF\n    END DO\n\n    !$acc wait(2)\n    DO x = 1, LOOPCOUNT\n      IF (abs(f(x) - (d(x) + e(x))) .gt. PRECISION) THEN\n        errors = errors + 1\n      END IF\n    END DO\n\n    !$acc wait(3)\n    DO x = 1, LOOPCOUNT\n      IF (abs(g(x) - (a(x) + b(x) + d(x) + e(x))) .gt. 4 * PRECISION) THEN\n        errors = errors + 1\n      END IF\n    END DO\n  !$acc end data\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "async",
                            "serial",
                            "update"
                        ],
                        "versions": [
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "serial_async.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:serial,async,wait,V:2.6-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n    real_t * c = (real_t *)malloc(n * sizeof(real_t));\n    real_t * d = (real_t *)malloc(n * sizeof(real_t));\n    real_t * e = (real_t *)malloc(n * sizeof(real_t));\n    real_t * f = (real_t *)malloc(n * sizeof(real_t));\n    real_t * g = (real_t *)malloc(n * sizeof(real_t));\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n        c[x] = 0.0;\n        d[x] = rand() / (real_t)(RAND_MAX / 10);\n        e[x] = rand() / (real_t)(RAND_MAX / 10);\n        f[x] = 0.0;\n        g[x] = 0.0;\n    }\n\n    #pragma acc data copyin(a[0:n], b[0:n], d[0:n], e[0:n], c[0:n], f[0:n], g[0:n])\n    {\n        #pragma acc serial async(1)\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                c[x] = a[x] + b[x];\n            }\n        }\n        #pragma acc serial async(2)\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                f[x] = d[x] + e[x];\n            }\n        }\n        #pragma acc serial wait(1, 2) async(3)\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                g[x] = c[x] + f[x];\n            }\n        }\n        #pragma acc update host(c[0:n]) async(1)\n        #pragma acc update host(f[0:n]) async(2)\n        #pragma acc update host(g[0:n]) async(3)\n\n        #pragma acc wait(1)\n        for (int x = 0; x < n; ++x){\n            if (fabs(c[x] - (a[x] + b[x])) > PRECISION){\n                err += 1;\n            }\n        }\n        #pragma acc wait(2)\n        for (int x = 0; x < n; ++x){\n            if (fabs(f[x] - (d[x] + e[x])) > PRECISION){\n                err += 1;\n            }\n        }\n        #pragma acc wait(3)\n        for (int x = 0; x < n; ++x){\n            if (fabs(g[x] - (a[x] + b[x] + d[x] + e[x])) > PRECISION){\n                err += 1;\n            }\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "serial",
                            "async",
                            "wait"
                        ],
                        "versions": [
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "serial_copy.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:serial,V:2.6-2.7\n      LOGICAL FUNCTION test1()\n  IMPLICIT NONE\n  INCLUDE \"acc_testsuite.Fh\"\n  INTEGER:: errors\n  REAL(8),DIMENSION(LOOPCOUNT):: a, a_host\n  INTEGER:: x\n  errors = 0\n\n  SEEDDIM(1) = 1\n# ifdef SEED\n  SEEDDIM(1) = SEED\n# endif\n  CALL RANDOM_SEED(PUT=SEEDDIM)\n\n  CALL RANDOM_NUMBER(a)\n  a_host = a\n\n  !$acc serial copy(a(1:LOOPCOUNT))\n    !$acc loop\n    DO x = 1, N\n      a(x) = 2 * a(x)\n    END DO\n  !$acc end serial\n\n  DO x = 1, N\n    IF (abs(a(x) - (2 * a_host(x))) .gt. PRECISION) THEN\n      errors = errors + 1\n    END IF\n  END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "serial"
                        ],
                        "versions": [
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "serial_copy.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:serial,data,data-region,V:2.6-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(n * sizeof(real_t));\n    real_t * a_host = (real_t *)malloc(n * sizeof(real_t));\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        a_host[x] = a[x];\n    }\n\n    #pragma acc serial copy(a[0:n])\n    {\n        #pragma acc loop\n        for (int x = 0; x < n; ++x){\n            a[x] = 2 * a[x];\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        if (fabs(a[x] - (2 * a_host[x])) > PRECISION){\n            err = 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "serial",
                            "data",
                            "data-region"
                        ],
                        "versions": [
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "serial_copyin.F90": {
                "num tests": 2,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:serial,V:2.6-2.7\n      LOGICAL FUNCTION test1()\n  IMPLICIT NONE\n  INCLUDE \"acc_testsuite.Fh\"\n  INTEGER:: errors\n  REAL(8),DIMENSION(LOOPCOUNT):: a, a_copy, b\n  INTEGER,DIMENSION(1):: hasDevice\n  INTEGER:: x\n  errors = 0\n\n  SEEDDIM(1) = 1\n# ifdef SEED\n  SEEDDIM(1) = SEED\n# endif\n  CALL RANDOM_SEED(PUT=SEEDDIM)\n\n  CALL RANDOM_NUMBER(a)\n  a_copy = a\n  b = 0\n\n  hasDevice(1) = 1\n  !$acc enter data copyin(hasDevice(1:1))\n  !$acc parallel present(hasDevice(1:1))\n    hasDevice(1) = 0\n  !$acc end parallel\n\n  !$acc serial copyin(a(1:LOOPCOUNT))\n    !$acc loop\n    DO x = 1, LOOPCOUNT\n      a(x) = 0\n    END DO\n  !$acc end serial\n\n  DO x = 1, LOOPCOUNT\n    IF (hasDevice(1) .eq. 1) THEN\n      IF (abs(a(x) - a_copy(x)) .gt. PRECISION) THEN\n        errors = errors + 1\n      END IF\n    ELSE\n      IF (abs(a(x)) .gt. PRECISION) THEN\n        errors = errors + 1\n      END IF\n    END IF\n  END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "serial"
                        ],
                        "versions": [
                            "2.6",
                            "2.7"
                        ]
                    },
                    "2": {
                        "content": "#ifndef T2\n!T2:serial,V:2.6-2.7\n      LOGICAL FUNCTION test2()\n  IMPLICIT NONE\n  INCLUDE \"acc_testsuite.Fh\"\n  INTEGER:: errors\n  REAL(8),DIMENSION(LOOPCOUNT):: a, a_copy, b\n  INTEGER,DIMENSION(1):: hasDevice\n  INTEGER:: x\n  errors = 0\n\n  SEEDDIM(1) = 1\n# ifdef SEED\n  SEEDDIM(1) = SEED\n# endif\n  CALL RANDOM_SEED(PUT=SEEDDIM)\n\n  CALL RANDOM_NUMBER(a)\n\n  !$acc data copy(b(1:LOOPCOUNT))\n    !$acc serial copyin(a(1:LOOPCOUNT))\n      !$acc loop\n      DO x = 1, LOOPCOUNT\n        b(x) = a(x)\n      END DO\n    !$acc end serial\n  !$acc end data\n\n  DO x = 1, LOOPCOUNT\n    IF (abs(a(x) - b(x)) .gt. PRECISION) THEN\n      errors = errors + 1\n    END IF\n  END DO\n\n        IF (errors .eq. 0) THEN\n          test2 = .FALSE.\n        ELSE\n          test2 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T2\n        LOGICAL :: test2\n#endif\n#ifndef T2\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test2()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 1\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "serial"
                        ],
                        "versions": [
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "serial_copyin.c": {
                "num tests": 2,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:serial,data,data-region,V:2.6-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(n * sizeof(real_t));\n    real_t * a_copy = (real_t *)malloc(n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n    int* hasDevice = (int *) malloc(sizeof(int));\n    hasDevice[0] = 1;\n    #pragma acc enter data copyin(hasDevice[0:1])\n    #pragma acc parallel present(hasDevice[0:1])\n    {\n      hasDevice[0] = 0;\n    }\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        a_copy[x] = a[x];\n        b[x] = 0.0;\n    }\n\n    #pragma acc serial copyin(a[0:n])\n    {\n        #pragma acc loop\n        for (int x = 0; x < n; ++x){\n            a[x] = 0.0;\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        if (((fabs(a[x] - a_copy[x]) > PRECISION) && (hasDevice[0] == 1)) || ((hasDevice[0] == 0) && (fabs(a[x]) > PRECISION))){\n            err = 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "serial",
                            "data",
                            "data-region"
                        ],
                        "versions": [
                            "2.6",
                            "2.7"
                        ]
                    },
                    "2": {
                        "content": "#ifndef T2\n//T2:serial,data,data-region,V:2.6-2.7\nint test2(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(n * sizeof(real_t));\n    real_t * a_copy = (real_t *)malloc(n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n    }\n\n    #pragma acc data copy(b[0:n])\n    {\n        #pragma acc serial copyin(a[0:n])\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                b[x] = a[x];\n            }\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        if (fabs(a[x] - b[x]) > PRECISION){\n            err = 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T2\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test2();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 1);\n    }\n#endif\n",
                        "tags": [
                            "serial",
                            "data",
                            "data-region"
                        ],
                        "versions": [
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "serial_copyout.F90": {
                "num tests": 3,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:serial,V:2.6-2.7\n      LOGICAL FUNCTION test1()\n  IMPLICIT NONE\n  INCLUDE \"acc_testsuite.Fh\"\n  INTEGER:: errors\n  REAL(8),DIMENSION(LOOPCOUNT):: a, b\n  INTEGER:: x\n  INTEGER,DIMENSION(1):: hasDevice\n  errors = 0\n\n  hasDevice(1) = 1\n  !$acc enter data copyin(hasDevice(1:1))\n  !$acc parallel present(hasDevice(1:1))\n  hasDevice(1) = 0\n  !$acc end parallel\n  \n  SEEDDIM(1) = 1\n# ifdef SEED\n  SEEDDIM(1) = SEED\n# endif\n  CALL RANDOM_SEED(PUT=SEEDDIM)\n\n  CALL RANDOM_NUMBER(a)\n  b = 0\n\n\n  !$acc data copyin(a(1:LOOPCOUNT))\n    !$acc serial copyout(b(1:LOOPCOUNT))\n      !$acc loop\n      DO x = 1, LOOPCOUNT\n        b(x) = a(x)\n      END DO\n    !$acc end serial\n  !$acc end data\n\n  DO x = 1, LOOPCOUNT\n    IF (abs(a(x) - b(x)) .gt. PRECISION) THEN\n      errors = errors + 1\n    END IF\n  END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "serial"
                        ],
                        "versions": [
                            "2.6",
                            "2.7"
                        ]
                    },
                    "2": {
                        "content": "#ifndef T2\n!T2:serial,V:2.6-2.7\n      LOGICAL FUNCTION test2()\n  IMPLICIT NONE\n  INCLUDE \"acc_testsuite.Fh\"\n  INTEGER:: errors\n  REAL(8),DIMENSION(LOOPCOUNT):: a, b\n  INTEGER:: x\n  INTEGER,DIMENSION(1):: hasDevice\n  errors = 0\n\n  hasDevice(1) = 1\n  !$acc enter data copyin(hasDevice(1:1))\n  !$acc parallel present(hasDevice(1:1))\n  hasDevice(1) = 0\n  !$acc end parallel\n  \n  SEEDDIM(1) = 1\n# ifdef SEED\n  SEEDDIM(1) = SEED\n# endif\n  CALL RANDOM_SEED(PUT=SEEDDIM)\n\n  IF (hasDevice(1) .eq. 1) THEN\n    !$acc data copyin(a(1:LOOPCOUNT), b(1:LOOPCOUNT))\n      !$acc serial copyout(b(1:LOOPCOUNT))\n        !$acc loop\n        DO x = 1, LOOPCOUNT\n          b(x) = b(x) - a(x)\n        END DO\n      !$acc end serial\n    !$acc end data\n\n    DO x = 1, LOOPCOUNT\n      IF (abs(a(x) - b(x)) .gt. PRECISION) THEN\n        errors = errors + 1\n      END IF\n    END DO\n  END IF\n\n        IF (errors .eq. 0) THEN\n          test2 = .FALSE.\n        ELSE\n          test2 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T2\n        LOGICAL :: test2\n#endif\n#ifndef T2\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test2()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 1\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "serial"
                        ],
                        "versions": [
                            "2.6",
                            "2.7"
                        ]
                    },
                    "3": {
                        "content": "#ifndef T3\n!T3:serial,update,V:2.6-2.7\n      LOGICAL FUNCTION test3()\n  IMPLICIT NONE\n  INCLUDE \"acc_testsuite.Fh\"\n  INTEGER:: errors\n  REAL(8),DIMENSION(LOOPCOUNT):: a, b\n  INTEGER:: x\n  INTEGER,DIMENSION(1):: hasDevice\n  errors = 0\n\n  hasDevice(1) = 1\n  !$acc enter data copyin(hasDevice(1:1))\n  !$acc parallel present(hasDevice(1:1))\n  hasDevice(1) = 0\n  !$acc end parallel\n  \n  SEEDDIM(1) = 1\n# ifdef SEED\n  SEEDDIM(1) = SEED\n# endif\n  CALL RANDOM_SEED(PUT=SEEDDIM)\n\n  !$acc data copyin(a(1:LOOPCOUNT), b(1:LOOPCOUNT))\n    !$acc serial copyout(b(1:LOOPCOUNT))\n      !$acc loop\n      DO x = 1, LOOPCOUNT\n        b(x) = b(x) - a(x)\n      END DO\n    !$acc end serial\n    !$acc update host(b(1:LOOPCOUNT))\n  !$acc end data\n\n  DO x = 1, LOOPCOUNT\n    IF (abs(b(x)) .gt. 2 * PRECISION) THEN\n      errors = errors + 1\n    END IF\n  END DO\n\n        IF (errors .eq. 0) THEN\n          test3 = .FALSE.\n        ELSE\n          test3 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T3\n        LOGICAL :: test3\n#endif\n#ifndef T3\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test3()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 2\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "serial",
                            "update"
                        ],
                        "versions": [
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "serial_copyout.c": {
                "num tests": 3,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:serial,data,data-region,V:2.6-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n\n    real_t * a = (real_t *)malloc(n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n    int* hasDevice = (int *) malloc(sizeof(int));\n    hasDevice[0] = 1;\n    #pragma acc enter data copyin(hasDevice[0:1])\n    #pragma acc serial present(hasDevice[0:1])\n    {\n      hasDevice[0] = 0;\n    }\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = 0.0;\n    }\n\n    #pragma acc data copyin(a[0:n])\n    {\n        #pragma acc serial copyout(b[0:n])\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                b[x] = a[x];\n            }\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        if (fabs(a[x] - b[x]) > PRECISION){\n            err += 1;\n            break;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "serial",
                            "data",
                            "data-region"
                        ],
                        "versions": [
                            "2.6",
                            "2.7"
                        ]
                    },
                    "2": {
                        "content": "#ifndef T2\n//T2:serial,data,data-region,reference-counting,devonly,V:2.6-2.7\nint test2(){\n    int err = 0;\n    srand(SEED);\n\n    real_t * a = (real_t *)malloc(n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n    int* hasDevice = (int *) malloc(sizeof(int));\n    hasDevice[0] = 1;\n    #pragma acc enter data copyin(hasDevice[0:1])\n    #pragma acc serial present(hasDevice[0:1])\n    {\n      hasDevice[0] = 0;\n    }\n\n    if (hasDevice[0] == 1){\n        for (int x = 0; x < n; ++x){\n            a[x] = rand() / (real_t)(RAND_MAX / 10);\n            b[x] = 0;\n        }\n        #pragma acc data copyin(a[0:n], b[0:n])\n        {\n            #pragma acc serial copyout(b[0:n])\n            {\n                #pragma acc loop\n                for (int x = 0; x < n; ++x){\n                    b[x] = a[x];\n                }\n            }\n        }\n        for (int x = 0; x < n; ++x){\n            if (fabs(b[x]) > PRECISION){\n                err += 2;\n                break;\n            }\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T2\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test2();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 1);\n    }\n#endif\n",
                        "tags": [
                            "serial",
                            "data",
                            "data-region",
                            "reference-counting",
                            "devonly"
                        ],
                        "versions": [
                            "2.6",
                            "2.7"
                        ]
                    },
                    "3": {
                        "content": "#ifndef T3\n//T3:serial,data,data-region,reference-counting,V:2.6-2.7\nint test3(){\n    int err = 0;\n    srand(SEED);\n\n    real_t * a = (real_t *)malloc(n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n    int* hasDevice = (int *) malloc(sizeof(int));\n    hasDevice[0] = 1;\n    #pragma acc enter data copyin(hasDevice[0:1])\n    #pragma acc serial present(hasDevice[0:1])\n    {\n      hasDevice[0] = 0;\n    }\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = 0;\n    }\n\n    #pragma acc data copyin(a[0:n], b[0:n])\n    {\n        #pragma acc serial copyout(b[0:n])\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                b[x] = a[x];\n            }\n        }\n        #pragma acc update host(b[0:n])\n    }\n\n    for (int x = 0; x < n; ++x){\n        if (fabs(b[x] - a[x]) > PRECISION){\n            err += 4;\n            break;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T3\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test3();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 2);\n    }\n#endif\n",
                        "tags": [
                            "serial",
                            "data",
                            "data-region",
                            "reference-counting"
                        ],
                        "versions": [
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "serial_create.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:serial,V:2.6-2.7\n      LOGICAL FUNCTION test1()\n  IMPLICIT NONE\n  INCLUDE \"acc_testsuite.Fh\"\n  INTEGER:: errors\n  REAL(8),DIMENSION(LOOPCOUNT):: a, b, c\n  INTEGER:: x\n  errors = 0\n\n  SEEDDIM(1) = 1\n# ifdef SEED\n  SEEDDIM(1) = SEED\n# endif\n  CALL RANDOM_SEED(PUT=SEEDDIM)\n\n  CALL RANDOM_NUMBER(a)\n  b = 0\n  c = 0\n\n  !$acc data copyin(a(1:LOOPCOUNT)) copy(c(1:LOOPCOUNT))\n    !$acc serial create(b(1:LOOPCOUNT))\n      !$acc loop\n      DO x = 1, LOOPCOUNT\n        b(x) = a(x)\n      END DO\n      !$acc loop\n      DO x = 1, LOOPCOUNT\n        c(x) = b(x)\n      END DO\n    !$acc end serial\n  !$acc end data\n\n  DO x = 1, LOOPCOUNT\n    IF (abs(a(x) - c(x)) .gt. PRECISION) THEN\n      errors = errors + 1\n    END IF\n  END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "serial"
                        ],
                        "versions": [
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "serial_create.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:serial,data,data-region,V:2.6-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n    real_t * c = (real_t *)malloc(n * sizeof(real_t));\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = 0.0;\n        c[x] = 0.0;\n    }\n\n    #pragma acc data copyin(a[0:n]) copy(c[0:n])\n    {\n        #pragma acc serial create(b[0:n])\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                b[x] = a[x];\n            }\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                c[x] = b[x];\n            }\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        if (fabs(a[x] - c[x]) > PRECISION){\n            err = 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "serial",
                            "data",
                            "data-region"
                        ],
                        "versions": [
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "serial_default_copy.F90": {
                "num tests": 2,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:devonly,V:2.6-2.7\n      LOGICAL FUNCTION test1()\n  IMPLICIT NONE\n  INCLUDE \"acc_testsuite.Fh\"\n  INTEGER:: errors\n  REAL(8),DIMENSION(LOOPCOUNT):: a, b, c\n  INTEGER,DIMENSION(1):: devtest\n  INTEGER:: x\n  errors = 0\n\n  devtest(1) = 1\n  !$acc enter data copyin(devtest(1:1))\n  !$acc parallel present(devtest(1:1))\n    devtest(1) = 0\n  !$acc end parallel\n\n  SEEDDIM(1) = 1\n# ifdef SEED\n  SEEDDIM(1) = SEED\n# endif\n  CALL RANDOM_SEED(PUT=SEEDDIM)\n\n  CALL RANDOM_NUMBER(a)\n  CALL RANDOM_NUMBER(b)\n  c = 0\n\n  !$acc data copyin(a(1:LOOPCOUNT), b(1:LOOPCOUNT))\n    !$acc serial\n      !$acc loop\n      DO x = 1, LOOPCOUNT\n        c(x) = c(x) + b(x) + a(x)\n      END DO\n    !$acc end serial\n  !$acc end data\n\n  DO x = 1, LOOPCOUNT\n    IF (abs(c(x) - (a(x) + b(x))) .gt. PRECISION) THEN\n      errors = errors + 1\n    END IF\n  END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "devonly"
                        ],
                        "versions": [
                            "2.6",
                            "2.7"
                        ]
                    },
                    "2": {
                        "content": "#ifndef T2\n!T2:devonly,V:2.6-2.7\n      LOGICAL FUNCTION test2()\n  IMPLICIT NONE\n  INCLUDE \"acc_testsuite.Fh\"\n  INTEGER:: errors\n  REAL(8),DIMENSION(LOOPCOUNT):: a, b, c\n  INTEGER,DIMENSION(1):: devtest\n  INTEGER:: x\n  errors = 0\n\n  devtest(1) = 1\n  !$acc enter data copyin(devtest(1:1))\n  !$acc parallel present(devtest(1:1))\n    devtest(1) = 0\n  !$acc end parallel\n\n  SEEDDIM(1) = 1\n# ifdef SEED\n  SEEDDIM(1) = SEED\n# endif\n  CALL RANDOM_SEED(PUT=SEEDDIM)\n\n  IF (devtest(1) .eq. 1) THEN\n    CALL RANDOM_NUMBER(a)\n    CALL RANDOM_NUMBER(b)\n    c = 1\n\n    !$acc enter data copyin(c(1:LOOPCOUNT))\n    DO x = 1, LOOPCOUNT\n      c(x) = 0\n    END DO\n\n    !$acc data copyin(a(1:LOOPCOUNT), b(1:LOOPCOUNT))\n      !$acc serial\n        !$acc loop\n        DO x = 1, LOOPCOUNT\n          c(x) = c(x) + a(x) + b(x)\n        END DO\n      !$acc end serial\n    !$acc end data\n\n    DO x = 1, LOOPCOUNT\n      if (abs(c(x)) .gt. PRECISION) THEN\n        errors = errors + 1\n      END IF\n    END DO\n\n    !$acc exit data copyout(c(1:LOOPCOUNT))\n\n    DO x = 1, LOOPCOUNT\n      IF (abs(c(x) - (a(x) + b(x) + 1)) .gt. PRECISION) THEN\n        errors = errors + 1\n      END IF\n    END DO\n  END IF\n\n        IF (errors .eq. 0) THEN\n          test2 = .FALSE.\n        ELSE\n          test2 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T2\n        LOGICAL :: test2\n#endif\n#ifndef T2\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test2()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 1\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "devonly"
                        ],
                        "versions": [
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "serial_default_copy.c": {
                "num tests": 2,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:serial,data,data-region,default-mapping,V:2.6-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n    real_t * c = (real_t *)malloc(n * sizeof(real_t));\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n        c[x] = 0.0;\n    }\n\n    #pragma acc data copyin(a[0:n], b[0:n])\n    {\n        #pragma acc serial\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                c[x] += a[x] + b[x];\n            }\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        if (fabs(c[x] - (a[x] + b[x])) > PRECISION){\n            err += 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "serial",
                            "data",
                            "data-region",
                            "default-mapping"
                        ],
                        "versions": [
                            "2.6",
                            "2.7"
                        ]
                    },
                    "2": {
                        "content": "#ifndef T2\n//T2:serial,data,data-region,default-mapping,devonly,V:2.6-2.7\nint test2(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n    real_t * c = (real_t *)malloc(n * sizeof(real_t));\n    int * devtest = (int *)malloc(sizeof(real_t));\n\n    devtest[0] = 1;\n    #pragma acc enter data copyin(devtest[0:1])\n    #pragma acc parallel present(devtest[0:1])\n    {\n        devtest[0] = 0;\n    }\n\n    if (devtest[0] == 1){\n        for (int x = 0; x < n; ++x){\n            a[x] = rand() / (real_t)(RAND_MAX / 10);\n            b[x] = rand() / (real_t)(RAND_MAX / 10);\n            c[x] = 1;\n        }\n\n        #pragma acc enter data copyin(c[0:n])\n        for (int x = 0; x < n; ++x){\n            c[x] = 0.0;\n        }\n        #pragma acc data copyin(a[0:n], b[0:n])\n        {\n            #pragma acc serial\n            {\n                #pragma acc loop\n                for (int x = 0; x < n; ++x){\n                    c[x] += a[x] + b[x];\n                }\n            }\n        }\n\n        for (int x = 0; x < n; ++x){\n            if (fabs(c[x]) > PRECISION){\n                err += 1;\n            }\n        }\n\n        #pragma acc exit data copyout(c[0:n])\n\n        for (int x = 0; x < n; ++x){\n            if (fabs(c[x] - (a[x] + b[x] + 1)) > PRECISION){\n                err += 1;\n            }\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T2\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test2();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 1);\n    }\n#endif\n",
                        "tags": [
                            "serial",
                            "data",
                            "data-region",
                            "default-mapping",
                            "devonly"
                        ],
                        "versions": [
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "serial_default_present.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:serial,default,V:2.6-2.7\n      LOGICAL FUNCTION test1()\n  IMPLICIT NONE\n  INCLUDE \"acc_testsuite.Fh\"\n  INTEGER:: errors\n  REAL(8),DIMENSION(LOOPCOUNT):: a\n  INTEGER:: x\n  errors = 0\n\n  a = 0\n\n  !$acc enter data copyin(a(1:LOOPCOUNT))\n  !$acc serial default(present)\n    !$acc loop\n    DO x = 1, LOOPCOUNT\n      a(x) = 1\n    END DO\n  !$acc end serial\n  !$acc exit data copyout(a(1:LOOPCOUNT))\n\n  DO x = 1, LOOPCOUNT\n    IF (abs(a(x) - 1) .gt. PRECISION) THEN\n      errors = errors + 1\n    END IF\n  END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "serial",
                            "default"
                        ],
                        "versions": [
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "serial_default_present.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:serial,data,data-region,default,V:2.6-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(n * sizeof(real_t));\n\n    for (int x = 0; x < n; ++x){\n        a[x] = 0.0;\n    }\n    #pragma acc enter data copyin(a[0:n])\n    #pragma acc serial default(present)\n    {\n        #pragma acc loop\n        for (int x = 0; x < n; ++x){\n            a[x] = 1.0;\n        }\n    }\n    #pragma acc exit data copyout(a[0:n])\n\n    for (int x = 0; x < n; ++x){\n        if (fabs(a[x] - 1.0) > PRECISION){\n            err = 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "serial",
                            "data",
                            "data-region",
                            "default"
                        ],
                        "versions": [
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "serial_deviceptr.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:serial,data,data-region,V:2.6-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(n * sizeof(real_t));\n    real_t * b;\n\n    for (int x = 0; x < n; ++x){\n        a[x] = 0;\n    }\n\n    #pragma acc enter data copyin(a[0:n])\n    b = (real_t *) acc_deviceptr(a);\n    if (b == NULL){\n        err = 1;\n    }\n    else{\n        #pragma acc serial deviceptr(b)\n        {\n            #pragma acc loop\n            for (int x = 0; x < (int) n/2; ++x){\n                b[x] = 1;\n            }\n        }\n        #pragma acc exit data copyout(a[0:n])\n    }\n    for (int x = 0; x < n; ++x){\n        if (x < (int) n/2){\n            if (fabs(a[x] - 1) > PRECISION){\n                err = 1;\n            }\n        }\n        else {\n            if (fabs(a[x]) > PRECISION){\n                err = 1;\n            }\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "serial",
                            "data",
                            "data-region"
                        ],
                        "versions": [
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "serial_firstprivate.F90": {
                "num tests": 2,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:serial,firstprivate,V:2.6-2.7\n      LOGICAL FUNCTION test1()\n  IMPLICIT NONE\n  INCLUDE \"acc_testsuite.Fh\"\n  INTEGER:: errors\n  REAL(8),DIMENSION(10, LOOPCOUNT):: a, b, d\n  REAL(8),DIMENSION(10):: c, c_copy\n  INTEGER:: x, y\n\n  errors = 0\n\n  SEEDDIM(1) = 1\n# ifdef SEED\n  SEEDDIM(1) = SEED\n# endif\n  CALL RANDOM_SEED(PUT=SEEDDIM)\n\n  CALL RANDOM_NUMBER(a)\n  CALL RANDOM_NUMBER(b)\n  CALL RANDOM_NUMBER(c)\n  c_copy = c\n  d = 0\n  !$acc data copyin(a(1:10, 1:LOOPCOUNT), b(1:10, 1:LOOPCOUNT)) copy(d(1:10, 1:LOOPCOUNT))\n    !$acc serial firstprivate(c(1:10))\n      !$acc loop gang\n      DO y = 1, LOOPCOUNT\n        !$acc loop worker\n        DO x = 1, 10\n          d(x, y) = a(x, y) + b(x, y) + c(x)\n        END DO\n      END DO\n    !$acc end serial\n  !$acc end data\n\n  DO y = 1, LOOPCOUNT\n    DO x = 1, 10\n      IF (abs(d(x, y) - (a(x, y) + b(x, y) + c_copy(x))) .gt. PRECISION) THEN\n        errors = errors + 1\n      END IF\n    END DO\n  END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "serial",
                            "firstprivate"
                        ],
                        "versions": [
                            "2.6",
                            "2.7"
                        ]
                    },
                    "2": {
                        "content": "#ifndef T2\n!T2:serial,firstprivate,V:2.6-2.7\n      LOGICAL FUNCTION test2()\n  IMPLICIT NONE\n  INCLUDE \"acc_testsuite.Fh\"\n  INTEGER:: errors\n  REAL(8),DIMENSION(10, LOOPCOUNT):: a, b, d\n  REAL(8),DIMENSION(10):: c, c_copy\n  INTEGER:: x, y\n\n  errors = 0\n\n  SEEDDIM(1) = 1\n# ifdef SEED\n  SEEDDIM(1) = SEED\n# endif\n  CALL RANDOM_SEED(PUT=SEEDDIM)\n\n  CALL RANDOM_NUMBER(a)\n  CALL RANDOM_NUMBER(b)\n  d = 0\n  c = 0\n\n  !$acc data copyin(a(1:10, 1:LOOPCOUNT), b(1:10, 1:LOOPCOUNT)) copy(d(1:10, 1:LOOPCOUNT))\n    !$acc serial firstprivate(c(1:10))\n      !$acc loop gang independent\n      DO y = 1, LOOPCOUNT\n        !$acc loop worker independent\n        DO x = 1, 10\n          c(x) = a(x, y) - b(x, y)\n        END DO\n        !$acc loop worker independent\n        DO x = 1, 10\n          d(x, y) = a(x, y) + b(x, y) + c(x)\n        END DO\n      END DO\n    !$acc end serial\n  !$acc end data\n\n  DO y = 1, LOOPCOUNT\n    DO x = 1, 10\n      IF (abs(d(x, y) - (2 * a(x, y))) .gt. PRECISION) THEN\n        errors = errors + 1\n      END IF\n    END DO\n  END DO\n\n        IF (errors .eq. 0) THEN\n          test2 = .FALSE.\n        ELSE\n          test2 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T2\n        LOGICAL :: test2\n#endif\n#ifndef T2\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test2()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 1\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "serial",
                            "firstprivate"
                        ],
                        "versions": [
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "serial_firstprivate.c": {
                "num tests": 2,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:serial,firstprivate,V:2.6-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(10 * n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(10 * n * sizeof(real_t));\n    real_t * c = (real_t *)malloc(10 * sizeof(real_t));\n    real_t * c_copy = (real_t *)malloc(10 * sizeof(real_t));\n    real_t * d = (real_t *)malloc(10 * n * sizeof(real_t));\n\n    for (int x = 0; x < 10*n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n        d[x] = 0.0;\n    }\n    for (int x = 0; x < 10; ++x){\n        c[x] = rand() / (real_t)(RAND_MAX / 10);\n        c_copy[x] = c[x];\n    }\n    #pragma acc data copyin(a[0:10*n], b[0:10*n]) copy(d[0:10*n])\n    {\n        #pragma acc serial firstprivate(c[0:n])\n        {\n            #pragma acc loop gang\n            for (int x = 0; x < n; ++x){\n                #pragma acc loop worker\n                for (int y = 0; y < 10; ++y){\n                    d[x * 10 + y] = a[x * 10 + y] + b[x * 10 + y] + c[y];\n                }\n            }\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        for (int y = 0; y < 10; ++y){\n            if (fabs(d[x * 10 + y] - (a[x * 10 + y] + b[x * 10 + y] + c_copy[y])) > PRECISION){\n                err += 1;\n            }\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "serial",
                            "firstprivate"
                        ],
                        "versions": [
                            "2.6",
                            "2.7"
                        ]
                    },
                    "2": {
                        "content": "#ifndef T2\n//T2:serial,firstprivate,V:2.6-2.7\nint test2(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(10 * n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(10 * n * sizeof(real_t));\n    real_t * c = (real_t *)malloc(10 * sizeof(real_t));\n    real_t * c_copy = (real_t *)malloc(10 * sizeof(real_t));\n    real_t * d = (real_t *)malloc(10 * n * sizeof(real_t));\n\n    for (int x = 0; x < 10*n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n        d[x] = 0.0;\n    }\n    for (int x = 0; x < 10; ++x){\n        c[x] = 0.0;\n    }\n\n    #pragma acc data copyin(a[0:10*n], b[0:10*n]) copy(d[0:10*n])\n    {\n        #pragma acc serial firstprivate(c[0:n])\n        {\n            #pragma acc loop gang independent\n            for (int x = 0; x < n; ++x){\n                #pragma acc loop worker independent\n                for (int y = 0; y < 10; ++y){\n                    c[y] = a[x * 10 + y] - b[x * 10 + y];\n                }\n                #pragma acc loop worker independent\n                for (int y = 0; y < 10; ++y){\n                    d[x * 10 + y] = a[x * 10 + y] + b[x * 10 + y] + c[y];\n                }\n            }\n        }\n    }\n\n    for (int x = 0; x < 10 * n; ++x){\n        if (fabs(d[x] - 2 * a[x]) > PRECISION){\n            err += 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T2\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test2();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 1);\n    }\n#endif\n",
                        "tags": [
                            "serial",
                            "firstprivate"
                        ],
                        "versions": [
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "serial_if.F90": {
                "num tests": 3,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:devonly,serial,if,V:2.6-2.7\n      LOGICAL FUNCTION test1()\n  IMPLICIT NONE\n  INCLUDE \"acc_testsuite.Fh\"\n  INTEGER:: errors\n  REAL(8),DIMENSION(LOOPCOUNT):: a, b, c\n  LOGICAL,DIMENSION(1):: devtest\n  LOGICAL:: host, device\n  INTEGER:: x\n  host = .FALSE.\n  device = .TRUE.\n  errors = 0\n\n  devtest(1) = .TRUE.\n  !$acc enter data copyin(devtest(1:1))\n  !$acc parallel present(devtest(1:1))\n    devtest(1) = .FALSE.\n  !$acc end parallel\n\n  SEEDDIM(1) = 1\n# ifdef SEED\n  SEEDDIM(1) = SEED\n# endif\n  CALL RANDOM_SEED(PUT=SEEDDIM)\n\n  CALL RANDOM_NUMBER(a)\n  CALL RANDOM_NUMBER(b)\n  c = 0\n\n  !$acc serial if(host)\n    !$acc loop\n    DO x = 1, LOOPCOUNT\n      c(x) = a(x) + b(x)\n    END DO\n  !$acc end serial\n\n  DO x = 1, N\n    IF (abs(c(x) - (a(x) + b(x))) .gt. PRECISION) THEN\n      errors = errors + 1\n    END IF\n  END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "devonly",
                            "serial",
                            "if"
                        ],
                        "versions": [
                            "2.6",
                            "2.7"
                        ]
                    },
                    "2": {
                        "content": "#ifndef T2\n!T2:devonly,serial,if,V:2.6-2.7\n      LOGICAL FUNCTION test2()\n  IMPLICIT NONE\n  INCLUDE \"acc_testsuite.Fh\"\n  INTEGER:: errors\n  REAL(8),DIMENSION(LOOPCOUNT):: a, b, c\n  LOGICAL,DIMENSION(1):: devtest\n  LOGICAL:: host, device\n  INTEGER:: x\n  host = .FALSE.\n  device = .TRUE.\n  errors = 0\n\n  devtest(1) = .TRUE.\n  !$acc enter data copyin(devtest(1:1))\n  !$acc parallel present(devtest(1:1))\n    devtest(1) = .FALSE.\n  !$acc end parallel\n\n  SEEDDIM(1) = 1\n# ifdef SEED\n  SEEDDIM(1) = SEED\n# endif\n  CALL RANDOM_SEED(PUT=SEEDDIM)\n\n  IF (devtest(1)) THEN\n    CALL RANDOM_NUMBER(a)\n    CALL RANDOM_NUMBER(b)\n    c = a + b\n\n    !$acc enter data copyin(a(1:LOOPCOUNT), b(1:LOOPCOUNT), c(1:LOOPCOUNT))\n    !$acc serial if(host) present(a(1:LOOPCOUNT), b(1:LOOPCOUNT), c(1:LOOPCOUNT))\n      !$acc loop\n      DO x = 1, LOOPCOUNT\n        c(x) = c(x) + a(x) + b(x)\n      END DO\n    !$acc end serial\n    !$acc exit data delete(a(1:LOOPCOUNT), b(1:LOOPCOUNT)) copyout(c(1:LOOPCOUNT))\n\n    DO x = 1, LOOPCOUNT\n      IF (abs(c(x) - (a(x) + b(x))) .gt. PRECISION) THEN\n        errors = errors + 1\n      END IF\n    END DO\n  END IF\n\n        IF (errors .eq. 0) THEN\n          test2 = .FALSE.\n        ELSE\n          test2 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T2\n        LOGICAL :: test2\n#endif\n#ifndef T2\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test2()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 1\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "devonly",
                            "serial",
                            "if"
                        ],
                        "versions": [
                            "2.6",
                            "2.7"
                        ]
                    },
                    "3": {
                        "content": "#ifndef T3\n!T3:devonly,serial,if,V:2.6-2.7\n      LOGICAL FUNCTION test3()\n  IMPLICIT NONE\n  INCLUDE \"acc_testsuite.Fh\"\n  INTEGER:: errors\n  REAL(8),DIMENSION(LOOPCOUNT):: a, b, c\n  LOGICAL,DIMENSION(1):: devtest\n  LOGICAL:: host, device\n  INTEGER:: x\n  host = .FALSE.\n  device = .TRUE.\n  errors = 0\n\n  devtest(1) = .TRUE.\n  !$acc enter data copyin(devtest(1:1))\n  !$acc parallel present(devtest(1:1))\n    devtest(1) = .FALSE.\n  !$acc end parallel\n\n  SEEDDIM(1) = 1\n# ifdef SEED\n  SEEDDIM(1) = SEED\n# endif\n  CALL RANDOM_SEED(PUT=SEEDDIM)\n\n  CALL RANDOM_NUMBER(a)\n  CALL RANDOM_NUMBER(b)\n  c = a + b\n  \n  !$acc enter data copyin(a(1:LOOPCOUNT), b(1:LOOPCOUNT), c(1:LOOPCOUNT))\n  !$acc serial if(device) present(a(1:LOOPCOUNT), b(1:LOOPCOUNT), c(1:LOOPCOUNT))\n    !$acc loop\n    DO x = 1, LOOPCOUNT\n      c(x) = c(x) + a(x) + b(x)\n    END DO\n  !$acc end serial\n  !$acc exit data delete(a(1:LOOPCOUNT), b(1:LOOPCOUNT)) copyout(c(1:LOOPCOUNT))\n\n  DO x = 1, LOOPCOUNT\n    IF (abs(c(x) - (2 * (a(x) + b(x)))) .gt. PRECISION * 2) THEN\n      errors = errors + 1\n    END IF\n  END DO\n\n        IF (errors .eq. 0) THEN\n          test3 = .FALSE.\n        ELSE\n          test3 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T3\n        LOGICAL :: test3\n#endif\n#ifndef T3\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test3()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 2\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "devonly",
                            "serial",
                            "if"
                        ],
                        "versions": [
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "serial_if.c": {
                "num tests": 3,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:serial,if,V:2.6-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n    real_t * c = (real_t *)malloc(n * sizeof(real_t));\n    int accel = 1;\n    int host = 0;\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n        c[x] = 0.0;\n    }\n    #pragma acc serial if(host)\n    {\n        #pragma acc loop\n        for (int x = 0; x < n; ++x){\n            c[x] = a[x] + b[x];\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        if (fabs(c[x] - (a[x] + b[x])) > PRECISION){\n            err = 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "serial",
                            "if"
                        ],
                        "versions": [
                            "2.6",
                            "2.7"
                        ]
                    },
                    "2": {
                        "content": "#ifndef T2\n//T2:serial,if,devonly,V:2.6-2.7\nint test2(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n    real_t * c = (real_t *)malloc(n * sizeof(real_t));\n    int accel = 1;\n    int host = 0;\n    int * devtest = (int *)malloc(sizeof(int));\n    devtest[0] = 1;\n    #pragma acc data copyin(devtest[0:1])\n    #pragma acc parallel present(devtest[0:1])\n    {\n      devtest[0] = 0;\n    }\n\n    if (devtest[0] == 1){\n        for (int x = 0; x < n; ++x){\n            a[x] = rand() / (real_t)(RAND_MAX / 10);\n            b[x] = rand() / (real_t)(RAND_MAX / 10);\n            c[x] = 0;\n        }\n        #pragma acc enter data copyin(a[0:n], b[0:n], c[0:n])\n        #pragma acc serial if(host) present(a[0:n], b[0:n], c[0:n])\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                c[x] += a[x] + b[x];\n            }\n        }\n        #pragma acc exit data delete(a[0:n], b[0:n]) copyout(c[0:n])\n\n        for (int x = 0; x < n; ++x){\n            if (fabs(c[x]) > PRECISION){\n                err = 1;\n            }\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T2\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test2();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 1);\n    }\n#endif\n",
                        "tags": [
                            "serial",
                            "if",
                            "devonly"
                        ],
                        "versions": [
                            "2.6",
                            "2.7"
                        ]
                    },
                    "3": {
                        "content": "#ifndef T3\n//T3:serial,if,V:2.6-2.7\nint test3(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n    real_t * c = (real_t *)malloc(n * sizeof(real_t));\n    int accel = 1;\n    int host = 0;\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n        c[x] = 0;\n    }\n    #pragma acc enter data copyin(a[0:n], b[0:n], c[0:n])\n    #pragma acc serial if(accel) present(a[0:n], b[0:n], c[0:n])\n    {\n        #pragma acc loop\n        for (int x = 0; x < n; ++x){\n            c[x] += a[x] + b[x];\n        }\n    }\n\n    #pragma acc exit data delete(a[0:n], b[0:n]) copyout(c[0:n])\n\n    for (int x = 0; x < n; ++x){\n        if (fabs(c[x] - (a[x] + b[x])) > PRECISION * 2){\n            err = 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T3\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test3();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 2);\n    }\n#endif\n",
                        "tags": [
                            "serial",
                            "if"
                        ],
                        "versions": [
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "serial_loop.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:serial,loop,V:2.6-2.7\n      LOGICAL FUNCTION test1()\n  IMPLICIT NONE\n  INCLUDE \"acc_testsuite.Fh\"\n  REAL(8),DIMENSION(LOOPCOUNT):: a, b, c\n  INTEGER:: x\n  INTEGER:: errors\n\n  errors = 0\n\n  SEEDDIM(1) = 1\n# ifdef SEED\n  SEEDDIM(1) = SEED\n# endif\n  CALL RANDOM_SEED(PUT=SEEDDIM)\n\n  CALL RANDOM_NUMBER(a)\n  CALL RANDOM_NUMBER(b)\n  c = 0\n\n  !$acc data copy(c(1:LOOPCOUNT))\n    !$acc serial loop\n    DO x = 1, LOOPCOUNT\n      c(x) = 1\n    END DO\n  !$acc end data\n\n  DO x = 1, LOOPCOUNT\n    IF (abs(c(x) - 1) .gt. PRECISION) THEN\n      errors = errors + 1\n    END IF\n  END DO\n\n  !$acc data copy(a(1:LOOPCOUNT), b(1:LOOPCOUNT), c(1:LOOPCOUNT))\n    !$acc serial\n      !$acc loop\n      DO x = 1, LOOPCOUNT\n        c(x) = b(x)\n      END DO\n      !$acc loop\n      DO x = 1, LOOPCOUNT\n        c(x) = c(x) + a(x)\n      END DO\n    !$acc end serial\n  !$acc end data\n\n  DO x = 1, LOOPCOUNT\n    IF (abs(c(x) - (a(x) + b(x))) .gt. PRECISION) THEN\n      errors = errors + 1\n    END IF\n  END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "serial",
                            "loop"
                        ],
                        "versions": [
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "serial_loop.c": {
                "num tests": 2,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:serial,loop,combined-constructs,V:2.6-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n    real_t * c = (real_t *)malloc(n * sizeof(real_t));\n\n    for (int x = 0; x < n; ++x){\n        a[x] = 0;\n    }\n\n    #pragma acc data copy(a[0:n])\n    {\n        #pragma acc serial loop\n        for (int x = 0; x < n; ++x){\n            a[x] = 1.0;\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        if (fabs(a[x] - 1.0) > PRECISION){\n            err = 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "serial",
                            "loop",
                            "combined-constructs"
                        ],
                        "versions": [
                            "2.6",
                            "2.7"
                        ]
                    },
                    "2": {
                        "content": "#ifndef T2\n//T2:serial,loop,V:2.6-2.7\nint test2(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n    real_t * c = (real_t *)malloc(n * sizeof(real_t));\n\n    for (int x = 0; x < n; ++x){\n      a[x] = 0.0;\n      b[x] = rand() / (real_t)(RAND_MAX / 10);\n      c[x] = rand() / (real_t)(RAND_MAX / 10);\n    }\n    #pragma acc data copy(a[0:n], b[0:n], c[0:n])\n    {\n        #pragma acc serial\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                a[x] = b[x];\n            }\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                a[x] += c[x];\n            }\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        if (fabs(a[x] - (b[x] + c[x])) > PRECISION * 2){\n            err = 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T2\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test2();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 1);\n    }\n#endif\n",
                        "tags": [
                            "serial",
                            "loop"
                        ],
                        "versions": [
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "serial_loop_async.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:async,serial,combined-constructs,loop,V:2.6-2.7\n      LOGICAL FUNCTION test1()\n  IMPLICIT NONE\n  INCLUDE \"acc_testsuite.Fh\"\n  INTEGER:: errors\n  REAL(8),DIMENSION(LOOPCOUNT, 10):: a, b, c, d\n  INTEGER,DIMENSION(10):: error_array\n  INTEGER:: x, y\n\n  errors = 0\n  SEEDDIM(1) = 1\n# ifdef SEED\n  SEEDDIM(1) = SEED\n# endif\n  CALL RANDOM_SEED(PUT=SEEDDIM)\n\n  CALL RANDOM_NUMBER(a)\n  CALL RANDOM_NUMBER(b)\n  c = 0\n\n  DO y = 1, 10\n    DO x = 1, LOOPCOUNT\n      d(x, y) = a(x, y) + b(x, y)\n    END DO\n  END DO\n\n  error_array = 0\n\n  !$acc data copyin(a(1:LOOPCOUNT, 1:10), b(1:LOOPCOUNT, 1:10), c(1:LOOPCOUNT, 1:10), d(1:LOOPCOUNT, 1:10)) copy(error_array(1:10))\n    DO y = 1, 10\n      !$acc serial loop async(y)\n      DO x = 1, LOOPCOUNT\n        c(x, y) = a(x, y) + b(x, y)\n      END DO\n      !$acc serial loop async(y)\n      DO x = 1, LOOPCOUNT\n        IF (((c(x, y) - d(x, y)) .gt. PRECISION) .OR. ((d(x, y) - c(x, y)) .gt. PRECISION)) THEN\n          error_array(y) = error_array(y) + 1\n        END IF\n      END DO\n    END DO\n  !$acc end data\n\n  DO x = 1, 10\n    errors = errors + error_array(x)\n  END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "async",
                            "serial",
                            "combined-constructs",
                            "loop"
                        ],
                        "versions": [
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "serial_loop_async.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:serial,loop,async,combined-constructs,V:2.6-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(10 * n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(10 * n * sizeof(real_t));\n    real_t * c = (real_t *)malloc(10 * n * sizeof(real_t));\n    real_t * d = (real_t *)malloc(10 * n * sizeof(real_t));\n\t\tint * errors = (int *)malloc(10 * sizeof(int));\n\n\t\tfor (int x = 0; x < 10; ++x){\n\t\t\terrors[x] = 0;\n\t\t}\n\n    for (int x = 0; x < 10 * n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n        c[x] = 0.0;\n        d[x] = a[x] + b[x];\n    }\n\n    #pragma acc data copyin(a[0:10*n], b[0:10*n], c[0:10*n], d[0:10*n]) copy(errors[0:10])\n    {\n        for (int x = 0; x < 10; ++x){\n            #pragma acc serial loop async(x)\n            for (int y = 0; y < n; ++y){\n                c[x * n + y] = a[x * n + y] + b[x * n + y];\n            }\n            #pragma acc serial loop async(x)\n            for (int y = 0; y < n; ++y){\n                if(c[x * n + y] - d[x * n + y] > PRECISION || d[x * n + y] - c[x * n + y] > PRECISION){\n                    errors[x] += 1;\n                }\n            }\n        }\n\t\t\t\t#pragma acc wait\n    }\n\n    for (int x = 0; x < 10; ++x){\n        err += errors[x];\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "serial",
                            "loop",
                            "async",
                            "combined-constructs"
                        ],
                        "versions": [
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "serial_loop_auto.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:serial,combined-constructs,loop,auto,V:2.6-2.7\n      LOGICAL FUNCTION test1()\n  IMPLICIT NONE\n  INCLUDE \"acc_testsuite.Fh\"\n  INTEGER:: errors\n  REAL(8),DIMENSION(LOOPCOUNT):: a, a_copy, b\n  INTEGER:: x\n  REAL(8):: temp\n  errors = 0\n\n  SEEDDIM(1) = 1\n# ifdef SEED\n  SEEDDIM(1) = SEED\n# endif\n  CALL RANDOM_SEED(PUT=SEEDDIM)\n\n  CALL RANDOM_NUMBER(a)\n  a_copy = a\n  b = 0\n\n  !$acc data copyin(a(1:LOOPCOUNT)) copyout(b(1:LOOPCOUNT))\n    !$acc serial loop auto\n    DO x = 1, LOOPCOUNT\n      b(x) = a(x)\n    END DO\n  !$acc end data\n\n  DO x = 1, LOOPCOUNT\n    IF (abs(b(x) - a(x)) .gt. PRECISION) THEN\n      errors = errors + 1\n    END IF\n  END DO\n\n  !$acc data copy(a(1:LOOPCOUNT))\n    !$acc serial loop auto\n    DO x = 2, LOOPCOUNT\n      a(x) = a(x - 1) + a(x)\n    END DO\n  !$acc end data\n\n  temp = 0\n  DO x = 1, LOOPCOUNT\n    temp = temp + a_copy(x)\n    IF (abs(temp - a(x)) .gt. PRECISION) THEN\n      errors = errors + 1\n    END IF\n  END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "serial",
                            "combined-constructs",
                            "loop",
                            "auto"
                        ],
                        "versions": [
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "serial_loop_auto.c": {
                "num tests": 2,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:serial,loop,auto,V:2.6-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(n * sizeof(real_t));\n    real_t * a_copy = (real_t *)malloc(n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n    real_t rolling_total = 0.0;\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = 0;\n    }\n\n    #pragma acc data copyin(a[0:n]) copyout(b[0:n])\n    {\n      #pragma acc serial loop auto\n      for (int x = 0; x < n; ++x){\n        b[x] = a[x];\n      }\n    }\n\n    for (int x = 0; x < n; ++x){\n      if (fabs(b[x] - a[x]) > PRECISION){\n        err = 1;\n      }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "serial",
                            "loop",
                            "auto"
                        ],
                        "versions": [
                            "2.6",
                            "2.7"
                        ]
                    },
                    "2": {
                        "content": "#ifndef T2\n//T2:serial,loop,combined-constructs,V:2.6-2.7\nint test2(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(n * sizeof(real_t));\n    real_t * a_copy = (real_t *)malloc(n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n    real_t rolling_total = 0.0;\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        a_copy[x] = a[x];\n    }\n\n    #pragma acc data copy(a[0:n])\n    {\n      #pragma acc serial loop auto\n      for (int x = 1; x < n; ++x){\n        a[x] = a[x - 1] + a[x];\n      }\n    }\n\n    for (int x = 0; x < n; ++x){\n      rolling_total += a_copy[x];\n      if (fabs(rolling_total - a[x]) > PRECISION){\n        err = 1;\n      }\n    }\n\n    return err;\n}\n#endif\n#ifndef T2\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test2();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 1);\n    }\n#endif\n",
                        "tags": [
                            "serial",
                            "loop",
                            "combined-constructs"
                        ],
                        "versions": [
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "serial_loop_gang.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:serial,combined-constructs,loop,V:2.6-2.7\n      LOGICAL FUNCTION test1()\n  IMPLICIT NONE\n  INCLUDE \"acc_testsuite.Fh\"\n  INTEGER:: errors\n  REAL(8),DIMENSION(LOOPCOUNT):: a, b, c\n  INTEGER:: x\n\n  errors = 0\n\n  SEEDDIM(1) = 1\n# ifdef SEED\n  SEEDDIM(1) = SEED\n# endif\n  CALL RANDOM_SEED(PUT=SEEDDIM)\n\n  CALL RANDOM_NUMBER(a)\n  CALL RANDOM_NUMBER(b)\n  c = 0\n\n  !$acc data copyin(a(1:LOOPCOUNT), b(1:LOOPCOUNT)) copy(c(1:LOOPCOUNT))\n    !$acc serial loop gang\n    DO x = 1, LOOPCOUNT\n      c(x) = a(x) + b(x)\n    END DO\n  !$acc end data\n\n  DO x = 1, LOOPCOUNT\n    IF (abs(c(x) - (a(x) + b(x))) .gt. PRECISION) THEN\n      errors = errors + 1\n    END IF\n  END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "serial",
                            "combined-constructs",
                            "loop"
                        ],
                        "versions": [
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "serial_loop_gang.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:serial,loop,combined-constructs,V:2.6-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n    real_t * c = (real_t *)malloc(n * sizeof(real_t));\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n        c[x] = 0.0;\n    }\n\n    #pragma acc data copyin(a[0:n], b[0:n]) copy(c[0:n])\n    {\n        #pragma acc serial loop gang\n        for (int x = 0; x < n; ++x){\n            c[x] = a[x] + b[x];\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        if (fabs(c[x] - (a[x] + b[x])) > PRECISION){\n            err = 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "serial",
                            "loop",
                            "combined-constructs"
                        ],
                        "versions": [
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "serial_loop_reduction_add_general.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:serial,reduction,combined-constructs,loop,V:2.6-2.7\n      LOGICAL FUNCTION test1()\n  IMPLICIT NONE\n  INCLUDE \"acc_testsuite.Fh\"\n  INTEGER:: errors\n  REAL(8),DIMENSION(LOOPCOUNT):: a, b\n  REAL(8):: total\n  INTEGER:: x\n  errors = 0\n\n  SEEDDIM(1) = 1\n# ifdef SEED\n  SEEDDIM(1) = SEED\n# endif\n  CALL RANDOM_SEED(PUT=SEEDDIM)\n\n  CALL RANDOM_NUMBER(a)\n  CALL RANDOM_NUMBER(b)\n\n  total = 10\n  !$acc data copyin(a(1:LOOPCOUNT), b(1:LOOPCOUNT))\n    !$acc serial loop reduction(+:total)\n    DO x = 1, LOOPCOUNT\n      total = total + a(x) + b(x)\n    END DO\n  !$acc end data\n\n  DO x = 1, LOOPCOUNT\n    total = total - (a(x) + b(x))\n  END DO\n\n  IF (abs(total - 10) .gt. PRECISION) THEN\n    errors = errors + 1\n  END IF\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "serial",
                            "reduction",
                            "combined-constructs",
                            "loop"
                        ],
                        "versions": [
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "serial_loop_reduction_add_general.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:serial,loop,reduction,combined-constructs,V:2.6-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n    real_t total = 10;\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n    }\n\n    #pragma acc data copyin(a[0:n], b[0:n])\n    {\n        #pragma acc serial loop reduction(+:total)\n        for (int x = 0; x < n; ++x){\n            total += a[x] + b[x];\n        }\n    }\n    for (int x = 0; x < n; ++x){\n        total -= a[x] + b[x];\n    }\n    if (fabs(total - 10) > PRECISION * (2 * n - 1)){ //199 = # of mathematical operations necessary\n        err = 1;\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "serial",
                            "loop",
                            "reduction",
                            "combined-constructs"
                        ],
                        "versions": [
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "serial_loop_reduction_add_loop.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:serial,private,reduction,combined-constructs,loop,V:2.6-2.7\n      LOGICAL FUNCTION test1()\n  IMPLICIT NONE\n  INCLUDE \"acc_testsuite.Fh\"\n  INTEGER:: errors\n  REAL(8),DIMENSION(LOOPCOUNT, 10):: a, b, c, d\n  REAL(8):: avg, temp\n  INTEGER:: x, y\n  avg = 0\n  errors = 0\n\n  SEEDDIM(1) = 1\n# ifdef SEED\n  SEEDDIM(1) = SEED\n# endif\n  CALL RANDOM_SEED(PUT=SEEDDIM)\n\n  CALL RANDOM_NUMBER(a)\n  CALL RANDOM_NUMBER(b)\n\n  !$acc data copyin(a(1:LOOPCOUNT, 1:10), b(1:LOOPCOUNT, 1:10)) create(c(1:LOOPCOUNT, 1:10)) copyout(d(1:LOOPCOUNT, 1:10))\n    !$acc serial loop gang private(avg)\n    DO y = 1, 10\n      avg = 0\n      !$acc loop worker reduction(+:avg)\n      DO x = 1, LOOPCOUNT\n        c(x, y) = a(x, y) + b(x, y)\n        avg = avg + c(x, y)\n      END DO\n      avg = avg / LOOPCOUNT\n      !$acc loop worker\n      DO x = 1, LOOPCOUNT\n        d(x, y) = c(x, y) - avg\n      END DO\n    END DO\n  !$acc end data\n\n  DO y = 1, 10\n    temp = 0\n    DO x = 1, LOOPCOUNT\n      temp = temp + (a(x, y) + b(x, y))\n    END DO\n    temp = temp / LOOPCOUNT\n    DO x = 1, LOOPCOUNT\n      IF (abs(d(x, y) - ((a(x, y) + b(x, y)) - temp)) .gt. PRECISION) THEN\n        errors = errors + 1\n      END IF\n    END DO\n  END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "serial",
                            "private",
                            "reduction",
                            "combined-constructs",
                            "loop"
                        ],
                        "versions": [
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "serial_loop_reduction_add_loop.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:serial,loop,reduction,combined-constructs,V:2.6-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(10 * n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(10 * n * sizeof(real_t));\n    real_t * c = (real_t *)malloc(10 * n * sizeof(real_t));\n    real_t * d = (real_t *)malloc(10 * n * sizeof(real_t));\n    real_t avg = 0.0;\n    real_t rolling_total = 0;\n\n    for (int x = 0; x < 10 * n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n    }\n\n    #pragma acc data copyin(a[0:10*n], b[0:10*n]) create(c[0:10*n]) copyout(d[0:10*n])\n    {\n        #pragma acc serial loop gang private(avg)\n        for (int x = 0; x < 10; ++x){\n            avg = 0;\n            #pragma acc loop worker reduction(+:avg)\n            for (int y = 0; y < n; ++y){\n                avg += c[x * n + y] = a[x * n + y] + b[x * n + y];\n            }\n            avg = avg / n;\n            #pragma acc loop worker\n            for (int y = 0; y < n; ++y){\n                d[x * n + y] = c[x * n + y] - avg;\n            }\n        }\n    }\n\n\n    for (int x = 0; x < 10; ++x){\n        rolling_total = 0;\n        for (int y = 0; y < n; ++y){\n            rolling_total += a[x * n + y] + b[x * n + y];\n        }\n        rolling_total = rolling_total / n;\n        for (int y = 0; y < n; ++y){\n            if (fabs(d[x * n + y] - ((a[x * n + y] + b[x * n + y]) - rolling_total)) > PRECISION){\n                err += 1;\n            }\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "serial",
                            "loop",
                            "reduction",
                            "combined-constructs"
                        ],
                        "versions": [
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "serial_loop_reduction_add_vector_loop.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:serial,private,reduction,combined-constructs,loop,V:2.6-2.7\n      LOGICAL FUNCTION test1()\n  IMPLICIT NONE\n  INCLUDE \"acc_testsuite.Fh\"\n  INTEGER:: errors\n  REAL(8),DIMENSION(LOOPCOUNT, 10):: a, b\n  REAL(8),DIMENSION(10):: c\n  REAL(8):: temp\n  INTEGER:: x, y\n\n  errors = 0\n\n  SEEDDIM(1) = 1\n# ifdef SEED\n  SEEDDIM(1) = SEED\n# endif\n  CALL RANDOM_SEED(PUT=SEEDDIM)\n\n  CALL RANDOM_NUMBER(a)\n  CALL RANDOM_NUMBER(b)\n\n  !$acc data copyin(a(1:LOOPCOUNT,1:10), b(1:LOOPCOUNT,1:10)) copyout(c(1:10))\n    !$acc serial loop private(temp)\n    DO y = 1, 10\n      temp = 0\n      !$acc loop vector reduction(+:temp)\n      DO x = 1, LOOPCOUNT\n        temp = temp + (a(x, y) + b(x, y))\n      END DO\n      c(y) = temp\n    END DO\n  !$acc end data\n\n  DO y = 1, 10\n    DO x = 1, LOOPCOUNT\n      c(y) = c(y) - (a(x, y) + b(x, y))\n    END DO\n    IF (abs(c(y)) .gt. PRECISION) THEN\n      errors = errors + 1\n    END IF\n  END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "serial",
                            "private",
                            "reduction",
                            "combined-constructs",
                            "loop"
                        ],
                        "versions": [
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "serial_loop_reduction_add_vector_loop.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:serial,loop,reduction,combined-constructs,V:2.6-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(10 * n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(10 * n * sizeof(real_t));\n    real_t * c = (real_t *)malloc(10 * sizeof(real_t));\n    real_t temp = 0.0;\n\n    for(int x = 0; x < 10 * n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n    }\n    #pragma acc data copyin(a[0:10*n], b[0:10*n]) copyout(c[0:10])\n    {\n        #pragma acc serial loop private(temp)\n        for (int x = 0; x < 10; ++x){\n            temp = 0.0;\n            #pragma acc loop vector reduction(+:temp)\n            for (int y = 0; y < n; ++y){\n                temp += a[(x * n) + y] + b[(x * n) + y];\n            }\n            c[x] = temp;\n        }\n    }\n    for (int x = 0; x < 10; ++x){\n        for (int y = 0; y < n; ++y){\n            c[x] -= a[(x * n) + y] + b[(x * n) + y];\n        }\n        if (fabs(c[x]) > PRECISION * (2 * n - 1)){\n            err = 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "serial",
                            "loop",
                            "reduction",
                            "combined-constructs"
                        ],
                        "versions": [
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "serial_loop_reduction_and_general.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:serial,reduction,combined-constructs,loop,V:2.6-2.7\n      LOGICAL FUNCTION test1()\n  IMPLICIT NONE\n  INCLUDE \"acc_testsuite.Fh\"\n  INTEGER:: errors\n  INTEGER:: x\n  LOGICAL,DIMENSION(LOOPCOUNT):: a\n  LOGICAL:: result, host_result\n  REAL(8),DIMENSION(LOOPCOUNT):: randoms\n  REAL(8):: false_margin = EXP(LOG(.5) / LOOPCOUNT)\n\n  errors = 0\n  SEEDDIM(1) = 1\n# ifdef SEED\n  SEEDDIM(1) = SEED\n# endif\n  CALL RANDOM_SEED(PUT=SEEDDIM)\n\n  CALL RANDOM_NUMBER(randoms)\n\n  DO x = 1, LOOPCOUNT\n    IF (randoms(x) .lt. false_margin) THEN\n      a(x) = .TRUE.\n    ELSE\n      a(x) = .FALSE.\n    END IF\n  END DO\n\n  result = .TRUE.\n  !$acc data copyin(a(1:LOOPCOUNT))\n    !$acc serial loop reduction(.AND.:result)\n    DO x = 1, LOOPCOUNT\n      result = result .AND. a(x)\n    END DO\n  !$acc end data\n\n  host_result = .TRUE.\n  DO x = 1, LOOPCOUNT\n    host_result = host_result .AND. a(x)\n  END DO\n\n  IF (host_result .NEQV. result) THEN\n    errors = errors + 1\n  END IF\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "serial",
                            "reduction",
                            "combined-constructs",
                            "loop"
                        ],
                        "versions": [
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "serial_loop_reduction_and_general.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:serial,loop,reduction,combined-constructs,V:2.6-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    char * a = (char *)malloc(n * sizeof(char));\n    real_t false_margin = pow(exp(1), log(.5)/n);\n    char result = 1;\n    char found = 0;\n\n    for (int x = 0; x < n; ++x){\n        if(rand() / (real_t)(RAND_MAX) < false_margin){\n            a[x] = 1;\n        }\n        else{\n            a[x] = 0;\n        }\n    }\n\n    #pragma acc data copyin(a[0:n])\n    {\n        #pragma acc serial loop reduction(&&:result)\n        for (int x = 0; x < n; ++x){\n            result = result && a[x];\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        if (a[x] == 0){\n            found = 1;\n            break;\n        }\n    }\n    if (found == result){\n        err = 1;\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "serial",
                            "loop",
                            "reduction",
                            "combined-constructs"
                        ],
                        "versions": [
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "serial_loop_reduction_and_loop.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:serial,private,reduction,combined-constructs,loop,V:2.6-2.7\n      LOGICAL FUNCTION test1()\n  IMPLICIT NONE\n  INCLUDE \"acc_testsuite.Fh\"\n  INTEGER:: errors\n  REAL(8):: false_margin\n  REAL(8),DIMENSION(LOOPCOUNT, 10):: randoms\n  LOGICAL,DIMENSION(LOOPCOUNT, 10):: a, a_copy\n  LOGICAL,DIMENSIOn(10):: has_false\n  LOGICAL:: temp\n  INTEGER:: x, y\n  errors = 0\n  false_margin = EXP(LOG(.5) / LOOPCOUNT)\n\n  SEEDDIM(1) = 1\n# ifdef SEED\n  SEEDDIM(1) = SEED\n# endif\n  CALL RANDOM_SEED(PUT=SEEDDIM)\n\n  CALL RANDOM_NUMBER(randoms)\n\n  has_false = .FALSE.\n  a = .TRUE.\n  DO y = 1, 10\n    DO x = 1, LOOPCOUNT\n      IF (randoms(x, y) .gt. false_margin) THEN\n        a(x, y) = .FALSE.\n        has_false(y) = .TRUE.\n      END IF\n    END DO\n  END DO\n  a_copy = a\n\n  !$acc data copy(a(1:LOOPCOUNT, 1:10))\n    !$acc serial loop gang private(temp)\n    DO y = 1, 10\n      temp = .TRUE.\n      !$acc loop worker reduction(.AND.:temp)\n      DO x = 1, LOOPCOUNT\n        temp = temp .AND. a(x, y)\n      END DO\n      !$acc loop worker\n      DO x = 1, LOOPCOUNT\n        IF (temp) THEN\n          IF (a(x, y) .eq. 1) THEN\n            a(x, y) = .FALSE.\n          ELSE\n            a(x, y) = .TRUE.\n          END IF\n        END IF\n      END DO\n    END DO\n  !$acc end data\n\n  DO y = 1, 10\n    DO x = 1, LOOPCOUNT\n      IF ((has_false(y) .eqv. .TRUE.) .AND. (a(x, y) .neqv. a_copy(x, y))) THEN\n        errors = errors + 1\n      ELSEIF ((has_false(y) .eqv. .FALSE.) .AND. (a(x, y) .eqv. a_copy(x, y))) THEN\n        errors = errors + 1\n      END IF\n    END DO\n  END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "serial",
                            "private",
                            "reduction",
                            "combined-constructs",
                            "loop"
                        ],
                        "versions": [
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "serial_loop_reduction_and_loop.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:serial,loop,reduction,combined-constructs,V:2.6-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    char * a = (char *)malloc(10 * n * sizeof(char));\n    char * a_copy = (char *)malloc(10 * n * sizeof(char));\n    char * has_false = (char *)malloc(10 * sizeof(char));\n    real_t false_margin = pow(exp(1), log(.5)/n);\n    char temp = 1;\n\n    for (int x = 0; x < 10; ++x){\n        has_false[x] = 0;\n    }\n\n    for (int x = 0; x < 10; ++x){\n        for (int y = 0; y < n; ++y){\n            if (rand() / (real_t)(RAND_MAX) < false_margin){\n                a[x * n + y] = 1;\n                a_copy[x * n + y] = 1;\n            }\n            else {\n                a[x * n + y] = 0;\n                a_copy[x * n + y] = 0;\n                has_false[x] = 1;\n            }\n        }\n    }\n\n    #pragma acc data copy(a[0:10*n])\n    {\n        #pragma acc serial loop gang private(temp)\n        for (int x = 0; x < 10; ++x){\n            temp = 1;\n            #pragma acc loop worker reduction(&&:temp)\n            for (int y = 0; y < n; ++y){\n                temp = temp && a[x * n + y];\n            }\n            #pragma acc loop worker\n            for (int y = 0; y < n; ++y){\n                if(temp == 1){\n                    if  (a[x * n + y] == 1){\n                        a[x * n + y] = 0;\n                    }\n                    else {\n                        a[x * n + y] = 1;\n                    }\n                }\n            }\n        }\n    }\n\n\n    for (int x = 0; x < 10; ++x){\n        for (int y = 0; y < n; ++y){\n            if (has_false[x] == 1 && a[x * n + y] != a_copy[x * n + y]){\n                err = 1;\n            }\n            else if (has_false[x] == 0 && a[x * n + y] == a_copy[x * n + y]){\n                err = 1;\n            }\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "serial",
                            "loop",
                            "reduction",
                            "combined-constructs"
                        ],
                        "versions": [
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "serial_loop_reduction_and_vector_loop.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:serial,private,reduction,combined-constructs,loop,V:2.6-2.7\n      LOGICAL FUNCTION test1()\n  IMPLICIT NONE\n  INCLUDE \"acc_testsuite.Fh\"\n  LOGICAL,DIMENSION(LOOPCOUNT, 10):: a\n  LOGICAL,DIMENSION(10):: b, has_false\n  LOGICAL:: temp\n  REAL(8),DIMENSION(LOOPCOUNT, 10):: randoms\n  REAL(8):: false_margin\n  INTEGER:: errors, x, y\n\n  errors = 0\n  false_margin = exp(log(.5) / LOOPCOUNT)\n\n  SEEDDIM(1) = 1\n# ifdef SEED\n  SEEDDIM(1) = SEED\n# endif\n  CALL RANDOM_SEED(PUT=SEEDDIM)\n\n  CALL RANDOM_NUMBER(randoms)\n\n  has_false = .FALSE.\n  DO y = 1, 10\n    DO x = 1, LOOPCOUNT\n      IF (randoms(x, y) .lt. false_margin) THEN\n        a(x, y) = .TRUE.\n      ELSE\n        a(x, y) = .FALSE.\n        has_false(y) = .TRUE.\n      END IF\n    END DO\n  END DO\n\n  !$acc data copyin(a(1:LOOPCOUNT, 1:10)) copy(b(1:10))\n    !$acc serial loop private(temp)\n    DO y = 1, 10\n      temp = .TRUE.\n      !$acc loop vector reduction(.AND.:temp)\n      DO x = 1, LOOPCOUNT\n        temp = temp .AND. a(x, y)\n      END DO\n      b(y) = temp\n    END DO\n  !$acc end data\n\n  DO x = 1, 10\n    IF (has_false(x) .eqv. b(x)) THEN\n      errors = errors + 1\n    END IF\n  END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "serial",
                            "private",
                            "reduction",
                            "combined-constructs",
                            "loop"
                        ],
                        "versions": [
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "serial_loop_reduction_and_vector_loop.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:serial,loop,reduction,combined-constructs,V:2.6-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    char * a = (char *)malloc(10 * n * sizeof(char));\n    char * b = (char *)malloc(10 * sizeof(char));\n    char * has_false = (char *)malloc(10 * sizeof(char));\n    char temp = 1;\n    real_t false_margin = pow(exp(1), log(.5)/n);\n\n    for (int x = 0; x < 10; ++x){\n        has_false[x] = 0;\n    }\n    for (int x = 0; x < 10 * n; ++x){\n        if(rand() / (real_t)(RAND_MAX) < false_margin){\n            a[x] = 1;\n        }\n        else{\n            a[x] = 0;\n            has_false[x/n] = 1;\n        }\n    }\n    #pragma acc data copyin(a[0:10*n]) copy(b[0:10])\n    {\n        #pragma acc serial loop private(temp)\n        for (int x = 0; x < 10; ++x){\n            temp = 1;\n            #pragma acc loop vector reduction(&&:temp)\n            for (int y = 0; y < n; ++y){\n                temp = temp && a[x * n + y];\n            }\n            b[x] = temp;\n        }\n    }\n    for (int x = 0; x < 10; ++x){\n        if (has_false[x] == b[x]){\n            err = 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "serial",
                            "loop",
                            "reduction",
                            "combined-constructs"
                        ],
                        "versions": [
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "serial_loop_reduction_bitand_general.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:serial,reduction,combined-constructs,loop,V:2.6-2.7\n      LOGICAL FUNCTION test1()\n  IMPLICIT NONE\n  INCLUDE \"acc_testsuite.Fh\"\n  INTEGER,DIMENSION(N):: a\n  INTEGER:: b, host_b\n  REAL(8):: false_margin\n  REAL(8),DIMENSION(LOOPCOUNT, 16):: randoms\n  INTEGER:: x, y\n  INTEGER:: errors\n\n  errors = 0\n  false_margin = exp(log(.5)/LOOPCOUNT)\n\n  SEEDDIM(1) = 1\n# ifdef SEED\n  SEEDDIM(1) = SEED\n# endif\n  CALL RANDOM_SEED(PUT=SEEDDIM)\n\n  CALL RANDOM_NUMBER(randoms)\n\n  DO x = 1, LOOPCOUNT\n    DO y = 1, 16\n      IF (randoms(x, y) .lt. false_margin) THEN\n        a(x) = a(x) + 2**(y - 1)\n      END IF\n    END DO\n  END DO\n\n  b = a(1)\n  host_b = a(1)\n  DO x = 2, LOOPCOUNT\n    host_b = iand(host_b, a(x))\n  END DO\n\n  !$acc data copyin(a(1:LOOPCOUNT))\n    !$acc serial loop reduction(iand: b)\n    DO x = 1, LOOPCOUNT\n      b = iand(b, a(x))\n    END DO\n  !$acc end data\n\n  IF (b .ne. host_b) THEN\n    errors = errors + 1\n  END IF\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "serial",
                            "reduction",
                            "combined-constructs",
                            "loop"
                        ],
                        "versions": [
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "serial_loop_reduction_bitand_general.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:serial,loop,reduction,combined-constructs,V:2.6-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    n = 10;\n    unsigned int * a = (unsigned int *)malloc(n * sizeof(unsigned int));\n    real_t false_margin = pow(exp(1), log(.5)/n);\n    unsigned int temp = 1;\n    unsigned int b = 0;\n    unsigned int host_b;\n\n    for (int x = 0; x < n; ++x){\n        for (int y = 0; y < 16; ++y){\n            if (rand() / (real_t) RAND_MAX < false_margin){\n                for (int z = 0; z < y; ++z){\n                    temp *= 2;\n                }\n                a[x] += temp;\n                temp = 1;\n            }\n        }\n    }\n    for (int x = 0; x < 16; ++x){\n        temp = 1;\n        for (int y = 0; y < x; ++y){\n            temp *= 2;\n        }\n        b += temp;\n    }\n    #pragma acc data copyin(a[0:n])\n    {\n        #pragma acc serial loop reduction(&:b)\n        for (int x = 0; x < n; ++x){\n            b = b & a[x];\n        }\n    }\n\n    host_b = a[0];\n    for (int x = 1; x < n; ++x){\n        host_b = host_b & a[x];\n    }\n    if (b != host_b){\n        err = 1;\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "serial",
                            "loop",
                            "reduction",
                            "combined-constructs"
                        ],
                        "versions": [
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "serial_loop_reduction_bitand_loop.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:serial,private,reduction,combined-constructs,loop,V:2.6-2.7\n      LOGICAL FUNCTION test1()\n  IMPLICIT NONE\n  INCLUDE \"acc_testsuite.Fh\"\n  INTEGER,DIMENSION(LOOPCOUNT, 10):: a, b, b_copy\n  INTEGER,DIMENSION(10):: c, host_c\n  INTEGER:: errors, x, y, z, temp\n  REAL(8):: false_margin\n  REAL(8),DIMENSION(LOOPCOUNT, 10, 17):: randoms\n\n  errors = 0\n  false_margin = exp(log(.5) / LOOPCOUNT)\n\n  SEEDDIM(1) = 1\n# ifdef SEED\n  SEEDDIM(1) = SEED\n# endif\n  CALL RANDOM_SEED(PUT=SEEDDIM)\n\n  CALL RANDOM_NUMBER(randoms)\n\n  DO y = 1, 10\n    DO x = 1, LOOPCOUNT\n      b(x) = INT(10 * randoms(x, y, 17))\n      DO z = 1, 16\n        IF (randoms(x, y, z) .lt. false_margin) THEN\n          a(x) = a(x) + 2**(z - 1)\n        END IF\n      END DO\n    END DO\n  END DO\n\n  b_copy = b\n\n  DO y = 1, 10\n    temp = a(1, y)\n    DO x = 1, LOOPCOUNT\n      temp = iand(temp, a(x, y))\n    END DO\n    host_c(y) = temp\n  END DO\n\n  !$acc data copyin(a(1:LOOPCOUNT, 1:10)) copy(b(1:LOOPCOUNT, 1:10), c(1:10))\n    !$acc serial loop gang private(temp)\n    DO y = 1, 10\n      temp = a(1, y)\n      !$acc loop worker reduction(iand:temp)\n      DO x = 1, LOOPCOUNT\n        temp = iand(temp, a(x, y))\n      END DO\n      c(y) = temp\n      !$acc loop worker\n      DO x = 1, LOOPCOUNT\n        b(x, y) = b(x, y) + c(y)\n      END DO\n    END DO\n  !$acc end data\n\n  DO y = 1, 10\n    IF (host_c(y) .ne. c(y)) THEN\n      errors = errors + 1\n    END IF\n    DO x = 1, LOOPCOUNT\n      IF (b(x, y) .ne. b_copy(x, y) + c(y)) THEN\n        errors = errors + 1\n      END IF\n    END DO\n  END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "serial",
                            "private",
                            "reduction",
                            "combined-constructs",
                            "loop"
                        ],
                        "versions": [
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "serial_loop_reduction_bitand_loop.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:serial,loop,reduction,combined-constructs,V:2.6-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    unsigned int * a = (unsigned int *)malloc(10 * n * sizeof(unsigned int));\n    unsigned int * b = (unsigned int *)malloc(10 * n * sizeof(unsigned int));\n    unsigned int * b_copy = (unsigned int *)malloc(10 * n * sizeof(unsigned int));\n    unsigned int * c = (unsigned int *)malloc(10 * sizeof(unsigned int));\n    unsigned int* host_c = (unsigned int *)malloc(10 * sizeof(unsigned int));\n\n    real_t false_margin = pow(exp(1), log(.5)/n);\n    unsigned int temp = 1;\n\n    for (int x = 0; x < 10 * n; ++x){\n        b[x] = (unsigned int) rand() / (real_t)(RAND_MAX / 1000);\n        b_copy[x] = b[x];\n        for (int y = 0; y < 16; ++y){\n            if (rand() / (real_t) RAND_MAX < false_margin){\n                for (int z = 0; z < y; ++z){\n                    temp *= 2;\n                }\n                a[x] += temp;\n                temp = 1;\n            }\n        }\n    }\n    #pragma acc data copyin(a[0:10 * n]) copy(b[0:10 * n], c[0:10])\n    {\n        #pragma acc serial loop gang private(temp)\n        for (int y = 0; y < 10; ++y){\n            temp = a[y * n];\n            #pragma acc loop worker reduction(&:temp)\n            for (int x = 1; x < n; ++x){\n                temp = temp & a[y * n + x];\n            }\n            c[y] = temp;\n            #pragma acc loop worker\n            for (int x = 0; x < n; ++x){\n                b[y * n + x] = b[y * n + x] + c[y];\n            }\n        }\n    }\n    for (int x = 0; x < 10; ++x){\n        host_c[x] = a[x * n];\n        for (int y = 1; y < n; ++y){\n            host_c[x] = host_c[x] & a[x * n + y];\n        }\n        if (host_c[x] != c[x]){\n          err += 1;\n        }\n    }\n\n    for (int x = 0; x < 10; ++x){\n        for (int y = 0; y < n; ++y){\n            if (b[x * n + y] != b_copy[x * n + y] + c[x]){\n                err += 1;\n            }\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "serial",
                            "loop",
                            "reduction",
                            "combined-constructs"
                        ],
                        "versions": [
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "serial_loop_reduction_bitand_vector_loop.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:serial,private,reduction,combined-constructs,loop,V:2.6-2.7\n      LOGICAL FUNCTION test1()\n  IMPLICIT NONE\n  INCLUDE \"acc_testsuite.Fh\"\n  INTEGER,DIMENSION(LOOPCOUNT, 10):: a\n  INTEGER,DIMENSION(10):: b, b_host\n  REAL(8),DIMENSION(LOOPCOUNT, 10, 16):: randoms\n  REAL(8):: false_margin\n  INTEGER:: x, y, temp, c\n  INTEGER:: errors\n\n  errors = 0\n  false_margin = exp(log(.5) / LOOPCOUNT)\n  SEEDDIM(1) = 1\n# ifdef SEED\n  SEEDDIM(1) = SEED\n# endif\n  CALL RANDOM_SEED(PUT=SEEDDIM)\n\n  CALL RANDOM_NUMBER(randoms)\n\n  DO y = 1, 10\n    DO x = 1, LOOPCOUNT\n      DO z = 1, 16\n        IF (randoms(x, y, z) .lt. false_margin) THEN\n          a(x, y) = a(x, y) + 2**(z - 1)\n        END IF\n      END DO\n    END DO\n  END DO\n\n  DO y = 1, 10\n    b_host(y) = a(1, y)\n    DO x = 1, LOOPCOUNT\n      b_host(y) = iand(b_host(y), a(x, y))\n    END DO\n  END DO\n\n  !$acc data copyin(a(1:LOOPCOUNT, 1:10)) copy(b(1:10))\n    !$acc serial loop private(c)\n    DO y = 1, 10\n      c = a(1, y)\n      !$acc loop vector reduction(iand:c)\n      DO x = 1, LOOPCOUNT\n        c = iand(c, a(x, y))\n      END DO\n      b(y) = c\n    END DO\n  !$acc end data\n\n  DO x = 1, 10\n    IF (b(x) .ne. b_host(x)) THEN\n      errors = errors + 1\n    END IF\n  END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "serial",
                            "private",
                            "reduction",
                            "combined-constructs",
                            "loop"
                        ],
                        "versions": [
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "serial_loop_reduction_bitand_vector_loop.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:serial,loop,reduction,combined-constructs,V:2.6-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    unsigned int* a = (unsigned int *)malloc(10 * n * sizeof(unsigned int));\n    unsigned int* b = (unsigned int *)malloc(10 * sizeof(unsigned int));\n    unsigned int b_host;\n    unsigned int c = 0;\n\n    real_t false_margin = pow(exp(1), log(.5)/n);\n    unsigned int temp = 1;\n\n    for (int x = 0; x < 10 * n; ++x){\n        for (int y = 0; y < 16; ++y){\n            if (rand() / (real_t) RAND_MAX < false_margin){\n                for (int z = 0; z < y; ++z){\n                    temp *= 2;\n                }\n                a[x] += temp;\n                temp = 1;\n            }\n        }\n    }\n\n    #pragma acc data copyin(a[0:10*n]) copy(b[0:10])\n    {\n        #pragma acc serial loop private(c)\n        for (int x = 0; x < 10; ++x){\n            c = a[x * n];\n            #pragma acc loop vector reduction(&:c)\n            for (int y = 1; y < n; ++y){\n                c = c & a[x * n + y];\n            }\n            b[x] = c;\n        }\n    }\n    for (int x = 0; x < 10; ++x){\n        b_host = a[x * n];\n        for (int y = 1; y < n; ++y){\n            b_host = b_host & a[x * n + y];\n        }\n        if (b_host != b[x]){\n            err = 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "serial",
                            "loop",
                            "reduction",
                            "combined-constructs"
                        ],
                        "versions": [
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "serial_loop_reduction_bitor_general.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:serial,reduction,combined-constructs,loop,V:2.6-2.7\n      LOGICAL FUNCTION test1()\n  IMPLICIT NONE\n  INCLUDE \"acc_testsuite.Fh\"\n  INTEGER:: errors, temp, x, y, b, host_b\n  INTEGER,DIMENSION(LOOPCOUNT):: a\n  REAL(8):: false_margin\n  REAL(8),DIMENSION(LOOPCOUNT, 16):: randoms\n  errors = 0\n  false_margin = exp(log(.5) / LOOPCOUNT)\n\n  SEEDDIM(1) = 1\n# ifdef SEED\n  SEEDDIM(1) = SEED\n# endif\n  CALL RANDOM_SEED(PUT=SEEDDIM)\n\n  CALL RANDOM_NUMBER(randoms)\n\n  DO x = 1, LOOPCOUNT\n    DO y = 1, 16\n      IF (randoms(x, y) .gt. false_margin) THEN\n        a(x) = a(x) + 2**(y - 1)\n      END IF\n    END DO\n  END DO\n\n  DO x = 1, LOOPCOUNT\n    host_b = ior(host_b, a(x))\n  END DO\n\n  !$acc data copyin(a(1:LOOPCOUNT))\n    !$acc serial loop reduction(ior:b)\n    DO x = 1, LOOPCOUNT\n      b = ior(b, a(x))\n    END DO\n  !$acc end data\n\n  IF (b .ne. host_b) THEN\n    errors = errors + 1\n  END IF\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "serial",
                            "reduction",
                            "combined-constructs",
                            "loop"
                        ],
                        "versions": [
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "serial_loop_reduction_bitor_general.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:serial,loop,reduction,combined-constructs,V:2.6-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    unsigned int * a = (unsigned int *)malloc(n * sizeof(unsigned int));\n    unsigned int b = 0;\n    unsigned int host_b;\n    real_t false_margin = pow(exp(1), log(.5)/n);\n    unsigned int temp = 1;\n\n    for (int x = 0; x < n; ++x){\n        for (int y = 0; y < 16; ++y){\n            if (rand() / (real_t) RAND_MAX > false_margin){\n                for (int z = 0; z < y; ++z){\n                    temp *= 2;\n                }\n                a[x] += temp;\n                temp = 1;\n            }\n        }\n    }\n\n    #pragma acc data copyin(a[0:n])\n    {\n        #pragma acc serial loop reduction(|:b)\n        for (int x = 0; x < n; ++x){\n            b = b | a[x];\n        }\n    }\n\n    host_b = a[0];\n    for (int x = 1; x < n; ++x){\n        host_b = host_b | a[x];\n    }\n    if (b != host_b){\n        err = 1;\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "serial",
                            "loop",
                            "reduction",
                            "combined-constructs"
                        ],
                        "versions": [
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "serial_loop_reduction_bitor_loop.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:serial,private,reduction,combined-constructs,loop,V:2.6-2.7\n      LOGICAL FUNCTION test1()\n  IMPLICIT NONE\n  INCLUDE \"acc_testsuite.Fh\"\n  INTEGER:: errors, x, y, z, temp\n  INTEGER,DIMENSION(LOOPCOUNT, 10):: a, b, b_copy\n  INTEGER,DIMENSION(10):: c\n  REAL(8):: false_margin\n  REAL(8),DIMENSION(LOOPCOUNT, 10, 17):: randoms\n\n  errors = 0\n  false_margin = exp(log(.5) / LOOPCOUNT)\n\n  SEEDDIM(1) = 1\n# ifdef SEED\n  SEEDDIM(1) = SEED\n# endif\n  CALL RANDOM_SEED(PUT=SEEDDIM)\n\n  CALL RANDOM_NUMBER(randoms)\n\n  DO x = 1, LOOPCOUNT\n    DO y = 1, 10\n      b(x, y) = INT(randoms(x, y, 17) * 1000)\n      DO z = 1, 16\n        IF (randoms(x, y, z) .gt. false_margin) THEN\n          a(x, y) = a(x, y) + 2**(z-1)\n        END IF\n      END DO\n    END DO\n  END DO\n\n  b_copy = b\n\n  !$acc data copyin(a(1:LOOPCOUNT, 1:10)) copy(b(1:LOOPCOUNT, 1:10), c(1:10))\n    !$acc serial loop gang private(temp)\n    DO y = 1, 10\n      temp = 0\n      !$acc loop worker reduction(ior:temp)\n      DO x = 1, LOOPCOUNT\n        temp = ior(temp, a(x, y))\n      END DO\n      c(y) = temp\n      !$acc loop worker\n      DO x = 1, LOOPCOUNT\n        b(x, y) = b(x, y) + c(y)\n      END DO\n    END DO\n  !$acc end data\n\n  DO y = 1, 10\n    temp = a(1, y)\n    DO x = 2, LOOPCOUNT\n      temp = ior(temp, a(x, y))\n    END DO\n    IF (temp .ne. c(y)) THEN\n      errors = errors + 1\n    END IF\n    DO x = 1, LOOPCOUNT\n      IF (b(x, y) .ne. (b_copy(x, y) + temp)) THEN\n        errors = errors + 1\n      END IF\n    END DO\n  END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "serial",
                            "private",
                            "reduction",
                            "combined-constructs",
                            "loop"
                        ],
                        "versions": [
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "serial_loop_reduction_bitor_loop.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:serial,loop,reduction,combined-constructs,V:2.6-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    unsigned int * a = (unsigned int *)malloc(10 * n * sizeof(unsigned int));\n    unsigned int * b = (unsigned int *)malloc(10 * n * sizeof(unsigned int));\n    unsigned int * b_copy = (unsigned int *)malloc(10 * n * sizeof(unsigned int));\n    unsigned int * c = (unsigned int *)malloc(10 * sizeof(unsigned int));\n    unsigned int host_c;\n\n    real_t false_margin = pow(exp(1), log(.5)/n);\n    unsigned int temp = 1;\n\n    for (int x = 0; x < 10; ++x){\n        for (int y = 0; y < n; ++y){\n            b[x * n + y] = (unsigned int) rand() / (real_t)(RAND_MAX / 1000);\n            b_copy[x * n + y] = b[x * n + y];\n            for (int z = 0; z < 16; ++z){\n                if (rand() / (real_t) RAND_MAX > false_margin){\n                    temp = 1;\n                    for (int i = 0; i < z; ++i){\n                        temp = temp * 2;\n                    }\n                    a[x * n + y] += temp;\n                }\n            }\n        }\n    }\n\n    #pragma acc data copyin(a[0:10*n]) copy(b[0:10*n], c[0:10])\n    {\n        #pragma acc serial loop gang private(temp)\n        for (int x = 0; x < 10; ++x){\n            temp = 0;\n            #pragma acc loop worker reduction(|:temp)\n            for (int y = 0; y < n; ++y){\n                temp = temp | a[x * n + y];\n            }\n            c[x] = temp;\n            #pragma acc loop worker\n            for (int y = 0; y < n; ++y){\n                b[x * n + y] = b[x * n + y] + c[x];\n            }\n        }\n    }\n    for (int x = 0; x < 10; ++x){\n        host_c = a[x * n];\n        for (int y = 1; y < n; ++y){\n            host_c = host_c | a[x * n + y];\n        }\n        if (host_c != c[x]){\n            err += 1;\n        }\n        for (int y = 0; y < n; ++y){\n            if (b[x * n + y] != b_copy[x * n + y] + host_c){\n                err += 1;\n            }\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "serial",
                            "loop",
                            "reduction",
                            "combined-constructs"
                        ],
                        "versions": [
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "serial_loop_reduction_bitor_vector_loop.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:serial,private,reduction,combined-constructs,loop,V:2.6-2.7\n      LOGICAL FUNCTION test1()\n  IMPLICIT NONE\n  INCLUDE \"acc_testsuite.Fh\"\n  INTEGER:: errors, x, y, z, temp\n  INTEGER,DIMENSION(LOOPCOUNT, 10):: a\n  INTEGER,DIMENSION(10):: b\n  REAL(8):: false_margin\n  REAL(8),DIMENSION(LOOPCOUNT, 10, 16):: randoms\n\n  errors = 0\n  false_margin = exp(log(.5) / LOOPCOUNT)\n  SEEDDIM(1) = 1\n# ifdef SEED\n  SEEDDIM(1) = SEED\n# endif\n  CALL RANDOM_SEED(PUT=SEEDDIM)\n\n  CALL RANDOM_NUMBERs(randoms)\n\n  DO x = 1, LOOPCOUNT\n    DO y = 1, 10\n      DO z = 1, 16\n        IF (randoms(x, y, z) .gt. false_margin) THEN\n          a(x, y) = a(x, y) + 2**(z - 1)\n        END IF\n      END DO\n    END DO\n  END DO\n\n  !$acc data copyin(a(1:LOOPCOUNT,1:10)) copy(b(1:10))\n    !$acc serial loop private(temp)\n    DO y = 1, 10\n      temp = 0\n      !$acc loop vector reduction(ior:temp)\n      DO x = 1, LOOPCOUNT\n        temp = ior(temp, a(x, y))\n      END DO\n      b(y) = temp\n    END DO\n  !$acc end data\n\n  DO y = 1, 10\n    temp = a(1, y)\n    DO x = 2, LOOPCOUNT\n      temp = ior(temp, a(x, y))\n    END DO\n    IF (temp .ne. b(y)) THEN\n      errors = errors + 1\n    END IF\n  END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "serial",
                            "private",
                            "reduction",
                            "combined-constructs",
                            "loop"
                        ],
                        "versions": [
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "serial_loop_reduction_bitor_vector_loop.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:serial,loop,reduction,combined-constructs,V:2.6-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    unsigned int* a = (unsigned int *)malloc(10 * n * sizeof(unsigned int));\n    unsigned int* b = (unsigned int *)malloc(10 * sizeof(unsigned int));\n    unsigned int b_host;\n\n    real_t false_margin = pow(exp(1), log(.5)/n);\n    unsigned int temp = 1;\n\n    for (int x = 0; x < 10 * n; ++x){\n        for (int y = 0; y < 16; ++y){\n            if (rand() / (real_t) RAND_MAX > false_margin){\n                for (int z = 0; z < y; ++z){\n                    temp *= 2;\n                }\n                a[x] += temp;\n                temp = 1;\n            }\n        }\n    }\n    temp = 0;\n    #pragma acc data copyin(a[0:10*n]) copy(b[0:10])\n    {\n        #pragma acc serial loop private(temp)\n        for (int x = 0; x < 10; ++x){\n            temp = 0;\n            #pragma acc loop vector reduction(|:temp)\n            for (int y = 0; y < n; ++y){\n                temp = temp | a[x * n + y];\n            }\n            b[x] = temp;\n        }\n    }\n\n    for (int x = 0; x < 10; ++x){\n        b_host = a[x * n];\n        for (int y = 1; y < n; ++y){\n            b_host = b_host | a[x * n + y];\n        }\n        if (b_host != b[x]){\n            err = 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "serial",
                            "loop",
                            "reduction",
                            "combined-constructs"
                        ],
                        "versions": [
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "serial_loop_reduction_bitxor_general.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:serial,reduction,combined-constructs,loop,V:2.6-2.7\n      LOGICAL FUNCTION test1()\n  IMPLICIT NONE\n  INCLUDE \"acc_testsuite.Fh\"\n  INTEGER,DIMENSION(LOOPCOUNT):: a\n  REAL(8),DIMENSION(LOOPCOUNT):: randoms\n  INTEGER:: errors, b, host_b, x\n\n  errors = 0\n  SEEDDIM(1) = 1\n# ifdef SEED\n  SEEDDIM(1) = SEED\n# endif\n  CALL RANDOM_SEED(PUT=SEEDDIM)\n\n  CALL RANDOM_NUMBER(randoms)\n\n  DO x = 1, LOOPCOUNT\n    a(x) = INT(randoms(x) * 100000)\n  END DO\n\n  b = 0\n  host_b = 0\n\n  DO x = 1, LOOPCOUNT\n    host_b = ieor(host_b, a(x))\n  END DO\n\n  !$acc data copyin(a(1:LOOPCOUNT))\n    !$acc serial loop reduction(ieor:b)\n    DO x = 1, LOOPCOUNT\n      b = ieor(b, a(x))\n    END DO\n  !$acc end data\n\n  IF (b .ne. host_b) THEN\n    errors = errors + 1\n  END IF\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "serial",
                            "reduction",
                            "combined-constructs",
                            "loop"
                        ],
                        "versions": [
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "serial_loop_reduction_bitxor_general.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:serial,loop,reduction,combined-constructs,V:2.6-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    unsigned int * a = (unsigned int *)malloc(n * sizeof(unsigned int));\n    unsigned int host_b;\n    unsigned int b = 0;\n\n    for (int x = 0; x < n; ++x){\n        a[x] = (unsigned int) rand() / (real_t) (RAND_MAX / 2);\n    }\n\n    #pragma acc data copyin(a[0:n])\n    {\n        #pragma acc serial loop reduction(^:b)\n        for (int x = 0; x < n; ++x){\n            b = b ^ a[x];\n        }\n    }\n\n    host_b = a[0];\n\n    for (int x = 1; x < n; ++x){\n        host_b = host_b ^ a[x];\n    }\n    if (b != host_b){\n        err = 1;\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "serial",
                            "loop",
                            "reduction",
                            "combined-constructs"
                        ],
                        "versions": [
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "serial_loop_reduction_bitxor_loop.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:serial,private,reduction,combined-constructs,loop,V:2.6-2.7\n      LOGICAL FUNCTION test1()\n  IMPLICIT NONE\n  INCLUDE \"acc_testsuite.Fh\"\n  INTEGER,DIMENSION(LOOPCOUNT, 10):: a, b, host_b\n  INTEGER,DIMENSION(10):: c, host_c\n  REAL(8),DIMENSION(LOOPCOUNT, 10, 2):: randoms\n  INTEGER:: errors, x, y, temp\n\n  errors = 0\n  SEEDDIM(1) = 1\n# ifdef SEED\n  SEEDDIM(1) = SEED\n# endif\n  CALL RANDOM_SEED(PUT=SEEDDIM)\n\n  CALL RANDOM_NUMBER(randoms)\n\n  c = 0\n  host_c = 0\n  DO x = 1, LOOPCOUNT\n    DO y = 1, 10\n      b(x, y) = INT(randoms(x, y, 1) * 1000)\n      a(x, y) = INT(randoms(x, y, 2) * 1000)\n    END DO\n  END DO\n  host_b = b\n\n  DO y = 1, 10\n    DO x = 1, LOOPCOUNT\n      host_c(y) = ieor(host_c(y), a(x, y))\n    END DO\n    DO x = 1, LOOPCOUNT\n      host_b(x, y) = host_b(x, y) + host_c(y)\n    END DO\n  END DO\n\n  !$acc data copyin(a(1:LOOPCOUNT, 1:10)) copy(b(1:LOOPCOUNT, 1:10), c(1:10))\n    !$acc serial loop gang private(temp)\n    DO y = 1, 10\n      temp = 0\n      !$acc loop worker reduction(ieor:temp)\n      DO x = 1, LOOPCOUNT\n        temp = ieor(temp, a(x, y))\n      END DO\n      c(y) = temp\n      DO x = 1, LOOPCOUNT\n        b(x, y) = b(x, y) + c(y)\n      END DO\n    END DO\n  !$acc end data\n\n  DO y = 1, 10\n    IF (c(y) .ne. host_c(y)) THEN\n      errors = errors + 1\n    END IF\n    DO x = 1, LOOPCOUNT\n      IF (host_b(x, y) .ne. b(x, y)) THEN\n        errors = errors + 1\n      END IF\n    END DO\n  END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "serial",
                            "private",
                            "reduction",
                            "combined-constructs",
                            "loop"
                        ],
                        "versions": [
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "serial_loop_reduction_bitxor_loop.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:serial,loop,reduction,combined-constructs,V:2.6-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    unsigned int * a = (unsigned int *)malloc(10 * n * sizeof(unsigned int));\n    unsigned int * b = (unsigned int *)malloc(10 * n * sizeof(unsigned int));\n    unsigned int * b_copy = (unsigned int *)malloc(10 * n * sizeof(unsigned int));\n    unsigned int * c = (unsigned int *)malloc(10 * sizeof(unsigned int));\n    unsigned int temp = 0;\n\n    for (int x = 0; x < 10*n; ++x){\n        b[x] = (unsigned int) rand() / (real_t)(RAND_MAX / 1000);\n        b_copy[x] = b[x];\n        a[x] = (unsigned int) rand() / (real_t)(RAND_MAX / 1000);\n    }\n    for (int x = 0; x < 10; ++x){\n        c[x] = 0;\n    }\n\n    #pragma acc data copyin(a[0:10*n]) copy(b[0:10*n], c[0:10])\n    {\n        #pragma acc serial loop gang private(temp)\n        for (int x = 0; x < 10; ++x){\n            temp = 0;\n            #pragma acc loop worker reduction(^:temp)\n            for (int y = 0; y < n; ++y){\n                temp = temp ^ a[x * n + y];\n            }\n            c[x] = temp;\n            #pragma acc loop worker\n            for (int y = 0; y < n; ++y){\n                b[x * n + y] = b[x * n + y] + c[x];\n            }\n        }\n    }\n\n    for (int x = 0; x < 10; ++x){\n        temp = 0;\n        for (int y = 0; y < n; ++y){\n            temp = temp ^ a[x * n + y];\n        }\n        if (temp != c[x]){\n            err += 1;\n        }\n        for (int y = 0; y < n; ++y){\n            if (b[x * n + y] != b_copy[x * n + y] + c[x]){\n                err += 1;\n            }\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "serial",
                            "loop",
                            "reduction",
                            "combined-constructs"
                        ],
                        "versions": [
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "serial_loop_reduction_bitxor_vector_loop.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:serial,private,reduction,combined-constructs,loop,V:2.6-2.7\n      LOGICAL FUNCTION test1()\n  IMPLICIT NONE\n  INCLUDE \"acc_testsuite.Fh\"\n  INTEGER,DIMENSION(LOOPCOUNT, 10):: a\n  INTEGER,DIMENSION(10):: b, host_b\n  REAL(8),DIMENSION(LOOPCOUNT, 10):: randoms\n  INTEGER:: errors, x, y, temp\n\n  errors = 0\n  SEEDDIM(1) = 1\n# ifdef SEED\n  SEEDDIM(1) = SEED\n# endif\n  CALL RANDOM_SEED(PUT=SEEDDIM)\n\n  CALL RANDOM_NUMBER(randoms)\n\n  DO y = 1, 10\n    DO x = 1, LOOPCOUNT\n      a(x, y) = INT(randoms(x, y) * 10000)\n    END DO\n  END DO\n\n  DO y = 1, 10\n    DO x = 1, LOOPCOUNT\n      host_b(y) = ieor(host_b(y), a(x, y))\n    END DO\n  END DO\n\n  !$acc data copyin(a(1:LOOPCOUNT, 1:10))\n    !$acc serial loop private(temp)\n    DO y = 1, 10\n      temp = 0\n      !$acc loop vector reduction(ieor:temp)\n      DO x = 1, LOOPCOUNT\n        temp = ieor(temp, a(x, y))\n      END DO\n      b(y) = temp\n    END DO\n  !$acc end data\n\n  DO y = 1, 10\n    IF (b(y) .ne. host_b(y)) THEN\n      errors = errors + 1\n    END IF\n  END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "serial",
                            "private",
                            "reduction",
                            "combined-constructs",
                            "loop"
                        ],
                        "versions": [
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "serial_loop_reduction_bitxor_vector_loop.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:serial,loop,reduction,combined-constructs,V:2.6-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    unsigned int* a = (unsigned int *)malloc(10 * n * sizeof(unsigned int));\n    unsigned int* b = (unsigned int *)malloc(10 * sizeof(unsigned int));\n    unsigned int temp = 0;\n    unsigned int b_host;\n\n    for (int x = 0; x < 10 * n; ++x){\n        a[x] = (unsigned int) rand() / (real_t) (RAND_MAX / 2);\n    }\n\n    #pragma acc data copyin(a[0:10*n]) copy(b[0:10])\n    {\n        #pragma acc serial loop private(temp)\n        for (int x = 0; x < 10; ++x){\n            temp = 0;\n            #pragma acc loop vector reduction(^:temp)\n            for (int y = 0; y < n; ++y){\n                temp = temp ^ a[x * n + y];\n            }\n            b[x] = temp;\n        }\n    }\n\n    for (int x = 0; x < 10; ++x){\n        b_host = a[x * n];\n        for (int y = 1; y < n; ++y){\n            b_host = b_host ^ a[x * n + y];\n        }\n        if (b_host != b[x]){\n            err = 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "serial",
                            "loop",
                            "reduction",
                            "combined-constructs"
                        ],
                        "versions": [
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "serial_loop_reduction_max_general.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:serial,reduction,combined-constructs,loop,V:2.6-2.7\n      LOGICAL FUNCTION test1()\n  IMPLICIT NONE\n  INCLUDE \"acc_testsuite.Fh\"\n  REAL(8),DIMENSION(LOOPCOUNT):: a, b\n  REAL(8):: maxval, host_max\n  INTEGER:: errors, x\n\n  SEEDDIM(1) = 1\n# ifdef SEED\n  SEEDDIM(1) = SEED\n# endif\n  CALL RANDOM_SEED(PUT=SEEDDIM)\n\n  CALL RANDOM_NUMBER(a)\n  CALL RANDOM_NUMBER(b)\n\n  errors = 0\n\n  DO x = 1, LOOPCOUNT\n    host_max = max(host_max, a(x) * b(x))\n  END DO\n\n  !$acc data copyin(a(1:LOOPCOUNT), b(1:LOOPCOUNT))\n    !$acc serial loop reduction(max:maxval)\n    DO x = 1, LOOPCOUNT\n      maxval = max(maxval, a(x) * b(x))\n    END DO\n  !$acc end data\n\n  IF (abs(host_max - max) .gt. PRECISION) THEN\n    errors = errors + 1\n  END IF\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "serial",
                            "reduction",
                            "combined-constructs",
                            "loop"
                        ],
                        "versions": [
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "serial_loop_reduction_max_general.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:serial,loop,reduction,combined-constructs,V:2.6-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n    real_t max = 0.0;\n    int found = 0;\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX/10);\n        b[x] = rand() / (real_t)(RAND_MAX/10);\n    }\n    #pragma acc data copyin(a[0:n], b[0:n]) copy(max)\n    {\n        #pragma acc serial loop reduction(max:max)\n        for (int x = 0; x < n; ++x){\n            max = fmax(a[x] * b[x], max);\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        if (fabs(max - (a[x] * b[x] + PRECISION)) < 0){\n            err = 1;\n        }\n        if (fabs(max - (a[x] * b[x] - PRECISION)) > 0){\n            found = 1;\n        }\n    }\n    if (found = 0){\n        err = 1;\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "serial",
                            "loop",
                            "reduction",
                            "combined-constructs"
                        ],
                        "versions": [
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "serial_loop_reduction_max_loop.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:serial,private,reduction,combined-constructs,loop,V:2.6-2.7\n      LOGICAL FUNCTION test1()\n  IMPLICIT NONE\n  INCLUDE \"acc_testsuite.Fh\"\n  REAL(8),DIMENSION(LOOPCOUNT, 10):: a, b, c\n  REAL(8),DIMENSIOn(10):: host_maximums, maximums\n  REAL(8):: temp\n  INTEGER:: errors, x, y\n\n  errors = 0\n  SEEDDIM(1) = 1\n# ifdef SEED\n  SEEDDIM(1) = SEED\n# endif\n  CALL RANDOM_SEED(PUT=SEEDDIM)\n\n  CALL RANDOM_NUMBER(a)\n  CALL RANDOM_NUMBER(b)\n  c = 0\n  maximums = 0\n  host_maximums = 0\n\n  DO y = 1, 10\n    DO x = 1, LOOPCOUNT\n      host_maximums(y) = max(host_maximums(y), a(x, y) * b(x, y))\n    ENDDO\n  END DO\n\n  !$acc data copyin(a(1:LOOPCOUNT, 1:10), b(1:LOOPCOUNT, 1:10)) copy(c(1:LOOPCOUNT, 1:10), maximums(1:10))\n    !$acc serial loop gang private(temp)\n    DO y = 1, 10\n      temp = 0\n      !$acc loop worker reduction(max:temp)\n      DO x = 1, LOOPCOUNT\n        temp = max(temp, a(x, y) * b(x, y))\n      END DO\n      maximums(y) = temp\n      !$acc loop worker\n      DO x = 1, LOOPCOUNT\n        c(x, y) = (a(x, y) * b(x, y)) / maximums(y)\n      END DO\n    END DO\n  !$acc end data\n\n  DO y = 1, 10\n    IF (maximums(y) .ne. host_maximums(y)) THEN\n      errors = errors + 1\n    END IF\n    DO x = 1, LOOPCOUNT\n      IF (abs(c(x, y) - ((a(x, y) * b(x, y)) / maximums(y))) .gt. PRECISION) THEN\n        errors = errors + 1\n      END IF\n    END DO\n  END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "serial",
                            "private",
                            "reduction",
                            "combined-constructs",
                            "loop"
                        ],
                        "versions": [
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "serial_loop_reduction_max_loop.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:serial,loop,reduction,combined-constructs,V:2.6-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(10 * n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(10 * n * sizeof(real_t));\n    real_t * c = (real_t *)malloc(10 * n * sizeof(real_t));\n    real_t * maximum = (real_t *)malloc(10 * sizeof(real_t));\n    real_t temp = 0;\n    real_t max = 0.0;\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX/10);\n        b[x] = rand() / (real_t)(RAND_MAX/10);\n        c[x] = 0.0;\n    }\n    for (int x = 0; x < 10; ++x){\n        maximum[x] = 0;\n    }\n\n    #pragma acc data copyin(a[0:10*n], b[0:10*n]) copy(c[0:10*n], maximum[0:10])\n    {\n        #pragma acc serial loop gang private(temp)\n        for (int x = 0; x < 10; ++x){\n            temp = 0;\n            #pragma acc loop worker reduction(max:temp)\n            for (int y = 0; y < n; ++y){\n                temp = fmax(a[x * n + y] * b[x * n + y], temp);\n            }\n            maximum[x] = temp;\n            #pragma acc loop worker\n            for (int y = 0; y < n; ++y){\n                c[x * n + y] = (a[x * n + y] * b[x * n + y]) / maximum[x];\n            }\n        }\n    }\n    for (int x = 0; x < 10; ++x){\n        temp = 0;\n        for (int y = 0; y < n; ++y){\n            temp = fmax(temp, a[x * n + y] * b[x * n + y]);\n        }\n        if (fabs(temp - maximum[x]) > PRECISION){\n            err += 1;\n        }\n        for (int y = 0; y < n; ++y){\n            if (c[x * n + y] > 1){\n                err += 1;\n            }\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "serial",
                            "loop",
                            "reduction",
                            "combined-constructs"
                        ],
                        "versions": [
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "serial_loop_reduction_max_vector_loop.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:serial,private,reduction,combined-constructs,loop,V:2.6-2.7\n      LOGICAL FUNCTION test1()\n  IMPLICIT NONE\n  INCLUDE \"acc_testsuite.Fh\"\n  REAL(8),DIMENSION(LOOPCOUNT, 10):: a, b\n  REAL(8),DIMENSION(10):: maximums, host_maximums\n  REAL(8):: temp\n  INTEGER:: errors, x, y\n\n  errors = 0\n\n  SEEDDIM(1) = 1\n# ifdef SEED\n  SEEDDIM(1) = SEED\n# endif\n  CALL RANDOM_SEED(PUT=SEEDDIM)\n\n  CALL RANDOM_NUMBER(a)\n  CALL RANDOM_NUMBER(b)\n\n  host_maximums = 0\n  DO y = 1, 10\n    DO x = 1, LOOPCOUNT\n      host_maximums(y) = max(host_maximums(y), a(x, y) * b(x, y))\n    END DO\n  END DO\n\n  !$acc data copyin(a(1:LOOPCOUNT, 1:10), b(1:LOOPCOUNT, 1:10)) copy(maximums(1:10))\n    !$acc serial loop private(temp)\n    DO y = 1, 10\n      temp = 0\n      !$acc loop vector reduction(max:temp)\n      DO x = 1, LOOPCOUNT\n        temp = max(temp, a(x, y) * b(x, y))\n      END DO\n      maximums(y) = temp\n    END DO\n  !$acc end data\n\n  DO x = 1, 10\n    IF (abs(host_maximums(x) - maximums(x)) .gt. PRECISION) THEN\n      errors = errors + 1\n    END IF\n  END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "serial",
                            "private",
                            "reduction",
                            "combined-constructs",
                            "loop"
                        ],
                        "versions": [
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "serial_loop_reduction_max_vector_loop.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:serial,loop,reduction,combined-constructs,V:2.6-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(10 * n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(10 * n * sizeof(real_t));\n    real_t * max = (real_t *)malloc(10 * sizeof(real_t));\n    real_t temp = 0;\n    real_t temp_max;\n\n    for (int x = 0; x < 10 * n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX/10);\n        b[x] = rand() / (real_t)(RAND_MAX/10);\n    }\n    #pragma acc data copyin(a[0:10*n], b[0:10*n]) copy(max[0:10])\n    {\n        #pragma acc serial loop private(temp)\n        for (int x = 0; x < 10; ++x){\n            temp = 0;\n            #pragma acc loop vector reduction(max:temp)\n            for (int y = 0; y < n; ++y){\n                temp = fmax(a[x * n + y] * b[x * n + y], temp);\n            }\n            max[x] = temp;\n        }\n    }\n    for (int x = 0; x < 10; ++x){\n        temp_max = 0;\n        for (int y = 0; y < n; ++y){\n            if (temp_max < a[x * n + y] * b[x * n + y]){\n                temp_max = a[x * n + y] * b[x * n + y];\n            }\n        }\n        if (fabs(temp_max - max[x]) > PRECISION){\n            err = 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "serial",
                            "loop",
                            "reduction",
                            "combined-constructs"
                        ],
                        "versions": [
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "serial_loop_reduction_min_general.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:serial,reduction,combined-constructs,loop,V:2.6-2.7\n      LOGICAL FUNCTION test1()\n  IMPLICIT NONE\n  INCLUDE \"acc_testsuite.Fh\"\n  INTEGER:: errors, x\n  REAL(8),DIMENSION(LOOPCOUNT):: a, b\n  REAL(8):: minimum, host_minimum\n\n  errors = 0\n\n  SEEDDIM(1) = 1\n# ifdef SEED\n  SEEDDIM(1) = SEED\n# endif\n  CALL RANDOM_SEED(PUT=SEEDDIM)\n\n  CALL RANDOM_NUMBER(a)\n  CALL RANDOM_NUMBER(b)\n\n  minimum = a(1) * b(1)\n  host_minimum = minimum\n\n  DO x = 2, LOOPCOUNT\n    host_minimum = min(host_minimum, a(x) * b(x))\n  END DO\n\n  !$acc data copyin(a(1:LOOPCOUNT), b(1:LOOPCOUNT))\n    !$acc serial loop reduction(min:minimum)\n    DO x = 1, LOOPCOUNT\n      minimum = min(minimum, a(x) * b(x))\n    END DO\n  !$acc end data\n\n  IF (abs(host_minimum - minimum) .gt. PRECISION) THEN\n    errors = errors + 1\n  END IF\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "serial",
                            "reduction",
                            "combined-constructs",
                            "loop"
                        ],
                        "versions": [
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "serial_loop_reduction_min_general.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:serial,loop,reduction,combined-constructs,V:2.6-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n    real_t min = 1000.0;\n    int found = 0;\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX/10);\n        b[x] = rand() / (real_t)(RAND_MAX/10);\n    }\n    #pragma acc data copyin(a[0:n], b[0:n]) copy(min)\n    {\n        #pragma acc serial loop reduction(min:min)\n        for (int x = 0; x < n; ++x){\n            min = fmin(a[x] * b[x], min);\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        if (fabs((a[x] * b[x]) - (min + PRECISION)) < 0){\n            err = 1;\n        }\n        if (fabs(min - (a[x] * b[x])) < PRECISION){\n            found = 1;\n        }\n    }\n    if (found == 0){\n        err = 1;\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "serial",
                            "loop",
                            "reduction",
                            "combined-constructs"
                        ],
                        "versions": [
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "serial_loop_reduction_min_loop.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:serial,private,reduction,combined-constructs,loop,V:2.6-2.7\n      LOGICAL FUNCTION test1()\n  IMPLICIT NONE\n  INCLUDE \"acc_testsuite.Fh\"\n  REAL(8),DIMENSION(LOOPCOUNT, 10):: a, b, c\n  REAL(8),DIMENSION(10):: minimums, host_minimums\n  REAL(8):: temp\n  INTEGER:: errors, x, y\n\n  errors = 0\n\n  SEEDDIM(1) = 1\n# ifdef SEED\n  SEEDDIM(1) = SEED\n# endif\n  CALL RANDOM_SEED(PUT=SEEDDIM)\n\n  CALL RANDOM_NUMBER(a)\n  CALL RANDOM_NUMBER(b)\n  c = 0\n  mimimums = 0\n  host_minimums = 0\n\n  DO y = 1, 10\n    DO x = 1, LOOPCOUNT\n      host_minimums(y) = min(host_minimums(y), a(x, y) * b(x, y))\n    END DO\n  END DO\n\n  !$acc data copyin(a(1:LOOPCOUNT, 1:10), b(1:LOOPCOUNT, 1:10)) copy(c(1:LOOPCOUNT, 1:10), minimums(1:10))\n    !$acc serial loop gang private(temp)\n    DO y = 1, 10\n      temp = 1\n      !$acc loop reduction(min: temp)\n      DO x = 1, LOOPCOUNT\n        temp = min(temp, a(x, y) * b(x, y))\n      END DO\n      minimums(y) = temp\n      !$acc loop\n      DO x = 1, LOOPCOUNT\n        c(x, y) = (a(x, y) * b(x, y)) / minimums(y)\n      END DO\n    END DO\n  !$acc end data\n\n  DO y = 1, 10\n    IF (abs(minimums(y) - host_minimums(y)) .gt. PRECISION) THEN\n      errors = errors + 1\n    END IF\n    DO x = 1, LOOPCOUNT\n      IF (abs(c(x, y) - ((a(x, y) * b(x, y)) / minimums(y))) .gt. PRECISION) THEN\n        errors = errors + 1\n      END IF\n    END DO\n  END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "serial",
                            "private",
                            "reduction",
                            "combined-constructs",
                            "loop"
                        ],
                        "versions": [
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "serial_loop_reduction_min_loop.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:serial,loop,reduction,combined-constructs,V:2.6-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(10 * n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(10 * n * sizeof(real_t));\n    real_t * c = (real_t *)malloc(10 * n * sizeof(real_t));\n    real_t * minimum = (real_t *)malloc(10 * sizeof(real_t));\n    real_t temp = 0;\n\n    for (int x = 0; x < 10 * n; ++x){\n        a[x] = 1 + rand() / (real_t)(RAND_MAX/10);\n        b[x] = 1 + rand() / (real_t)(RAND_MAX/10);\n        c[x] = 0.0;\n    }\n\n    #pragma acc data copyin(a[0:10*n], b[0:10*n]) copy(c[0:10*n], minimum[0:10])\n    {\n        #pragma acc serial loop gang private(temp)\n        for (int x = 0; x < 10; ++x){\n            temp = 1000;\n            #pragma acc loop reduction(min:temp)\n            for (int y = 0; y < n; ++y){\n                temp = fmin(a[x * n + y] * b[x * n + y], temp);\n            }\n            minimum[x] = temp;\n            #pragma acc loop\n            for (int y = 0; y < n; ++y){\n                c[x * n + y] = (a[x * n + y] * b[x * n + y]) / minimum[x];\n            }\n        }\n    }\n\n    for (int x = 0; x < 10; ++x){\n        temp = 1000;\n        for (int y = 0; y < n; ++y){\n            temp = fmin(temp, a[x * n + y] * b[x * n + y]);\n        }\n        if (fabs(temp - minimum[x]) > PRECISION){\n            err += 1;\n        }\n        for (int y = 0; y < n; ++y){\n            if (fabs(c[x * n + y] - (a[x * n + y] * b[x * n + y] / minimum[x])) > PRECISION){\n                err += 1;\n            }\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "serial",
                            "loop",
                            "reduction",
                            "combined-constructs"
                        ],
                        "versions": [
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "serial_loop_reduction_min_vector_loop.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:serial,private,reduction,combined-constructs,loop,V:2.6-2.7\n      LOGICAL FUNCTION test1()\n  IMPLICIT NONE\n  INCLUDE \"acc_testsuite.Fh\"\n  REAL(8),DIMENSION(LOOPCOUNT, 10):: a, b\n  REAL(8),DIMENSION(10):: minimums, host_minimums\n  REAL(8):: temp\n  INTEGER:: errors, x, y\n\n  errors = 0\n  minimums = 1\n  host_minimums = 1\n\n  SEEDDIM(1) = 1\n# ifdef SEED\n  SEEDDIM(1) = SEED\n# endif\n  CALL RANDOM_SEED(PUT=SEEDDIM)\n\n  CALL RANDOM_NUMBER(a)\n  CALL RANDOM_NUMBER(b)\n\n  DO y = 1, 10\n    DO x = 1, LOOPCOUNT\n      host_minimums(y) = min(host_minimums(y), a(x, y) * b(x, y))\n    END DO\n  END DO\n\n  !$acc data copyin(a(1:LOOPCOUNT, 1:10), b(1:LOOPCOUNT, 1:10)) copy(minimums(1:10))\n    !$acc serial loop gang private(temp)\n    DO y = 1, 10\n      temp = 1\n      !$acc loop vector reduction(min:temp)\n      DO x = 1, LOOPCOUNT\n        temp = min(temp, a(x, y) * b(x, y))\n      END DO\n      minimums(y) = temp\n    END DO\n  !$acc end data\n\n  DO x = 1, 10\n    IF (abs(host_minimums(x) - minimums(x)) .gt. PRECISION) THEN\n      errors = errors + 1\n    END IF\n  END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "serial",
                            "private",
                            "reduction",
                            "combined-constructs",
                            "loop"
                        ],
                        "versions": [
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "serial_loop_reduction_min_vector_loop.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:serial,loop,reduction,combined-constructs,V:2.6-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(10 * n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(10 * n * sizeof(real_t));\n    real_t * min = (real_t *)malloc(10 * sizeof(real_t));\n    real_t temp = 100;\n    real_t temp_min;\n\n    for (int x = 0; x < 10 * n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX/10);\n        b[x] = rand() / (real_t)(RAND_MAX/10);\n    }\n\n    #pragma acc data copyin(a[0:10*n], b[0:10*n]) copy(min[0:10])\n    {\n        #pragma acc serial loop gang private(temp)\n        for (int x = 0; x < 10; ++x){\n            temp = 100;\n            #pragma acc loop vector reduction(min:temp)\n            for (int y = 0; y < n; ++y){\n                temp = fmin(a[x * n + y] * b[x * n + y], temp);\n            }\n            min[x] = temp;\n        }\n    }\n    for (int x = 0; x < 10; ++x){\n        temp_min = 100;\n        for (int y = 0; y < n; ++y){\n            if (temp_min > a[x * n + y] * b[x * n + y]){\n                temp_min = a[x * n + y] * b[x * n + y];\n            }\n        }\n        if (fabs(temp_min - min[x]) > PRECISION){\n            err = 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "serial",
                            "loop",
                            "reduction",
                            "combined-constructs"
                        ],
                        "versions": [
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "serial_loop_reduction_multiply_general.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:serial,reduction,combined-constructs,loop,V:2.6-2.7\n      LOGICAL FUNCTION test1()\n  IMPLICIT NONE\n  INCLUDE \"acc_testsuite.Fh\"\n  REAL(8),DIMENSION(10):: a, b\n  REAL(8):: reduced, host_reduced\n  INTEGER:: errors, x, y\n\n  errors = 0\n  SEEDDIM(1) = 1\n# ifdef SEED\n  SEEDDIM(1) = SEED\n# endif\n  CALL RANDOM_SEED(PUT=SEEDDIM)\n\n  DO y = 1, LOOPCOUNT\n    CALL RANDOM_NUMBER(a)\n    CALL RANDOM_NUMBER(b)\n    reduced = 1\n    host_reduced = 1\n\n    DO x = 1, 10\n      host_reduced = host_reduced * (a(x) + b(x))\n    END DO\n\n    !$acc data copyin(a(1:10), b(1:10))\n      !$acc serial loop reduction(*:reduced)\n      DO x = 1, 10\n        reduced = reduced * (a(x) + b(x))\n      END DO\n    !$acc end data\n\n    IF (abs(host_reduced - reduced) .gt. PRECISION) THEN\n      errors = errors + 1\n    END IF\n  END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "serial",
                            "reduction",
                            "combined-constructs",
                            "loop"
                        ],
                        "versions": [
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "serial_loop_reduction_multiply_general.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:serial,loop,reduction,combined-constructs,V:2.6-2.7\nint test1(){\n    int err = 0;\n    int multiplicitive_n = 128;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(multiplicitive_n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(multiplicitive_n * sizeof(real_t));\n\n    real_t multiplied_total = 1.0;\n\n    for (int x = 0; x < multiplicitive_n; ++x){\n        a[x] = rand() / (real_t) RAND_MAX;\n        b[x] = rand() / (real_t) RAND_MAX;\n    }\n\n    #pragma acc data copyin(a[0:multiplicitive_n], b[0:multiplicitive_n]) copy(multiplied_total)\n    {\n        #pragma acc serial loop reduction (*:multiplied_total)\n        for (int x = 0; x < multiplicitive_n; ++x){\n            multiplied_total *= a[x] + b[x];\n        }\n    }\n\n    for (int x = 0; x < multiplicitive_n; ++x){\n        multiplied_total /= (a[x] + b[x]);\n    }\n    if (fabs(multiplied_total - 1) > PRECISION * (2 * multiplicitive_n - 1)){\n        err = 1;\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "serial",
                            "loop",
                            "reduction",
                            "combined-constructs"
                        ],
                        "versions": [
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "serial_loop_reduction_multiply_loop.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:serial,private,reduction,combined-constructs,loop,V:2.6-2.7\n      LOGICAL FUNCTION test1()\n  IMPLICIT NONE\n  INCLUDE \"acc_testsuite.Fh\"\n  REAL(8),DIMENSION(10, LOOPCOUNT):: a, b, c\n  REAL(8),DIMENSION(LOOPCOUNT):: totals, host_totals\n  REAL(8):: temp\n  INTEGER:: errors, x, y\n\n  errors = 0\n\n  SEEDDIM(1) = 1\n# ifdef SEED\n  SEEDDIM(1) = SEED\n# endif\n  CALL RANDOM_SEED(PUT=SEEDDIM)\n\n  CALL RANDOM_NUMBER(a)\n  CALL RANDOM_NUMBER(b)\n  c = 0\n\n\n  host_totals = 1\n  DO y = 1, LOOPCOUNT\n    DO x = 1, 10\n      host_totals(y) = host_totals(y) * (a(x, y) + b(x, y))\n    END DO\n  END DO\n\n  !$acc data copyin(a(1:10, 1:LOOPCOUNT), b(1:10, 1:LOOPCOUNT)) copyout(c(1:10, 1:LOOPCOUNT)) copy(totals(1:LOOPCOUNT))\n    !$acc serial loop gang private(temp)\n    DO y = 1, LOOPCOUNT\n      temp = 1\n      !$acc loop worker reduction(*:temp)\n      DO x = 1, 10\n        temp = temp * (a(x, y) + b(x, y))\n      END DO\n      totals(y) = temp\n      !$acc loop worker\n      DO x = 1, 10\n        c(x, y) = (a(x, y) + b(x, y)) / totals(y)\n      END DO\n    END DO\n  !$acc end data\n\n  DO y = 1, LOOPCOUNT\n    IF (abs(host_totals(y) - totals(y)) .gt. PRECISION) THEN\n      errors = errors + 1\n    END IF\n    DO x = 1, 10\n      IF (c(x, y) - ((a(x, y) + b(x, y)) / totals(y)) .gt. PRECISION) THEN\n        errors = errors + 1\n      END IF\n    END DO\n  END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "serial",
                            "private",
                            "reduction",
                            "combined-constructs",
                            "loop"
                        ],
                        "versions": [
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "serial_loop_reduction_multiply_loop.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:serial,loop,reduction,combined-constructs,V:2.6-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(10 * n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(10 * n * sizeof(real_t));\n    real_t * c = (real_t *)malloc(10 * n * sizeof(real_t));\n    real_t * totals = (real_t *)malloc(10 * sizeof(real_t));\n    real_t temp;\n\n    for (int x = 0; x < n; ++x){\n        a[x] = (999.4 + rand() / (real_t)(RAND_MAX)) / 1000;\n        b[x] = (999.4 + rand() / (real_t)(RAND_MAX)) / 1000;\n        c[x] = 0.0;\n    }\n\n\n    #pragma acc data copyin(a[0:10*n], b[0:10*n]) copyout(c[0:10*n]) copy(totals[0:10])\n    {\n        #pragma acc serial loop gang private(temp)\n        for (int x = 0; x < 10; ++x){\n            temp = 1;\n            #pragma acc loop worker reduction(*:temp)\n            for (int y = 0; y < n; ++y){\n                temp *= a[x * n + y] + b[x * n + y];\n            }\n            totals[x] = temp;\n            #pragma acc loop worker\n            for (int y = 0; y < n; ++y){\n                c[x * n + y] = (a[x * n + y] + b[x * n + y]) / totals[x];\n            }\n        }\n    }\n\n    for (int x = 0; x < 10; ++x){\n        temp = 1;\n        for (int y = 0; y < n; ++y){\n            temp *= a[x * n + y] + b[x * n + y];\n        }\n        if (fabs(temp - totals[x]) > (temp / 2 + totals[x] / 2) * PRECISION){\n            err += 1;\n        }\n        for (int y = 0; y < n; ++y){\n            if (fabs(c[x * n + y] - ((a[x * n + y] + b[x * n + y]) / totals[x])) > PRECISION){\n                err += 1;\n            }\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "serial",
                            "loop",
                            "reduction",
                            "combined-constructs"
                        ],
                        "versions": [
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "serial_loop_reduction_multiply_vector_loop.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:serial,private,reduction,combined-constructs,loop,V:2.6-2.7\n      LOGICAL FUNCTION test1()\n  IMPLICIT NONE\n  INCLUDE \"acc_testsuite.Fh\"\n  REAL(8),DIMENSION(10, LOOPCOUNT):: a, b\n  REAL(8),DIMENSION(LOOPCOUNT):: totals, host_totals\n  REAL(8):: temp\n  INTEGER:: errors\n\n  errors = 0\n\n  SEEDDIM(1) = 1\n# ifdef SEED\n  SEEDDIM(1) = SEED\n# endif\n  CALL RANDOM_SEED(PUT=SEEDDIM)\n\n  CALL RANDOM_NUMBER(a)\n  CALL RANDOM_NUMBER(b)\n\n  host_totals = 1\n  DO y = 1, LOOPCOUNT\n    DO x = 1, 10\n      host_totals(y) = host_totals(y) * (a(x, y) + b(x, y))\n    END DO\n  END DO\n\n  !$acc data copyin(a(1:10, 1:LOOPCOUNT), b(1:10, 1:LOOPCOUNT)) copyout(totals(1:LOOPCOUNT))\n    !$acc serial loop private(temp)\n    DO y = 1, LOOPCOUNT\n      temp = 1\n      !$acc loop vector reduction(*:temp)\n      DO x = 1, 10\n        temp = temp * (a(x, y) + b(x, y))\n      END DO\n      totals(y) = temp\n    END DO\n  !$acc end data\n\n  DO y = 1, LOOPCOUNT\n    IF (abs(host_totals(y) - totals(y)) .gt. PRECISION) THEN\n      errors = errors + 1\n    END IF\n  END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "serial",
                            "private",
                            "reduction",
                            "combined-constructs",
                            "loop"
                        ],
                        "versions": [
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "serial_loop_reduction_multiply_vector_loop.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:serial,loop,reduction,combined-constructs,V:2.6-2.7\nint test1(){\n    int err = 0;\n    int multiplicitive_n = 128;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(10 * multiplicitive_n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(10 * multiplicitive_n * sizeof(real_t));\n    real_t * c = (real_t *)malloc(10 * sizeof(real_t));\n    real_t temp;\n\n    for (int x = 0; x < 10 * multiplicitive_n; ++x){\n        a[x] = rand() / (real_t) RAND_MAX;\n        b[x] = rand() / (real_t) RAND_MAX;\n    }\n\n    #pragma acc data copyin(a[0:10*multiplicitive_n], b[0:10*multiplicitive_n]) copyout(c[0:10])\n    {\n        #pragma acc serial loop private(temp)\n        for (int x = 0; x < 10; ++x){\n            temp = 1.0;\n            #pragma acc loop vector reduction(*:temp)\n            for (int y = 0; y < multiplicitive_n; ++y){\n                temp *= a[(x * multiplicitive_n) + y] + b[(x * multiplicitive_n) + y];\n            }\n            c[x] = temp;\n        }\n    }\n\n    for (int x = 0; x < 10; ++x){\n        for (int y = 0; y < multiplicitive_n; ++y){\n            c[x] /= a[(x * multiplicitive_n) + y] + b[(x * multiplicitive_n) + y];\n        }\n    }\n\n    for (int x = 0; x < 10; ++x){\n        if (fabs(c[x] - 1) > PRECISION * (4 * multiplicitive_n - 1)){\n            err = 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "serial",
                            "loop",
                            "reduction",
                            "combined-constructs"
                        ],
                        "versions": [
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "serial_loop_reduction_or_general.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:serial,reduction,combined-constructs,loop,V:2.6-2.7\n      LOGICAL FUNCTION test1()\n  IMPLICIT NONE\n  INCLUDE \"acc_testsuite.Fh\"\n  LOGICAL,DIMENSION(LOOPCOUNT):: a\n  LOGICAL:: result, host_result\n  REAL(8),DIMENSION(LOOPCOUNT):: randoms\n  REAL(8):: false_margin\n  INTEGER:: errors, x\n\n  errors = 0\n  false_margin = exp(log(.5) / LOOPCOUNT)\n\n  SEEDDIM(1) = 1\n# ifdef SEED\n  SEEDDIM(1) = SEED\n# endif\n  CALL RANDOM_SEED(PUT=SEEDDIM)\n\n  CALL RANDOM_NUMBER(randoms)\n\n  DO x = 1, LOOPCOUNT\n    IF (randoms(x) .gt. false_margin) THEN\n      a(x) = .TRUE.\n    ELSE\n      a(x) = .FALSE.\n    END IF\n  END DO\n\n  host_result = .FALSE.\n  result = .FALSE.\n\n  DO x = 1, LOOPCOUNT\n    host_result = host_result .OR. a(x)\n  END DO\n\n  !$acc data copyin(a(1:LOOPCOUNT))\n    !$acc serial loop reduction(.OR.: result)\n    DO x = 1, LOOPCOUNT\n      result = result .OR. a(x)\n    END DO\n  !$acc end data\n\n  IF (host_result .neqv. result) THEN\n    errors = errors + 1\n  END IF\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "serial",
                            "reduction",
                            "combined-constructs",
                            "loop"
                        ],
                        "versions": [
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "serial_loop_reduction_or_general.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:serial,loop,reduction,combined-constructs,V:2.6-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    char * a = (char *)malloc(n * sizeof(char));\n    real_t false_margin = pow(exp(1), log(.5)/n);\n    char result = 0;\n    char found = 0;\n\n    for (int x = 0; x < n; ++x){\n        if(rand() / (real_t)(RAND_MAX) > false_margin){\n            a[x] = 1;\n        }\n        else{\n            a[x] = 0;\n        }\n    }\n\n\n    #pragma acc data copyin(a[0:n])\n    {\n        #pragma acc serial loop reduction(||:result)\n        for (int x = 0; x < n; ++x){\n            result = result || a[x];\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        if (a[x] == 1){\n            found = 1;\n        }\n    }\n    if (found != result){\n        err = 1;\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "serial",
                            "loop",
                            "reduction",
                            "combined-constructs"
                        ],
                        "versions": [
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "serial_loop_reduction_or_loop.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:serial,private,reduction,combined-constructs,loop,V:2.6-2.7\n      LOGICAL FUNCTION test1()\n  IMPLICIT NONE\n  INCLUDE \"acc_testsuite.Fh\"\n  LOGICAL,DIMENSION(LOOPCOUNT, 10):: a, a_copy\n  LOGICAL,DIMENSION(10):: results\n  LOGICAL:: temp\n  REAL(8):: false_margin\n  REAL(8),DIMENSION(LOOPCOUNT, 10):: randoms\n  INTEGER:: errors\n  INTEGER:: x, y\n\n  errors = 0\n  SEEDDIM(1) = 1\n# ifdef SEED\n  SEEDDIM(1) = SEED\n# endif\n  CALL RANDOM_SEED(PUT=SEEDDIM)\n\n  CALL RANDOM_NUMBER(randoms)\n\n  DO y = 1, 10\n    DO x = 1, LOOPCOUNT\n      IF (randoms(x, y) .gt. false_margin) THEN\n        a(x, y) = .TRUE.\n      ELSE\n        a(x, y) = .FALSE.\n      END IF\n    END DO\n  END DO\n\n  a_copy = a\n\n  !$acc data copy(a(1:LOOPCOUNT, 1:10))\n    !$acc serial loop gang private(temp)\n    DO y = 1, 10\n      temp = .FALSE.\n      !$acc loop worker reduction(.OR.:temp)\n      DO x = 1, LOOPCOUNT\n        temp = temp .OR. a(x, y)\n      END DO\n      results(y) = temp\n      !$acc loop worker\n      DO x = 1, LOOPCOUNT\n        IF (results(y)) THEN\n          IF (a(x, y)) THEN\n            a(x, y) = .FALSE.\n          ELSE\n            a(x, y) = .TRUE.\n          END IF\n        END IF\n      END DO\n    END DO\n  !$acc data\n\n  DO y = 1, 10\n    temp = .FALSE.\n    DO x = 1, LOOPCOUNT\n      temp = temp .OR. a(x, y)\n    END DO\n    IF (temp .neqv. results(y)) THEN\n      errors = errors + 1\n    END IF\n    DO x = 1, LOOPCOUNT\n      IF (temp) THEN\n        IF (a(x, y) .eqv. a_copy(x, y)) THEN\n          errors = errors + 1\n        END IF\n      ELSE\n        IF (a(x, y) .neqv. a_copy(x, y)) THEN\n          errors = errors + 1\n        END IF\n      END IF\n    END DO\n  END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "serial",
                            "private",
                            "reduction",
                            "combined-constructs",
                            "loop"
                        ],
                        "versions": [
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "serial_loop_reduction_or_loop.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:serial,loop,reduction,combined-constructs,V:2.6-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    char * a = (char *)malloc(10 * n * sizeof(char));\n    char * a_copy = (char *)malloc(10 * n * sizeof(char));\n    char * results = (char *)malloc(10 * sizeof(char));\n    char temp = 0;\n    real_t false_margin = pow(exp(1), log(.5)/n);\n\n    for (int x = 0; x < 10 * n; ++x){\n        if (rand() / (real_t)(RAND_MAX) > false_margin){\n            a[x] = 1;\n            a_copy[x] = 1;\n        }\n        else{\n            a[x] = 0;\n            a_copy[x] = 0;\n        }\n    }\n    #pragma acc data copy(a[0:10*n]) copyout(results[0:10])\n    {\n        #pragma acc serial loop gang private(temp)\n        for (int x = 0; x < 10; ++x){\n            temp = 0;\n            #pragma acc loop worker reduction(||:temp)\n            for (int y = 0; y < n; ++y){\n                temp = temp || a[x * n + y];\n            }\n            results[x] = temp;\n            #pragma acc loop worker\n            for (int y = 0; y < n; ++y){\n                if(results[x] == 1){\n                    if (a[x * n + y] == 1){\n                        a[x * n + y] = 0;\n                    }\n                    else{\n                        a[x * n + y] = 1;\n                    }\n                }\n            }\n        }\n    }\n    for (int x = 0; x < 10; ++x){\n        temp = 0;\n        for (int y = 0; y < n; ++y){\n            temp = temp || a_copy[x * n + y];\n        }\n        if (temp != results[x]) {\n            err += 1;\n        }\n        for (int y = 0; y < n; ++y){\n            if (temp == 1){\n                if (a[x * n + y] == a_copy[x * n + y]){\n                    err += 1;\n                }\n            }\n            else {\n                if (a[x * n + y] != a_copy[x * n + y]){\n                    err += 1;\n                }\n            }\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "serial",
                            "loop",
                            "reduction",
                            "combined-constructs"
                        ],
                        "versions": [
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "serial_loop_reduction_or_vector_loop.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:serial,private,reduction,combined-constructs,loop,V:2.6-2.7\n      LOGICAL FUNCTION test1()\n  IMPLICIT NONE\n  INCLUDE \"acc_testsuite.Fh\"\n  LOGICAL,DIMENSION(LOOPCOUNT, 10):: a\n  LOGICAL,DIMENSION(10):: b\n  LOGICAL:: temp\n  REAL(8):: false_margin\n  REAL(8),DIMENSION(LOOPCOUNT, 10):: randoms\n  INTEGER:: errors\n  INTEGER:: x, y\n\n  errors = 0\n  SEEDDIM(1) = 1\n# ifdef SEED\n  SEEDDIM(1) = SEED\n# endif\n  CALL RANDOM_SEED(PUT=SEEDDIM)\n\n  CALL RANDOM_NUMBER(randoms)\n\n  DO y = 1, 10\n    DO x = 1, LOOPCOUNT\n      IF (randoms(x, y) .gt. false_margin) THEN\n        a(x, y) = .TRUE.\n      ELSE\n        a(x, y) = .FALSE.\n      END IF\n    END DO\n  END DO\n\n  !$acc data copyin(a(1:LOOPCOUNT, 1:10)) copy(b(1:10))\n    !$acc serial loop private(temp)\n    DO y = 1, 10\n      temp = .FALSE.\n      !$acc loop vector reduction(.OR.:temp)\n      DO x = 1, LOOPCOUNT\n        temp = temp .OR. a(x, y)\n      END DO\n      b(y) = temp\n    END DO\n  !$acc end data\n\n  DO y = 1, 10\n    temp = .FALSE.\n    DO x = 1, LOOPCOUNT\n      temp = temp .OR. a(x, y)\n    END DO\n    IF (temp .neqv. b(y)) THEN\n      errors = errors + 1\n    END IF\n  END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "serial",
                            "private",
                            "reduction",
                            "combined-constructs",
                            "loop"
                        ],
                        "versions": [
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "serial_loop_reduction_or_vector_loop.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:serial,loop,reduction,combined-constructs,V:2.6-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    char * a = (char *)malloc(10 * n * sizeof(char));\n    char * b = (char *)malloc(10 * sizeof(char));\n    real_t false_margin = pow(exp(1), log(.5)/n);\n    char temp = 0;\n    char found;\n\n    for (int x = 0; x < 10 * n; ++x){\n        if(rand() / (real_t)(RAND_MAX) > false_margin){\n            a[x] = 1;\n        }\n        else{\n            a[x] = 0;\n        }\n    }\n    #pragma acc data copyin(a[0:10*n]) copy(b[0:10])\n    {\n        #pragma acc serial loop private(temp)\n        for (int x = 0; x < 10; ++x){\n            temp = 0;\n            #pragma acc loop vector reduction(||:temp)\n            for (int y = 0; y < n; ++y){\n                temp = temp || a[x * n + y];\n            }\n            b[x] = temp;\n        }\n    }\n    for (int x = 0; x < 10; ++x){\n        found = 0;\n        for (int y = 0; y < n; ++y){\n            if (a[x * n + y] &! 0){\n                found = 1;\n            }\n        }\n        if (found != b[x]){\n            err = 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "serial",
                            "loop",
                            "reduction",
                            "combined-constructs"
                        ],
                        "versions": [
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "serial_loop_seq.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:serial,combined-constructs,loop,V:2.6-2.7\n      LOGICAL FUNCTION test1()\n  IMPLICIT NONE\n  INCLUDE \"acc_testsuite.Fh\"\n  REAL(8),DIMENSION(LOOPCOUNT):: a, b\n  REAL(8):: temp\n  INTEGER:: errors, x\n\n  errors = 0\n  SEEDDIM(1) = 1\n# ifdef SEED\n  SEEDDIM(1) = SEED\n# endif\n  CALL RANDOM_SEED(PUT=SEEDDIM)\n\n  CALL RANDOM_NUMBER(a)\n  b = 0\n\n  !$acc data copyin(a(1:LOOPCOUNT)) copy(b(1:LOOPCOUNT))\n    !$acc serial loop seq\n    DO x = 2, LOOPCOUNT\n      b(x) = b(x - 1) + a(x)\n    END DO\n  !$acc end data\n\n  temp = 0\n  DO x = 2, LOOPCOUNT\n    temp = temp + a(x)\n    IF (abs(b(x) - temp) .gt. PRECISION) THEN\n      errors = errors + 1\n    END IF\n  END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "serial",
                            "combined-constructs",
                            "loop"
                        ],
                        "versions": [
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "serial_loop_seq.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:serial,loop,combined-constructs,V:2.6-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n    real_t temp = 0.0;\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = 0.0;\n    }\n\n    #pragma acc data copyin(a[0:n]) copy(b[0:n])\n    {\n        #pragma acc serial loop seq\n        for (int x = 1; x < n; ++x){\n            b[x] = b[x-1] + a[x];\n        }\n    }\n\n    for (int x = 1; x < n; ++x){\n        temp += a[x];\n        if (fabs(b[x] - temp) > PRECISION){\n            err = 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "serial",
                            "loop",
                            "combined-constructs"
                        ],
                        "versions": [
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "serial_loop_tile.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:serial,combined-constructs,loop,tile,V:2.6-2.7\n      LOGICAL FUNCTION test1()\n  IMPLICIT NONE\n  INCLUDE \"acc_testsuite.Fh\"\n  INTEGER:: errors\n  REAL(8),DIMENSION(100):: a, b, c\n  REAL(8),DIMENSION(100, 100):: d2\n  REAL(8),DIMENSION(100, 100, 100):: d3\n  INTEGER:: x, y, z\n  errors = 0\n\n  SEEDDIM(1) = 1\n# ifdef SEED\n  SEEDDIM(1) = SEED\n# endif\n  CALL RANDOM_SEED(PUT=SEEDDIM)\n\n  CALL RANDOM_NUMBER(a)\n  CALL RANDOM_NUMBER(b)\n  CALL RANDOM_NUMBER(c)\n  d2 = 0\n  d3 = 0\n\n  !$acc data copyin(a(1:100), b(1:100), c(1:100)) copyout(d2(1:100, 1:100))\n    !$acc serial loop tile(*, *)\n    DO x = 1, 100\n      DO y = 1, 100\n        DO z = 1, 100\n          d2(x, y) = d2(x, y) + (a(x) * b(y) * c(z))\n        END DO\n      END DO\n    END DO\n  !$acc end data\n\n  DO x = 1, 100\n    DO y = 1, 100\n      DO z = 1, 100\n        d2(x, y) = d2(x, y) - (a(x) * b(y) * c(z))\n      END DO\n      IF (abs(d2(x, y)) .gt. 10*PRECISION) THEN\n        errors = errors + 1\n      END IF\n    END DO\n  END DO\n\n  !$acc data copyin(a(1:100), b(1:100), c(1:100)) copyout(d3(1:100, 1:100, 1:100))\n    !$acc serial loop tile(*, *, *)\n    DO x = 1, 100\n      DO y = 1, 100\n        DO z = 1, 100\n          d3(x, y, z) = a(x) * b(y) * c(z)\n        END DO\n      END DO\n    END DO\n  !$acc end data\n\n  DO x = 1, 100\n    DO y = 1, 100\n      DO z = 1, 100\n        IF (abs(d3(x, y, z) - (a(x) * b(y) * c(z))) .gt. PRECISION) THEN\n          errors = errors + 1\n        END IF\n      END DO\n    END DO\n  END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "serial",
                            "combined-constructs",
                            "loop",
                            "tile"
                        ],
                        "versions": [
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "serial_loop_tile.c": {
                "num tests": 2,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:serial,loop,tile,combined-constructs,syntactic,V:2.6-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n    real_t * c = (real_t *)malloc(n * sizeof(real_t));\n    real_t * d2 = (real_t *)malloc(n * n * sizeof(real_t));\n    real_t * d3 = (real_t *)malloc(n * n * n * sizeof(real_t));\n    real_t temp = 0.0;\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n        c[x] = rand() / (real_t)(RAND_MAX / 10);\n    }\n    #pragma acc data copy(a[0:n], b[0:n], c[0:n], d2[0:n*n])\n    {\n        #pragma acc serial loop tile(*, *) reduction(+:temp)\n        for (int x = 0; x < n; ++x){\n            for (int y = 0; y < n; ++y){\n                temp = 0;\n                for (int z = 0; z < n; ++z){\n                    temp += a[x] + b[y] + c[z];\n                }\n                d2[x * n + y] = temp;\n            }\n        }\n    }\n    for (int x = 0; x < n; ++x){\n        for (int y = 0; y < n; ++y){\n            temp = 0.0;\n            for (int z = 0; z < n; ++z){\n                temp += a[x] + b[y] + c[z];\n            }\n            if (fabs(temp - d2[x * n + y]) > PRECISION * n){\n                err += 1;\n            }\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "serial",
                            "loop",
                            "tile",
                            "combined-constructs",
                            "syntactic"
                        ],
                        "versions": [
                            "2.6",
                            "2.7"
                        ]
                    },
                    "2": {
                        "content": "#ifndef T2\n//T2:serial,loop,combined-constructs,tile,V:2.6-2.7\nint test2(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n    real_t * c = (real_t *)malloc(n * sizeof(real_t));\n    real_t * d2 = (real_t *)malloc(n * n * sizeof(real_t));\n    real_t * d3 = (real_t *)malloc(n * n * n * sizeof(real_t));\n    real_t temp = 0.0;\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n        c[x] = rand() / (real_t)(RAND_MAX / 10);\n    }\n\n    #pragma acc data copyin(a[0:n], b[0:n], c[0:n]) copyout(d3[0:n*n*n])\n    {\n        #pragma acc serial loop tile(2, 4, 8)\n        for (int x = 0; x < n; ++x){\n            for (int y = 0; y < n; ++y){\n                for (int z = 0; z < n; ++z){\n                    d3[(n * n * x) + (n * y) + z] = a[x] + b[x] + c[x];\n                }\n            }\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        for (int y = 0; y < n; ++y){\n            for (int z = 0; z < n; ++z){\n                if (fabs(d3[(n * n * x) + (n * y) + z] - a[x] - b[x] - c[x]) > PRECISION * 2){\n                    err = 1;\n                }\n            }\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T2\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test2();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 1);\n    }\n#endif\n",
                        "tags": [
                            "serial",
                            "loop",
                            "combined-constructs",
                            "tile"
                        ],
                        "versions": [
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "serial_loop_vector.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:serial,combined-constructs,loop,V:2.6-2.7\n      LOGICAL FUNCTION test1()\n  IMPLICIT NONE\n  INCLUDE \"acc_testsuite.Fh\"\n  REAL(8),DIMENSION(LOOPCOUNT):: a, b, c\n  INTEGER:: x\n  INTEGER:: errors\n\n  errors = 0\n\n  SEEDDIM(1) = 1\n# ifdef SEED\n  SEEDDIM(1) = SEED\n# endif\n  CALL RANDOM_SEED(PUT=SEEDDIM)\n\n  CALL RANDOM_NUMBER(a)\n  CALL RANDOM_NUMBER(b)\n  c = 0\n\n  !$acc data copyin(a(1:LOOPCOUNT), b(1:LOOPCOUNT)) copy(c(1:LOOPCOUNT))\n    !$acc serial loop vector\n    DO x = 1, LOOPCOUNT\n      c(x) = a(x) + b(x)\n    END DO\n  !$acc end data\n\n  DO x = 1, LOOPCOUNT\n    IF (abs(c(x) - (a(x) + b(x))) .gt. PRECISION) THEN\n      errors = errors + 1\n    END IF\n  END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "serial",
                            "combined-constructs",
                            "loop"
                        ],
                        "versions": [
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "serial_loop_vector.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:serial,loop,combined-constructs,V:2.6-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n    real_t * c = (real_t *)malloc(n * sizeof(real_t));\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n        c[x] = 0.0;\n    }\n\n    #pragma acc data copyin(a[0:n], b[0:n]) copy(c[0:n])\n    {\n        #pragma acc serial loop vector\n        for (int x = 0; x < n; ++x){\n            c[x] = a[x] + b[x];\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        if(fabs(c[x] - (a[x] + b[x])) > PRECISION){\n            err = 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "serial",
                            "loop",
                            "combined-constructs"
                        ],
                        "versions": [
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "serial_loop_vector_blocking.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:loop,V:2.6-2.7\n      LOGICAL FUNCTION test1()\n  IMPLICIT NONE\n  INCLUDE \"acc_testsuite.Fh\"\n  INTEGER:: errors\n  REAL(8),DIMENSION(LOOPCOUNT):: a, b, c\n  INTEGER:: multiplier, x\n  errors = 0\n\n  SEEDDIM(1) = 1\n# ifdef SEED\n  SEEDDIM(1) = SEED\n# endif\n  CALL RANDOM_SEED(PUT=SEEDDIM)\n\n  CALL RANDOM_NUMBER(a)\n  CALL RANDOM_NUMBER(b)\n  c = 0\n\n  !$acc data copyin(a(1:LOOPCOUNT), b(1:LOOPCOUNT)) copyout(c(1:LOOPCOUNT))\n    !$acc serial\n      !$acc loop vector\n      DO x = 1, LOOPCOUNT\n        c(x) = (a(x) + b(x)) * multiplier\n      END DO\n      multiplier = multiplier + 1\n      !$acc loop vector\n      DO x = 1, LOOPCOUNT\n        c(x) = c(x) + ((a(x) + b(x)) * multiplier)\n      END DO\n    !$acc end serial\n  !$acc end data\n\n  DO x = 1, LOOPCOUNT\n    IF (abs(c(x) - ((a(x) + b(x)) * 3)) .gt. PRECISION) THEN\n      errors = errors + 1\n    END IF\n  END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "loop"
                        ],
                        "versions": [
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "serial_loop_vector_blocking.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:serial,loop,V:2.6-2.7\nint test1(){\n  int err = 0;\n  srand(SEED);\n  real_t * a = (real_t *)malloc(n * sizeof(real_t));\n  real_t * b = (real_t *)malloc(n * sizeof(real_t));\n  real_t * c = (real_t *)malloc(n * sizeof(real_t));\n  real_t multiplyer = 1;\n\n  for (int x = 0; x < n; ++x){\n      a[x] = rand() / (real_t)(RAND_MAX / 10);\n      b[x] = rand() / (real_t)(RAND_MAX / 10);\n      c[x] = 0.0;\n  }\n\n  #pragma acc data copyin(a[0:n], b[0:n]) copyout(c[0:n])\n  {\n    #pragma acc serial\n    {\n      #pragma acc loop vector\n      for (int x = 0; x < n; ++x){\n        c[x] = (a[x] + b[x]) * multiplyer;\n      }\n      multiplyer += 1;\n      #pragma acc loop vector\n      for (int x = 0; x < n; ++x){\n        c[x] += (a[x] + b[x]) * multiplyer;\n      }\n    }\n  }\n\n  for (int x = 0; x < n; ++x){\n    if (fabs(c[x] - 3 * (a[x] + b[x])) > PRECISION){\n      err + 1;\n      break;\n    }\n  }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "serial",
                            "loop"
                        ],
                        "versions": [
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "serial_loop_worker.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:serial,combined-constructs,loop,V:2.6-2.7\n      LOGICAL FUNCTION test1()\n  IMPLICIT NONE\n  INCLUDE \"acc_testsuite.Fh\"\n  REAL(8),DIMENSION(LOOPCOUNT):: a, b, c\n  INTEGER:: x\n  INTEGER:: errors\n\n  errors = 0\n\n  SEEDDIM(1) = 1\n# ifdef SEED\n  SEEDDIM(1) = SEED\n# endif\n  CALL RANDOM_SEED(PUT=SEEDDIM)\n\n  CALL RANDOM_NUMBER(a)\n  CALL RANDOM_NUMBER(b)\n  c = 0\n\n  !$acc data copyin(a(1:LOOPCOUNT), b(1:LOOPCOUNT)) copy(c(1:LOOPCOUNT))\n    !$acc serial loop worker\n    DO x = 1, LOOPCOUNT\n      c(x) = a(x) + b(x)\n    END DO\n  !$acc end data\n\n  DO x = 1, LOOPCOUNT\n    IF (abs(c(x) - (a(x) + b(x))) .gt. PRECISION) THEN\n      errors = errors + 1\n    END IF\n  END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "serial",
                            "combined-constructs",
                            "loop"
                        ],
                        "versions": [
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "serial_loop_worker.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:serial,loop,combined-constructs,V:2.6-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n    real_t * c = (real_t *)malloc(n * sizeof(real_t));\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n        c[x] = 0.0;\n    }\n\n    #pragma acc data copyin(a[0:n], b[0:n]) copy(c[0:n])\n    {\n        #pragma acc serial loop worker\n        for (int x = 0; x < n; ++x){\n            c[x] = a[x] + b[x];\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        if (fabs(c[x] - (a[x] + b[x])) > PRECISION){\n            err = 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "serial",
                            "loop",
                            "combined-constructs"
                        ],
                        "versions": [
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "serial_loop_worker_blocking.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:loop,V:2.6-2.7\n      LOGICAL FUNCTION test1()\n  IMPLICIT NONE\n  INCLUDE \"acc_testsuite.Fh\"\n  REAL(8),DIMENSION(LOOPCOUNT):: a, b, c\n  INTEGER:: multiplier\n  INTEGER:: x\n  INTEGER:: errors\n\n  errors = 0\n\n  SEEDDIM(1) = 1\n# ifdef SEED\n  SEEDDIM(1) = SEED\n# endif\n  CALL RANDOM_SEED(PUT=SEEDDIM)\n\n  CALL RANDOM_NUMBER(a)\n  CALL RANDOM_NUMBER(b)\n  c = 0\n\n  !$acc data copyin(a(1:LOOPCOUNT), b(1:LOOPCOUNT)) copyout(c(1:LOOPCOUNT))\n    !$acc serial\n      !$acc loop worker\n      DO x = 1, LOOPCOUNT\n        c(x) = (a(x) + b(x)) * multiplier\n      END DO\n      multiplier = multiplier + 1\n      !$acc loop worker\n      DO x = 1, LOOPCOUNT\n        c(x) = c(x) + ((a(x) + b(x)) * multiplier)\n      END DO\n    !$acc end serial\n  !$acc end data\n\n  DO x = 1, LOOPCOUNT\n    IF (abs(c(x) - (3 * (a(x) + b(x)))) .gt. PRECISION) THEN\n      errors = errors + 1\n    END IF\n  END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "loop"
                        ],
                        "versions": [
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "serial_loop_worker_blocking.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:serial,loop,V:2.6-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n    real_t * c = (real_t *)malloc(n * sizeof(real_t));\n    real_t multiplyer = 1;\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n        c[x] = 0.0;\n    }\n\n    #pragma acc data copyin(a[0:n], b[0:n]) copyout(c[0:n])\n    {\n      #pragma acc serial\n      {\n        #pragma acc loop worker\n        for (int x = 0; x < n; ++x){\n          c[x] = (a[x] + b[x]) * multiplyer;\n        }\n        multiplyer += 1;\n        #pragma acc loop worker\n        for (int x = 0; x < n; ++x){\n          c[x] += (a[x] + b[x]) * multiplyer;\n        }\n      }\n    }\n\n    for (int x = 0; x < n; ++x){\n      if (fabs(c[x] - 3 * (a[x] + b[x])) > PRECISION){\n        err + 1;\n        break;\n      }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "serial",
                            "loop"
                        ],
                        "versions": [
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "serial_present.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:serial,V:2.6-2.7\n      LOGICAL FUNCTION test1()\n  IMPLICIT NONE\n  INCLUDE \"acc_testsuite.Fh\"\n  REAL(8),DIMENSION(LOOPCOUNT):: a, b, c\n  INTEGER:: x\n  INTEGER:: errors\n\n  errors = 0\n\n  SEEDDIM(1) = 1\n# ifdef SEED\n  SEEDDIM(1) = SEED\n# endif\n  CALL RANDOM_SEED(PUT=SEEDDIM)\n\n  CALL RANDOM_NUMBER(a)\n  CALL RANDOM_NUMBER(b)\n  c = 0\n\n  !$acc enter data copyin(a(1:LOOPCOUNT), b(1:LOOPCOUNT)) create(c(1:LOOPCOUNT))\n  !$acc serial present(a(1:LOOPCOUNT), b(1:LOOPCOUNT), c(1:LOOPCOUNT))\n    !$acc loop\n    DO x = 1, LOOPCOUNT\n      c(x) = a(x) + b(x)\n    END DO\n  !$acc end serial\n  !$acc exit data delete(a(1:LOOPCOUNT), b(1:LOOPCOUNT)) copyout(c(1:LOOPCOUNT))\n\n  DO x = 1, LOOPCOUNT\n    IF (abs(c(x) - (a(x) + b(x))) .gt. PRECISION) THEN\n      errors = errors + 1\n    END IF\n  END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "serial"
                        ],
                        "versions": [
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "serial_present.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:serial,present,V:2.6-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n    real_t * c = (real_t *)malloc(n * sizeof(real_t));\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n        c[x] = 0.0;\n    }\n\n    #pragma acc enter data copyin(a[0:n], b[0:n])\n    #pragma acc serial present(a[0:n], b[0:n]) copy(c[0:n])\n    {\n        #pragma acc loop\n        for (int x = 0; x < n; ++x){\n            c[x] = a[x] + b[x];\n        }\n    }\n    #pragma acc exit data delete(a[0:n], b[0:n])\n\n    for (int x = 0; x < n; ++x){\n        if (fabs(c[x] - (a[x] + b[x])) > PRECISION){\n            err += 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "serial",
                            "present"
                        ],
                        "versions": [
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "serial_private.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:serial,private,V:2.6-2.7\n      LOGICAL FUNCTION test1()\n  IMPLICIT NONE\n  INCLUDE \"acc_testsuite.Fh\"\n  REAL(8),DIMENSION(LOOPCOUNT, 10):: a, b\n  REAL(8),DIMENSION(LOOPCOUNT):: c\n  REAL(8),DIMENSION(10):: d\n  REAL(8):: temp\n  INTEGER:: x, y\n  INTEGER:: errors\n\n  errors = 0\n\n  SEEDDIM(1) = 1\n# ifdef SEED\n  SEEDDIM(1) = SEED\n# endif\n  CALL RANDOM_SEED(PUT=SEEDDIM)\n\n  CALL RANDOM_NUMBER(a)\n  CALL RANDOM_NUMBER(b)\n  c = 0\n  d = 0\n\n  !$acc data copyin(a(1:LOOPCOUNT, 1:10), b(1:LOOPCOUNT, 1:10)) copy(d(1:10))\n    !$acc serial private(c(1:LOOPCOUNT))\n      !$acc loop gang\n      DO y = 1, 10\n        !$acc loop worker\n        DO x = 1, LOOPCOUNT\n          c(x) = a(x, y) + b(x, y)\n        END DO\n        !$acc loop seq\n        DO x = 1, LOOPCOUNT\n          d(y) = d(y) + c(x)\n        END DO\n      END DO\n    !$acc end serial\n  !$acc end data\n\n  DO y = 1, 10\n    temp = 0\n    DO x = 1, LOOPCOUNT\n      temp = temp + (a(x, y) + b(x, y))\n    END DO\n    IF (abs(d(x) - temp) .gt. (2 * PRECISION * LOOPCOUNT)) THEN\n      errors = errors + 1\n    END IF\n  END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "serial",
                            "private"
                        ],
                        "versions": [
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "serial_private.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:serial,private,V:2.6-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    n = 10;\n    real_t * a = (real_t *)malloc(10 * n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(10 * n * sizeof(real_t));\n    real_t * c = (real_t *)malloc(n * sizeof(real_t));\n    real_t * d = (real_t *)malloc(10 * sizeof(real_t));\n    real_t temp;\n\n    for (int x = 0; x < 10; ++x){\n        for (int y = 0; y < n; ++y){\n            a[x * n + y] = rand() / (real_t)(RAND_MAX / 10);\n            b[x * n + y] = rand() / (real_t)(RAND_MAX / 10);\n            c[y] = 0.0;\n        }\n        d[x] = 0.0;\n    }\n\n    #pragma acc enter data copyin(a[0:10*n], b[0:10*n], d[0:10])\n    #pragma acc serial private(c[0:n])\n    {\n        #pragma acc loop gang\n        for (int x = 0; x < 10; ++x){\n            #pragma acc loop worker\n            for (int y = 0; y < n; ++y){\n                c[y] = a[x * n + y] + b[x * n + y];\n            }\n            #pragma acc loop seq\n            for (int y = 0; y < n; ++y){\n                d[x] += c[y];\n            }\n        }\n    }\n    #pragma acc exit data copyout(d[0:10]) delete(a[0:10*n], b[0:10*n])\n\n    for (int x = 0; x < 10; ++x){\n        temp = 0.0;\n        for (int y = 0; y < n; ++y){\n            temp += a[x * n + y] + b[x * n + y];\n        }\n        if (fabs(temp - d[x]) > (2 * PRECISION * n)){\n            err = 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "serial",
                            "private"
                        ],
                        "versions": [
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "serial_reduction.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:serial,reduction,V:2.6-2.7\n      LOGICAL FUNCTION test1()\n  IMPLICIT NONE\n  INCLUDE \"acc_testsuite.Fh\"\n  REAL(8),DIMENSION(LOOPCOUNT):: a\n  REAL(8):: reduction\n  INTEGER:: errors, x\n\n  errors = 0\n\n  SEEDDIM(1) = 1\n# ifdef SEED\n  SEEDDIM(1) = SEED\n# endif\n  CALL RANDOM_SEED(PUT=SEEDDIM)\n\n  CALL RANDOM_NUMBER(a)\n\n  !$acc serial copyin(a(1:LOOPCOUNT)) reduction(+:reduction)\n    !$acc loop\n    DO x = 1, LOOPCOUNT\n      reduction = reduction + a(x)\n    END DO\n  !$acc end serial\n\n  DO x = 1, LOOPCOUNT\n    reduction = reduction - a(x)\n  END DO\n\n  IF (abs(reduction) .gt. PRECISION) THEN\n    errors = errors + 1\n  END IF\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "serial",
                            "reduction"
                        ],
                        "versions": [
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "serial_reduction.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:serial,reduction,V:2.6-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(n * sizeof(real_t));\n    real_t reduction;\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n    }\n\n    #pragma acc serial copyin(a[0:n]) reduction(+:reduction)\n    {\n        #pragma acc loop\n        for (int x = 0; x < n; ++x){\n            reduction = reduction + a[x];\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        reduction = reduction - a[x];\n    }\n    if (fabs(reduction) > PRECISION){\n        err += 1;\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "serial",
                            "reduction"
                        ],
                        "versions": [
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "serial_scalar_default_firstprivate.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:,V:2.6-2.7\n      LOGICAL FUNCTION test1()\n  IMPLICIT NONE\n  INCLUDE \"acc_testsuite.Fh\"\n  REAL(8),DIMENSION(LOOPCOUNT):: a, b\n  REAL(8):: scalar, scalar_copy\n  INTEGER:: x\n  INTEGER:: errors\n\n  errors = 0\n\n  SEEDDIM(1) = 1\n# ifdef SEED\n  SEEDDIM(1) = SEED\n# endif\n  CALL RANDOM_SEED(PUT=SEEDDIM)\n\n  CALL RANDOM_NUMBER(a)\n  b = 0\n  scalar = 5.5\n  scalar_copy = scalar\n\n  !$acc data copyin(a(1:LOOPCOUNT)) copyout(b(1:LOOPCOUNT))\n    !$acc serial\n      !$acc loop\n      DO x = 1, LOOPCOUNT\n        b(x) = a(x) + scalar\n      END DO\n    !$acc end serial\n  !$acc end data\n\n  DO x = 1, LOOPCOUNT\n    IF (abs(b(x) - (a(x) + scalar_copy)) .gt. PRECISION) THEN\n      errors = errors + 1\n    END IF\n  END DO\n\n  IF (abs(scalar_copy - scalar) .gt. PRECISION) THEN\n    errors = errors + 1\n  END IF\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            ""
                        ],
                        "versions": [
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "serial_scalar_default_firstprivate.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:data,default-mapping,serial,firstprivate,V:2.6-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(n * sizeof(real_t));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n    real_t scalar = rand() / (real_t)(RAND_MAX / 10);\n    real_t scalar_copy = scalar;\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = 0.0;\n    }\n\n    #pragma acc data copyin(a[0:n]) copyout(b[0:n])\n    {\n        #pragma acc serial\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                b[x] = a[x] + scalar;\n            }\n        }\n    }\n\n    for (int x = 0; x < n; ++x){\n        if (fabs(b[x] - (a[x] + scalar_copy)) > PRECISION){\n            err += 1;\n        }\n    }\n    if (fabs(scalar_copy - scalar) > PRECISION){\n        err += 1;\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "data",
                            "default-mapping",
                            "serial",
                            "firstprivate"
                        ],
                        "versions": [
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "serial_switch.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:,V:2.6-2.7\n      LOGICAL FUNCTION test1()\n  IMPLICIT NONE\n  INCLUDE \"acc_testsuite.Fh\"\n  INTEGER,DIMENSION(LOOPCOUNT):: a\n  REAL(8),DIMENSION(LOOPCOUNT):: a_randoms, b, b_host, c\n  INTEGER:: errors, x\n\n  errors = 0\n\n  SEEDDIM(1) = 1\n# ifdef SEED\n  SEEDDIM(1) = SEED\n# endif\n  CALL RANDOM_SEED(PUT=SEEDDIM)\n\n  CALL RANDOM_NUMBER(a_randoms)\n  CALL RANDOM_NUMBER(b)\n  c = 0\n  b_host = b\n\n  DO x = 1, LOOPCOUNT\n    a(x) = INT(a_randoms(x) * 4)\n  END DO\n\n  !$acc data copyin(a(1:LOOPCOUNT)) copy(b(1:LOOPCOUNT), c(1:LOOPCOUNT))\n    !$acc serial\n      !$acc loop\n      DO x = 1, LOOPCOUNT\n        SELECT CASE(a(x))\n        CASE (0)\n          c(x) = b(x) * b(x)\n        CASE (1)\n          c(x) = b(x) / b(x)\n        CASE (2)\n          b(x) = b(x) / 2\n        CASE DEFAULT\n          c(x) = a(x) + b(x)\n        END SELECT\n      END DO\n    !$acc end serial\n  !$acc end data\n\n  DO x = 1, LOOPCOUNT\n    SELECT CASE(a(x))\n    CASE(0)\n      IF (abs(c(x) - (b_host(x) * b_host(x))) .gt. PRECISION) THEN\n        errors = errors + 1\n      END IF\n    CASE(1)\n      IF (abs(c(x) - 1) .gt. PRECISION) THEN\n        errors = errors + 1\n      END IF\n    CASE(2)\n      IF (abs(c(x)) .gt. PRECISION) THEN\n        errors = errors + 1\n      END IF\n      IF (abs(b(x) - (b_host(x) / 2)) .gt. PRECISION) THEN\n        errors = errors + 1\n      END IF\n    CASE DEFAULT\n      IF (abs(c(x) - (b_host(x) + a(x))) .gt. PRECISION) THEN\n        errors = errors + 1\n      END IF\n    END SELECT\n  END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            ""
                        ],
                        "versions": [
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "serial_switch.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:serial,V:2.6-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    int * a = (int *)malloc(n * sizeof(int));\n    real_t * b = (real_t *)malloc(n * sizeof(real_t));\n    real_t * b_host = (real_t *)malloc(n * sizeof(real_t));\n    real_t * c = (real_t *)malloc(n * sizeof(real_t));\n\n    for (int x = 0; x < n; ++x){\n        a[x] = floor(rand() / (real_t)(RAND_MAX / 10));\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n        b_host[x] = b[x];\n        c[x] = 0.0;\n    }\n    #pragma acc enter data copyin(a[0:n], b[0:n], c[0:n])\n    #pragma acc serial present(a[0:n], b[0:n], c[0:n])\n    {\n        #pragma acc loop\n        for (int x = 0; x < n; ++x){\n            switch(a[x]){\n                case 0:\n                    c[x] = b[x] * b[x];\n                    break;\n                case 1:\n                    c[x] = b[x] / b[x];\n                    break;\n                case 2:\n                    b[x] = b[x] / 2;\n                default:\n                    c[x] = a[x] + b[x];\n\n\n            }\n        }\n    }\n    #pragma acc exit data delete(a[0:n], b[0:n]) copyout(c[0:n])\n\n    real_t tempc = 0.0;\n    for (int x = 0; x < n; ++x){\n        switch(a[x]){\n            case 0:\n                tempc = b_host[x] * b_host[x];\n                break;\n            case 1:\n                tempc = b_host[x] / b_host[x];\n                break;\n            case 2:\n                b_host[x] = b_host[x] / 2;\n            default:\n                tempc = a[x] + b_host[x];\n        }\n        if (fabs(c[x] - tempc) > PRECISION){\n            err = 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "serial"
                        ],
                        "versions": [
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "serial_wait.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:async,serial,update,V:2.6-2.7\n      LOGICAL FUNCTION test1()\n  IMPLICIT NONE\n  INCLUDE \"acc_testsuite.Fh\"\n  REAL(8),DIMENSION(LOOPCOUNT):: a, a_copy\n  INTEGER:: errors, x\n\n  errors = 0\n\n  SEEDDIM(1) = 1\n# ifdef SEED\n  SEEDDIM(1) = SEED\n# endif\n  CALL RANDOM_SEED(PUT=SEEDDIM)\n\n  CALL RANDOM_NUMBER(a)\n  a_copy = a\n\n  !$acc enter data create(a(1:LOOPCOUNT))\n  !$acc update device(a(1:LOOPCOUNT)) async(1)\n  !$acc serial present(a(1:lOOPCOUNT)) wait(1)\n    !$acc loop\n    DO x = 1, LOOPCOUNT\n      a(x) = a(x) + 1\n    END DO\n  !$acc end serial\n  !$acc exit data copyout(a(1:LOOPCOUNT))\n\n  DO x = 1, LOOPCOUNT\n    IF (abs(a(x) - (a_copy(x) + 1)) .gt. PRECISION) THEN\n      errors = errors + 1\n    END IF\n  END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "async",
                            "serial",
                            "update"
                        ],
                        "versions": [
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "serial_wait.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:serial,data,executable-data,async,wait,V:2.6-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t *a = (real_t *)malloc(n * sizeof(real_t));\n    real_t *b = (real_t *)malloc(n * sizeof(real_t));\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = a[x];\n    }\n\n    #pragma acc enter data create(a[0:n])\n    #pragma acc update device(a[0:n]) async(1)\n    #pragma acc serial present(a[0:n]) wait(1)\n    {\n        #pragma acc loop\n        for (int x = 0; x < n; ++x){\n            a[x] += 1;\n        }\n    }\n    #pragma acc exit data copyout(a[0:n])\n    for (int x = 0; x < n; ++x){\n        if (fabs(a[x] - (b[x] + 1)) > PRECISION){\n            err = 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "serial",
                            "data",
                            "executable-data",
                            "async",
                            "wait"
                        ],
                        "versions": [
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "serial_while_loop.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:reduction,loop,V:2.6-2.7\n      LOGICAL FUNCTION test1()\n  IMPLICIT NONE\n  INCLUDE \"acc_testsuite.Fh\"\n  REAL(8),DIMENSION(LOOPCOUNT, 10):: a\n  REAL(8):: avg\n  INTEGER:: errors, x, y\n\n  errors = 0\n\n  SEEDDIM(1) = 1\n# ifdef SEED\n  SEEDDIM(1) = SEED\n# endif\n  CALL RANDOM_SEED(PUT=SEEDDIM)\n\n  CALL RANDOM_NUMBER(a)\n\n  !$acc data copy(a(1:LOOPCOUNT, 1:10))\n    !$acc serial\n      !$acc loop\n      DO y = 1, 10\n        avg = 0\n        DO WHILE (avg .lt. 1000)\n          avg = 0\n          !$acc loop reduction(+:avg)\n          DO x = 1, LOOPCOUNT\n            a(x, y) = a(x, y) * 1.5\n            avg = avg + (a(x, y) / LOOPCOUNT)\n          END DO\n        END DO\n      END DO\n    !$acc end serial\n  !$acc end data\n\n  DO y = 1, 10\n    avg = 0\n    DO x = 1, LOOPCOUNT\n      avg = avg + (a(x, y) / LOOPCOUNT)\n    END DO\n    IF ((avg .lt. 1000) .or. (avg .gt. 1500)) THEN\n      errors = errors + 1\n    END IF\n  END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "reduction",
                            "loop"
                        ],
                        "versions": [
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "serial_while_loop.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:serial,reduction,V:2.6-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    real_t * a = (real_t *)malloc(10 * n * sizeof(real_t));\n    real_t avg = 0.0;\n\n    for (int x = 0; x < 10 * n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n    }\n\n    #pragma acc data copy(a[0:10*n])\n    {\n        #pragma acc serial\n        {\n            #pragma acc loop\n            for (int y = 0; y < 10; ++y){\n                avg = 0.0;\n                while (avg - 1000 < PRECISION * n){\n                    avg = 0.0;\n                    #pragma acc loop reduction(+:avg)\n                    for (int x = 0; x < n; ++x){\n                        a[n * y + x] *= 1.5;\n                        avg += a[n * y + x] / n;\n                    }\n                }\n            }\n        }\n    }\n\n    for (int y = 0 y < 10; ++y){\n        avg = 0.0;\n        for (int x = 0; x < n; ++x){\n            avg += a[y * n + x]/n;\n        }\n\n        if (avg < 1000 || avg > 1500){\n            err = 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "serial",
                            "reduction"
                        ],
                        "versions": [
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "set_default_async.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:async,construct-independent,internal-control-values,set,V:2.5-2.7\n      LOGICAL FUNCTION test1()\n        USE OPENACC\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT):: a, b, c, a_host, b_host !Data\n        REAL(8) :: RAND\n        INTEGER :: errors = 0\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(a)\n        CALL RANDOM_NUMBER(b)\n        a_host = a\n        b_host = b\n        c = 0\n\n        !$acc data copyin(a(1:LOOPCOUNT), b(1:LOOPCOUNT)) copyout(c(1:LOOPCOUNT))\n          !$acc set default_async(1)\n          !$acc parallel async\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              a(x) = a(x) * a(x)\n            END DO\n          !$acc end parallel\n          !$acc set default_async(2)\n          !$acc parallel async\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              b(x) = b(x) * b(x)\n            END DO\n          !$acc end parallel\n          !$acc parallel async(1) wait(2)\n            !$acc loop\n            DO x = 1, LOOPCOUNT\n              c(x) = a(x) + b(x)\n            END DO\n          !$acc end parallel\n          !$acc wait(1)\n        !$acc end data\n\n        DO x = 1, LOOPCOUNT\n          IF (abs(c(x) - (a_host(x) * a_host(x) + b_host(x) * b_host(x))) .gt. 4 * PRECISION) THEN\n            errors = errors + 1\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "async",
                            "construct-independent",
                            "internal-control-values",
                            "set"
                        ],
                        "versions": [
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "set_default_async.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:async,set,construct-independent,V:2.5-2.7\nint test1(){\n    int err = 0;\n    real_t *a = (real_t *)malloc(n * sizeof(real_t));\n    real_t *b = (real_t *)malloc(n * sizeof(real_t));\n    real_t *c = (real_t *)malloc(n * sizeof(real_t));\n    real_t *a_host = (real_t *)malloc(n * sizeof(real_t));\n    real_t *b_host = (real_t *)malloc(n * sizeof(real_t));\n\n    for (int x = 0; x < n; ++x){\n        a[x] = rand() / (real_t)(RAND_MAX / 10);\n        b[x] = rand() / (real_t)(RAND_MAX / 10);\n        c[x] = 0;\n        a_host[x] = a[x];\n        b_host[x] = b[x];\n    }\n\n    #pragma acc data copyin(a[0:n], b[0:n]) copyout(c[0:n])\n    {\n        #pragma acc set default_async(1)\n        #pragma acc parallel async\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                a[x] = a[x] * a[x];\n            }\n        }\n        #pragma acc set default_async(2)\n        #pragma acc parallel async\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                b[x] = b[x] * b[x];\n            }\n        }\n        #pragma acc parallel async(1) wait(2)\n        {\n            #pragma acc loop\n            for (int x = 0; x < n; ++x){\n                c[x] = a[x] + b[x];\n            }\n        }\n        #pragma acc wait(1)\n    }\n\n    for (int x = 0; x < n; ++x){\n        if (fabs(c[x] - (a_host[x] * a_host[x] + b_host[x] * b_host[x])) > 4*PRECISION){\n            err += 1;\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "async",
                            "set",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "set_device_num.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:runtime,construct-independent,internal-control-values,set,V:2.5-2.7\n      LOGICAL FUNCTION test1()\n        USE OPENACC\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x, y !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT):: a !Data\n        REAL(8),DIMENSION(:, :),ALLOCATABLE :: host_copy\n        REAL(8) :: RAND\n        INTEGER :: errors = 0\n        INTEGER :: temp\n\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        ALLOCATE(host_copy(acc_get_num_devices(acc_get_device_type()), LOOPCOUNT))\n\n        IF (acc_get_device_type() .ne. acc_device_none) THEN\n          !host_copy(acc_get_num_devices(acc_get_device_type()), LOOPCOUNT)\n          DO x = 1, acc_get_num_devices(acc_get_device_type())\n            CALL RANDOM_NUMBER(a)\n            host_copy(x, :) = a\n            !$acc set device_num(x)\n            !$acc enter data copyin(a(1:LOOPCOUNT))\n          END DO\n\n          DO x = 1, acc_get_num_devices(acc_get_device_type())\n            !$acc set device_num(x)\n            !$acc data present(a(1:LOOPCOUNT))\n              !$acc parallel\n                !$acc loop\n                DO y = 1, LOOPCOUNT\n                  a(y) = a(y) + 1\n                END DO\n              !$acc end parallel\n            !$acc end data\n          END DO\n\n          DO x = 1, acc_get_num_devices(acc_get_device_type())\n            !$acc set device_num(x)\n            !$acc exit data copyout(a(1:LOOPCOUNT))\n            temp = errors\n            DO y = 1, LOOPCOUNT\n              IF (abs(a(y) - (host_copy(x, y) + 1)) .gt. PRECISION) THEN\n                PRINT*, a(y)\n                PRINT*, host_copy(x, y)\n                errors = errors + 1\n              END IF\n            END DO\n            IF (temp .ne. errors) THEN\n              PRINT*, x\n            END IF\n          END DO\n        END IF\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "runtime",
                            "construct-independent",
                            "internal-control-values",
                            "set"
                        ],
                        "versions": [
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "set_device_num.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:set,devonly,runtime,construct-independent,V:2.5-2.7\nint test1(){\n    int err = 0;\n\n    if (acc_get_device_type() != acc_device_none){\n        real_t **host_copy = (real_t **)malloc(acc_get_num_devices(acc_get_device_type()) * sizeof(real_t *));\n        for (int x = 0; x < acc_get_num_devices(acc_get_device_type()); ++x){\n            host_copy[x] = (real_t *)malloc(n * sizeof(real_t));\n        }\n        real_t *a = (real_t *)malloc(n * sizeof(real_t));\n        for (int x = 0; x < acc_get_num_devices(acc_get_device_type()); ++x){\n            for (int y = 0; y < n; ++y){\n                a[y] = rand() / (real_t)(RAND_MAX / 10);\n                host_copy[x][y] = a[y];\n            }\n            #pragma acc set device_num(x)\n            #pragma acc enter data copyin(a[0:n])\n        }\n        for (int x = 0; x < acc_get_num_devices(acc_get_device_type()); ++x){\n            #pragma acc set device_num(x)\n            #pragma acc data present(a[0:n])\n            {\n                #pragma acc parallel\n                {\n                    #pragma acc loop\n                    for (int y = 0; y < n; ++y){\n                        a[y] = a[y] + 1;\n                    }\n                }\n            }\n        }\n        for (int x = 0; x < acc_get_num_devices(acc_get_device_type()); ++x){\n            #pragma acc set device_num(x)\n            #pragma acc exit data copyout(a[0:n])\n            for (int y = 0; y < n; ++y){\n                if (fabs(a[y] - (host_copy[x][y] + 1)) > PRECISION){\n                    err += 1;\n                }\n            }\n        }\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "set",
                            "devonly",
                            "runtime",
                            "construct-independent"
                        ],
                        "versions": [
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "set_device_type.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:runtime,construct-independent,internal-control-values,set,V:2.5-2.7\n      LOGICAL FUNCTION test1()\n        USE OPENACC\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: errors = 0\n        INTEGER :: device_type\n\n        device_type = acc_get_device_type()\n        !$acc set device_type(device_type)\n        IF (acc_get_device_type() .ne. device_type) THEN\n          errors = errors + 1\n        END IF\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "runtime",
                            "construct-independent",
                            "internal-control-values",
                            "set"
                        ],
                        "versions": [
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "set_device_type.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:set,runtime,syntactic,V:2.5-2.7\nint test1(){\n    int err = 0;\n\n    int device_type = acc_get_device_type();\n\n    #pragma acc set device_type(device_type)\n    if (acc_get_device_type() != device_type){\n        err += 1;\n    }\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "set",
                            "runtime",
                            "syntactic"
                        ],
                        "versions": [
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "shutdown.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:construct-independent,shutdown,nonvalidating,V:2.5-2.7\n      LOGICAL FUNCTION test1()\n        USE OPENACC\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: errors = 0\n\n        !$acc shutdown\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "construct-independent",
                            "shutdown",
                            "nonvalidating"
                        ],
                        "versions": [
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "shutdown.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:shutdown,V:2.5-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n\n    #pragma acc shutdown\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "shutdown"
                        ],
                        "versions": [
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "shutdown_device_num.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:runtime,construct-independent,internal-control-values,shutdown,nonvalidating,V:2.5-2.7\n      LOGICAL FUNCTION test1()\n        USE OPENACC\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: device_num\n        INTEGER :: device_type\n        INTEGER :: errors = 0\n\n        device_num = acc_get_device_num(acc_get_device_type())\n        !$acc shutdown device_num(device_num)\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "runtime",
                            "construct-independent",
                            "internal-control-values",
                            "shutdown",
                            "nonvalidating"
                        ],
                        "versions": [
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "shutdown_device_num.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:shutdown,runtime,syntactic,V:2.5-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    int device_num;\n\n    device_num = acc_get_device_num(acc_get_device_type());\n    #pragma acc shutdown device_num(device_num)\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "shutdown",
                            "runtime",
                            "syntactic"
                        ],
                        "versions": [
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "shutdown_device_type.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:runtime,construct-independent,internal-control-values,shutdown,nonvalidating,V:2.5-2.7\n      LOGICAL FUNCTION test1()\n        USE OPENACC\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: device_type\n        INTEGER :: errors = 0\n\n        device_type = acc_get_device_type()\n        !$acc shutdown device_type(device_type)\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "runtime",
                            "construct-independent",
                            "internal-control-values",
                            "shutdown",
                            "nonvalidating"
                        ],
                        "versions": [
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "shutdown_device_type.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:shutdown,runtime,syntactic,V:2.5-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    int device_type; \n\n    device_type = acc_get_device_type();\n    #pragma acc shutdown device_type(device_type)\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "shutdown",
                            "runtime",
                            "syntactic"
                        ],
                        "versions": [
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "shutdown_device_type_num.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:runtime,construct-independent,internal-control-values,shutdown,nonvalidating,V:2.5-2.7\n      LOGICAL FUNCTION test1()\n        USE OPENACC\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: device_num\n        INTEGER :: device_type\n        INTEGER :: errors = 0\n\n        device_type = acc_get_device_type()\n        device_num = acc_get_device_num(device_type)\n        !$acc shutdown device_type(device_num) device_num(device_num)\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "runtime",
                            "construct-independent",
                            "internal-control-values",
                            "shutdown",
                            "nonvalidating"
                        ],
                        "versions": [
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "shutdown_device_type_num.c": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n//T1:shutdown,runtime,syntactic,V:2.5-2.7\nint test1(){\n    int err = 0;\n    srand(SEED);\n    int device_type\n    int device_num\n\n    device_type = acc_get_device_type();\n    device_num = acc_get_device_num(device_type);\n    #pragma acc shutdown device_type(device_type) device_num(device_num)\n\n    return err;\n}\n#endif\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n",
                        "tags": [
                            "shutdown",
                            "runtime",
                            "syntactic"
                        ],
                        "versions": [
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            },
            "template.F90": {
                "num tests": 1,
                "tests": {
                    "1": {
                        "content": "#ifndef T1\n!T1:construct-independent,V:1.0-2.7\n      LOGICAL FUNCTION test1()\n        IMPLICIT NONE\n        INCLUDE \"acc_testsuite.Fh\"\n        INTEGER :: x !Iterators\n        REAL(8),DIMENSION(LOOPCOUNT):: a, b, c !Data\n        REAL(8) :: RAND\n        INTEGER :: errors = 0\n\n        !Initilization\n        SEEDDIM(1) = 1\n#       ifdef SEED\n        SEEDDIM(1) = SEED\n#       endif\n        CALL RANDOM_SEED(PUT=SEEDDIM)\n\n        CALL RANDOM_NUMBER(a)\n        CALL RANDOM_NUMBER(b)\n        c = 0\n\n        !$acc data copyin(a(1:LOOPCOUNT))\n          !$acc parallel\n\n          !$acc end parallel\n        !$acc end data\n        DO x = 1, LOOPCOUNT\n          IF (abs(a(x)) .gt. PRECISION) THEN\n            errors = errors + 1\n          END IF\n        END DO\n\n        IF (errors .eq. 0) THEN\n          test1 = .FALSE.\n        ELSE\n          test1 = .TRUE.\n        END IF\n      END\n#endif\n#ifndef T1\n        LOGICAL :: test1\n#endif\n#ifndef T1\n        DO testrun = 1, NUM_TEST_CALLS\n          failed = failed .or. test1()\n        END DO\n        IF (failed) THEN\n          failcode = failcode + 2 ** 0\n          failed = .FALSE.\n        END IF\n#endif\n",
                        "tags": [
                            "construct-independent"
                        ],
                        "versions": [
                            "1.0",
                            "2.0",
                            "2.5",
                            "2.6",
                            "2.7"
                        ]
                    }
                }
            }
        }
    ]
};